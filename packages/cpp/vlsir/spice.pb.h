// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spice.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_spice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_spice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "circuit.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_spice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spice_2eproto;
namespace vlsir {
namespace spice {
class AcInput;
struct AcInputDefaultTypeInternal;
extern AcInputDefaultTypeInternal _AcInput_default_instance_;
class AcResult;
struct AcResultDefaultTypeInternal;
extern AcResultDefaultTypeInternal _AcResult_default_instance_;
class AcResult_MeasurementsEntry_DoNotUse;
struct AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _AcResult_MeasurementsEntry_DoNotUse_default_instance_;
class Analysis;
struct AnalysisDefaultTypeInternal;
extern AnalysisDefaultTypeInternal _Analysis_default_instance_;
class AnalysisResult;
struct AnalysisResultDefaultTypeInternal;
extern AnalysisResultDefaultTypeInternal _AnalysisResult_default_instance_;
class Circuit;
struct CircuitDefaultTypeInternal;
extern CircuitDefaultTypeInternal _Circuit_default_instance_;
class ComplexNum;
struct ComplexNumDefaultTypeInternal;
extern ComplexNumDefaultTypeInternal _ComplexNum_default_instance_;
class Control;
struct ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class CustomAnalysisInput;
struct CustomAnalysisInputDefaultTypeInternal;
extern CustomAnalysisInputDefaultTypeInternal _CustomAnalysisInput_default_instance_;
class CustomAnalysisResult;
struct CustomAnalysisResultDefaultTypeInternal;
extern CustomAnalysisResultDefaultTypeInternal _CustomAnalysisResult_default_instance_;
class DcInput;
struct DcInputDefaultTypeInternal;
extern DcInputDefaultTypeInternal _DcInput_default_instance_;
class DcResult;
struct DcResultDefaultTypeInternal;
extern DcResultDefaultTypeInternal _DcResult_default_instance_;
class DcResult_MeasurementsEntry_DoNotUse;
struct DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _DcResult_MeasurementsEntry_DoNotUse_default_instance_;
class Include;
struct IncludeDefaultTypeInternal;
extern IncludeDefaultTypeInternal _Include_default_instance_;
class LibInclude;
struct LibIncludeDefaultTypeInternal;
extern LibIncludeDefaultTypeInternal _LibInclude_default_instance_;
class LinearSweep;
struct LinearSweepDefaultTypeInternal;
extern LinearSweepDefaultTypeInternal _LinearSweep_default_instance_;
class LogSweep;
struct LogSweepDefaultTypeInternal;
extern LogSweepDefaultTypeInternal _LogSweep_default_instance_;
class Meas;
struct MeasDefaultTypeInternal;
extern MeasDefaultTypeInternal _Meas_default_instance_;
class MonteInput;
struct MonteInputDefaultTypeInternal;
extern MonteInputDefaultTypeInternal _MonteInput_default_instance_;
class MonteResult;
struct MonteResultDefaultTypeInternal;
extern MonteResultDefaultTypeInternal _MonteResult_default_instance_;
class OpInput;
struct OpInputDefaultTypeInternal;
extern OpInputDefaultTypeInternal _OpInput_default_instance_;
class OpResult;
struct OpResultDefaultTypeInternal;
extern OpResultDefaultTypeInternal _OpResult_default_instance_;
class PointSweep;
struct PointSweepDefaultTypeInternal;
extern PointSweepDefaultTypeInternal _PointSweep_default_instance_;
class Save;
struct SaveDefaultTypeInternal;
extern SaveDefaultTypeInternal _Save_default_instance_;
class Signal;
struct SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Signals;
struct SignalsDefaultTypeInternal;
extern SignalsDefaultTypeInternal _Signals_default_instance_;
class SimInput;
struct SimInputDefaultTypeInternal;
extern SimInputDefaultTypeInternal _SimInput_default_instance_;
class SimOptions;
struct SimOptionsDefaultTypeInternal;
extern SimOptionsDefaultTypeInternal _SimOptions_default_instance_;
class SimResult;
struct SimResultDefaultTypeInternal;
extern SimResultDefaultTypeInternal _SimResult_default_instance_;
class Sweep;
struct SweepDefaultTypeInternal;
extern SweepDefaultTypeInternal _Sweep_default_instance_;
class SweepInput;
struct SweepInputDefaultTypeInternal;
extern SweepInputDefaultTypeInternal _SweepInput_default_instance_;
class SweepResult;
struct SweepResultDefaultTypeInternal;
extern SweepResultDefaultTypeInternal _SweepResult_default_instance_;
class TranInput;
struct TranInputDefaultTypeInternal;
extern TranInputDefaultTypeInternal _TranInput_default_instance_;
class TranInput_IcEntry_DoNotUse;
struct TranInput_IcEntry_DoNotUseDefaultTypeInternal;
extern TranInput_IcEntry_DoNotUseDefaultTypeInternal _TranInput_IcEntry_DoNotUse_default_instance_;
class TranResult;
struct TranResultDefaultTypeInternal;
extern TranResultDefaultTypeInternal _TranResult_default_instance_;
class TranResult_MeasurementsEntry_DoNotUse;
struct TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _TranResult_MeasurementsEntry_DoNotUse_default_instance_;
}  // namespace spice
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::spice::AcInput* Arena::CreateMaybeMessage<::vlsir::spice::AcInput>(Arena*);
template<> ::vlsir::spice::AcResult* Arena::CreateMaybeMessage<::vlsir::spice::AcResult>(Arena*);
template<> ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::Analysis* Arena::CreateMaybeMessage<::vlsir::spice::Analysis>(Arena*);
template<> ::vlsir::spice::AnalysisResult* Arena::CreateMaybeMessage<::vlsir::spice::AnalysisResult>(Arena*);
template<> ::vlsir::spice::Circuit* Arena::CreateMaybeMessage<::vlsir::spice::Circuit>(Arena*);
template<> ::vlsir::spice::ComplexNum* Arena::CreateMaybeMessage<::vlsir::spice::ComplexNum>(Arena*);
template<> ::vlsir::spice::Control* Arena::CreateMaybeMessage<::vlsir::spice::Control>(Arena*);
template<> ::vlsir::spice::CustomAnalysisInput* Arena::CreateMaybeMessage<::vlsir::spice::CustomAnalysisInput>(Arena*);
template<> ::vlsir::spice::CustomAnalysisResult* Arena::CreateMaybeMessage<::vlsir::spice::CustomAnalysisResult>(Arena*);
template<> ::vlsir::spice::DcInput* Arena::CreateMaybeMessage<::vlsir::spice::DcInput>(Arena*);
template<> ::vlsir::spice::DcResult* Arena::CreateMaybeMessage<::vlsir::spice::DcResult>(Arena*);
template<> ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::Include* Arena::CreateMaybeMessage<::vlsir::spice::Include>(Arena*);
template<> ::vlsir::spice::LibInclude* Arena::CreateMaybeMessage<::vlsir::spice::LibInclude>(Arena*);
template<> ::vlsir::spice::LinearSweep* Arena::CreateMaybeMessage<::vlsir::spice::LinearSweep>(Arena*);
template<> ::vlsir::spice::LogSweep* Arena::CreateMaybeMessage<::vlsir::spice::LogSweep>(Arena*);
template<> ::vlsir::spice::Meas* Arena::CreateMaybeMessage<::vlsir::spice::Meas>(Arena*);
template<> ::vlsir::spice::MonteInput* Arena::CreateMaybeMessage<::vlsir::spice::MonteInput>(Arena*);
template<> ::vlsir::spice::MonteResult* Arena::CreateMaybeMessage<::vlsir::spice::MonteResult>(Arena*);
template<> ::vlsir::spice::OpInput* Arena::CreateMaybeMessage<::vlsir::spice::OpInput>(Arena*);
template<> ::vlsir::spice::OpResult* Arena::CreateMaybeMessage<::vlsir::spice::OpResult>(Arena*);
template<> ::vlsir::spice::PointSweep* Arena::CreateMaybeMessage<::vlsir::spice::PointSweep>(Arena*);
template<> ::vlsir::spice::Save* Arena::CreateMaybeMessage<::vlsir::spice::Save>(Arena*);
template<> ::vlsir::spice::Signal* Arena::CreateMaybeMessage<::vlsir::spice::Signal>(Arena*);
template<> ::vlsir::spice::Signals* Arena::CreateMaybeMessage<::vlsir::spice::Signals>(Arena*);
template<> ::vlsir::spice::SimInput* Arena::CreateMaybeMessage<::vlsir::spice::SimInput>(Arena*);
template<> ::vlsir::spice::SimOptions* Arena::CreateMaybeMessage<::vlsir::spice::SimOptions>(Arena*);
template<> ::vlsir::spice::SimResult* Arena::CreateMaybeMessage<::vlsir::spice::SimResult>(Arena*);
template<> ::vlsir::spice::Sweep* Arena::CreateMaybeMessage<::vlsir::spice::Sweep>(Arena*);
template<> ::vlsir::spice::SweepInput* Arena::CreateMaybeMessage<::vlsir::spice::SweepInput>(Arena*);
template<> ::vlsir::spice::SweepResult* Arena::CreateMaybeMessage<::vlsir::spice::SweepResult>(Arena*);
template<> ::vlsir::spice::TranInput* Arena::CreateMaybeMessage<::vlsir::spice::TranInput>(Arena*);
template<> ::vlsir::spice::TranInput_IcEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::TranInput_IcEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::TranResult* Arena::CreateMaybeMessage<::vlsir::spice::TranResult>(Arena*);
template<> ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace spice {

enum Save_SaveMode : int {
  Save_SaveMode_NONE = 0,
  Save_SaveMode_ALL = 1,
  Save_SaveMode_Save_SaveMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Save_SaveMode_Save_SaveMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Save_SaveMode_IsValid(int value);
constexpr Save_SaveMode Save_SaveMode_SaveMode_MIN = Save_SaveMode_NONE;
constexpr Save_SaveMode Save_SaveMode_SaveMode_MAX = Save_SaveMode_ALL;
constexpr int Save_SaveMode_SaveMode_ARRAYSIZE = Save_SaveMode_SaveMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Save_SaveMode_descriptor();
template<typename T>
inline const std::string& Save_SaveMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Save_SaveMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Save_SaveMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Save_SaveMode_descriptor(), enum_t_value);
}
inline bool Save_SaveMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Save_SaveMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Save_SaveMode>(
    Save_SaveMode_descriptor(), name, value);
}
enum Signal_Quantity : int {
  Signal_Quantity_VOLTAGE = 0,
  Signal_Quantity_CURRENT = 1,
  Signal_Quantity_NONE = 3,
  Signal_Quantity_Signal_Quantity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Signal_Quantity_Signal_Quantity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Signal_Quantity_IsValid(int value);
constexpr Signal_Quantity Signal_Quantity_Quantity_MIN = Signal_Quantity_VOLTAGE;
constexpr Signal_Quantity Signal_Quantity_Quantity_MAX = Signal_Quantity_NONE;
constexpr int Signal_Quantity_Quantity_ARRAYSIZE = Signal_Quantity_Quantity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Signal_Quantity_descriptor();
template<typename T>
inline const std::string& Signal_Quantity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Signal_Quantity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Signal_Quantity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Signal_Quantity_descriptor(), enum_t_value);
}
inline bool Signal_Quantity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Signal_Quantity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Signal_Quantity>(
    Signal_Quantity_descriptor(), name, value);
}
// ===================================================================

class SimInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimInput) */ {
 public:
  inline SimInput() : SimInput(nullptr) {}
  ~SimInput() override;
  explicit constexpr SimInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimInput(const SimInput& from);
  SimInput(SimInput&& from) noexcept
    : SimInput() {
    *this = ::std::move(from);
  }

  inline SimInput& operator=(const SimInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimInput& operator=(SimInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimInput* internal_default_instance() {
    return reinterpret_cast<const SimInput*>(
               &_SimInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SimInput& a, SimInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SimInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimInput* New() const final {
    return new SimInput();
  }

  SimInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SimInput";
  }
  protected:
  explicit SimInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 3,
    kCtrlsFieldNumber = 4,
    kCktFieldNumber = 1,
    kOptsFieldNumber = 2,
  };
  // repeated .vlsir.spice.Analysis an = 3;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  private:
  const ::vlsir::spice::Analysis& _internal_an(int index) const;
  ::vlsir::spice::Analysis* _internal_add_an();
  public:
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 4;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // .vlsir.spice.Circuit ckt = 1;
  bool has_ckt() const;
  private:
  bool _internal_has_ckt() const;
  public:
  void clear_ckt();
  const ::vlsir::spice::Circuit& ckt() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Circuit* release_ckt();
  ::vlsir::spice::Circuit* mutable_ckt();
  void set_allocated_ckt(::vlsir::spice::Circuit* ckt);
  private:
  const ::vlsir::spice::Circuit& _internal_ckt() const;
  ::vlsir::spice::Circuit* _internal_mutable_ckt();
  public:
  void unsafe_arena_set_allocated_ckt(
      ::vlsir::spice::Circuit* ckt);
  ::vlsir::spice::Circuit* unsafe_arena_release_ckt();

  // .vlsir.spice.SimOptions opts = 2;
  bool has_opts() const;
  private:
  bool _internal_has_opts() const;
  public:
  void clear_opts();
  const ::vlsir::spice::SimOptions& opts() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::SimOptions* release_opts();
  ::vlsir::spice::SimOptions* mutable_opts();
  void set_allocated_opts(::vlsir::spice::SimOptions* opts);
  private:
  const ::vlsir::spice::SimOptions& _internal_opts() const;
  ::vlsir::spice::SimOptions* _internal_mutable_opts();
  public:
  void unsafe_arena_set_allocated_opts(
      ::vlsir::spice::SimOptions* opts);
  ::vlsir::spice::SimOptions* unsafe_arena_release_opts();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::vlsir::spice::Circuit* ckt_;
  ::vlsir::spice::SimOptions* opts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SimResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimResult) */ {
 public:
  inline SimResult() : SimResult(nullptr) {}
  ~SimResult() override;
  explicit constexpr SimResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimResult(const SimResult& from);
  SimResult(SimResult&& from) noexcept
    : SimResult() {
    *this = ::std::move(from);
  }

  inline SimResult& operator=(const SimResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimResult& operator=(SimResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimResult* internal_default_instance() {
    return reinterpret_cast<const SimResult*>(
               &_SimResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SimResult& a, SimResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SimResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimResult* New() const final {
    return new SimResult();
  }

  SimResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SimResult";
  }
  protected:
  explicit SimResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 1,
  };
  // repeated .vlsir.spice.AnalysisResult an = 1;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  private:
  const ::vlsir::spice::AnalysisResult& _internal_an(int index) const;
  ::vlsir::spice::AnalysisResult* _internal_add_an();
  public:
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SimOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimOptions) */ {
 public:
  inline SimOptions() : SimOptions(nullptr) {}
  ~SimOptions() override;
  explicit constexpr SimOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimOptions(const SimOptions& from);
  SimOptions(SimOptions&& from) noexcept
    : SimOptions() {
    *this = ::std::move(from);
  }

  inline SimOptions& operator=(const SimOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimOptions& operator=(SimOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimOptions* internal_default_instance() {
    return reinterpret_cast<const SimOptions*>(
               &_SimOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SimOptions& a, SimOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SimOptions* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimOptions* New() const final {
    return new SimOptions();
  }

  SimOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SimOptions";
  }
  protected:
  explicit SimOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTempFieldNumber = 1,
    kTnomFieldNumber = 2,
    kGminFieldNumber = 3,
    kIabstolFieldNumber = 4,
    kReltolFieldNumber = 5,
  };
  // .google.protobuf.DoubleValue temp = 1;
  bool has_temp() const;
  private:
  bool _internal_has_temp() const;
  public:
  void clear_temp();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& temp() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_temp();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_temp();
  void set_allocated_temp(PROTOBUF_NAMESPACE_ID::DoubleValue* temp);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_temp() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_temp();
  public:
  void unsafe_arena_set_allocated_temp(
      PROTOBUF_NAMESPACE_ID::DoubleValue* temp);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_temp();

  // .google.protobuf.DoubleValue tnom = 2;
  bool has_tnom() const;
  private:
  bool _internal_has_tnom() const;
  public:
  void clear_tnom();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& tnom() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_tnom();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_tnom();
  void set_allocated_tnom(PROTOBUF_NAMESPACE_ID::DoubleValue* tnom);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_tnom() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_tnom();
  public:
  void unsafe_arena_set_allocated_tnom(
      PROTOBUF_NAMESPACE_ID::DoubleValue* tnom);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_tnom();

  // .google.protobuf.DoubleValue gmin = 3;
  bool has_gmin() const;
  private:
  bool _internal_has_gmin() const;
  public:
  void clear_gmin();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& gmin() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_gmin();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_gmin();
  void set_allocated_gmin(PROTOBUF_NAMESPACE_ID::DoubleValue* gmin);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_gmin() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_gmin();
  public:
  void unsafe_arena_set_allocated_gmin(
      PROTOBUF_NAMESPACE_ID::DoubleValue* gmin);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_gmin();

  // .google.protobuf.DoubleValue iabstol = 4;
  bool has_iabstol() const;
  private:
  bool _internal_has_iabstol() const;
  public:
  void clear_iabstol();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& iabstol() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_iabstol();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_iabstol();
  void set_allocated_iabstol(PROTOBUF_NAMESPACE_ID::DoubleValue* iabstol);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_iabstol() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_iabstol();
  public:
  void unsafe_arena_set_allocated_iabstol(
      PROTOBUF_NAMESPACE_ID::DoubleValue* iabstol);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_iabstol();

  // .google.protobuf.DoubleValue reltol = 5;
  bool has_reltol() const;
  private:
  bool _internal_has_reltol() const;
  public:
  void clear_reltol();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& reltol() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_reltol();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_reltol();
  void set_allocated_reltol(PROTOBUF_NAMESPACE_ID::DoubleValue* reltol);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_reltol() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_reltol();
  public:
  void unsafe_arena_set_allocated_reltol(
      PROTOBUF_NAMESPACE_ID::DoubleValue* reltol);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_reltol();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* tnom_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* gmin_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* iabstol_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* reltol_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Circuit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Circuit) */ {
 public:
  inline Circuit() : Circuit(nullptr) {}
  ~Circuit() override;
  explicit constexpr Circuit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Circuit(const Circuit& from);
  Circuit(Circuit&& from) noexcept
    : Circuit() {
    *this = ::std::move(from);
  }

  inline Circuit& operator=(const Circuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circuit& operator=(Circuit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circuit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circuit* internal_default_instance() {
    return reinterpret_cast<const Circuit*>(
               &_Circuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Circuit& a, Circuit& b) {
    a.Swap(&b);
  }
  inline void Swap(Circuit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circuit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Circuit* New() const final {
    return new Circuit();
  }

  Circuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Circuit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Circuit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Circuit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circuit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Circuit";
  }
  protected:
  explicit Circuit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 3,
    kInstancesFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Signal signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  private:
  const ::vlsir::circuit::Signal& _internal_signals(int index) const;
  ::vlsir::circuit::Signal* _internal_add_signals();
  public:
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.circuit.Instance instances = 4;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::circuit::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
      mutable_instances();
  private:
  const ::vlsir::circuit::Instance& _internal_instances(int index) const;
  ::vlsir::circuit::Instance* _internal_add_instances();
  public:
  const ::vlsir::circuit::Instance& instances(int index) const;
  ::vlsir::circuit::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
      instances() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Circuit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance > instances_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Analysis final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Analysis) */ {
 public:
  inline Analysis() : Analysis(nullptr) {}
  ~Analysis() override;
  explicit constexpr Analysis(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Analysis(const Analysis& from);
  Analysis(Analysis&& from) noexcept
    : Analysis() {
    *this = ::std::move(from);
  }

  inline Analysis& operator=(const Analysis& from) {
    CopyFrom(from);
    return *this;
  }
  inline Analysis& operator=(Analysis&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Analysis& default_instance() {
    return *internal_default_instance();
  }
  enum AnCase {
    kOp = 1,
    kDc = 2,
    kTran = 3,
    kAc = 4,
    kSweep = 10,
    kMonte = 11,
    kCustom = 20,
    AN_NOT_SET = 0,
  };

  static inline const Analysis* internal_default_instance() {
    return reinterpret_cast<const Analysis*>(
               &_Analysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Analysis& a, Analysis& b) {
    a.Swap(&b);
  }
  inline void Swap(Analysis* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Analysis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Analysis* New() const final {
    return new Analysis();
  }

  Analysis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Analysis>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Analysis& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Analysis& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Analysis* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Analysis";
  }
  protected:
  explicit Analysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kDcFieldNumber = 2,
    kTranFieldNumber = 3,
    kAcFieldNumber = 4,
    kSweepFieldNumber = 10,
    kMonteFieldNumber = 11,
    kCustomFieldNumber = 20,
  };
  // .vlsir.spice.OpInput op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::vlsir::spice::OpInput& op() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::OpInput* release_op();
  ::vlsir::spice::OpInput* mutable_op();
  void set_allocated_op(::vlsir::spice::OpInput* op);
  private:
  const ::vlsir::spice::OpInput& _internal_op() const;
  ::vlsir::spice::OpInput* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::vlsir::spice::OpInput* op);
  ::vlsir::spice::OpInput* unsafe_arena_release_op();

  // .vlsir.spice.DcInput dc = 2;
  bool has_dc() const;
  private:
  bool _internal_has_dc() const;
  public:
  void clear_dc();
  const ::vlsir::spice::DcInput& dc() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::DcInput* release_dc();
  ::vlsir::spice::DcInput* mutable_dc();
  void set_allocated_dc(::vlsir::spice::DcInput* dc);
  private:
  const ::vlsir::spice::DcInput& _internal_dc() const;
  ::vlsir::spice::DcInput* _internal_mutable_dc();
  public:
  void unsafe_arena_set_allocated_dc(
      ::vlsir::spice::DcInput* dc);
  ::vlsir::spice::DcInput* unsafe_arena_release_dc();

  // .vlsir.spice.TranInput tran = 3;
  bool has_tran() const;
  private:
  bool _internal_has_tran() const;
  public:
  void clear_tran();
  const ::vlsir::spice::TranInput& tran() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::TranInput* release_tran();
  ::vlsir::spice::TranInput* mutable_tran();
  void set_allocated_tran(::vlsir::spice::TranInput* tran);
  private:
  const ::vlsir::spice::TranInput& _internal_tran() const;
  ::vlsir::spice::TranInput* _internal_mutable_tran();
  public:
  void unsafe_arena_set_allocated_tran(
      ::vlsir::spice::TranInput* tran);
  ::vlsir::spice::TranInput* unsafe_arena_release_tran();

  // .vlsir.spice.AcInput ac = 4;
  bool has_ac() const;
  private:
  bool _internal_has_ac() const;
  public:
  void clear_ac();
  const ::vlsir::spice::AcInput& ac() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::AcInput* release_ac();
  ::vlsir::spice::AcInput* mutable_ac();
  void set_allocated_ac(::vlsir::spice::AcInput* ac);
  private:
  const ::vlsir::spice::AcInput& _internal_ac() const;
  ::vlsir::spice::AcInput* _internal_mutable_ac();
  public:
  void unsafe_arena_set_allocated_ac(
      ::vlsir::spice::AcInput* ac);
  ::vlsir::spice::AcInput* unsafe_arena_release_ac();

  // .vlsir.spice.SweepInput sweep = 10;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::SweepInput& sweep() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::SweepInput* release_sweep();
  ::vlsir::spice::SweepInput* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::SweepInput* sweep);
  private:
  const ::vlsir::spice::SweepInput& _internal_sweep() const;
  ::vlsir::spice::SweepInput* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::SweepInput* sweep);
  ::vlsir::spice::SweepInput* unsafe_arena_release_sweep();

  // .vlsir.spice.MonteInput monte = 11;
  bool has_monte() const;
  private:
  bool _internal_has_monte() const;
  public:
  void clear_monte();
  const ::vlsir::spice::MonteInput& monte() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::MonteInput* release_monte();
  ::vlsir::spice::MonteInput* mutable_monte();
  void set_allocated_monte(::vlsir::spice::MonteInput* monte);
  private:
  const ::vlsir::spice::MonteInput& _internal_monte() const;
  ::vlsir::spice::MonteInput* _internal_mutable_monte();
  public:
  void unsafe_arena_set_allocated_monte(
      ::vlsir::spice::MonteInput* monte);
  ::vlsir::spice::MonteInput* unsafe_arena_release_monte();

  // .vlsir.spice.CustomAnalysisInput custom = 20;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::vlsir::spice::CustomAnalysisInput& custom() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::CustomAnalysisInput* release_custom();
  ::vlsir::spice::CustomAnalysisInput* mutable_custom();
  void set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom);
  private:
  const ::vlsir::spice::CustomAnalysisInput& _internal_custom() const;
  ::vlsir::spice::CustomAnalysisInput* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::vlsir::spice::CustomAnalysisInput* custom);
  ::vlsir::spice::CustomAnalysisInput* unsafe_arena_release_custom();

  void clear_an();
  AnCase an_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Analysis)
 private:
  class _Internal;
  void set_has_op();
  void set_has_dc();
  void set_has_tran();
  void set_has_ac();
  void set_has_sweep();
  void set_has_monte();
  void set_has_custom();

  inline bool has_an() const;
  inline void clear_has_an();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union AnUnion {
    constexpr AnUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::spice::OpInput* op_;
    ::vlsir::spice::DcInput* dc_;
    ::vlsir::spice::TranInput* tran_;
    ::vlsir::spice::AcInput* ac_;
    ::vlsir::spice::SweepInput* sweep_;
    ::vlsir::spice::MonteInput* monte_;
    ::vlsir::spice::CustomAnalysisInput* custom_;
  } an_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class AnalysisResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AnalysisResult) */ {
 public:
  inline AnalysisResult() : AnalysisResult(nullptr) {}
  ~AnalysisResult() override;
  explicit constexpr AnalysisResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalysisResult(const AnalysisResult& from);
  AnalysisResult(AnalysisResult&& from) noexcept
    : AnalysisResult() {
    *this = ::std::move(from);
  }

  inline AnalysisResult& operator=(const AnalysisResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalysisResult& operator=(AnalysisResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalysisResult& default_instance() {
    return *internal_default_instance();
  }
  enum AnCase {
    kOp = 1,
    kDc = 2,
    kTran = 3,
    kAc = 4,
    kSweep = 10,
    kMonte = 11,
    kCustom = 20,
    AN_NOT_SET = 0,
  };

  static inline const AnalysisResult* internal_default_instance() {
    return reinterpret_cast<const AnalysisResult*>(
               &_AnalysisResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AnalysisResult& a, AnalysisResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalysisResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalysisResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnalysisResult* New() const final {
    return new AnalysisResult();
  }

  AnalysisResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnalysisResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalysisResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnalysisResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.AnalysisResult";
  }
  protected:
  explicit AnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kDcFieldNumber = 2,
    kTranFieldNumber = 3,
    kAcFieldNumber = 4,
    kSweepFieldNumber = 10,
    kMonteFieldNumber = 11,
    kCustomFieldNumber = 20,
  };
  // .vlsir.spice.OpResult op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::vlsir::spice::OpResult& op() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::OpResult* release_op();
  ::vlsir::spice::OpResult* mutable_op();
  void set_allocated_op(::vlsir::spice::OpResult* op);
  private:
  const ::vlsir::spice::OpResult& _internal_op() const;
  ::vlsir::spice::OpResult* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::vlsir::spice::OpResult* op);
  ::vlsir::spice::OpResult* unsafe_arena_release_op();

  // .vlsir.spice.DcResult dc = 2;
  bool has_dc() const;
  private:
  bool _internal_has_dc() const;
  public:
  void clear_dc();
  const ::vlsir::spice::DcResult& dc() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::DcResult* release_dc();
  ::vlsir::spice::DcResult* mutable_dc();
  void set_allocated_dc(::vlsir::spice::DcResult* dc);
  private:
  const ::vlsir::spice::DcResult& _internal_dc() const;
  ::vlsir::spice::DcResult* _internal_mutable_dc();
  public:
  void unsafe_arena_set_allocated_dc(
      ::vlsir::spice::DcResult* dc);
  ::vlsir::spice::DcResult* unsafe_arena_release_dc();

  // .vlsir.spice.TranResult tran = 3;
  bool has_tran() const;
  private:
  bool _internal_has_tran() const;
  public:
  void clear_tran();
  const ::vlsir::spice::TranResult& tran() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::TranResult* release_tran();
  ::vlsir::spice::TranResult* mutable_tran();
  void set_allocated_tran(::vlsir::spice::TranResult* tran);
  private:
  const ::vlsir::spice::TranResult& _internal_tran() const;
  ::vlsir::spice::TranResult* _internal_mutable_tran();
  public:
  void unsafe_arena_set_allocated_tran(
      ::vlsir::spice::TranResult* tran);
  ::vlsir::spice::TranResult* unsafe_arena_release_tran();

  // .vlsir.spice.AcResult ac = 4;
  bool has_ac() const;
  private:
  bool _internal_has_ac() const;
  public:
  void clear_ac();
  const ::vlsir::spice::AcResult& ac() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::AcResult* release_ac();
  ::vlsir::spice::AcResult* mutable_ac();
  void set_allocated_ac(::vlsir::spice::AcResult* ac);
  private:
  const ::vlsir::spice::AcResult& _internal_ac() const;
  ::vlsir::spice::AcResult* _internal_mutable_ac();
  public:
  void unsafe_arena_set_allocated_ac(
      ::vlsir::spice::AcResult* ac);
  ::vlsir::spice::AcResult* unsafe_arena_release_ac();

  // .vlsir.spice.SweepResult sweep = 10;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::SweepResult& sweep() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::SweepResult* release_sweep();
  ::vlsir::spice::SweepResult* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::SweepResult* sweep);
  private:
  const ::vlsir::spice::SweepResult& _internal_sweep() const;
  ::vlsir::spice::SweepResult* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::SweepResult* sweep);
  ::vlsir::spice::SweepResult* unsafe_arena_release_sweep();

  // .vlsir.spice.MonteResult monte = 11;
  bool has_monte() const;
  private:
  bool _internal_has_monte() const;
  public:
  void clear_monte();
  const ::vlsir::spice::MonteResult& monte() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::MonteResult* release_monte();
  ::vlsir::spice::MonteResult* mutable_monte();
  void set_allocated_monte(::vlsir::spice::MonteResult* monte);
  private:
  const ::vlsir::spice::MonteResult& _internal_monte() const;
  ::vlsir::spice::MonteResult* _internal_mutable_monte();
  public:
  void unsafe_arena_set_allocated_monte(
      ::vlsir::spice::MonteResult* monte);
  ::vlsir::spice::MonteResult* unsafe_arena_release_monte();

  // .vlsir.spice.CustomAnalysisResult custom = 20;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::vlsir::spice::CustomAnalysisResult& custom() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::CustomAnalysisResult* release_custom();
  ::vlsir::spice::CustomAnalysisResult* mutable_custom();
  void set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom);
  private:
  const ::vlsir::spice::CustomAnalysisResult& _internal_custom() const;
  ::vlsir::spice::CustomAnalysisResult* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::vlsir::spice::CustomAnalysisResult* custom);
  ::vlsir::spice::CustomAnalysisResult* unsafe_arena_release_custom();

  void clear_an();
  AnCase an_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.AnalysisResult)
 private:
  class _Internal;
  void set_has_op();
  void set_has_dc();
  void set_has_tran();
  void set_has_ac();
  void set_has_sweep();
  void set_has_monte();
  void set_has_custom();

  inline bool has_an() const;
  inline void clear_has_an();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union AnUnion {
    constexpr AnUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::spice::OpResult* op_;
    ::vlsir::spice::DcResult* dc_;
    ::vlsir::spice::TranResult* tran_;
    ::vlsir::spice::AcResult* ac_;
    ::vlsir::spice::SweepResult* sweep_;
    ::vlsir::spice::MonteResult* monte_;
    ::vlsir::spice::CustomAnalysisResult* custom_;
  } an_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class OpInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.OpInput) */ {
 public:
  inline OpInput() : OpInput(nullptr) {}
  ~OpInput() override;
  explicit constexpr OpInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpInput(const OpInput& from);
  OpInput(OpInput&& from) noexcept
    : OpInput() {
    *this = ::std::move(from);
  }

  inline OpInput& operator=(const OpInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpInput& operator=(OpInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpInput* internal_default_instance() {
    return reinterpret_cast<const OpInput*>(
               &_OpInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OpInput& a, OpInput& b) {
    a.Swap(&b);
  }
  inline void Swap(OpInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpInput* New() const final {
    return new OpInput();
  }

  OpInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.OpInput";
  }
  protected:
  explicit OpInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
  };
  // repeated .vlsir.spice.Control ctrl = 5;
  int ctrl_size() const;
  private:
  int _internal_ctrl_size() const;
  public:
  void clear_ctrl();
  ::vlsir::spice::Control* mutable_ctrl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrl();
  private:
  const ::vlsir::spice::Control& _internal_ctrl(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrl();
  public:
  const ::vlsir::spice::Control& ctrl(int index) const;
  ::vlsir::spice::Control* add_ctrl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrl() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.OpInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class OpResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.OpResult) */ {
 public:
  inline OpResult() : OpResult(nullptr) {}
  ~OpResult() override;
  explicit constexpr OpResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpResult(const OpResult& from);
  OpResult(OpResult&& from) noexcept
    : OpResult() {
    *this = ::std::move(from);
  }

  inline OpResult& operator=(const OpResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpResult& operator=(OpResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpResult* internal_default_instance() {
    return reinterpret_cast<const OpResult*>(
               &_OpResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OpResult& a, OpResult& b) {
    a.Swap(&b);
  }
  inline void Swap(OpResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpResult* New() const final {
    return new OpResult();
  }

  OpResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.OpResult";
  }
  protected:
  explicit OpResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kSignalsFieldNumber = 3,
  };
  // repeated double data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // .vlsir.spice.Signals signals = 3;
  bool has_signals() const;
  private:
  bool _internal_has_signals() const;
  public:
  void clear_signals();
  const ::vlsir::spice::Signals& signals() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Signals* release_signals();
  ::vlsir::spice::Signals* mutable_signals();
  void set_allocated_signals(::vlsir::spice::Signals* signals);
  private:
  const ::vlsir::spice::Signals& _internal_signals() const;
  ::vlsir::spice::Signals* _internal_mutable_signals();
  public:
  void unsafe_arena_set_allocated_signals(
      ::vlsir::spice::Signals* signals);
  ::vlsir::spice::Signals* unsafe_arena_release_signals();

  // @@protoc_insertion_point(class_scope:vlsir.spice.OpResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::vlsir::spice::Signals* signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class DcInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.DcInput) */ {
 public:
  inline DcInput() : DcInput(nullptr) {}
  ~DcInput() override;
  explicit constexpr DcInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DcInput(const DcInput& from);
  DcInput(DcInput&& from) noexcept
    : DcInput() {
    *this = ::std::move(from);
  }

  inline DcInput& operator=(const DcInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DcInput& operator=(DcInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DcInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const DcInput* internal_default_instance() {
    return reinterpret_cast<const DcInput*>(
               &_DcInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DcInput& a, DcInput& b) {
    a.Swap(&b);
  }
  inline void Swap(DcInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DcInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DcInput* New() const final {
    return new DcInput();
  }

  DcInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DcInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DcInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DcInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DcInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.DcInput";
  }
  protected:
  explicit DcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kIndepNameFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.Control ctrl = 5;
  int ctrl_size() const;
  private:
  int _internal_ctrl_size() const;
  public:
  void clear_ctrl();
  ::vlsir::spice::Control* mutable_ctrl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrl();
  private:
  const ::vlsir::spice::Control& _internal_ctrl(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrl();
  public:
  const ::vlsir::spice::Control& ctrl(int index) const;
  ::vlsir::spice::Control* add_ctrl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrl() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string indep_name = 2;
  void clear_indep_name();
  const std::string& indep_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_indep_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_indep_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_indep_name();
  void set_allocated_indep_name(std::string* indep_name);
  private:
  const std::string& _internal_indep_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indep_name(const std::string& value);
  std::string* _internal_mutable_indep_name();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.DcInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indep_name_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class DcResult_MeasurementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  DcResult_MeasurementsEntry_DoNotUse();
  explicit constexpr DcResult_MeasurementsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DcResult_MeasurementsEntry_DoNotUse& other);
  static const DcResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DcResult_MeasurementsEntry_DoNotUse*>(&_DcResult_MeasurementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.DcResult.MeasurementsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class DcResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.DcResult) */ {
 public:
  inline DcResult() : DcResult(nullptr) {}
  ~DcResult() override;
  explicit constexpr DcResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DcResult(const DcResult& from);
  DcResult(DcResult&& from) noexcept
    : DcResult() {
    *this = ::std::move(from);
  }

  inline DcResult& operator=(const DcResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DcResult& operator=(DcResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DcResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const DcResult* internal_default_instance() {
    return reinterpret_cast<const DcResult*>(
               &_DcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DcResult& a, DcResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DcResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DcResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DcResult* New() const final {
    return new DcResult();
  }

  DcResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DcResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DcResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DcResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DcResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.DcResult";
  }
  protected:
  explicit DcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMeasurementsFieldNumber = 10,
    kAnalysisNameFieldNumber = 1,
    kIndepNameFieldNumber = 2,
    kSignalsFieldNumber = 3,
    kNumPointsFieldNumber = 4,
  };
  // repeated double data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // map<string, double> measurements = 10;
  int measurements_size() const;
  private:
  int _internal_measurements_size() const;
  public:
  void clear_measurements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_measurements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string indep_name = 2;
  void clear_indep_name();
  const std::string& indep_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_indep_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_indep_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_indep_name();
  void set_allocated_indep_name(std::string* indep_name);
  private:
  const std::string& _internal_indep_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indep_name(const std::string& value);
  std::string* _internal_mutable_indep_name();
  public:

  // .vlsir.spice.Signals signals = 3;
  bool has_signals() const;
  private:
  bool _internal_has_signals() const;
  public:
  void clear_signals();
  const ::vlsir::spice::Signals& signals() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Signals* release_signals();
  ::vlsir::spice::Signals* mutable_signals();
  void set_allocated_signals(::vlsir::spice::Signals* signals);
  private:
  const ::vlsir::spice::Signals& _internal_signals() const;
  ::vlsir::spice::Signals* _internal_mutable_signals();
  public:
  void unsafe_arena_set_allocated_signals(
      ::vlsir::spice::Signals* signals);
  ::vlsir::spice::Signals* unsafe_arena_release_signals();

  // int64 num_points = 4;
  void clear_num_points();
  ::PROTOBUF_NAMESPACE_ID::int64 num_points() const;
  void set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_points() const;
  void _internal_set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.DcResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DcResult_MeasurementsEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> measurements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indep_name_;
  ::vlsir::spice::Signals* signals_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class TranInput_IcEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranInput_IcEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranInput_IcEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  TranInput_IcEntry_DoNotUse();
  explicit constexpr TranInput_IcEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TranInput_IcEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TranInput_IcEntry_DoNotUse& other);
  static const TranInput_IcEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TranInput_IcEntry_DoNotUse*>(&_TranInput_IcEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.TranInput.IcEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TranInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.TranInput) */ {
 public:
  inline TranInput() : TranInput(nullptr) {}
  ~TranInput() override;
  explicit constexpr TranInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranInput(const TranInput& from);
  TranInput(TranInput&& from) noexcept
    : TranInput() {
    *this = ::std::move(from);
  }

  inline TranInput& operator=(const TranInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranInput& operator=(TranInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranInput* internal_default_instance() {
    return reinterpret_cast<const TranInput*>(
               &_TranInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TranInput& a, TranInput& b) {
    a.Swap(&b);
  }
  inline void Swap(TranInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranInput* New() const final {
    return new TranInput();
  }

  TranInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.TranInput";
  }
  protected:
  explicit TranInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIcFieldNumber = 4,
    kCtrlFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kTstopFieldNumber = 2,
    kTstepFieldNumber = 3,
  };
  // map<string, double> ic = 4;
  int ic_size() const;
  private:
  int _internal_ic_size() const;
  public:
  void clear_ic();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_ic() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_ic();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      ic() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_ic();

  // repeated .vlsir.spice.Control ctrl = 5;
  int ctrl_size() const;
  private:
  int _internal_ctrl_size() const;
  public:
  void clear_ctrl();
  ::vlsir::spice::Control* mutable_ctrl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrl();
  private:
  const ::vlsir::spice::Control& _internal_ctrl(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrl();
  public:
  const ::vlsir::spice::Control& ctrl(int index) const;
  ::vlsir::spice::Control* add_ctrl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrl() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // double tstop = 2;
  void clear_tstop();
  double tstop() const;
  void set_tstop(double value);
  private:
  double _internal_tstop() const;
  void _internal_set_tstop(double value);
  public:

  // double tstep = 3;
  void clear_tstep();
  double tstep() const;
  void set_tstep(double value);
  private:
  double _internal_tstep() const;
  void _internal_set_tstep(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.TranInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TranInput_IcEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> ic_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  double tstop_;
  double tstep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class TranResult_MeasurementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  TranResult_MeasurementsEntry_DoNotUse();
  explicit constexpr TranResult_MeasurementsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TranResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TranResult_MeasurementsEntry_DoNotUse& other);
  static const TranResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TranResult_MeasurementsEntry_DoNotUse*>(&_TranResult_MeasurementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.TranResult.MeasurementsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TranResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.TranResult) */ {
 public:
  inline TranResult() : TranResult(nullptr) {}
  ~TranResult() override;
  explicit constexpr TranResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranResult(const TranResult& from);
  TranResult(TranResult&& from) noexcept
    : TranResult() {
    *this = ::std::move(from);
  }

  inline TranResult& operator=(const TranResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranResult& operator=(TranResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranResult* internal_default_instance() {
    return reinterpret_cast<const TranResult*>(
               &_TranResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TranResult& a, TranResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TranResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranResult* New() const final {
    return new TranResult();
  }

  TranResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.TranResult";
  }
  protected:
  explicit TranResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMeasurementsFieldNumber = 10,
    kAnalysisNameFieldNumber = 1,
    kSignalsFieldNumber = 3,
    kNumPointsFieldNumber = 4,
  };
  // repeated double data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // map<string, double> measurements = 10;
  int measurements_size() const;
  private:
  int _internal_measurements_size() const;
  public:
  void clear_measurements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_measurements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // .vlsir.spice.Signals signals = 3;
  bool has_signals() const;
  private:
  bool _internal_has_signals() const;
  public:
  void clear_signals();
  const ::vlsir::spice::Signals& signals() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Signals* release_signals();
  ::vlsir::spice::Signals* mutable_signals();
  void set_allocated_signals(::vlsir::spice::Signals* signals);
  private:
  const ::vlsir::spice::Signals& _internal_signals() const;
  ::vlsir::spice::Signals* _internal_mutable_signals();
  public:
  void unsafe_arena_set_allocated_signals(
      ::vlsir::spice::Signals* signals);
  ::vlsir::spice::Signals* unsafe_arena_release_signals();

  // int64 num_points = 4;
  void clear_num_points();
  ::PROTOBUF_NAMESPACE_ID::int64 num_points() const;
  void set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_points() const;
  void _internal_set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.TranResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TranResult_MeasurementsEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> measurements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::vlsir::spice::Signals* signals_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class ComplexNum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.ComplexNum) */ {
 public:
  inline ComplexNum() : ComplexNum(nullptr) {}
  ~ComplexNum() override;
  explicit constexpr ComplexNum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComplexNum(const ComplexNum& from);
  ComplexNum(ComplexNum&& from) noexcept
    : ComplexNum() {
    *this = ::std::move(from);
  }

  inline ComplexNum& operator=(const ComplexNum& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComplexNum& operator=(ComplexNum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComplexNum& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComplexNum* internal_default_instance() {
    return reinterpret_cast<const ComplexNum*>(
               &_ComplexNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ComplexNum& a, ComplexNum& b) {
    a.Swap(&b);
  }
  inline void Swap(ComplexNum* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComplexNum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComplexNum* New() const final {
    return new ComplexNum();
  }

  ComplexNum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComplexNum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComplexNum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComplexNum& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplexNum* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.ComplexNum";
  }
  protected:
  explicit ComplexNum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReFieldNumber = 1,
    kImFieldNumber = 2,
  };
  // double re = 1;
  void clear_re();
  double re() const;
  void set_re(double value);
  private:
  double _internal_re() const;
  void _internal_set_re(double value);
  public:

  // double im = 2;
  void clear_im();
  double im() const;
  void set_im(double value);
  private:
  double _internal_im() const;
  void _internal_set_im(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.ComplexNum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double re_;
  double im_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class AcInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AcInput) */ {
 public:
  inline AcInput() : AcInput(nullptr) {}
  ~AcInput() override;
  explicit constexpr AcInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcInput(const AcInput& from);
  AcInput(AcInput&& from) noexcept
    : AcInput() {
    *this = ::std::move(from);
  }

  inline AcInput& operator=(const AcInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcInput& operator=(AcInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcInput* internal_default_instance() {
    return reinterpret_cast<const AcInput*>(
               &_AcInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AcInput& a, AcInput& b) {
    a.Swap(&b);
  }
  inline void Swap(AcInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcInput* New() const final {
    return new AcInput();
  }

  AcInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AcInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.AcInput";
  }
  protected:
  explicit AcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kFstartFieldNumber = 2,
    kFstopFieldNumber = 3,
    kNptsFieldNumber = 4,
  };
  // repeated .vlsir.spice.Control ctrl = 5;
  int ctrl_size() const;
  private:
  int _internal_ctrl_size() const;
  public:
  void clear_ctrl();
  ::vlsir::spice::Control* mutable_ctrl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrl();
  private:
  const ::vlsir::spice::Control& _internal_ctrl(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrl();
  public:
  const ::vlsir::spice::Control& ctrl(int index) const;
  ::vlsir::spice::Control* add_ctrl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrl() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // double fstart = 2;
  void clear_fstart();
  double fstart() const;
  void set_fstart(double value);
  private:
  double _internal_fstart() const;
  void _internal_set_fstart(double value);
  public:

  // double fstop = 3;
  void clear_fstop();
  double fstop() const;
  void set_fstop(double value);
  private:
  double _internal_fstop() const;
  void _internal_set_fstop(double value);
  public:

  // uint64 npts = 4;
  void clear_npts();
  ::PROTOBUF_NAMESPACE_ID::uint64 npts() const;
  void set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_npts() const;
  void _internal_set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.AcInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  double fstart_;
  double fstop_;
  ::PROTOBUF_NAMESPACE_ID::uint64 npts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class AcResult_MeasurementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  AcResult_MeasurementsEntry_DoNotUse();
  explicit constexpr AcResult_MeasurementsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AcResult_MeasurementsEntry_DoNotUse& other);
  static const AcResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AcResult_MeasurementsEntry_DoNotUse*>(&_AcResult_MeasurementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.AcResult.MeasurementsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AcResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AcResult) */ {
 public:
  inline AcResult() : AcResult(nullptr) {}
  ~AcResult() override;
  explicit constexpr AcResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcResult(const AcResult& from);
  AcResult(AcResult&& from) noexcept
    : AcResult() {
    *this = ::std::move(from);
  }

  inline AcResult& operator=(const AcResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcResult& operator=(AcResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcResult* internal_default_instance() {
    return reinterpret_cast<const AcResult*>(
               &_AcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AcResult& a, AcResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AcResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcResult* New() const final {
    return new AcResult();
  }

  AcResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AcResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.AcResult";
  }
  protected:
  explicit AcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFreqFieldNumber = 2,
    kDataFieldNumber = 5,
    kMeasurementsFieldNumber = 10,
    kAnalysisNameFieldNumber = 1,
    kSignalsFieldNumber = 3,
    kNumPointsFieldNumber = 4,
  };
  // repeated double freq = 2;
  int freq_size() const;
  private:
  int _internal_freq_size() const;
  public:
  void clear_freq();
  private:
  double _internal_freq(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_freq() const;
  void _internal_add_freq(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_freq();
  public:
  double freq(int index) const;
  void set_freq(int index, double value);
  void add_freq(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      freq() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_freq();

  // repeated .vlsir.spice.ComplexNum data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::vlsir::spice::ComplexNum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >*
      mutable_data();
  private:
  const ::vlsir::spice::ComplexNum& _internal_data(int index) const;
  ::vlsir::spice::ComplexNum* _internal_add_data();
  public:
  const ::vlsir::spice::ComplexNum& data(int index) const;
  ::vlsir::spice::ComplexNum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >&
      data() const;

  // map<string, double> measurements = 10;
  int measurements_size() const;
  private:
  int _internal_measurements_size() const;
  public:
  void clear_measurements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_measurements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // .vlsir.spice.Signals signals = 3;
  bool has_signals() const;
  private:
  bool _internal_has_signals() const;
  public:
  void clear_signals();
  const ::vlsir::spice::Signals& signals() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Signals* release_signals();
  ::vlsir::spice::Signals* mutable_signals();
  void set_allocated_signals(::vlsir::spice::Signals* signals);
  private:
  const ::vlsir::spice::Signals& _internal_signals() const;
  ::vlsir::spice::Signals* _internal_mutable_signals();
  public:
  void unsafe_arena_set_allocated_signals(
      ::vlsir::spice::Signals* signals);
  ::vlsir::spice::Signals* unsafe_arena_release_signals();

  // int64 num_points = 4;
  void clear_num_points();
  ::PROTOBUF_NAMESPACE_ID::int64 num_points() const;
  void set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_points() const;
  void _internal_set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.AcResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > freq_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AcResult_MeasurementsEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> measurements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::vlsir::spice::Signals* signals_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SweepInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SweepInput) */ {
 public:
  inline SweepInput() : SweepInput(nullptr) {}
  ~SweepInput() override;
  explicit constexpr SweepInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SweepInput(const SweepInput& from);
  SweepInput(SweepInput&& from) noexcept
    : SweepInput() {
    *this = ::std::move(from);
  }

  inline SweepInput& operator=(const SweepInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SweepInput& operator=(SweepInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SweepInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SweepInput* internal_default_instance() {
    return reinterpret_cast<const SweepInput*>(
               &_SweepInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SweepInput& a, SweepInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SweepInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SweepInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SweepInput* New() const final {
    return new SweepInput();
  }

  SweepInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SweepInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SweepInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SweepInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SweepInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SweepInput";
  }
  protected:
  explicit SweepInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kVariableFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.Analysis an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  private:
  const ::vlsir::spice::Analysis& _internal_an(int index) const;
  ::vlsir::spice::Analysis* _internal_add_an();
  public:
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string variable = 2;
  void clear_variable();
  const std::string& variable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variable();
  PROTOBUF_MUST_USE_RESULT std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  private:
  const std::string& _internal_variable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SweepInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SweepResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SweepResult) */ {
 public:
  inline SweepResult() : SweepResult(nullptr) {}
  ~SweepResult() override;
  explicit constexpr SweepResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SweepResult(const SweepResult& from);
  SweepResult(SweepResult&& from) noexcept
    : SweepResult() {
    *this = ::std::move(from);
  }

  inline SweepResult& operator=(const SweepResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SweepResult& operator=(SweepResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SweepResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SweepResult* internal_default_instance() {
    return reinterpret_cast<const SweepResult*>(
               &_SweepResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SweepResult& a, SweepResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SweepResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SweepResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SweepResult* New() const final {
    return new SweepResult();
  }

  SweepResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SweepResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SweepResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SweepResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SweepResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SweepResult";
  }
  protected:
  explicit SweepResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kAnalysisNameFieldNumber = 1,
    kVariableFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.AnalysisResult an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  private:
  const ::vlsir::spice::AnalysisResult& _internal_an(int index) const;
  ::vlsir::spice::AnalysisResult* _internal_add_an();
  public:
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string variable = 2;
  void clear_variable();
  const std::string& variable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variable();
  PROTOBUF_MUST_USE_RESULT std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  private:
  const std::string& _internal_variable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SweepResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class MonteInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.MonteInput) */ {
 public:
  inline MonteInput() : MonteInput(nullptr) {}
  ~MonteInput() override;
  explicit constexpr MonteInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonteInput(const MonteInput& from);
  MonteInput(MonteInput&& from) noexcept
    : MonteInput() {
    *this = ::std::move(from);
  }

  inline MonteInput& operator=(const MonteInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonteInput& operator=(MonteInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonteInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonteInput* internal_default_instance() {
    return reinterpret_cast<const MonteInput*>(
               &_MonteInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MonteInput& a, MonteInput& b) {
    a.Swap(&b);
  }
  inline void Swap(MonteInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonteInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonteInput* New() const final {
    return new MonteInput();
  }

  MonteInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonteInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonteInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MonteInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonteInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.MonteInput";
  }
  protected:
  explicit MonteInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kNptsFieldNumber = 2,
    kSeedFieldNumber = 3,
  };
  // repeated .vlsir.spice.Analysis an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  private:
  const ::vlsir::spice::Analysis& _internal_an(int index) const;
  ::vlsir::spice::Analysis* _internal_add_an();
  public:
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // int64 npts = 2;
  void clear_npts();
  ::PROTOBUF_NAMESPACE_ID::int64 npts() const;
  void set_npts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_npts() const;
  void _internal_set_npts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 seed = 3;
  void clear_seed();
  ::PROTOBUF_NAMESPACE_ID::int64 seed() const;
  void set_seed(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seed() const;
  void _internal_set_seed(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.MonteInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 npts_;
  ::PROTOBUF_NAMESPACE_ID::int64 seed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class MonteResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.MonteResult) */ {
 public:
  inline MonteResult() : MonteResult(nullptr) {}
  ~MonteResult() override;
  explicit constexpr MonteResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonteResult(const MonteResult& from);
  MonteResult(MonteResult&& from) noexcept
    : MonteResult() {
    *this = ::std::move(from);
  }

  inline MonteResult& operator=(const MonteResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonteResult& operator=(MonteResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonteResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonteResult* internal_default_instance() {
    return reinterpret_cast<const MonteResult*>(
               &_MonteResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MonteResult& a, MonteResult& b) {
    a.Swap(&b);
  }
  inline void Swap(MonteResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonteResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonteResult* New() const final {
    return new MonteResult();
  }

  MonteResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonteResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonteResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MonteResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonteResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.MonteResult";
  }
  protected:
  explicit MonteResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kAnalysisNameFieldNumber = 1,
    kVariableFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.AnalysisResult an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  private:
  const ::vlsir::spice::AnalysisResult& _internal_an(int index) const;
  ::vlsir::spice::AnalysisResult* _internal_add_an();
  public:
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string variable = 2;
  void clear_variable();
  const std::string& variable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variable();
  PROTOBUF_MUST_USE_RESULT std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  private:
  const std::string& _internal_variable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.MonteResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class CustomAnalysisInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.CustomAnalysisInput) */ {
 public:
  inline CustomAnalysisInput() : CustomAnalysisInput(nullptr) {}
  ~CustomAnalysisInput() override;
  explicit constexpr CustomAnalysisInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomAnalysisInput(const CustomAnalysisInput& from);
  CustomAnalysisInput(CustomAnalysisInput&& from) noexcept
    : CustomAnalysisInput() {
    *this = ::std::move(from);
  }

  inline CustomAnalysisInput& operator=(const CustomAnalysisInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomAnalysisInput& operator=(CustomAnalysisInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomAnalysisInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomAnalysisInput* internal_default_instance() {
    return reinterpret_cast<const CustomAnalysisInput*>(
               &_CustomAnalysisInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CustomAnalysisInput& a, CustomAnalysisInput& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomAnalysisInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomAnalysisInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomAnalysisInput* New() const final {
    return new CustomAnalysisInput();
  }

  CustomAnalysisInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomAnalysisInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomAnalysisInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CustomAnalysisInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomAnalysisInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.CustomAnalysisInput";
  }
  protected:
  explicit CustomAnalysisInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kCmdFieldNumber = 2,
  };
  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string cmd = 2;
  void clear_cmd();
  const std::string& cmd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd();
  PROTOBUF_MUST_USE_RESULT std::string* release_cmd();
  void set_allocated_cmd(std::string* cmd);
  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(const std::string& value);
  std::string* _internal_mutable_cmd();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.CustomAnalysisInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class CustomAnalysisResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.CustomAnalysisResult) */ {
 public:
  inline CustomAnalysisResult() : CustomAnalysisResult(nullptr) {}
  ~CustomAnalysisResult() override;
  explicit constexpr CustomAnalysisResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomAnalysisResult(const CustomAnalysisResult& from);
  CustomAnalysisResult(CustomAnalysisResult&& from) noexcept
    : CustomAnalysisResult() {
    *this = ::std::move(from);
  }

  inline CustomAnalysisResult& operator=(const CustomAnalysisResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomAnalysisResult& operator=(CustomAnalysisResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomAnalysisResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomAnalysisResult* internal_default_instance() {
    return reinterpret_cast<const CustomAnalysisResult*>(
               &_CustomAnalysisResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CustomAnalysisResult& a, CustomAnalysisResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomAnalysisResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomAnalysisResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomAnalysisResult* New() const final {
    return new CustomAnalysisResult();
  }

  CustomAnalysisResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomAnalysisResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomAnalysisResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CustomAnalysisResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomAnalysisResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.CustomAnalysisResult";
  }
  protected:
  explicit CustomAnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vlsir.spice.CustomAnalysisResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Sweep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Sweep) */ {
 public:
  inline Sweep() : Sweep(nullptr) {}
  ~Sweep() override;
  explicit constexpr Sweep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sweep(const Sweep& from);
  Sweep(Sweep&& from) noexcept
    : Sweep() {
    *this = ::std::move(from);
  }

  inline Sweep& operator=(const Sweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sweep& operator=(Sweep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sweep& default_instance() {
    return *internal_default_instance();
  }
  enum TpCase {
    kLinear = 1,
    kLog = 2,
    kPoints = 3,
    TP_NOT_SET = 0,
  };

  static inline const Sweep* internal_default_instance() {
    return reinterpret_cast<const Sweep*>(
               &_Sweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Sweep& a, Sweep& b) {
    a.Swap(&b);
  }
  inline void Swap(Sweep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sweep* New() const final {
    return new Sweep();
  }

  Sweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sweep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sweep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Sweep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Sweep";
  }
  protected:
  explicit Sweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kLogFieldNumber = 2,
    kPointsFieldNumber = 3,
  };
  // .vlsir.spice.LinearSweep linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::vlsir::spice::LinearSweep& linear() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::LinearSweep* release_linear();
  ::vlsir::spice::LinearSweep* mutable_linear();
  void set_allocated_linear(::vlsir::spice::LinearSweep* linear);
  private:
  const ::vlsir::spice::LinearSweep& _internal_linear() const;
  ::vlsir::spice::LinearSweep* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::vlsir::spice::LinearSweep* linear);
  ::vlsir::spice::LinearSweep* unsafe_arena_release_linear();

  // .vlsir.spice.LogSweep log = 2;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::vlsir::spice::LogSweep& log() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::LogSweep* release_log();
  ::vlsir::spice::LogSweep* mutable_log();
  void set_allocated_log(::vlsir::spice::LogSweep* log);
  private:
  const ::vlsir::spice::LogSweep& _internal_log() const;
  ::vlsir::spice::LogSweep* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::vlsir::spice::LogSweep* log);
  ::vlsir::spice::LogSweep* unsafe_arena_release_log();

  // .vlsir.spice.PointSweep points = 3;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::vlsir::spice::PointSweep& points() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::PointSweep* release_points();
  ::vlsir::spice::PointSweep* mutable_points();
  void set_allocated_points(::vlsir::spice::PointSweep* points);
  private:
  const ::vlsir::spice::PointSweep& _internal_points() const;
  ::vlsir::spice::PointSweep* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::vlsir::spice::PointSweep* points);
  ::vlsir::spice::PointSweep* unsafe_arena_release_points();

  void clear_tp();
  TpCase tp_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Sweep)
 private:
  class _Internal;
  void set_has_linear();
  void set_has_log();
  void set_has_points();

  inline bool has_tp() const;
  inline void clear_has_tp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TpUnion {
    constexpr TpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::spice::LinearSweep* linear_;
    ::vlsir::spice::LogSweep* log_;
    ::vlsir::spice::PointSweep* points_;
  } tp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class LinearSweep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LinearSweep) */ {
 public:
  inline LinearSweep() : LinearSweep(nullptr) {}
  ~LinearSweep() override;
  explicit constexpr LinearSweep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearSweep(const LinearSweep& from);
  LinearSweep(LinearSweep&& from) noexcept
    : LinearSweep() {
    *this = ::std::move(from);
  }

  inline LinearSweep& operator=(const LinearSweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearSweep& operator=(LinearSweep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearSweep& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearSweep* internal_default_instance() {
    return reinterpret_cast<const LinearSweep*>(
               &_LinearSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LinearSweep& a, LinearSweep& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearSweep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearSweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinearSweep* New() const final {
    return new LinearSweep();
  }

  LinearSweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinearSweep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearSweep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearSweep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearSweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.LinearSweep";
  }
  protected:
  explicit LinearSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kStopFieldNumber = 2,
    kStepFieldNumber = 3,
  };
  // double start = 1;
  void clear_start();
  double start() const;
  void set_start(double value);
  private:
  double _internal_start() const;
  void _internal_set_start(double value);
  public:

  // double stop = 2;
  void clear_stop();
  double stop() const;
  void set_stop(double value);
  private:
  double _internal_stop() const;
  void _internal_set_stop(double value);
  public:

  // double step = 3;
  void clear_step();
  double step() const;
  void set_step(double value);
  private:
  double _internal_step() const;
  void _internal_set_step(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.LinearSweep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double start_;
  double stop_;
  double step_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class LogSweep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LogSweep) */ {
 public:
  inline LogSweep() : LogSweep(nullptr) {}
  ~LogSweep() override;
  explicit constexpr LogSweep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSweep(const LogSweep& from);
  LogSweep(LogSweep&& from) noexcept
    : LogSweep() {
    *this = ::std::move(from);
  }

  inline LogSweep& operator=(const LogSweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSweep& operator=(LogSweep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSweep& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogSweep* internal_default_instance() {
    return reinterpret_cast<const LogSweep*>(
               &_LogSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(LogSweep& a, LogSweep& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSweep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogSweep* New() const final {
    return new LogSweep();
  }

  LogSweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogSweep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSweep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogSweep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.LogSweep";
  }
  protected:
  explicit LogSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kStopFieldNumber = 2,
    kNptsFieldNumber = 3,
  };
  // double start = 1;
  void clear_start();
  double start() const;
  void set_start(double value);
  private:
  double _internal_start() const;
  void _internal_set_start(double value);
  public:

  // double stop = 2;
  void clear_stop();
  double stop() const;
  void set_stop(double value);
  private:
  double _internal_stop() const;
  void _internal_set_stop(double value);
  public:

  // double npts = 3;
  void clear_npts();
  double npts() const;
  void set_npts(double value);
  private:
  double _internal_npts() const;
  void _internal_set_npts(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.LogSweep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double start_;
  double stop_;
  double npts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class PointSweep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.PointSweep) */ {
 public:
  inline PointSweep() : PointSweep(nullptr) {}
  ~PointSweep() override;
  explicit constexpr PointSweep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointSweep(const PointSweep& from);
  PointSweep(PointSweep&& from) noexcept
    : PointSweep() {
    *this = ::std::move(from);
  }

  inline PointSweep& operator=(const PointSweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointSweep& operator=(PointSweep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointSweep& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointSweep* internal_default_instance() {
    return reinterpret_cast<const PointSweep*>(
               &_PointSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PointSweep& a, PointSweep& b) {
    a.Swap(&b);
  }
  inline void Swap(PointSweep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointSweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointSweep* New() const final {
    return new PointSweep();
  }

  PointSweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointSweep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointSweep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PointSweep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointSweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.PointSweep";
  }
  protected:
  explicit PointSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kStopFieldNumber = 2,
    kNptsFieldNumber = 3,
  };
  // repeated double points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  private:
  double _internal_points(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_points() const;
  void _internal_add_points(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_points();
  public:
  double points(int index) const;
  void set_points(int index, double value);
  void add_points(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_points();

  // double stop = 2;
  void clear_stop();
  double stop() const;
  void set_stop(double value);
  private:
  double _internal_stop() const;
  void _internal_set_stop(double value);
  public:

  // double npts = 3;
  void clear_npts();
  double npts() const;
  void set_npts(double value);
  private:
  double _internal_npts() const;
  void _internal_set_npts(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.PointSweep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > points_;
  double stop_;
  double npts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Control final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Control) */ {
 public:
  inline Control() : Control(nullptr) {}
  ~Control() override;
  explicit constexpr Control(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control(const Control& from);
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control& operator=(Control&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control& default_instance() {
    return *internal_default_instance();
  }
  enum CtrlCase {
    kSave = 1,
    kInclude = 2,
    kLiteral = 3,
    CTRL_NOT_SET = 0,
  };

  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }
  inline void Swap(Control* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control* New() const final {
    return new Control();
  }

  Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Control";
  }
  protected:
  explicit Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaveFieldNumber = 1,
    kIncludeFieldNumber = 2,
    kLiteralFieldNumber = 3,
  };
  // .vlsir.spice.Save save = 1;
  bool has_save() const;
  private:
  bool _internal_has_save() const;
  public:
  void clear_save();
  const ::vlsir::spice::Save& save() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Save* release_save();
  ::vlsir::spice::Save* mutable_save();
  void set_allocated_save(::vlsir::spice::Save* save);
  private:
  const ::vlsir::spice::Save& _internal_save() const;
  ::vlsir::spice::Save* _internal_mutable_save();
  public:
  void unsafe_arena_set_allocated_save(
      ::vlsir::spice::Save* save);
  ::vlsir::spice::Save* unsafe_arena_release_save();

  // .vlsir.spice.Include include = 2;
  bool has_include() const;
  private:
  bool _internal_has_include() const;
  public:
  void clear_include();
  const ::vlsir::spice::Include& include() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::spice::Include* release_include();
  ::vlsir::spice::Include* mutable_include();
  void set_allocated_include(::vlsir::spice::Include* include);
  private:
  const ::vlsir::spice::Include& _internal_include() const;
  ::vlsir::spice::Include* _internal_mutable_include();
  public:
  void unsafe_arena_set_allocated_include(
      ::vlsir::spice::Include* include);
  ::vlsir::spice::Include* unsafe_arena_release_include();

  // string literal = 3;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const std::string& literal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_literal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_literal();
  PROTOBUF_MUST_USE_RESULT std::string* release_literal();
  void set_allocated_literal(std::string* literal);
  private:
  const std::string& _internal_literal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_literal(const std::string& value);
  std::string* _internal_mutable_literal();
  public:

  void clear_ctrl();
  CtrlCase ctrl_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Control)
 private:
  class _Internal;
  void set_has_save();
  void set_has_include();
  void set_has_literal();

  inline bool has_ctrl() const;
  inline void clear_has_ctrl();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CtrlUnion {
    constexpr CtrlUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::spice::Save* save_;
    ::vlsir::spice::Include* include_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr literal_;
  } ctrl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Save final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Save) */ {
 public:
  inline Save() : Save(nullptr) {}
  ~Save() override;
  explicit constexpr Save(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Save(const Save& from);
  Save(Save&& from) noexcept
    : Save() {
    *this = ::std::move(from);
  }

  inline Save& operator=(const Save& from) {
    CopyFrom(from);
    return *this;
  }
  inline Save& operator=(Save&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Save& default_instance() {
    return *internal_default_instance();
  }
  enum SaveCase {
    kMode = 1,
    kSignal = 2,
    SAVE_NOT_SET = 0,
  };

  static inline const Save* internal_default_instance() {
    return reinterpret_cast<const Save*>(
               &_Save_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Save& a, Save& b) {
    a.Swap(&b);
  }
  inline void Swap(Save* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Save* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Save* New() const final {
    return new Save();
  }

  Save* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Save>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Save& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Save& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Save* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Save";
  }
  protected:
  explicit Save(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Save_SaveMode SaveMode;
  static constexpr SaveMode NONE =
    Save_SaveMode_NONE;
  static constexpr SaveMode ALL =
    Save_SaveMode_ALL;
  static inline bool SaveMode_IsValid(int value) {
    return Save_SaveMode_IsValid(value);
  }
  static constexpr SaveMode SaveMode_MIN =
    Save_SaveMode_SaveMode_MIN;
  static constexpr SaveMode SaveMode_MAX =
    Save_SaveMode_SaveMode_MAX;
  static constexpr int SaveMode_ARRAYSIZE =
    Save_SaveMode_SaveMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SaveMode_descriptor() {
    return Save_SaveMode_descriptor();
  }
  template<typename T>
  static inline const std::string& SaveMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SaveMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SaveMode_Name.");
    return Save_SaveMode_Name(enum_t_value);
  }
  static inline bool SaveMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SaveMode* value) {
    return Save_SaveMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
    kSignalFieldNumber = 2,
  };
  // .vlsir.spice.Save.SaveMode mode = 1;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::vlsir::spice::Save_SaveMode mode() const;
  void set_mode(::vlsir::spice::Save_SaveMode value);
  private:
  ::vlsir::spice::Save_SaveMode _internal_mode() const;
  void _internal_set_mode(::vlsir::spice::Save_SaveMode value);
  public:

  // string signal = 2;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  const std::string& signal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signal();
  PROTOBUF_MUST_USE_RESULT std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  private:
  const std::string& _internal_signal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  void clear_save();
  SaveCase save_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Save)
 private:
  class _Internal;
  void set_has_mode();
  void set_has_signal();

  inline bool has_save() const;
  inline void clear_has_save();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SaveUnion {
    constexpr SaveUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  } save_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Include final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Include) */ {
 public:
  inline Include() : Include(nullptr) {}
  ~Include() override;
  explicit constexpr Include(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Include(const Include& from);
  Include(Include&& from) noexcept
    : Include() {
    *this = ::std::move(from);
  }

  inline Include& operator=(const Include& from) {
    CopyFrom(from);
    return *this;
  }
  inline Include& operator=(Include&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Include& default_instance() {
    return *internal_default_instance();
  }
  static inline const Include* internal_default_instance() {
    return reinterpret_cast<const Include*>(
               &_Include_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Include& a, Include& b) {
    a.Swap(&b);
  }
  inline void Swap(Include* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Include* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Include* New() const final {
    return new Include();
  }

  Include* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Include>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Include& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Include& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Include* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Include";
  }
  protected:
  explicit Include(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Include)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class LibInclude final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LibInclude) */ {
 public:
  inline LibInclude() : LibInclude(nullptr) {}
  ~LibInclude() override;
  explicit constexpr LibInclude(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibInclude(const LibInclude& from);
  LibInclude(LibInclude&& from) noexcept
    : LibInclude() {
    *this = ::std::move(from);
  }

  inline LibInclude& operator=(const LibInclude& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibInclude& operator=(LibInclude&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibInclude& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibInclude* internal_default_instance() {
    return reinterpret_cast<const LibInclude*>(
               &_LibInclude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LibInclude& a, LibInclude& b) {
    a.Swap(&b);
  }
  inline void Swap(LibInclude* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibInclude* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LibInclude* New() const final {
    return new LibInclude();
  }

  LibInclude* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LibInclude>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibInclude& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LibInclude& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibInclude* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.LibInclude";
  }
  protected:
  explicit LibInclude(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kSectionFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string section = 2;
  void clear_section();
  const std::string& section() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_section(ArgT0&& arg0, ArgT... args);
  std::string* mutable_section();
  PROTOBUF_MUST_USE_RESULT std::string* release_section();
  void set_allocated_section(std::string* section);
  private:
  const std::string& _internal_section() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_section(const std::string& value);
  std::string* _internal_mutable_section();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.LibInclude)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr section_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Meas final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Meas) */ {
 public:
  inline Meas() : Meas(nullptr) {}
  ~Meas() override;
  explicit constexpr Meas(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meas(const Meas& from);
  Meas(Meas&& from) noexcept
    : Meas() {
    *this = ::std::move(from);
  }

  inline Meas& operator=(const Meas& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meas& operator=(Meas&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Meas& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meas* internal_default_instance() {
    return reinterpret_cast<const Meas*>(
               &_Meas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Meas& a, Meas& b) {
    a.Swap(&b);
  }
  inline void Swap(Meas* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meas* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Meas* New() const final {
    return new Meas();
  }

  Meas* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Meas>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Meas& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Meas& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Meas* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Meas";
  }
  protected:
  explicit Meas(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExprFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string expr = 2;
  void clear_expr();
  const std::string& expr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expr();
  PROTOBUF_MUST_USE_RESULT std::string* release_expr();
  void set_allocated_expr(std::string* expr);
  private:
  const std::string& _internal_expr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expr(const std::string& value);
  std::string* _internal_mutable_expr();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Meas)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Signal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {}
  ~Signal() override;
  explicit constexpr Signal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return new Signal();
  }

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Signal";
  }
  protected:
  explicit Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signal_Quantity Quantity;
  static constexpr Quantity VOLTAGE =
    Signal_Quantity_VOLTAGE;
  static constexpr Quantity CURRENT =
    Signal_Quantity_CURRENT;
  static constexpr Quantity NONE =
    Signal_Quantity_NONE;
  static inline bool Quantity_IsValid(int value) {
    return Signal_Quantity_IsValid(value);
  }
  static constexpr Quantity Quantity_MIN =
    Signal_Quantity_Quantity_MIN;
  static constexpr Quantity Quantity_MAX =
    Signal_Quantity_Quantity_MAX;
  static constexpr int Quantity_ARRAYSIZE =
    Signal_Quantity_Quantity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Quantity_descriptor() {
    return Signal_Quantity_descriptor();
  }
  template<typename T>
  static inline const std::string& Quantity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Quantity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Quantity_Name.");
    return Signal_Quantity_Name(enum_t_value);
  }
  static inline bool Quantity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Quantity* value) {
    return Signal_Quantity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Signal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Signals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Signals) */ {
 public:
  inline Signals() : Signals(nullptr) {}
  ~Signals() override;
  explicit constexpr Signals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signals(const Signals& from);
  Signals(Signals&& from) noexcept
    : Signals() {
    *this = ::std::move(from);
  }

  inline Signals& operator=(const Signals& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signals& operator=(Signals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signals& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signals* internal_default_instance() {
    return reinterpret_cast<const Signals*>(
               &_Signals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Signals& a, Signals& b) {
    a.Swap(&b);
  }
  inline void Swap(Signals* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signals* New() const final {
    return new Signals();
  }

  Signals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signals& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signals* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Signals";
  }
  protected:
  explicit Signals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated .vlsir.spice.Signal signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  ::vlsir::spice::Signal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Signal >*
      mutable_signals();
  private:
  const ::vlsir::spice::Signal& _internal_signals(int index) const;
  ::vlsir::spice::Signal* _internal_add_signals();
  public:
  const ::vlsir::spice::Signal& signals(int index) const;
  ::vlsir::spice::Signal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Signal >&
      signals() const;

  // @@protoc_insertion_point(class_scope:vlsir.spice.Signals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Signal > signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimInput

// .vlsir.spice.Circuit ckt = 1;
inline bool SimInput::_internal_has_ckt() const {
  return this != internal_default_instance() && ckt_ != nullptr;
}
inline bool SimInput::has_ckt() const {
  return _internal_has_ckt();
}
inline void SimInput::clear_ckt() {
  if (GetArenaForAllocation() == nullptr && ckt_ != nullptr) {
    delete ckt_;
  }
  ckt_ = nullptr;
}
inline const ::vlsir::spice::Circuit& SimInput::_internal_ckt() const {
  const ::vlsir::spice::Circuit* p = ckt_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Circuit&>(
      ::vlsir::spice::_Circuit_default_instance_);
}
inline const ::vlsir::spice::Circuit& SimInput::ckt() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.ckt)
  return _internal_ckt();
}
inline void SimInput::unsafe_arena_set_allocated_ckt(
    ::vlsir::spice::Circuit* ckt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ckt_);
  }
  ckt_ = ckt;
  if (ckt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimInput.ckt)
}
inline ::vlsir::spice::Circuit* SimInput::release_ckt() {
  
  ::vlsir::spice::Circuit* temp = ckt_;
  ckt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Circuit* SimInput::unsafe_arena_release_ckt() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimInput.ckt)
  
  ::vlsir::spice::Circuit* temp = ckt_;
  ckt_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Circuit* SimInput::_internal_mutable_ckt() {
  
  if (ckt_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Circuit>(GetArenaForAllocation());
    ckt_ = p;
  }
  return ckt_;
}
inline ::vlsir::spice::Circuit* SimInput::mutable_ckt() {
  ::vlsir::spice::Circuit* _msg = _internal_mutable_ckt();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.ckt)
  return _msg;
}
inline void SimInput::set_allocated_ckt(::vlsir::spice::Circuit* ckt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ckt_;
  }
  if (ckt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Circuit>::GetOwningArena(ckt);
    if (message_arena != submessage_arena) {
      ckt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ckt, submessage_arena);
    }
    
  } else {
    
  }
  ckt_ = ckt;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimInput.ckt)
}

// .vlsir.spice.SimOptions opts = 2;
inline bool SimInput::_internal_has_opts() const {
  return this != internal_default_instance() && opts_ != nullptr;
}
inline bool SimInput::has_opts() const {
  return _internal_has_opts();
}
inline void SimInput::clear_opts() {
  if (GetArenaForAllocation() == nullptr && opts_ != nullptr) {
    delete opts_;
  }
  opts_ = nullptr;
}
inline const ::vlsir::spice::SimOptions& SimInput::_internal_opts() const {
  const ::vlsir::spice::SimOptions* p = opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::SimOptions&>(
      ::vlsir::spice::_SimOptions_default_instance_);
}
inline const ::vlsir::spice::SimOptions& SimInput::opts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.opts)
  return _internal_opts();
}
inline void SimInput::unsafe_arena_set_allocated_opts(
    ::vlsir::spice::SimOptions* opts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opts_);
  }
  opts_ = opts;
  if (opts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimInput.opts)
}
inline ::vlsir::spice::SimOptions* SimInput::release_opts() {
  
  ::vlsir::spice::SimOptions* temp = opts_;
  opts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::SimOptions* SimInput::unsafe_arena_release_opts() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimInput.opts)
  
  ::vlsir::spice::SimOptions* temp = opts_;
  opts_ = nullptr;
  return temp;
}
inline ::vlsir::spice::SimOptions* SimInput::_internal_mutable_opts() {
  
  if (opts_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::SimOptions>(GetArenaForAllocation());
    opts_ = p;
  }
  return opts_;
}
inline ::vlsir::spice::SimOptions* SimInput::mutable_opts() {
  ::vlsir::spice::SimOptions* _msg = _internal_mutable_opts();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.opts)
  return _msg;
}
inline void SimInput::set_allocated_opts(::vlsir::spice::SimOptions* opts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete opts_;
  }
  if (opts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::SimOptions>::GetOwningArena(opts);
    if (message_arena != submessage_arena) {
      opts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opts, submessage_arena);
    }
    
  } else {
    
  }
  opts_ = opts;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimInput.opts)
}

// repeated .vlsir.spice.Analysis an = 3;
inline int SimInput::_internal_an_size() const {
  return an_.size();
}
inline int SimInput::an_size() const {
  return _internal_an_size();
}
inline void SimInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* SimInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
SimInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& SimInput::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::Analysis& SimInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.an)
  return _internal_an(index);
}
inline ::vlsir::spice::Analysis* SimInput::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::Analysis* SimInput::add_an() {
  ::vlsir::spice::Analysis* _add = _internal_add_an();
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.an)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
SimInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 4;
inline int SimInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int SimInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void SimInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* SimInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
SimInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& SimInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& SimInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* SimInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* SimInput::add_ctrls() {
  ::vlsir::spice::Control* _add = _internal_add_ctrls();
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.ctrls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
SimInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// SimResult

// repeated .vlsir.spice.AnalysisResult an = 1;
inline int SimResult::_internal_an_size() const {
  return an_.size();
}
inline int SimResult::an_size() const {
  return _internal_an_size();
}
inline void SimResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* SimResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimResult.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
SimResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& SimResult::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::AnalysisResult& SimResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimResult.an)
  return _internal_an(index);
}
inline ::vlsir::spice::AnalysisResult* SimResult::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::AnalysisResult* SimResult::add_an() {
  ::vlsir::spice::AnalysisResult* _add = _internal_add_an();
  // @@protoc_insertion_point(field_add:vlsir.spice.SimResult.an)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
SimResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimResult.an)
  return an_;
}

// -------------------------------------------------------------------

// SimOptions

// .google.protobuf.DoubleValue temp = 1;
inline bool SimOptions::_internal_has_temp() const {
  return this != internal_default_instance() && temp_ != nullptr;
}
inline bool SimOptions::has_temp() const {
  return _internal_has_temp();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::_internal_temp() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = temp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::temp() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.temp)
  return _internal_temp();
}
inline void SimOptions::unsafe_arena_set_allocated_temp(
    PROTOBUF_NAMESPACE_ID::DoubleValue* temp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp_);
  }
  temp_ = temp;
  if (temp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimOptions.temp)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::release_temp() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = temp_;
  temp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::unsafe_arena_release_temp() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimOptions.temp)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = temp_;
  temp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::_internal_mutable_temp() {
  
  if (temp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    temp_ = p;
  }
  return temp_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::mutable_temp() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_temp();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimOptions.temp)
  return _msg;
}
inline void SimOptions::set_allocated_temp(PROTOBUF_NAMESPACE_ID::DoubleValue* temp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp_);
  }
  if (temp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp));
    if (message_arena != submessage_arena) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temp, submessage_arena);
    }
    
  } else {
    
  }
  temp_ = temp;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimOptions.temp)
}

// .google.protobuf.DoubleValue tnom = 2;
inline bool SimOptions::_internal_has_tnom() const {
  return this != internal_default_instance() && tnom_ != nullptr;
}
inline bool SimOptions::has_tnom() const {
  return _internal_has_tnom();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::_internal_tnom() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = tnom_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::tnom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.tnom)
  return _internal_tnom();
}
inline void SimOptions::unsafe_arena_set_allocated_tnom(
    PROTOBUF_NAMESPACE_ID::DoubleValue* tnom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tnom_);
  }
  tnom_ = tnom;
  if (tnom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimOptions.tnom)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::release_tnom() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = tnom_;
  tnom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::unsafe_arena_release_tnom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimOptions.tnom)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = tnom_;
  tnom_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::_internal_mutable_tnom() {
  
  if (tnom_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    tnom_ = p;
  }
  return tnom_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::mutable_tnom() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_tnom();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimOptions.tnom)
  return _msg;
}
inline void SimOptions::set_allocated_tnom(PROTOBUF_NAMESPACE_ID::DoubleValue* tnom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tnom_);
  }
  if (tnom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tnom));
    if (message_arena != submessage_arena) {
      tnom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tnom, submessage_arena);
    }
    
  } else {
    
  }
  tnom_ = tnom;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimOptions.tnom)
}

// .google.protobuf.DoubleValue gmin = 3;
inline bool SimOptions::_internal_has_gmin() const {
  return this != internal_default_instance() && gmin_ != nullptr;
}
inline bool SimOptions::has_gmin() const {
  return _internal_has_gmin();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::_internal_gmin() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = gmin_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::gmin() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.gmin)
  return _internal_gmin();
}
inline void SimOptions::unsafe_arena_set_allocated_gmin(
    PROTOBUF_NAMESPACE_ID::DoubleValue* gmin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gmin_);
  }
  gmin_ = gmin;
  if (gmin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimOptions.gmin)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::release_gmin() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = gmin_;
  gmin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::unsafe_arena_release_gmin() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimOptions.gmin)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = gmin_;
  gmin_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::_internal_mutable_gmin() {
  
  if (gmin_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    gmin_ = p;
  }
  return gmin_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::mutable_gmin() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_gmin();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimOptions.gmin)
  return _msg;
}
inline void SimOptions::set_allocated_gmin(PROTOBUF_NAMESPACE_ID::DoubleValue* gmin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gmin_);
  }
  if (gmin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gmin));
    if (message_arena != submessage_arena) {
      gmin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gmin, submessage_arena);
    }
    
  } else {
    
  }
  gmin_ = gmin;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimOptions.gmin)
}

// .google.protobuf.DoubleValue iabstol = 4;
inline bool SimOptions::_internal_has_iabstol() const {
  return this != internal_default_instance() && iabstol_ != nullptr;
}
inline bool SimOptions::has_iabstol() const {
  return _internal_has_iabstol();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::_internal_iabstol() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = iabstol_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::iabstol() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.iabstol)
  return _internal_iabstol();
}
inline void SimOptions::unsafe_arena_set_allocated_iabstol(
    PROTOBUF_NAMESPACE_ID::DoubleValue* iabstol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(iabstol_);
  }
  iabstol_ = iabstol;
  if (iabstol) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimOptions.iabstol)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::release_iabstol() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = iabstol_;
  iabstol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::unsafe_arena_release_iabstol() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimOptions.iabstol)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = iabstol_;
  iabstol_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::_internal_mutable_iabstol() {
  
  if (iabstol_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    iabstol_ = p;
  }
  return iabstol_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::mutable_iabstol() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_iabstol();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimOptions.iabstol)
  return _msg;
}
inline void SimOptions::set_allocated_iabstol(PROTOBUF_NAMESPACE_ID::DoubleValue* iabstol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(iabstol_);
  }
  if (iabstol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(iabstol));
    if (message_arena != submessage_arena) {
      iabstol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, iabstol, submessage_arena);
    }
    
  } else {
    
  }
  iabstol_ = iabstol;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimOptions.iabstol)
}

// .google.protobuf.DoubleValue reltol = 5;
inline bool SimOptions::_internal_has_reltol() const {
  return this != internal_default_instance() && reltol_ != nullptr;
}
inline bool SimOptions::has_reltol() const {
  return _internal_has_reltol();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::_internal_reltol() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = reltol_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& SimOptions::reltol() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.reltol)
  return _internal_reltol();
}
inline void SimOptions::unsafe_arena_set_allocated_reltol(
    PROTOBUF_NAMESPACE_ID::DoubleValue* reltol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reltol_);
  }
  reltol_ = reltol;
  if (reltol) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimOptions.reltol)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::release_reltol() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = reltol_;
  reltol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::unsafe_arena_release_reltol() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimOptions.reltol)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = reltol_;
  reltol_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::_internal_mutable_reltol() {
  
  if (reltol_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    reltol_ = p;
  }
  return reltol_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* SimOptions::mutable_reltol() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_reltol();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimOptions.reltol)
  return _msg;
}
inline void SimOptions::set_allocated_reltol(PROTOBUF_NAMESPACE_ID::DoubleValue* reltol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reltol_);
  }
  if (reltol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reltol));
    if (message_arena != submessage_arena) {
      reltol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reltol, submessage_arena);
    }
    
  } else {
    
  }
  reltol_ = reltol;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimOptions.reltol)
}

// -------------------------------------------------------------------

// Circuit

// string name = 1;
inline void Circuit::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Circuit::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Circuit.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Circuit::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Circuit.name)
}
inline std::string* Circuit::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Circuit.name)
  return _s;
}
inline const std::string& Circuit::_internal_name() const {
  return name_.Get();
}
inline void Circuit::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Circuit::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Circuit::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Circuit.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Circuit::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Circuit.name)
}

// repeated .vlsir.circuit.Signal signals = 3;
inline int Circuit::_internal_signals_size() const {
  return signals_.size();
}
inline int Circuit::signals_size() const {
  return _internal_signals_size();
}
inline ::vlsir::circuit::Signal* Circuit::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Circuit.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
Circuit::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.Circuit.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& Circuit::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const ::vlsir::circuit::Signal& Circuit::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Circuit.signals)
  return _internal_signals(index);
}
inline ::vlsir::circuit::Signal* Circuit::_internal_add_signals() {
  return signals_.Add();
}
inline ::vlsir::circuit::Signal* Circuit::add_signals() {
  ::vlsir::circuit::Signal* _add = _internal_add_signals();
  // @@protoc_insertion_point(field_add:vlsir.spice.Circuit.signals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
Circuit::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.Circuit.signals)
  return signals_;
}

// repeated .vlsir.circuit.Instance instances = 4;
inline int Circuit::_internal_instances_size() const {
  return instances_.size();
}
inline int Circuit::instances_size() const {
  return _internal_instances_size();
}
inline ::vlsir::circuit::Instance* Circuit::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Circuit.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
Circuit::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.Circuit.instances)
  return &instances_;
}
inline const ::vlsir::circuit::Instance& Circuit::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::vlsir::circuit::Instance& Circuit::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Circuit.instances)
  return _internal_instances(index);
}
inline ::vlsir::circuit::Instance* Circuit::_internal_add_instances() {
  return instances_.Add();
}
inline ::vlsir::circuit::Instance* Circuit::add_instances() {
  ::vlsir::circuit::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:vlsir.spice.Circuit.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
Circuit::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.Circuit.instances)
  return instances_;
}

// -------------------------------------------------------------------

// Analysis

// .vlsir.spice.OpInput op = 1;
inline bool Analysis::_internal_has_op() const {
  return an_case() == kOp;
}
inline bool Analysis::has_op() const {
  return _internal_has_op();
}
inline void Analysis::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void Analysis::clear_op() {
  if (_internal_has_op()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.op_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::OpInput* Analysis::release_op() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.op)
  if (_internal_has_op()) {
    clear_has_an();
      ::vlsir::spice::OpInput* temp = an_.op_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::OpInput& Analysis::_internal_op() const {
  return _internal_has_op()
      ? *an_.op_
      : reinterpret_cast< ::vlsir::spice::OpInput&>(::vlsir::spice::_OpInput_default_instance_);
}
inline const ::vlsir::spice::OpInput& Analysis::op() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.op)
  return _internal_op();
}
inline ::vlsir::spice::OpInput* Analysis::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.op)
  if (_internal_has_op()) {
    clear_has_an();
    ::vlsir::spice::OpInput* temp = an_.op_;
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_op(::vlsir::spice::OpInput* op) {
  clear_an();
  if (op) {
    set_has_op();
    an_.op_ = op;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.op)
}
inline ::vlsir::spice::OpInput* Analysis::_internal_mutable_op() {
  if (!_internal_has_op()) {
    clear_an();
    set_has_op();
    an_.op_ = CreateMaybeMessage< ::vlsir::spice::OpInput >(GetArenaForAllocation());
  }
  return an_.op_;
}
inline ::vlsir::spice::OpInput* Analysis::mutable_op() {
  ::vlsir::spice::OpInput* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.op)
  return _msg;
}

// .vlsir.spice.DcInput dc = 2;
inline bool Analysis::_internal_has_dc() const {
  return an_case() == kDc;
}
inline bool Analysis::has_dc() const {
  return _internal_has_dc();
}
inline void Analysis::set_has_dc() {
  _oneof_case_[0] = kDc;
}
inline void Analysis::clear_dc() {
  if (_internal_has_dc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.dc_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::DcInput* Analysis::release_dc() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.dc)
  if (_internal_has_dc()) {
    clear_has_an();
      ::vlsir::spice::DcInput* temp = an_.dc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::DcInput& Analysis::_internal_dc() const {
  return _internal_has_dc()
      ? *an_.dc_
      : reinterpret_cast< ::vlsir::spice::DcInput&>(::vlsir::spice::_DcInput_default_instance_);
}
inline const ::vlsir::spice::DcInput& Analysis::dc() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.dc)
  return _internal_dc();
}
inline ::vlsir::spice::DcInput* Analysis::unsafe_arena_release_dc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.dc)
  if (_internal_has_dc()) {
    clear_has_an();
    ::vlsir::spice::DcInput* temp = an_.dc_;
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_dc(::vlsir::spice::DcInput* dc) {
  clear_an();
  if (dc) {
    set_has_dc();
    an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.dc)
}
inline ::vlsir::spice::DcInput* Analysis::_internal_mutable_dc() {
  if (!_internal_has_dc()) {
    clear_an();
    set_has_dc();
    an_.dc_ = CreateMaybeMessage< ::vlsir::spice::DcInput >(GetArenaForAllocation());
  }
  return an_.dc_;
}
inline ::vlsir::spice::DcInput* Analysis::mutable_dc() {
  ::vlsir::spice::DcInput* _msg = _internal_mutable_dc();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.dc)
  return _msg;
}

// .vlsir.spice.TranInput tran = 3;
inline bool Analysis::_internal_has_tran() const {
  return an_case() == kTran;
}
inline bool Analysis::has_tran() const {
  return _internal_has_tran();
}
inline void Analysis::set_has_tran() {
  _oneof_case_[0] = kTran;
}
inline void Analysis::clear_tran() {
  if (_internal_has_tran()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.tran_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::TranInput* Analysis::release_tran() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.tran)
  if (_internal_has_tran()) {
    clear_has_an();
      ::vlsir::spice::TranInput* temp = an_.tran_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::TranInput& Analysis::_internal_tran() const {
  return _internal_has_tran()
      ? *an_.tran_
      : reinterpret_cast< ::vlsir::spice::TranInput&>(::vlsir::spice::_TranInput_default_instance_);
}
inline const ::vlsir::spice::TranInput& Analysis::tran() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.tran)
  return _internal_tran();
}
inline ::vlsir::spice::TranInput* Analysis::unsafe_arena_release_tran() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.tran)
  if (_internal_has_tran()) {
    clear_has_an();
    ::vlsir::spice::TranInput* temp = an_.tran_;
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_tran(::vlsir::spice::TranInput* tran) {
  clear_an();
  if (tran) {
    set_has_tran();
    an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.tran)
}
inline ::vlsir::spice::TranInput* Analysis::_internal_mutable_tran() {
  if (!_internal_has_tran()) {
    clear_an();
    set_has_tran();
    an_.tran_ = CreateMaybeMessage< ::vlsir::spice::TranInput >(GetArenaForAllocation());
  }
  return an_.tran_;
}
inline ::vlsir::spice::TranInput* Analysis::mutable_tran() {
  ::vlsir::spice::TranInput* _msg = _internal_mutable_tran();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.tran)
  return _msg;
}

// .vlsir.spice.AcInput ac = 4;
inline bool Analysis::_internal_has_ac() const {
  return an_case() == kAc;
}
inline bool Analysis::has_ac() const {
  return _internal_has_ac();
}
inline void Analysis::set_has_ac() {
  _oneof_case_[0] = kAc;
}
inline void Analysis::clear_ac() {
  if (_internal_has_ac()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.ac_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::AcInput* Analysis::release_ac() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.ac)
  if (_internal_has_ac()) {
    clear_has_an();
      ::vlsir::spice::AcInput* temp = an_.ac_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::AcInput& Analysis::_internal_ac() const {
  return _internal_has_ac()
      ? *an_.ac_
      : reinterpret_cast< ::vlsir::spice::AcInput&>(::vlsir::spice::_AcInput_default_instance_);
}
inline const ::vlsir::spice::AcInput& Analysis::ac() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.ac)
  return _internal_ac();
}
inline ::vlsir::spice::AcInput* Analysis::unsafe_arena_release_ac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.ac)
  if (_internal_has_ac()) {
    clear_has_an();
    ::vlsir::spice::AcInput* temp = an_.ac_;
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_ac(::vlsir::spice::AcInput* ac) {
  clear_an();
  if (ac) {
    set_has_ac();
    an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.ac)
}
inline ::vlsir::spice::AcInput* Analysis::_internal_mutable_ac() {
  if (!_internal_has_ac()) {
    clear_an();
    set_has_ac();
    an_.ac_ = CreateMaybeMessage< ::vlsir::spice::AcInput >(GetArenaForAllocation());
  }
  return an_.ac_;
}
inline ::vlsir::spice::AcInput* Analysis::mutable_ac() {
  ::vlsir::spice::AcInput* _msg = _internal_mutable_ac();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.ac)
  return _msg;
}

// .vlsir.spice.SweepInput sweep = 10;
inline bool Analysis::_internal_has_sweep() const {
  return an_case() == kSweep;
}
inline bool Analysis::has_sweep() const {
  return _internal_has_sweep();
}
inline void Analysis::set_has_sweep() {
  _oneof_case_[0] = kSweep;
}
inline void Analysis::clear_sweep() {
  if (_internal_has_sweep()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.sweep_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::SweepInput* Analysis::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
      ::vlsir::spice::SweepInput* temp = an_.sweep_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::SweepInput& Analysis::_internal_sweep() const {
  return _internal_has_sweep()
      ? *an_.sweep_
      : reinterpret_cast< ::vlsir::spice::SweepInput&>(::vlsir::spice::_SweepInput_default_instance_);
}
inline const ::vlsir::spice::SweepInput& Analysis::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.sweep)
  return _internal_sweep();
}
inline ::vlsir::spice::SweepInput* Analysis::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
    ::vlsir::spice::SweepInput* temp = an_.sweep_;
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_sweep(::vlsir::spice::SweepInput* sweep) {
  clear_an();
  if (sweep) {
    set_has_sweep();
    an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.sweep)
}
inline ::vlsir::spice::SweepInput* Analysis::_internal_mutable_sweep() {
  if (!_internal_has_sweep()) {
    clear_an();
    set_has_sweep();
    an_.sweep_ = CreateMaybeMessage< ::vlsir::spice::SweepInput >(GetArenaForAllocation());
  }
  return an_.sweep_;
}
inline ::vlsir::spice::SweepInput* Analysis::mutable_sweep() {
  ::vlsir::spice::SweepInput* _msg = _internal_mutable_sweep();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.sweep)
  return _msg;
}

// .vlsir.spice.MonteInput monte = 11;
inline bool Analysis::_internal_has_monte() const {
  return an_case() == kMonte;
}
inline bool Analysis::has_monte() const {
  return _internal_has_monte();
}
inline void Analysis::set_has_monte() {
  _oneof_case_[0] = kMonte;
}
inline void Analysis::clear_monte() {
  if (_internal_has_monte()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.monte_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::MonteInput* Analysis::release_monte() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.monte)
  if (_internal_has_monte()) {
    clear_has_an();
      ::vlsir::spice::MonteInput* temp = an_.monte_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::MonteInput& Analysis::_internal_monte() const {
  return _internal_has_monte()
      ? *an_.monte_
      : reinterpret_cast< ::vlsir::spice::MonteInput&>(::vlsir::spice::_MonteInput_default_instance_);
}
inline const ::vlsir::spice::MonteInput& Analysis::monte() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.monte)
  return _internal_monte();
}
inline ::vlsir::spice::MonteInput* Analysis::unsafe_arena_release_monte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.monte)
  if (_internal_has_monte()) {
    clear_has_an();
    ::vlsir::spice::MonteInput* temp = an_.monte_;
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_monte(::vlsir::spice::MonteInput* monte) {
  clear_an();
  if (monte) {
    set_has_monte();
    an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.monte)
}
inline ::vlsir::spice::MonteInput* Analysis::_internal_mutable_monte() {
  if (!_internal_has_monte()) {
    clear_an();
    set_has_monte();
    an_.monte_ = CreateMaybeMessage< ::vlsir::spice::MonteInput >(GetArenaForAllocation());
  }
  return an_.monte_;
}
inline ::vlsir::spice::MonteInput* Analysis::mutable_monte() {
  ::vlsir::spice::MonteInput* _msg = _internal_mutable_monte();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.monte)
  return _msg;
}

// .vlsir.spice.CustomAnalysisInput custom = 20;
inline bool Analysis::_internal_has_custom() const {
  return an_case() == kCustom;
}
inline bool Analysis::has_custom() const {
  return _internal_has_custom();
}
inline void Analysis::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void Analysis::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.custom_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::release_custom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.custom)
  if (_internal_has_custom()) {
    clear_has_an();
      ::vlsir::spice::CustomAnalysisInput* temp = an_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::CustomAnalysisInput& Analysis::_internal_custom() const {
  return _internal_has_custom()
      ? *an_.custom_
      : reinterpret_cast< ::vlsir::spice::CustomAnalysisInput&>(::vlsir::spice::_CustomAnalysisInput_default_instance_);
}
inline const ::vlsir::spice::CustomAnalysisInput& Analysis::custom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.custom)
  return _internal_custom();
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.custom)
  if (_internal_has_custom()) {
    clear_has_an();
    ::vlsir::spice::CustomAnalysisInput* temp = an_.custom_;
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom) {
  clear_an();
  if (custom) {
    set_has_custom();
    an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.custom)
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_an();
    set_has_custom();
    an_.custom_ = CreateMaybeMessage< ::vlsir::spice::CustomAnalysisInput >(GetArenaForAllocation());
  }
  return an_.custom_;
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::mutable_custom() {
  ::vlsir::spice::CustomAnalysisInput* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.custom)
  return _msg;
}

inline bool Analysis::has_an() const {
  return an_case() != AN_NOT_SET;
}
inline void Analysis::clear_has_an() {
  _oneof_case_[0] = AN_NOT_SET;
}
inline Analysis::AnCase Analysis::an_case() const {
  return Analysis::AnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnalysisResult

// .vlsir.spice.OpResult op = 1;
inline bool AnalysisResult::_internal_has_op() const {
  return an_case() == kOp;
}
inline bool AnalysisResult::has_op() const {
  return _internal_has_op();
}
inline void AnalysisResult::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void AnalysisResult::clear_op() {
  if (_internal_has_op()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.op_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::OpResult* AnalysisResult::release_op() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.op)
  if (_internal_has_op()) {
    clear_has_an();
      ::vlsir::spice::OpResult* temp = an_.op_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::OpResult& AnalysisResult::_internal_op() const {
  return _internal_has_op()
      ? *an_.op_
      : reinterpret_cast< ::vlsir::spice::OpResult&>(::vlsir::spice::_OpResult_default_instance_);
}
inline const ::vlsir::spice::OpResult& AnalysisResult::op() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.op)
  return _internal_op();
}
inline ::vlsir::spice::OpResult* AnalysisResult::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.op)
  if (_internal_has_op()) {
    clear_has_an();
    ::vlsir::spice::OpResult* temp = an_.op_;
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_op(::vlsir::spice::OpResult* op) {
  clear_an();
  if (op) {
    set_has_op();
    an_.op_ = op;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.op)
}
inline ::vlsir::spice::OpResult* AnalysisResult::_internal_mutable_op() {
  if (!_internal_has_op()) {
    clear_an();
    set_has_op();
    an_.op_ = CreateMaybeMessage< ::vlsir::spice::OpResult >(GetArenaForAllocation());
  }
  return an_.op_;
}
inline ::vlsir::spice::OpResult* AnalysisResult::mutable_op() {
  ::vlsir::spice::OpResult* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.op)
  return _msg;
}

// .vlsir.spice.DcResult dc = 2;
inline bool AnalysisResult::_internal_has_dc() const {
  return an_case() == kDc;
}
inline bool AnalysisResult::has_dc() const {
  return _internal_has_dc();
}
inline void AnalysisResult::set_has_dc() {
  _oneof_case_[0] = kDc;
}
inline void AnalysisResult::clear_dc() {
  if (_internal_has_dc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.dc_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::DcResult* AnalysisResult::release_dc() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.dc)
  if (_internal_has_dc()) {
    clear_has_an();
      ::vlsir::spice::DcResult* temp = an_.dc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::DcResult& AnalysisResult::_internal_dc() const {
  return _internal_has_dc()
      ? *an_.dc_
      : reinterpret_cast< ::vlsir::spice::DcResult&>(::vlsir::spice::_DcResult_default_instance_);
}
inline const ::vlsir::spice::DcResult& AnalysisResult::dc() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.dc)
  return _internal_dc();
}
inline ::vlsir::spice::DcResult* AnalysisResult::unsafe_arena_release_dc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.dc)
  if (_internal_has_dc()) {
    clear_has_an();
    ::vlsir::spice::DcResult* temp = an_.dc_;
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_dc(::vlsir::spice::DcResult* dc) {
  clear_an();
  if (dc) {
    set_has_dc();
    an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.dc)
}
inline ::vlsir::spice::DcResult* AnalysisResult::_internal_mutable_dc() {
  if (!_internal_has_dc()) {
    clear_an();
    set_has_dc();
    an_.dc_ = CreateMaybeMessage< ::vlsir::spice::DcResult >(GetArenaForAllocation());
  }
  return an_.dc_;
}
inline ::vlsir::spice::DcResult* AnalysisResult::mutable_dc() {
  ::vlsir::spice::DcResult* _msg = _internal_mutable_dc();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.dc)
  return _msg;
}

// .vlsir.spice.TranResult tran = 3;
inline bool AnalysisResult::_internal_has_tran() const {
  return an_case() == kTran;
}
inline bool AnalysisResult::has_tran() const {
  return _internal_has_tran();
}
inline void AnalysisResult::set_has_tran() {
  _oneof_case_[0] = kTran;
}
inline void AnalysisResult::clear_tran() {
  if (_internal_has_tran()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.tran_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::TranResult* AnalysisResult::release_tran() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.tran)
  if (_internal_has_tran()) {
    clear_has_an();
      ::vlsir::spice::TranResult* temp = an_.tran_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::TranResult& AnalysisResult::_internal_tran() const {
  return _internal_has_tran()
      ? *an_.tran_
      : reinterpret_cast< ::vlsir::spice::TranResult&>(::vlsir::spice::_TranResult_default_instance_);
}
inline const ::vlsir::spice::TranResult& AnalysisResult::tran() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.tran)
  return _internal_tran();
}
inline ::vlsir::spice::TranResult* AnalysisResult::unsafe_arena_release_tran() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.tran)
  if (_internal_has_tran()) {
    clear_has_an();
    ::vlsir::spice::TranResult* temp = an_.tran_;
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_tran(::vlsir::spice::TranResult* tran) {
  clear_an();
  if (tran) {
    set_has_tran();
    an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.tran)
}
inline ::vlsir::spice::TranResult* AnalysisResult::_internal_mutable_tran() {
  if (!_internal_has_tran()) {
    clear_an();
    set_has_tran();
    an_.tran_ = CreateMaybeMessage< ::vlsir::spice::TranResult >(GetArenaForAllocation());
  }
  return an_.tran_;
}
inline ::vlsir::spice::TranResult* AnalysisResult::mutable_tran() {
  ::vlsir::spice::TranResult* _msg = _internal_mutable_tran();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.tran)
  return _msg;
}

// .vlsir.spice.AcResult ac = 4;
inline bool AnalysisResult::_internal_has_ac() const {
  return an_case() == kAc;
}
inline bool AnalysisResult::has_ac() const {
  return _internal_has_ac();
}
inline void AnalysisResult::set_has_ac() {
  _oneof_case_[0] = kAc;
}
inline void AnalysisResult::clear_ac() {
  if (_internal_has_ac()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.ac_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::AcResult* AnalysisResult::release_ac() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.ac)
  if (_internal_has_ac()) {
    clear_has_an();
      ::vlsir::spice::AcResult* temp = an_.ac_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::AcResult& AnalysisResult::_internal_ac() const {
  return _internal_has_ac()
      ? *an_.ac_
      : reinterpret_cast< ::vlsir::spice::AcResult&>(::vlsir::spice::_AcResult_default_instance_);
}
inline const ::vlsir::spice::AcResult& AnalysisResult::ac() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.ac)
  return _internal_ac();
}
inline ::vlsir::spice::AcResult* AnalysisResult::unsafe_arena_release_ac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.ac)
  if (_internal_has_ac()) {
    clear_has_an();
    ::vlsir::spice::AcResult* temp = an_.ac_;
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_ac(::vlsir::spice::AcResult* ac) {
  clear_an();
  if (ac) {
    set_has_ac();
    an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.ac)
}
inline ::vlsir::spice::AcResult* AnalysisResult::_internal_mutable_ac() {
  if (!_internal_has_ac()) {
    clear_an();
    set_has_ac();
    an_.ac_ = CreateMaybeMessage< ::vlsir::spice::AcResult >(GetArenaForAllocation());
  }
  return an_.ac_;
}
inline ::vlsir::spice::AcResult* AnalysisResult::mutable_ac() {
  ::vlsir::spice::AcResult* _msg = _internal_mutable_ac();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.ac)
  return _msg;
}

// .vlsir.spice.SweepResult sweep = 10;
inline bool AnalysisResult::_internal_has_sweep() const {
  return an_case() == kSweep;
}
inline bool AnalysisResult::has_sweep() const {
  return _internal_has_sweep();
}
inline void AnalysisResult::set_has_sweep() {
  _oneof_case_[0] = kSweep;
}
inline void AnalysisResult::clear_sweep() {
  if (_internal_has_sweep()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.sweep_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::SweepResult* AnalysisResult::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
      ::vlsir::spice::SweepResult* temp = an_.sweep_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::SweepResult& AnalysisResult::_internal_sweep() const {
  return _internal_has_sweep()
      ? *an_.sweep_
      : reinterpret_cast< ::vlsir::spice::SweepResult&>(::vlsir::spice::_SweepResult_default_instance_);
}
inline const ::vlsir::spice::SweepResult& AnalysisResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.sweep)
  return _internal_sweep();
}
inline ::vlsir::spice::SweepResult* AnalysisResult::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
    ::vlsir::spice::SweepResult* temp = an_.sweep_;
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_sweep(::vlsir::spice::SweepResult* sweep) {
  clear_an();
  if (sweep) {
    set_has_sweep();
    an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.sweep)
}
inline ::vlsir::spice::SweepResult* AnalysisResult::_internal_mutable_sweep() {
  if (!_internal_has_sweep()) {
    clear_an();
    set_has_sweep();
    an_.sweep_ = CreateMaybeMessage< ::vlsir::spice::SweepResult >(GetArenaForAllocation());
  }
  return an_.sweep_;
}
inline ::vlsir::spice::SweepResult* AnalysisResult::mutable_sweep() {
  ::vlsir::spice::SweepResult* _msg = _internal_mutable_sweep();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.sweep)
  return _msg;
}

// .vlsir.spice.MonteResult monte = 11;
inline bool AnalysisResult::_internal_has_monte() const {
  return an_case() == kMonte;
}
inline bool AnalysisResult::has_monte() const {
  return _internal_has_monte();
}
inline void AnalysisResult::set_has_monte() {
  _oneof_case_[0] = kMonte;
}
inline void AnalysisResult::clear_monte() {
  if (_internal_has_monte()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.monte_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::MonteResult* AnalysisResult::release_monte() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.monte)
  if (_internal_has_monte()) {
    clear_has_an();
      ::vlsir::spice::MonteResult* temp = an_.monte_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::MonteResult& AnalysisResult::_internal_monte() const {
  return _internal_has_monte()
      ? *an_.monte_
      : reinterpret_cast< ::vlsir::spice::MonteResult&>(::vlsir::spice::_MonteResult_default_instance_);
}
inline const ::vlsir::spice::MonteResult& AnalysisResult::monte() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.monte)
  return _internal_monte();
}
inline ::vlsir::spice::MonteResult* AnalysisResult::unsafe_arena_release_monte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.monte)
  if (_internal_has_monte()) {
    clear_has_an();
    ::vlsir::spice::MonteResult* temp = an_.monte_;
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_monte(::vlsir::spice::MonteResult* monte) {
  clear_an();
  if (monte) {
    set_has_monte();
    an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.monte)
}
inline ::vlsir::spice::MonteResult* AnalysisResult::_internal_mutable_monte() {
  if (!_internal_has_monte()) {
    clear_an();
    set_has_monte();
    an_.monte_ = CreateMaybeMessage< ::vlsir::spice::MonteResult >(GetArenaForAllocation());
  }
  return an_.monte_;
}
inline ::vlsir::spice::MonteResult* AnalysisResult::mutable_monte() {
  ::vlsir::spice::MonteResult* _msg = _internal_mutable_monte();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.monte)
  return _msg;
}

// .vlsir.spice.CustomAnalysisResult custom = 20;
inline bool AnalysisResult::_internal_has_custom() const {
  return an_case() == kCustom;
}
inline bool AnalysisResult::has_custom() const {
  return _internal_has_custom();
}
inline void AnalysisResult::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void AnalysisResult::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete an_.custom_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::release_custom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.custom)
  if (_internal_has_custom()) {
    clear_has_an();
      ::vlsir::spice::CustomAnalysisResult* temp = an_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::CustomAnalysisResult& AnalysisResult::_internal_custom() const {
  return _internal_has_custom()
      ? *an_.custom_
      : reinterpret_cast< ::vlsir::spice::CustomAnalysisResult&>(::vlsir::spice::_CustomAnalysisResult_default_instance_);
}
inline const ::vlsir::spice::CustomAnalysisResult& AnalysisResult::custom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.custom)
  return _internal_custom();
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.custom)
  if (_internal_has_custom()) {
    clear_has_an();
    ::vlsir::spice::CustomAnalysisResult* temp = an_.custom_;
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom) {
  clear_an();
  if (custom) {
    set_has_custom();
    an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.custom)
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_an();
    set_has_custom();
    an_.custom_ = CreateMaybeMessage< ::vlsir::spice::CustomAnalysisResult >(GetArenaForAllocation());
  }
  return an_.custom_;
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::mutable_custom() {
  ::vlsir::spice::CustomAnalysisResult* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.custom)
  return _msg;
}

inline bool AnalysisResult::has_an() const {
  return an_case() != AN_NOT_SET;
}
inline void AnalysisResult::clear_has_an() {
  _oneof_case_[0] = AN_NOT_SET;
}
inline AnalysisResult::AnCase AnalysisResult::an_case() const {
  return AnalysisResult::AnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpInput

// string analysis_name = 1;
inline void OpInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& OpInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.OpInput.analysis_name)
}
inline std::string* OpInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpInput.analysis_name)
  return _s;
}
inline const std::string& OpInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void OpInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OpInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OpInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OpInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpInput.analysis_name)
}

// repeated .vlsir.spice.Control ctrl = 5;
inline int OpInput::_internal_ctrl_size() const {
  return ctrl_.size();
}
inline int OpInput::ctrl_size() const {
  return _internal_ctrl_size();
}
inline void OpInput::clear_ctrl() {
  ctrl_.Clear();
}
inline ::vlsir::spice::Control* OpInput::mutable_ctrl(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpInput.ctrl)
  return ctrl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
OpInput::mutable_ctrl() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpInput.ctrl)
  return &ctrl_;
}
inline const ::vlsir::spice::Control& OpInput::_internal_ctrl(int index) const {
  return ctrl_.Get(index);
}
inline const ::vlsir::spice::Control& OpInput::ctrl(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpInput.ctrl)
  return _internal_ctrl(index);
}
inline ::vlsir::spice::Control* OpInput::_internal_add_ctrl() {
  return ctrl_.Add();
}
inline ::vlsir::spice::Control* OpInput::add_ctrl() {
  ::vlsir::spice::Control* _add = _internal_add_ctrl();
  // @@protoc_insertion_point(field_add:vlsir.spice.OpInput.ctrl)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
OpInput::ctrl() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpInput.ctrl)
  return ctrl_;
}

// -------------------------------------------------------------------

// OpResult

// string analysis_name = 1;
inline void OpResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& OpResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpResult::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.analysis_name)
}
inline std::string* OpResult::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.analysis_name)
  return _s;
}
inline const std::string& OpResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void OpResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OpResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OpResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OpResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpResult.analysis_name)
}

// .vlsir.spice.Signals signals = 3;
inline bool OpResult::_internal_has_signals() const {
  return this != internal_default_instance() && signals_ != nullptr;
}
inline bool OpResult::has_signals() const {
  return _internal_has_signals();
}
inline void OpResult::clear_signals() {
  if (GetArenaForAllocation() == nullptr && signals_ != nullptr) {
    delete signals_;
  }
  signals_ = nullptr;
}
inline const ::vlsir::spice::Signals& OpResult::_internal_signals() const {
  const ::vlsir::spice::Signals* p = signals_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Signals&>(
      ::vlsir::spice::_Signals_default_instance_);
}
inline const ::vlsir::spice::Signals& OpResult::signals() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.signals)
  return _internal_signals();
}
inline void OpResult::unsafe_arena_set_allocated_signals(
    ::vlsir::spice::Signals* signals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signals_);
  }
  signals_ = signals;
  if (signals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.OpResult.signals)
}
inline ::vlsir::spice::Signals* OpResult::release_signals() {
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Signals* OpResult::unsafe_arena_release_signals() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpResult.signals)
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Signals* OpResult::_internal_mutable_signals() {
  
  if (signals_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Signals>(GetArenaForAllocation());
    signals_ = p;
  }
  return signals_;
}
inline ::vlsir::spice::Signals* OpResult::mutable_signals() {
  ::vlsir::spice::Signals* _msg = _internal_mutable_signals();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.signals)
  return _msg;
}
inline void OpResult::set_allocated_signals(::vlsir::spice::Signals* signals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signals_;
  }
  if (signals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Signals>::GetOwningArena(signals);
    if (message_arena != submessage_arena) {
      signals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signals, submessage_arena);
    }
    
  } else {
    
  }
  signals_ = signals;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpResult.signals)
}

// repeated double data = 5;
inline int OpResult::_internal_data_size() const {
  return data_.size();
}
inline int OpResult::data_size() const {
  return _internal_data_size();
}
inline void OpResult::clear_data() {
  data_.Clear();
}
inline double OpResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline double OpResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.data)
  return _internal_data(index);
}
inline void OpResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.data)
}
inline void OpResult::_internal_add_data(double value) {
  data_.Add(value);
}
inline void OpResult::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
OpResult::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
OpResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpResult.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
OpResult::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
OpResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpResult.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// DcInput

// string analysis_name = 1;
inline void DcInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& DcInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DcInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.analysis_name)
}
inline std::string* DcInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.analysis_name)
  return _s;
}
inline const std::string& DcInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void DcInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DcInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DcInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DcInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.analysis_name)
}

// string indep_name = 2;
inline void DcInput::clear_indep_name() {
  indep_name_.ClearToEmpty();
}
inline const std::string& DcInput::indep_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.indep_name)
  return _internal_indep_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DcInput::set_indep_name(ArgT0&& arg0, ArgT... args) {
 
 indep_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.indep_name)
}
inline std::string* DcInput::mutable_indep_name() {
  std::string* _s = _internal_mutable_indep_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.indep_name)
  return _s;
}
inline const std::string& DcInput::_internal_indep_name() const {
  return indep_name_.Get();
}
inline void DcInput::_internal_set_indep_name(const std::string& value) {
  
  indep_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DcInput::_internal_mutable_indep_name() {
  
  return indep_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DcInput::release_indep_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.indep_name)
  return indep_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DcInput::set_allocated_indep_name(std::string* indep_name) {
  if (indep_name != nullptr) {
    
  } else {
    
  }
  indep_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indep_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.indep_name)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool DcInput::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool DcInput::has_sweep() const {
  return _internal_has_sweep();
}
inline void DcInput::clear_sweep() {
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& DcInput::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Sweep&>(
      ::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& DcInput::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.sweep)
  return _internal_sweep();
}
inline void DcInput::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcInput.sweep)
}
inline ::vlsir::spice::Sweep* DcInput::release_sweep() {
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Sweep* DcInput::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* DcInput::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaForAllocation());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* DcInput::mutable_sweep() {
  ::vlsir::spice::Sweep* _msg = _internal_mutable_sweep();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.sweep)
  return _msg;
}
inline void DcInput::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Sweep>::GetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.sweep)
}

// repeated .vlsir.spice.Control ctrl = 5;
inline int DcInput::_internal_ctrl_size() const {
  return ctrl_.size();
}
inline int DcInput::ctrl_size() const {
  return _internal_ctrl_size();
}
inline void DcInput::clear_ctrl() {
  ctrl_.Clear();
}
inline ::vlsir::spice::Control* DcInput::mutable_ctrl(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.ctrl)
  return ctrl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
DcInput::mutable_ctrl() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcInput.ctrl)
  return &ctrl_;
}
inline const ::vlsir::spice::Control& DcInput::_internal_ctrl(int index) const {
  return ctrl_.Get(index);
}
inline const ::vlsir::spice::Control& DcInput::ctrl(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.ctrl)
  return _internal_ctrl(index);
}
inline ::vlsir::spice::Control* DcInput::_internal_add_ctrl() {
  return ctrl_.Add();
}
inline ::vlsir::spice::Control* DcInput::add_ctrl() {
  ::vlsir::spice::Control* _add = _internal_add_ctrl();
  // @@protoc_insertion_point(field_add:vlsir.spice.DcInput.ctrl)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
DcInput::ctrl() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcInput.ctrl)
  return ctrl_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DcResult

// string analysis_name = 1;
inline void DcResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& DcResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DcResult::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.analysis_name)
}
inline std::string* DcResult::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.analysis_name)
  return _s;
}
inline const std::string& DcResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void DcResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DcResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DcResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DcResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.analysis_name)
}

// string indep_name = 2;
inline void DcResult::clear_indep_name() {
  indep_name_.ClearToEmpty();
}
inline const std::string& DcResult::indep_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.indep_name)
  return _internal_indep_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DcResult::set_indep_name(ArgT0&& arg0, ArgT... args) {
 
 indep_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.indep_name)
}
inline std::string* DcResult::mutable_indep_name() {
  std::string* _s = _internal_mutable_indep_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.indep_name)
  return _s;
}
inline const std::string& DcResult::_internal_indep_name() const {
  return indep_name_.Get();
}
inline void DcResult::_internal_set_indep_name(const std::string& value) {
  
  indep_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DcResult::_internal_mutable_indep_name() {
  
  return indep_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DcResult::release_indep_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.indep_name)
  return indep_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DcResult::set_allocated_indep_name(std::string* indep_name) {
  if (indep_name != nullptr) {
    
  } else {
    
  }
  indep_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indep_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.indep_name)
}

// .vlsir.spice.Signals signals = 3;
inline bool DcResult::_internal_has_signals() const {
  return this != internal_default_instance() && signals_ != nullptr;
}
inline bool DcResult::has_signals() const {
  return _internal_has_signals();
}
inline void DcResult::clear_signals() {
  if (GetArenaForAllocation() == nullptr && signals_ != nullptr) {
    delete signals_;
  }
  signals_ = nullptr;
}
inline const ::vlsir::spice::Signals& DcResult::_internal_signals() const {
  const ::vlsir::spice::Signals* p = signals_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Signals&>(
      ::vlsir::spice::_Signals_default_instance_);
}
inline const ::vlsir::spice::Signals& DcResult::signals() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.signals)
  return _internal_signals();
}
inline void DcResult::unsafe_arena_set_allocated_signals(
    ::vlsir::spice::Signals* signals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signals_);
  }
  signals_ = signals;
  if (signals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcResult.signals)
}
inline ::vlsir::spice::Signals* DcResult::release_signals() {
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Signals* DcResult::unsafe_arena_release_signals() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.signals)
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Signals* DcResult::_internal_mutable_signals() {
  
  if (signals_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Signals>(GetArenaForAllocation());
    signals_ = p;
  }
  return signals_;
}
inline ::vlsir::spice::Signals* DcResult::mutable_signals() {
  ::vlsir::spice::Signals* _msg = _internal_mutable_signals();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.signals)
  return _msg;
}
inline void DcResult::set_allocated_signals(::vlsir::spice::Signals* signals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signals_;
  }
  if (signals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Signals>::GetOwningArena(signals);
    if (message_arena != submessage_arena) {
      signals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signals, submessage_arena);
    }
    
  } else {
    
  }
  signals_ = signals;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.signals)
}

// int64 num_points = 4;
inline void DcResult::clear_num_points() {
  num_points_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DcResult::_internal_num_points() const {
  return num_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DcResult::num_points() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.num_points)
  return _internal_num_points();
}
inline void DcResult::_internal_set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  num_points_ = value;
}
inline void DcResult::set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_points(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.num_points)
}

// repeated double data = 5;
inline int DcResult::_internal_data_size() const {
  return data_.size();
}
inline int DcResult::data_size() const {
  return _internal_data_size();
}
inline void DcResult::clear_data() {
  data_.Clear();
}
inline double DcResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline double DcResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.data)
  return _internal_data(index);
}
inline void DcResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.data)
}
inline void DcResult::_internal_add_data(double value) {
  data_.Add(value);
}
inline void DcResult::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DcResult::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DcResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcResult.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DcResult::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DcResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcResult.data)
  return _internal_mutable_data();
}

// map<string, double> measurements = 10;
inline int DcResult::_internal_measurements_size() const {
  return measurements_.size();
}
inline int DcResult::measurements_size() const {
  return _internal_measurements_size();
}
inline void DcResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
DcResult::_internal_measurements() const {
  return measurements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
DcResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.DcResult.measurements)
  return _internal_measurements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
DcResult::_internal_mutable_measurements() {
  return measurements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
DcResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.DcResult.measurements)
  return _internal_mutable_measurements();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TranInput

// string analysis_name = 1;
inline void TranInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& TranInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.analysis_name)
}
inline std::string* TranInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.analysis_name)
  return _s;
}
inline const std::string& TranInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void TranInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranInput.analysis_name)
}

// double tstop = 2;
inline void TranInput::clear_tstop() {
  tstop_ = 0;
}
inline double TranInput::_internal_tstop() const {
  return tstop_;
}
inline double TranInput::tstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.tstop)
  return _internal_tstop();
}
inline void TranInput::_internal_set_tstop(double value) {
  
  tstop_ = value;
}
inline void TranInput::set_tstop(double value) {
  _internal_set_tstop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.tstop)
}

// double tstep = 3;
inline void TranInput::clear_tstep() {
  tstep_ = 0;
}
inline double TranInput::_internal_tstep() const {
  return tstep_;
}
inline double TranInput::tstep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.tstep)
  return _internal_tstep();
}
inline void TranInput::_internal_set_tstep(double value) {
  
  tstep_ = value;
}
inline void TranInput::set_tstep(double value) {
  _internal_set_tstep(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.tstep)
}

// map<string, double> ic = 4;
inline int TranInput::_internal_ic_size() const {
  return ic_.size();
}
inline int TranInput::ic_size() const {
  return _internal_ic_size();
}
inline void TranInput::clear_ic() {
  ic_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranInput::_internal_ic() const {
  return ic_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranInput::ic() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.TranInput.ic)
  return _internal_ic();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranInput::_internal_mutable_ic() {
  return ic_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranInput::mutable_ic() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.TranInput.ic)
  return _internal_mutable_ic();
}

// repeated .vlsir.spice.Control ctrl = 5;
inline int TranInput::_internal_ctrl_size() const {
  return ctrl_.size();
}
inline int TranInput::ctrl_size() const {
  return _internal_ctrl_size();
}
inline void TranInput::clear_ctrl() {
  ctrl_.Clear();
}
inline ::vlsir::spice::Control* TranInput::mutable_ctrl(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.ctrl)
  return ctrl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
TranInput::mutable_ctrl() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranInput.ctrl)
  return &ctrl_;
}
inline const ::vlsir::spice::Control& TranInput::_internal_ctrl(int index) const {
  return ctrl_.Get(index);
}
inline const ::vlsir::spice::Control& TranInput::ctrl(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.ctrl)
  return _internal_ctrl(index);
}
inline ::vlsir::spice::Control* TranInput::_internal_add_ctrl() {
  return ctrl_.Add();
}
inline ::vlsir::spice::Control* TranInput::add_ctrl() {
  ::vlsir::spice::Control* _add = _internal_add_ctrl();
  // @@protoc_insertion_point(field_add:vlsir.spice.TranInput.ctrl)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
TranInput::ctrl() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranInput.ctrl)
  return ctrl_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TranResult

// string analysis_name = 1;
inline void TranResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& TranResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranResult::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.analysis_name)
}
inline std::string* TranResult::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranResult.analysis_name)
  return _s;
}
inline const std::string& TranResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void TranResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranResult.analysis_name)
}

// .vlsir.spice.Signals signals = 3;
inline bool TranResult::_internal_has_signals() const {
  return this != internal_default_instance() && signals_ != nullptr;
}
inline bool TranResult::has_signals() const {
  return _internal_has_signals();
}
inline void TranResult::clear_signals() {
  if (GetArenaForAllocation() == nullptr && signals_ != nullptr) {
    delete signals_;
  }
  signals_ = nullptr;
}
inline const ::vlsir::spice::Signals& TranResult::_internal_signals() const {
  const ::vlsir::spice::Signals* p = signals_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Signals&>(
      ::vlsir::spice::_Signals_default_instance_);
}
inline const ::vlsir::spice::Signals& TranResult::signals() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.signals)
  return _internal_signals();
}
inline void TranResult::unsafe_arena_set_allocated_signals(
    ::vlsir::spice::Signals* signals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signals_);
  }
  signals_ = signals;
  if (signals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.TranResult.signals)
}
inline ::vlsir::spice::Signals* TranResult::release_signals() {
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Signals* TranResult::unsafe_arena_release_signals() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranResult.signals)
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Signals* TranResult::_internal_mutable_signals() {
  
  if (signals_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Signals>(GetArenaForAllocation());
    signals_ = p;
  }
  return signals_;
}
inline ::vlsir::spice::Signals* TranResult::mutable_signals() {
  ::vlsir::spice::Signals* _msg = _internal_mutable_signals();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranResult.signals)
  return _msg;
}
inline void TranResult::set_allocated_signals(::vlsir::spice::Signals* signals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signals_;
  }
  if (signals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Signals>::GetOwningArena(signals);
    if (message_arena != submessage_arena) {
      signals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signals, submessage_arena);
    }
    
  } else {
    
  }
  signals_ = signals;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranResult.signals)
}

// int64 num_points = 4;
inline void TranResult::clear_num_points() {
  num_points_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TranResult::_internal_num_points() const {
  return num_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TranResult::num_points() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.num_points)
  return _internal_num_points();
}
inline void TranResult::_internal_set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  num_points_ = value;
}
inline void TranResult::set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_points(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.num_points)
}

// repeated double data = 5;
inline int TranResult::_internal_data_size() const {
  return data_.size();
}
inline int TranResult::data_size() const {
  return _internal_data_size();
}
inline void TranResult::clear_data() {
  data_.Clear();
}
inline double TranResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline double TranResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.data)
  return _internal_data(index);
}
inline void TranResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.data)
}
inline void TranResult::_internal_add_data(double value) {
  data_.Add(value);
}
inline void TranResult::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TranResult::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TranResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranResult.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TranResult::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TranResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranResult.data)
  return _internal_mutable_data();
}

// map<string, double> measurements = 10;
inline int TranResult::_internal_measurements_size() const {
  return measurements_.size();
}
inline int TranResult::measurements_size() const {
  return _internal_measurements_size();
}
inline void TranResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranResult::_internal_measurements() const {
  return measurements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.TranResult.measurements)
  return _internal_measurements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranResult::_internal_mutable_measurements() {
  return measurements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.TranResult.measurements)
  return _internal_mutable_measurements();
}

// -------------------------------------------------------------------

// ComplexNum

// double re = 1;
inline void ComplexNum::clear_re() {
  re_ = 0;
}
inline double ComplexNum::_internal_re() const {
  return re_;
}
inline double ComplexNum::re() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.ComplexNum.re)
  return _internal_re();
}
inline void ComplexNum::_internal_set_re(double value) {
  
  re_ = value;
}
inline void ComplexNum::set_re(double value) {
  _internal_set_re(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.ComplexNum.re)
}

// double im = 2;
inline void ComplexNum::clear_im() {
  im_ = 0;
}
inline double ComplexNum::_internal_im() const {
  return im_;
}
inline double ComplexNum::im() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.ComplexNum.im)
  return _internal_im();
}
inline void ComplexNum::_internal_set_im(double value) {
  
  im_ = value;
}
inline void ComplexNum::set_im(double value) {
  _internal_set_im(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.ComplexNum.im)
}

// -------------------------------------------------------------------

// AcInput

// string analysis_name = 1;
inline void AcInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& AcInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.analysis_name)
}
inline std::string* AcInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.analysis_name)
  return _s;
}
inline const std::string& AcInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void AcInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AcInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AcInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AcInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcInput.analysis_name)
}

// double fstart = 2;
inline void AcInput::clear_fstart() {
  fstart_ = 0;
}
inline double AcInput::_internal_fstart() const {
  return fstart_;
}
inline double AcInput::fstart() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.fstart)
  return _internal_fstart();
}
inline void AcInput::_internal_set_fstart(double value) {
  
  fstart_ = value;
}
inline void AcInput::set_fstart(double value) {
  _internal_set_fstart(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.fstart)
}

// double fstop = 3;
inline void AcInput::clear_fstop() {
  fstop_ = 0;
}
inline double AcInput::_internal_fstop() const {
  return fstop_;
}
inline double AcInput::fstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.fstop)
  return _internal_fstop();
}
inline void AcInput::_internal_set_fstop(double value) {
  
  fstop_ = value;
}
inline void AcInput::set_fstop(double value) {
  _internal_set_fstop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.fstop)
}

// uint64 npts = 4;
inline void AcInput::clear_npts() {
  npts_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AcInput::_internal_npts() const {
  return npts_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AcInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.npts)
  return _internal_npts();
}
inline void AcInput::_internal_set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  npts_ = value;
}
inline void AcInput::set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.npts)
}

// repeated .vlsir.spice.Control ctrl = 5;
inline int AcInput::_internal_ctrl_size() const {
  return ctrl_.size();
}
inline int AcInput::ctrl_size() const {
  return _internal_ctrl_size();
}
inline void AcInput::clear_ctrl() {
  ctrl_.Clear();
}
inline ::vlsir::spice::Control* AcInput::mutable_ctrl(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.ctrl)
  return ctrl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
AcInput::mutable_ctrl() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcInput.ctrl)
  return &ctrl_;
}
inline const ::vlsir::spice::Control& AcInput::_internal_ctrl(int index) const {
  return ctrl_.Get(index);
}
inline const ::vlsir::spice::Control& AcInput::ctrl(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.ctrl)
  return _internal_ctrl(index);
}
inline ::vlsir::spice::Control* AcInput::_internal_add_ctrl() {
  return ctrl_.Add();
}
inline ::vlsir::spice::Control* AcInput::add_ctrl() {
  ::vlsir::spice::Control* _add = _internal_add_ctrl();
  // @@protoc_insertion_point(field_add:vlsir.spice.AcInput.ctrl)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
AcInput::ctrl() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcInput.ctrl)
  return ctrl_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AcResult

// string analysis_name = 1;
inline void AcResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& AcResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcResult::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.analysis_name)
}
inline std::string* AcResult::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.analysis_name)
  return _s;
}
inline const std::string& AcResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void AcResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AcResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AcResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AcResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcResult.analysis_name)
}

// repeated double freq = 2;
inline int AcResult::_internal_freq_size() const {
  return freq_.size();
}
inline int AcResult::freq_size() const {
  return _internal_freq_size();
}
inline void AcResult::clear_freq() {
  freq_.Clear();
}
inline double AcResult::_internal_freq(int index) const {
  return freq_.Get(index);
}
inline double AcResult::freq(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.freq)
  return _internal_freq(index);
}
inline void AcResult::set_freq(int index, double value) {
  freq_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.freq)
}
inline void AcResult::_internal_add_freq(double value) {
  freq_.Add(value);
}
inline void AcResult::add_freq(double value) {
  _internal_add_freq(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.freq)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcResult::_internal_freq() const {
  return freq_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcResult::freq() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.freq)
  return _internal_freq();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcResult::_internal_mutable_freq() {
  return &freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcResult::mutable_freq() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.freq)
  return _internal_mutable_freq();
}

// .vlsir.spice.Signals signals = 3;
inline bool AcResult::_internal_has_signals() const {
  return this != internal_default_instance() && signals_ != nullptr;
}
inline bool AcResult::has_signals() const {
  return _internal_has_signals();
}
inline void AcResult::clear_signals() {
  if (GetArenaForAllocation() == nullptr && signals_ != nullptr) {
    delete signals_;
  }
  signals_ = nullptr;
}
inline const ::vlsir::spice::Signals& AcResult::_internal_signals() const {
  const ::vlsir::spice::Signals* p = signals_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Signals&>(
      ::vlsir::spice::_Signals_default_instance_);
}
inline const ::vlsir::spice::Signals& AcResult::signals() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.signals)
  return _internal_signals();
}
inline void AcResult::unsafe_arena_set_allocated_signals(
    ::vlsir::spice::Signals* signals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signals_);
  }
  signals_ = signals;
  if (signals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AcResult.signals)
}
inline ::vlsir::spice::Signals* AcResult::release_signals() {
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Signals* AcResult::unsafe_arena_release_signals() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcResult.signals)
  
  ::vlsir::spice::Signals* temp = signals_;
  signals_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Signals* AcResult::_internal_mutable_signals() {
  
  if (signals_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Signals>(GetArenaForAllocation());
    signals_ = p;
  }
  return signals_;
}
inline ::vlsir::spice::Signals* AcResult::mutable_signals() {
  ::vlsir::spice::Signals* _msg = _internal_mutable_signals();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.signals)
  return _msg;
}
inline void AcResult::set_allocated_signals(::vlsir::spice::Signals* signals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signals_;
  }
  if (signals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Signals>::GetOwningArena(signals);
    if (message_arena != submessage_arena) {
      signals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signals, submessage_arena);
    }
    
  } else {
    
  }
  signals_ = signals;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcResult.signals)
}

// int64 num_points = 4;
inline void AcResult::clear_num_points() {
  num_points_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AcResult::_internal_num_points() const {
  return num_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AcResult::num_points() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.num_points)
  return _internal_num_points();
}
inline void AcResult::_internal_set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  num_points_ = value;
}
inline void AcResult::set_num_points(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_points(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.num_points)
}

// repeated .vlsir.spice.ComplexNum data = 5;
inline int AcResult::_internal_data_size() const {
  return data_.size();
}
inline int AcResult::data_size() const {
  return _internal_data_size();
}
inline void AcResult::clear_data() {
  data_.Clear();
}
inline ::vlsir::spice::ComplexNum* AcResult::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >*
AcResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.data)
  return &data_;
}
inline const ::vlsir::spice::ComplexNum& AcResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::vlsir::spice::ComplexNum& AcResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.data)
  return _internal_data(index);
}
inline ::vlsir::spice::ComplexNum* AcResult::_internal_add_data() {
  return data_.Add();
}
inline ::vlsir::spice::ComplexNum* AcResult::add_data() {
  ::vlsir::spice::ComplexNum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >&
AcResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.data)
  return data_;
}

// map<string, double> measurements = 10;
inline int AcResult::_internal_measurements_size() const {
  return measurements_.size();
}
inline int AcResult::measurements_size() const {
  return _internal_measurements_size();
}
inline void AcResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AcResult::_internal_measurements() const {
  return measurements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AcResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.AcResult.measurements)
  return _internal_measurements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AcResult::_internal_mutable_measurements() {
  return measurements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AcResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.AcResult.measurements)
  return _internal_mutable_measurements();
}

// -------------------------------------------------------------------

// SweepInput

// string analysis_name = 1;
inline void SweepInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& SweepInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SweepInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepInput.analysis_name)
}
inline std::string* SweepInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.analysis_name)
  return _s;
}
inline const std::string& SweepInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void SweepInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SweepInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SweepInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SweepInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.analysis_name)
}

// string variable = 2;
inline void SweepInput::clear_variable() {
  variable_.ClearToEmpty();
}
inline const std::string& SweepInput::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.variable)
  return _internal_variable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SweepInput::set_variable(ArgT0&& arg0, ArgT... args) {
 
 variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepInput.variable)
}
inline std::string* SweepInput::mutable_variable() {
  std::string* _s = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.variable)
  return _s;
}
inline const std::string& SweepInput::_internal_variable() const {
  return variable_.Get();
}
inline void SweepInput::_internal_set_variable(const std::string& value) {
  
  variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SweepInput::_internal_mutable_variable() {
  
  return variable_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SweepInput::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.variable)
  return variable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SweepInput::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool SweepInput::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool SweepInput::has_sweep() const {
  return _internal_has_sweep();
}
inline void SweepInput::clear_sweep() {
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& SweepInput::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Sweep&>(
      ::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& SweepInput::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.sweep)
  return _internal_sweep();
}
inline void SweepInput::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepInput.sweep)
}
inline ::vlsir::spice::Sweep* SweepInput::release_sweep() {
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Sweep* SweepInput::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* SweepInput::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaForAllocation());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* SweepInput::mutable_sweep() {
  ::vlsir::spice::Sweep* _msg = _internal_mutable_sweep();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.sweep)
  return _msg;
}
inline void SweepInput::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Sweep>::GetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.sweep)
}

// repeated .vlsir.spice.Analysis an = 4;
inline int SweepInput::_internal_an_size() const {
  return an_.size();
}
inline int SweepInput::an_size() const {
  return _internal_an_size();
}
inline void SweepInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* SweepInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
SweepInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& SweepInput::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::Analysis& SweepInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.an)
  return _internal_an(index);
}
inline ::vlsir::spice::Analysis* SweepInput::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::Analysis* SweepInput::add_an() {
  ::vlsir::spice::Analysis* _add = _internal_add_an();
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepInput.an)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
SweepInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int SweepInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int SweepInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void SweepInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* SweepInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
SweepInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& SweepInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& SweepInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* SweepInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* SweepInput::add_ctrls() {
  ::vlsir::spice::Control* _add = _internal_add_ctrls();
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepInput.ctrls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
SweepInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// SweepResult

// string analysis_name = 1;
inline void SweepResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& SweepResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SweepResult::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepResult.analysis_name)
}
inline std::string* SweepResult::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.analysis_name)
  return _s;
}
inline const std::string& SweepResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void SweepResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SweepResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SweepResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SweepResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.analysis_name)
}

// string variable = 2;
inline void SweepResult::clear_variable() {
  variable_.ClearToEmpty();
}
inline const std::string& SweepResult::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.variable)
  return _internal_variable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SweepResult::set_variable(ArgT0&& arg0, ArgT... args) {
 
 variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepResult.variable)
}
inline std::string* SweepResult::mutable_variable() {
  std::string* _s = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.variable)
  return _s;
}
inline const std::string& SweepResult::_internal_variable() const {
  return variable_.Get();
}
inline void SweepResult::_internal_set_variable(const std::string& value) {
  
  variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SweepResult::_internal_mutable_variable() {
  
  return variable_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SweepResult::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.variable)
  return variable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SweepResult::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool SweepResult::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool SweepResult::has_sweep() const {
  return _internal_has_sweep();
}
inline void SweepResult::clear_sweep() {
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& SweepResult::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Sweep&>(
      ::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& SweepResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.sweep)
  return _internal_sweep();
}
inline void SweepResult::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepResult.sweep)
}
inline ::vlsir::spice::Sweep* SweepResult::release_sweep() {
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Sweep* SweepResult::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* SweepResult::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaForAllocation());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* SweepResult::mutable_sweep() {
  ::vlsir::spice::Sweep* _msg = _internal_mutable_sweep();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.sweep)
  return _msg;
}
inline void SweepResult::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Sweep>::GetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.sweep)
}

// repeated .vlsir.spice.AnalysisResult an = 4;
inline int SweepResult::_internal_an_size() const {
  return an_.size();
}
inline int SweepResult::an_size() const {
  return _internal_an_size();
}
inline void SweepResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* SweepResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
SweepResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& SweepResult::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::AnalysisResult& SweepResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.an)
  return _internal_an(index);
}
inline ::vlsir::spice::AnalysisResult* SweepResult::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::AnalysisResult* SweepResult::add_an() {
  ::vlsir::spice::AnalysisResult* _add = _internal_add_an();
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepResult.an)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
SweepResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepResult.an)
  return an_;
}

// -------------------------------------------------------------------

// MonteInput

// string analysis_name = 1;
inline void MonteInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& MonteInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MonteInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.analysis_name)
}
inline std::string* MonteInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.analysis_name)
  return _s;
}
inline const std::string& MonteInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void MonteInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MonteInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MonteInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MonteInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteInput.analysis_name)
}

// int64 npts = 2;
inline void MonteInput::clear_npts() {
  npts_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::_internal_npts() const {
  return npts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.npts)
  return _internal_npts();
}
inline void MonteInput::_internal_set_npts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  npts_ = value;
}
inline void MonteInput::set_npts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.npts)
}

// int64 seed = 3;
inline void MonteInput::clear_seed() {
  seed_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::_internal_seed() const {
  return seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::seed() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.seed)
  return _internal_seed();
}
inline void MonteInput::_internal_set_seed(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seed_ = value;
}
inline void MonteInput::set_seed(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.seed)
}

// repeated .vlsir.spice.Analysis an = 4;
inline int MonteInput::_internal_an_size() const {
  return an_.size();
}
inline int MonteInput::an_size() const {
  return _internal_an_size();
}
inline void MonteInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* MonteInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
MonteInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& MonteInput::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::Analysis& MonteInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.an)
  return _internal_an(index);
}
inline ::vlsir::spice::Analysis* MonteInput::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::Analysis* MonteInput::add_an() {
  ::vlsir::spice::Analysis* _add = _internal_add_an();
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteInput.an)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
MonteInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int MonteInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int MonteInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void MonteInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* MonteInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
MonteInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& MonteInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& MonteInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* MonteInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* MonteInput::add_ctrls() {
  ::vlsir::spice::Control* _add = _internal_add_ctrls();
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteInput.ctrls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
MonteInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// MonteResult

// string analysis_name = 1;
inline void MonteResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& MonteResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MonteResult::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteResult.analysis_name)
}
inline std::string* MonteResult::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.analysis_name)
  return _s;
}
inline const std::string& MonteResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void MonteResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MonteResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MonteResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MonteResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.analysis_name)
}

// string variable = 2;
inline void MonteResult::clear_variable() {
  variable_.ClearToEmpty();
}
inline const std::string& MonteResult::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.variable)
  return _internal_variable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MonteResult::set_variable(ArgT0&& arg0, ArgT... args) {
 
 variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteResult.variable)
}
inline std::string* MonteResult::mutable_variable() {
  std::string* _s = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.variable)
  return _s;
}
inline const std::string& MonteResult::_internal_variable() const {
  return variable_.Get();
}
inline void MonteResult::_internal_set_variable(const std::string& value) {
  
  variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MonteResult::_internal_mutable_variable() {
  
  return variable_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MonteResult::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.variable)
  return variable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MonteResult::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool MonteResult::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool MonteResult::has_sweep() const {
  return _internal_has_sweep();
}
inline void MonteResult::clear_sweep() {
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& MonteResult::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::spice::Sweep&>(
      ::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& MonteResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.sweep)
  return _internal_sweep();
}
inline void MonteResult::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.MonteResult.sweep)
}
inline ::vlsir::spice::Sweep* MonteResult::release_sweep() {
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::spice::Sweep* MonteResult::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* MonteResult::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaForAllocation());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* MonteResult::mutable_sweep() {
  ::vlsir::spice::Sweep* _msg = _internal_mutable_sweep();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.sweep)
  return _msg;
}
inline void MonteResult::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Sweep>::GetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.sweep)
}

// repeated .vlsir.spice.AnalysisResult an = 4;
inline int MonteResult::_internal_an_size() const {
  return an_.size();
}
inline int MonteResult::an_size() const {
  return _internal_an_size();
}
inline void MonteResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* MonteResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
MonteResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& MonteResult::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::AnalysisResult& MonteResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.an)
  return _internal_an(index);
}
inline ::vlsir::spice::AnalysisResult* MonteResult::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::AnalysisResult* MonteResult::add_an() {
  ::vlsir::spice::AnalysisResult* _add = _internal_add_an();
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteResult.an)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
MonteResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteResult.an)
  return an_;
}

// -------------------------------------------------------------------

// CustomAnalysisInput

// string analysis_name = 1;
inline void CustomAnalysisInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty();
}
inline const std::string& CustomAnalysisInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.analysis_name)
  return _internal_analysis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomAnalysisInput::set_analysis_name(ArgT0&& arg0, ArgT... args) {
 
 analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline std::string* CustomAnalysisInput::mutable_analysis_name() {
  std::string* _s = _internal_mutable_analysis_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.analysis_name)
  return _s;
}
inline const std::string& CustomAnalysisInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void CustomAnalysisInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CustomAnalysisInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CustomAnalysisInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.CustomAnalysisInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CustomAnalysisInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.CustomAnalysisInput.analysis_name)
}

// string cmd = 2;
inline void CustomAnalysisInput::clear_cmd() {
  cmd_.ClearToEmpty();
}
inline const std::string& CustomAnalysisInput::cmd() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.cmd)
  return _internal_cmd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomAnalysisInput::set_cmd(ArgT0&& arg0, ArgT... args) {
 
 cmd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.CustomAnalysisInput.cmd)
}
inline std::string* CustomAnalysisInput::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.cmd)
  return _s;
}
inline const std::string& CustomAnalysisInput::_internal_cmd() const {
  return cmd_.Get();
}
inline void CustomAnalysisInput::_internal_set_cmd(const std::string& value) {
  
  cmd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CustomAnalysisInput::_internal_mutable_cmd() {
  
  return cmd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CustomAnalysisInput::release_cmd() {
  // @@protoc_insertion_point(field_release:vlsir.spice.CustomAnalysisInput.cmd)
  return cmd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CustomAnalysisInput::set_allocated_cmd(std::string* cmd) {
  if (cmd != nullptr) {
    
  } else {
    
  }
  cmd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.CustomAnalysisInput.cmd)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int CustomAnalysisInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int CustomAnalysisInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void CustomAnalysisInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* CustomAnalysisInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
CustomAnalysisInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.CustomAnalysisInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& CustomAnalysisInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& CustomAnalysisInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* CustomAnalysisInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* CustomAnalysisInput::add_ctrls() {
  ::vlsir::spice::Control* _add = _internal_add_ctrls();
  // @@protoc_insertion_point(field_add:vlsir.spice.CustomAnalysisInput.ctrls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
CustomAnalysisInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// CustomAnalysisResult

// -------------------------------------------------------------------

// Sweep

// .vlsir.spice.LinearSweep linear = 1;
inline bool Sweep::_internal_has_linear() const {
  return tp_case() == kLinear;
}
inline bool Sweep::has_linear() const {
  return _internal_has_linear();
}
inline void Sweep::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void Sweep::clear_linear() {
  if (_internal_has_linear()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tp_.linear_;
    }
    clear_has_tp();
  }
}
inline ::vlsir::spice::LinearSweep* Sweep::release_linear() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.linear)
  if (_internal_has_linear()) {
    clear_has_tp();
      ::vlsir::spice::LinearSweep* temp = tp_.linear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tp_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::LinearSweep& Sweep::_internal_linear() const {
  return _internal_has_linear()
      ? *tp_.linear_
      : reinterpret_cast< ::vlsir::spice::LinearSweep&>(::vlsir::spice::_LinearSweep_default_instance_);
}
inline const ::vlsir::spice::LinearSweep& Sweep::linear() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.linear)
  return _internal_linear();
}
inline ::vlsir::spice::LinearSweep* Sweep::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Sweep.linear)
  if (_internal_has_linear()) {
    clear_has_tp();
    ::vlsir::spice::LinearSweep* temp = tp_.linear_;
    tp_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sweep::unsafe_arena_set_allocated_linear(::vlsir::spice::LinearSweep* linear) {
  clear_tp();
  if (linear) {
    set_has_linear();
    tp_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Sweep.linear)
}
inline ::vlsir::spice::LinearSweep* Sweep::_internal_mutable_linear() {
  if (!_internal_has_linear()) {
    clear_tp();
    set_has_linear();
    tp_.linear_ = CreateMaybeMessage< ::vlsir::spice::LinearSweep >(GetArenaForAllocation());
  }
  return tp_.linear_;
}
inline ::vlsir::spice::LinearSweep* Sweep::mutable_linear() {
  ::vlsir::spice::LinearSweep* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.linear)
  return _msg;
}

// .vlsir.spice.LogSweep log = 2;
inline bool Sweep::_internal_has_log() const {
  return tp_case() == kLog;
}
inline bool Sweep::has_log() const {
  return _internal_has_log();
}
inline void Sweep::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void Sweep::clear_log() {
  if (_internal_has_log()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tp_.log_;
    }
    clear_has_tp();
  }
}
inline ::vlsir::spice::LogSweep* Sweep::release_log() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.log)
  if (_internal_has_log()) {
    clear_has_tp();
      ::vlsir::spice::LogSweep* temp = tp_.log_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tp_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::LogSweep& Sweep::_internal_log() const {
  return _internal_has_log()
      ? *tp_.log_
      : reinterpret_cast< ::vlsir::spice::LogSweep&>(::vlsir::spice::_LogSweep_default_instance_);
}
inline const ::vlsir::spice::LogSweep& Sweep::log() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.log)
  return _internal_log();
}
inline ::vlsir::spice::LogSweep* Sweep::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Sweep.log)
  if (_internal_has_log()) {
    clear_has_tp();
    ::vlsir::spice::LogSweep* temp = tp_.log_;
    tp_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sweep::unsafe_arena_set_allocated_log(::vlsir::spice::LogSweep* log) {
  clear_tp();
  if (log) {
    set_has_log();
    tp_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Sweep.log)
}
inline ::vlsir::spice::LogSweep* Sweep::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_tp();
    set_has_log();
    tp_.log_ = CreateMaybeMessage< ::vlsir::spice::LogSweep >(GetArenaForAllocation());
  }
  return tp_.log_;
}
inline ::vlsir::spice::LogSweep* Sweep::mutable_log() {
  ::vlsir::spice::LogSweep* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.log)
  return _msg;
}

// .vlsir.spice.PointSweep points = 3;
inline bool Sweep::_internal_has_points() const {
  return tp_case() == kPoints;
}
inline bool Sweep::has_points() const {
  return _internal_has_points();
}
inline void Sweep::set_has_points() {
  _oneof_case_[0] = kPoints;
}
inline void Sweep::clear_points() {
  if (_internal_has_points()) {
    if (GetArenaForAllocation() == nullptr) {
      delete tp_.points_;
    }
    clear_has_tp();
  }
}
inline ::vlsir::spice::PointSweep* Sweep::release_points() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.points)
  if (_internal_has_points()) {
    clear_has_tp();
      ::vlsir::spice::PointSweep* temp = tp_.points_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tp_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::PointSweep& Sweep::_internal_points() const {
  return _internal_has_points()
      ? *tp_.points_
      : reinterpret_cast< ::vlsir::spice::PointSweep&>(::vlsir::spice::_PointSweep_default_instance_);
}
inline const ::vlsir::spice::PointSweep& Sweep::points() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.points)
  return _internal_points();
}
inline ::vlsir::spice::PointSweep* Sweep::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Sweep.points)
  if (_internal_has_points()) {
    clear_has_tp();
    ::vlsir::spice::PointSweep* temp = tp_.points_;
    tp_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sweep::unsafe_arena_set_allocated_points(::vlsir::spice::PointSweep* points) {
  clear_tp();
  if (points) {
    set_has_points();
    tp_.points_ = points;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Sweep.points)
}
inline ::vlsir::spice::PointSweep* Sweep::_internal_mutable_points() {
  if (!_internal_has_points()) {
    clear_tp();
    set_has_points();
    tp_.points_ = CreateMaybeMessage< ::vlsir::spice::PointSweep >(GetArenaForAllocation());
  }
  return tp_.points_;
}
inline ::vlsir::spice::PointSweep* Sweep::mutable_points() {
  ::vlsir::spice::PointSweep* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.points)
  return _msg;
}

inline bool Sweep::has_tp() const {
  return tp_case() != TP_NOT_SET;
}
inline void Sweep::clear_has_tp() {
  _oneof_case_[0] = TP_NOT_SET;
}
inline Sweep::TpCase Sweep::tp_case() const {
  return Sweep::TpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinearSweep

// double start = 1;
inline void LinearSweep::clear_start() {
  start_ = 0;
}
inline double LinearSweep::_internal_start() const {
  return start_;
}
inline double LinearSweep::start() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.start)
  return _internal_start();
}
inline void LinearSweep::_internal_set_start(double value) {
  
  start_ = value;
}
inline void LinearSweep::set_start(double value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.start)
}

// double stop = 2;
inline void LinearSweep::clear_stop() {
  stop_ = 0;
}
inline double LinearSweep::_internal_stop() const {
  return stop_;
}
inline double LinearSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.stop)
  return _internal_stop();
}
inline void LinearSweep::_internal_set_stop(double value) {
  
  stop_ = value;
}
inline void LinearSweep::set_stop(double value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.stop)
}

// double step = 3;
inline void LinearSweep::clear_step() {
  step_ = 0;
}
inline double LinearSweep::_internal_step() const {
  return step_;
}
inline double LinearSweep::step() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.step)
  return _internal_step();
}
inline void LinearSweep::_internal_set_step(double value) {
  
  step_ = value;
}
inline void LinearSweep::set_step(double value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.step)
}

// -------------------------------------------------------------------

// LogSweep

// double start = 1;
inline void LogSweep::clear_start() {
  start_ = 0;
}
inline double LogSweep::_internal_start() const {
  return start_;
}
inline double LogSweep::start() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.start)
  return _internal_start();
}
inline void LogSweep::_internal_set_start(double value) {
  
  start_ = value;
}
inline void LogSweep::set_start(double value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.start)
}

// double stop = 2;
inline void LogSweep::clear_stop() {
  stop_ = 0;
}
inline double LogSweep::_internal_stop() const {
  return stop_;
}
inline double LogSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.stop)
  return _internal_stop();
}
inline void LogSweep::_internal_set_stop(double value) {
  
  stop_ = value;
}
inline void LogSweep::set_stop(double value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.stop)
}

// double npts = 3;
inline void LogSweep::clear_npts() {
  npts_ = 0;
}
inline double LogSweep::_internal_npts() const {
  return npts_;
}
inline double LogSweep::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.npts)
  return _internal_npts();
}
inline void LogSweep::_internal_set_npts(double value) {
  
  npts_ = value;
}
inline void LogSweep::set_npts(double value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.npts)
}

// -------------------------------------------------------------------

// PointSweep

// repeated double points = 1;
inline int PointSweep::_internal_points_size() const {
  return points_.size();
}
inline int PointSweep::points_size() const {
  return _internal_points_size();
}
inline void PointSweep::clear_points() {
  points_.Clear();
}
inline double PointSweep::_internal_points(int index) const {
  return points_.Get(index);
}
inline double PointSweep::points(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.points)
  return _internal_points(index);
}
inline void PointSweep::set_points(int index, double value) {
  points_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.points)
}
inline void PointSweep::_internal_add_points(double value) {
  points_.Add(value);
}
inline void PointSweep::add_points(double value) {
  _internal_add_points(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.PointSweep.points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PointSweep::_internal_points() const {
  return points_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PointSweep::points() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.PointSweep.points)
  return _internal_points();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PointSweep::_internal_mutable_points() {
  return &points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PointSweep::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.PointSweep.points)
  return _internal_mutable_points();
}

// double stop = 2;
inline void PointSweep::clear_stop() {
  stop_ = 0;
}
inline double PointSweep::_internal_stop() const {
  return stop_;
}
inline double PointSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.stop)
  return _internal_stop();
}
inline void PointSweep::_internal_set_stop(double value) {
  
  stop_ = value;
}
inline void PointSweep::set_stop(double value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.stop)
}

// double npts = 3;
inline void PointSweep::clear_npts() {
  npts_ = 0;
}
inline double PointSweep::_internal_npts() const {
  return npts_;
}
inline double PointSweep::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.npts)
  return _internal_npts();
}
inline void PointSweep::_internal_set_npts(double value) {
  
  npts_ = value;
}
inline void PointSweep::set_npts(double value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.npts)
}

// -------------------------------------------------------------------

// Control

// .vlsir.spice.Save save = 1;
inline bool Control::_internal_has_save() const {
  return ctrl_case() == kSave;
}
inline bool Control::has_save() const {
  return _internal_has_save();
}
inline void Control::set_has_save() {
  _oneof_case_[0] = kSave;
}
inline void Control::clear_save() {
  if (_internal_has_save()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ctrl_.save_;
    }
    clear_has_ctrl();
  }
}
inline ::vlsir::spice::Save* Control::release_save() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.save)
  if (_internal_has_save()) {
    clear_has_ctrl();
      ::vlsir::spice::Save* temp = ctrl_.save_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::Save& Control::_internal_save() const {
  return _internal_has_save()
      ? *ctrl_.save_
      : reinterpret_cast< ::vlsir::spice::Save&>(::vlsir::spice::_Save_default_instance_);
}
inline const ::vlsir::spice::Save& Control::save() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.save)
  return _internal_save();
}
inline ::vlsir::spice::Save* Control::unsafe_arena_release_save() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.save)
  if (_internal_has_save()) {
    clear_has_ctrl();
    ::vlsir::spice::Save* temp = ctrl_.save_;
    ctrl_.save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_save(::vlsir::spice::Save* save) {
  clear_ctrl();
  if (save) {
    set_has_save();
    ctrl_.save_ = save;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.save)
}
inline ::vlsir::spice::Save* Control::_internal_mutable_save() {
  if (!_internal_has_save()) {
    clear_ctrl();
    set_has_save();
    ctrl_.save_ = CreateMaybeMessage< ::vlsir::spice::Save >(GetArenaForAllocation());
  }
  return ctrl_.save_;
}
inline ::vlsir::spice::Save* Control::mutable_save() {
  ::vlsir::spice::Save* _msg = _internal_mutable_save();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.save)
  return _msg;
}

// .vlsir.spice.Include include = 2;
inline bool Control::_internal_has_include() const {
  return ctrl_case() == kInclude;
}
inline bool Control::has_include() const {
  return _internal_has_include();
}
inline void Control::set_has_include() {
  _oneof_case_[0] = kInclude;
}
inline void Control::clear_include() {
  if (_internal_has_include()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ctrl_.include_;
    }
    clear_has_ctrl();
  }
}
inline ::vlsir::spice::Include* Control::release_include() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.include)
  if (_internal_has_include()) {
    clear_has_ctrl();
      ::vlsir::spice::Include* temp = ctrl_.include_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::Include& Control::_internal_include() const {
  return _internal_has_include()
      ? *ctrl_.include_
      : reinterpret_cast< ::vlsir::spice::Include&>(::vlsir::spice::_Include_default_instance_);
}
inline const ::vlsir::spice::Include& Control::include() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.include)
  return _internal_include();
}
inline ::vlsir::spice::Include* Control::unsafe_arena_release_include() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.include)
  if (_internal_has_include()) {
    clear_has_ctrl();
    ::vlsir::spice::Include* temp = ctrl_.include_;
    ctrl_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_include(::vlsir::spice::Include* include) {
  clear_ctrl();
  if (include) {
    set_has_include();
    ctrl_.include_ = include;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.include)
}
inline ::vlsir::spice::Include* Control::_internal_mutable_include() {
  if (!_internal_has_include()) {
    clear_ctrl();
    set_has_include();
    ctrl_.include_ = CreateMaybeMessage< ::vlsir::spice::Include >(GetArenaForAllocation());
  }
  return ctrl_.include_;
}
inline ::vlsir::spice::Include* Control::mutable_include() {
  ::vlsir::spice::Include* _msg = _internal_mutable_include();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.include)
  return _msg;
}

// string literal = 3;
inline bool Control::_internal_has_literal() const {
  return ctrl_case() == kLiteral;
}
inline bool Control::has_literal() const {
  return _internal_has_literal();
}
inline void Control::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Control::clear_literal() {
  if (_internal_has_literal()) {
    ctrl_.literal_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_ctrl();
  }
}
inline const std::string& Control::literal() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.literal)
  return _internal_literal();
}
template <typename ArgT0, typename... ArgT>
inline void Control::set_literal(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Control.literal)
}
inline std::string* Control::mutable_literal() {
  std::string* _s = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.literal)
  return _s;
}
inline const std::string& Control::_internal_literal() const {
  if (_internal_has_literal()) {
    return ctrl_.literal_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Control::_internal_set_literal(const std::string& value) {
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Control::_internal_mutable_literal() {
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return ctrl_.literal_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Control::release_literal() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.literal)
  if (_internal_has_literal()) {
    clear_has_ctrl();
    return ctrl_.literal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Control::set_allocated_literal(std::string* literal) {
  if (has_ctrl()) {
    clear_ctrl();
  }
  if (literal != nullptr) {
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(literal);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(literal);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.literal)
}

inline bool Control::has_ctrl() const {
  return ctrl_case() != CTRL_NOT_SET;
}
inline void Control::clear_has_ctrl() {
  _oneof_case_[0] = CTRL_NOT_SET;
}
inline Control::CtrlCase Control::ctrl_case() const {
  return Control::CtrlCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Save

// .vlsir.spice.Save.SaveMode mode = 1;
inline bool Save::_internal_has_mode() const {
  return save_case() == kMode;
}
inline bool Save::has_mode() const {
  return _internal_has_mode();
}
inline void Save::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void Save::clear_mode() {
  if (_internal_has_mode()) {
    save_.mode_ = 0;
    clear_has_save();
  }
}
inline ::vlsir::spice::Save_SaveMode Save::_internal_mode() const {
  if (_internal_has_mode()) {
    return static_cast< ::vlsir::spice::Save_SaveMode >(save_.mode_);
  }
  return static_cast< ::vlsir::spice::Save_SaveMode >(0);
}
inline ::vlsir::spice::Save_SaveMode Save::mode() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Save.mode)
  return _internal_mode();
}
inline void Save::_internal_set_mode(::vlsir::spice::Save_SaveMode value) {
  if (!_internal_has_mode()) {
    clear_save();
    set_has_mode();
  }
  save_.mode_ = value;
}
inline void Save::set_mode(::vlsir::spice::Save_SaveMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.mode)
}

// string signal = 2;
inline bool Save::_internal_has_signal() const {
  return save_case() == kSignal;
}
inline bool Save::has_signal() const {
  return _internal_has_signal();
}
inline void Save::set_has_signal() {
  _oneof_case_[0] = kSignal;
}
inline void Save::clear_signal() {
  if (_internal_has_signal()) {
    save_.signal_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_save();
  }
}
inline const std::string& Save::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Save.signal)
  return _internal_signal();
}
template <typename ArgT0, typename... ArgT>
inline void Save::set_signal(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.signal)
}
inline std::string* Save::mutable_signal() {
  std::string* _s = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Save.signal)
  return _s;
}
inline const std::string& Save::_internal_signal() const {
  if (_internal_has_signal()) {
    return save_.signal_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Save::_internal_set_signal(const std::string& value) {
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Save::_internal_mutable_signal() {
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return save_.signal_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Save::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Save.signal)
  if (_internal_has_signal()) {
    clear_has_save();
    return save_.signal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Save::set_allocated_signal(std::string* signal) {
  if (has_save()) {
    clear_save();
  }
  if (signal != nullptr) {
    set_has_signal();
    save_.signal_.UnsafeSetDefault(signal);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(signal);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Save.signal)
}

inline bool Save::has_save() const {
  return save_case() != SAVE_NOT_SET;
}
inline void Save::clear_has_save() {
  _oneof_case_[0] = SAVE_NOT_SET;
}
inline Save::SaveCase Save::save_case() const {
  return Save::SaveCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Include

// string path = 1;
inline void Include::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& Include::path() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Include.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Include::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Include.path)
}
inline std::string* Include::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Include.path)
  return _s;
}
inline const std::string& Include::_internal_path() const {
  return path_.Get();
}
inline void Include::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Include::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Include::release_path() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Include.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Include::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Include.path)
}

// -------------------------------------------------------------------

// LibInclude

// string path = 1;
inline void LibInclude::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& LibInclude::path() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LibInclude.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibInclude::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.LibInclude.path)
}
inline std::string* LibInclude::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.LibInclude.path)
  return _s;
}
inline const std::string& LibInclude::_internal_path() const {
  return path_.Get();
}
inline void LibInclude::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LibInclude::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LibInclude::release_path() {
  // @@protoc_insertion_point(field_release:vlsir.spice.LibInclude.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LibInclude::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.LibInclude.path)
}

// string section = 2;
inline void LibInclude::clear_section() {
  section_.ClearToEmpty();
}
inline const std::string& LibInclude::section() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LibInclude.section)
  return _internal_section();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibInclude::set_section(ArgT0&& arg0, ArgT... args) {
 
 section_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.LibInclude.section)
}
inline std::string* LibInclude::mutable_section() {
  std::string* _s = _internal_mutable_section();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.LibInclude.section)
  return _s;
}
inline const std::string& LibInclude::_internal_section() const {
  return section_.Get();
}
inline void LibInclude::_internal_set_section(const std::string& value) {
  
  section_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LibInclude::_internal_mutable_section() {
  
  return section_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LibInclude::release_section() {
  // @@protoc_insertion_point(field_release:vlsir.spice.LibInclude.section)
  return section_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LibInclude::set_allocated_section(std::string* section) {
  if (section != nullptr) {
    
  } else {
    
  }
  section_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), section,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.LibInclude.section)
}

// -------------------------------------------------------------------

// Meas

// string name = 1;
inline void Meas::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Meas::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Meas::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.name)
}
inline std::string* Meas::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.name)
  return _s;
}
inline const std::string& Meas::_internal_name() const {
  return name_.Get();
}
inline void Meas::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Meas::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Meas::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Meas::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.name)
}

// string expr = 2;
inline void Meas::clear_expr() {
  expr_.ClearToEmpty();
}
inline const std::string& Meas::expr() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.expr)
  return _internal_expr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Meas::set_expr(ArgT0&& arg0, ArgT... args) {
 
 expr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.expr)
}
inline std::string* Meas::mutable_expr() {
  std::string* _s = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.expr)
  return _s;
}
inline const std::string& Meas::_internal_expr() const {
  return expr_.Get();
}
inline void Meas::_internal_set_expr(const std::string& value) {
  
  expr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Meas::_internal_mutable_expr() {
  
  return expr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Meas::release_expr() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.expr)
  return expr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Meas::set_allocated_expr(std::string* expr) {
  if (expr != nullptr) {
    
  } else {
    
  }
  expr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.expr)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Signal.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Signal::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.spice.Signal.name)
}
inline std::string* Signal::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Signal.name)
  return _s;
}
inline const std::string& Signal::_internal_name() const {
  return name_.Get();
}
inline void Signal::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Signal::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Signal.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Signal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Signal.name)
}

// -------------------------------------------------------------------

// Signals

// repeated .vlsir.spice.Signal signals = 1;
inline int Signals::_internal_signals_size() const {
  return signals_.size();
}
inline int Signals::signals_size() const {
  return _internal_signals_size();
}
inline void Signals::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::spice::Signal* Signals::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Signals.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Signal >*
Signals::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.Signals.signals)
  return &signals_;
}
inline const ::vlsir::spice::Signal& Signals::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const ::vlsir::spice::Signal& Signals::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Signals.signals)
  return _internal_signals(index);
}
inline ::vlsir::spice::Signal* Signals::_internal_add_signals() {
  return signals_.Add();
}
inline ::vlsir::spice::Signal* Signals::add_signals() {
  ::vlsir::spice::Signal* _add = _internal_add_signals();
  // @@protoc_insertion_point(field_add:vlsir.spice.Signals.signals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Signal >&
Signals::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.Signals.signals)
  return signals_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spice
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::spice::Save_SaveMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::spice::Save_SaveMode>() {
  return ::vlsir::spice::Save_SaveMode_descriptor();
}
template <> struct is_proto_enum< ::vlsir::spice::Signal_Quantity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::spice::Signal_Quantity>() {
  return ::vlsir::spice::Signal_Quantity_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_spice_2eproto
