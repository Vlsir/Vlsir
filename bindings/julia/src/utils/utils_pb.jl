# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-04-07T22:11:03.216
# original file: /home/thomas/Projects/HW-Design/Vlsir/protos/utils.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export SIPrefix, QualifiedName, AuthorMetadata, Prefixed, Reference, LibraryMetadata
export ParamValue, Param

@enumx SIPrefix YOCTO=0 ZEPTO=1 ATTO=2 FEMTO=3 PICO=4 NANO=5 MICRO=6 MILLI=7 CENTI=8 DECI=9 DECA=10 HECTO=11 KILO=12 MEGA=13 GIGA=14 TERA=15 PETA=16 EXA=17 ZETTA=18 YOTTA=19 UNIT=20

struct QualifiedName
    domain::String
    name::String
end
PB.default_values(::Type{QualifiedName}) = (;domain = "", name = "")
PB.field_numbers(::Type{QualifiedName}) = (;domain = 1, name = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:QualifiedName})
    domain = ""
    name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            domain = PB.decode(d, String)
        elseif field_number == 2
            name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return QualifiedName(domain, name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::QualifiedName)
    initpos = position(e.io)
    !isempty(x.domain) && PB.encode(e, 1, x.domain)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::QualifiedName)
    encoded_size = 0
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    return encoded_size
end

struct AuthorMetadata
    author::String
    copyright::String
    license::String
end
PB.default_values(::Type{AuthorMetadata}) = (;author = "", copyright = "", license = "")
PB.field_numbers(::Type{AuthorMetadata}) = (;author = 1, copyright = 10, license = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AuthorMetadata})
    author = ""
    copyright = ""
    license = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            author = PB.decode(d, String)
        elseif field_number == 10
            copyright = PB.decode(d, String)
        elseif field_number == 11
            license = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return AuthorMetadata(author, copyright, license)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AuthorMetadata)
    initpos = position(e.io)
    !isempty(x.author) && PB.encode(e, 1, x.author)
    !isempty(x.copyright) && PB.encode(e, 10, x.copyright)
    !isempty(x.license) && PB.encode(e, 11, x.license)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AuthorMetadata)
    encoded_size = 0
    !isempty(x.author) && (encoded_size += PB._encoded_size(x.author, 1))
    !isempty(x.copyright) && (encoded_size += PB._encoded_size(x.copyright, 10))
    !isempty(x.license) && (encoded_size += PB._encoded_size(x.license, 11))
    return encoded_size
end

struct Prefixed
    prefix::SIPrefix.T
    number::Union{Nothing,OneOf{<:Union{Int64,Float64,String}}}
end
PB.oneof_field_types(::Type{Prefixed}) = (;
    number = (;integer=Int64, double=Float64, string=String),
)
PB.default_values(::Type{Prefixed}) = (;prefix = SIPrefix.YOCTO, integer = zero(Int64), double = zero(Float64), string = "")
PB.field_numbers(::Type{Prefixed}) = (;prefix = 1, integer = 2, double = 3, string = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Prefixed})
    prefix = SIPrefix.YOCTO
    number = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            prefix = PB.decode(d, SIPrefix.T)
        elseif field_number == 2
            number = OneOf(:integer, PB.decode(d, Int64))
        elseif field_number == 3
            number = OneOf(:double, PB.decode(d, Float64))
        elseif field_number == 4
            number = OneOf(:string, PB.decode(d, String))
        else
            PB.skip(d, wire_type)
        end
    end
    return Prefixed(prefix, number)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Prefixed)
    initpos = position(e.io)
    x.prefix != SIPrefix.YOCTO && PB.encode(e, 1, x.prefix)
    if isnothing(x.number);
    elseif x.number.name === :integer
        PB.encode(e, 2, x.number[]::Int64)
    elseif x.number.name === :double
        PB.encode(e, 3, x.number[]::Float64)
    elseif x.number.name === :string
        PB.encode(e, 4, x.number[]::String)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Prefixed)
    encoded_size = 0
    x.prefix != SIPrefix.YOCTO && (encoded_size += PB._encoded_size(x.prefix, 1))
    if isnothing(x.number);
    elseif x.number.name === :integer
        encoded_size += PB._encoded_size(x.number[]::Int64, 2)
    elseif x.number.name === :double
        encoded_size += PB._encoded_size(x.number[]::Float64, 3)
    elseif x.number.name === :string
        encoded_size += PB._encoded_size(x.number[]::String, 4)
    end
    return encoded_size
end

struct Reference
    to::Union{Nothing,OneOf{<:Union{String,QualifiedName}}}
end
PB.oneof_field_types(::Type{Reference}) = (;
    to = (;var"#local"=String, external=QualifiedName),
)
PB.default_values(::Type{Reference}) = (;var"#local" = "", external = nothing)
PB.field_numbers(::Type{Reference}) = (;var"#local" = 1, external = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Reference})
    to = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            to = OneOf(:var"#local", PB.decode(d, String))
        elseif field_number == 2
            to = OneOf(:external, PB.decode(d, Ref{QualifiedName}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Reference(to)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Reference)
    initpos = position(e.io)
    if isnothing(x.to);
    elseif x.to.name === :var"#local"
        PB.encode(e, 1, x.to[]::String)
    elseif x.to.name === :external
        PB.encode(e, 2, x.to[]::QualifiedName)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Reference)
    encoded_size = 0
    if isnothing(x.to);
    elseif x.to.name === :var"#local"
        encoded_size += PB._encoded_size(x.to[]::String, 1)
    elseif x.to.name === :external
        encoded_size += PB._encoded_size(x.to[]::QualifiedName, 2)
    end
    return encoded_size
end

struct LibraryMetadata
    domain::String
    cell_names::Vector{String}
    author::Union{Nothing,AuthorMetadata}
end
PB.default_values(::Type{LibraryMetadata}) = (;domain = "", cell_names = Vector{String}(), author = nothing)
PB.field_numbers(::Type{LibraryMetadata}) = (;domain = 1, cell_names = 10, author = 20)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LibraryMetadata})
    domain = ""
    cell_names = PB.BufferedVector{String}()
    author = Ref{Union{Nothing,AuthorMetadata}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            domain = PB.decode(d, String)
        elseif field_number == 10
            PB.decode!(d, cell_names)
        elseif field_number == 20
            PB.decode!(d, author)
        else
            PB.skip(d, wire_type)
        end
    end
    return LibraryMetadata(domain, cell_names[], author[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LibraryMetadata)
    initpos = position(e.io)
    !isempty(x.domain) && PB.encode(e, 1, x.domain)
    !isempty(x.cell_names) && PB.encode(e, 10, x.cell_names)
    !isnothing(x.author) && PB.encode(e, 20, x.author)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LibraryMetadata)
    encoded_size = 0
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 1))
    !isempty(x.cell_names) && (encoded_size += PB._encoded_size(x.cell_names, 10))
    !isnothing(x.author) && (encoded_size += PB._encoded_size(x.author, 20))
    return encoded_size
end

struct ParamValue
    value::Union{Nothing,OneOf{<:Union{Int64,Float64,String,Prefixed}}}
end
PB.oneof_field_types(::Type{ParamValue}) = (;
    value = (;integer=Int64, double=Float64, string=String, literal=String, prefixed=Prefixed),
)
PB.default_values(::Type{ParamValue}) = (;integer = zero(Int64), double = zero(Float64), string = "", literal = "", prefixed = nothing)
PB.field_numbers(::Type{ParamValue}) = (;integer = 2, double = 3, string = 4, literal = 5, prefixed = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ParamValue})
    value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            value = OneOf(:integer, PB.decode(d, Int64))
        elseif field_number == 3
            value = OneOf(:double, PB.decode(d, Float64))
        elseif field_number == 4
            value = OneOf(:string, PB.decode(d, String))
        elseif field_number == 5
            value = OneOf(:literal, PB.decode(d, String))
        elseif field_number == 6
            value = OneOf(:prefixed, PB.decode(d, Ref{Prefixed}))
        else
            PB.skip(d, wire_type)
        end
    end
    return ParamValue(value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ParamValue)
    initpos = position(e.io)
    if isnothing(x.value);
    elseif x.value.name === :integer
        PB.encode(e, 2, x.value[]::Int64)
    elseif x.value.name === :double
        PB.encode(e, 3, x.value[]::Float64)
    elseif x.value.name === :string
        PB.encode(e, 4, x.value[]::String)
    elseif x.value.name === :literal
        PB.encode(e, 5, x.value[]::String)
    elseif x.value.name === :prefixed
        PB.encode(e, 6, x.value[]::Prefixed)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ParamValue)
    encoded_size = 0
    if isnothing(x.value);
    elseif x.value.name === :integer
        encoded_size += PB._encoded_size(x.value[]::Int64, 2)
    elseif x.value.name === :double
        encoded_size += PB._encoded_size(x.value[]::Float64, 3)
    elseif x.value.name === :string
        encoded_size += PB._encoded_size(x.value[]::String, 4)
    elseif x.value.name === :literal
        encoded_size += PB._encoded_size(x.value[]::String, 5)
    elseif x.value.name === :prefixed
        encoded_size += PB._encoded_size(x.value[]::Prefixed, 6)
    end
    return encoded_size
end

struct Param
    name::String
    value::Union{Nothing,ParamValue}
    desc::String
end
PB.default_values(::Type{Param}) = (;name = "", value = nothing, desc = "")
PB.field_numbers(::Type{Param}) = (;name = 1, value = 2, desc = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Param})
    name = ""
    value = Ref{Union{Nothing,ParamValue}}(nothing)
    desc = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, value)
        elseif field_number == 3
            desc = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Param(name, value[], desc)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Param)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.value) && PB.encode(e, 2, x.value)
    !isempty(x.desc) && PB.encode(e, 3, x.desc)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Param)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.value) && (encoded_size += PB._encoded_size(x.value, 2))
    !isempty(x.desc) && (encoded_size += PB._encoded_size(x.desc, 3))
    return encoded_size
end
