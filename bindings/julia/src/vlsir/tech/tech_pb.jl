# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-04-06T12:42:59.850
# original file: /home/thomas/Projects/HW-Design/vlsir/protos/tech.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export LayerPurposeType, Package, LayerPurpose, LayerInfo, Technology

@enumx LayerPurposeType UNKNOWN=0 LABEL=1 DRAWING=2 PIN=3 OBSTRUCTION=4 OUTLINE=5

struct Package
    name::String
end
PB.default_values(::Type{Package}) = (;name = "")
PB.field_numbers(::Type{Package}) = (;name = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Package})
    name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Package(name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Package)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Package)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    return encoded_size
end

struct LayerPurpose
    description::String
    var"#type"::LayerPurposeType.T
end
PB.default_values(::Type{LayerPurpose}) = (;description = "", var"#type" = LayerPurposeType.UNKNOWN)
PB.field_numbers(::Type{LayerPurpose}) = (;description = 1, var"#type" = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LayerPurpose})
    description = ""
    var"#type" = LayerPurposeType.UNKNOWN
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            description = PB.decode(d, String)
        elseif field_number == 2
            var"#type" = PB.decode(d, LayerPurposeType.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return LayerPurpose(description, var"#type")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LayerPurpose)
    initpos = position(e.io)
    !isempty(x.description) && PB.encode(e, 1, x.description)
    x.var"#type" != LayerPurposeType.UNKNOWN && PB.encode(e, 2, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::LayerPurpose)
    encoded_size = 0
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 1))
    x.var"#type" != LayerPurposeType.UNKNOWN && (encoded_size += PB._encoded_size(x.var"#type", 2))
    return encoded_size
end

struct LayerInfo
    name::String
    purpose::Union{Nothing,LayerPurpose}
    index::UInt64
    sub_index::UInt64
end
PB.default_values(::Type{LayerInfo}) = (;name = "", purpose = nothing, index = zero(UInt64), sub_index = zero(UInt64))
PB.field_numbers(::Type{LayerInfo}) = (;name = 1, purpose = 11, index = 21, sub_index = 31)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LayerInfo})
    name = ""
    purpose = Ref{Union{Nothing,LayerPurpose}}(nothing)
    index = zero(UInt64)
    sub_index = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 11
            PB.decode!(d, purpose)
        elseif field_number == 21
            index = PB.decode(d, UInt64)
        elseif field_number == 31
            sub_index = PB.decode(d, UInt64)
        else
            PB.skip(d, wire_type)
        end
    end
    return LayerInfo(name, purpose[], index, sub_index)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LayerInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.purpose) && PB.encode(e, 11, x.purpose)
    x.index != zero(UInt64) && PB.encode(e, 21, x.index)
    x.sub_index != zero(UInt64) && PB.encode(e, 31, x.sub_index)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LayerInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.purpose) && (encoded_size += PB._encoded_size(x.purpose, 11))
    x.index != zero(UInt64) && (encoded_size += PB._encoded_size(x.index, 21))
    x.sub_index != zero(UInt64) && (encoded_size += PB._encoded_size(x.sub_index, 31))
    return encoded_size
end

struct Technology
    name::String
    packages::Vector{Package}
    layers::Vector{LayerInfo}
end
PB.default_values(::Type{Technology}) = (;name = "", packages = Vector{Package}(), layers = Vector{LayerInfo}())
PB.field_numbers(::Type{Technology}) = (;name = 1, packages = 11, layers = 101)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Technology})
    name = ""
    packages = PB.BufferedVector{Package}()
    layers = PB.BufferedVector{LayerInfo}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 11
            PB.decode!(d, packages)
        elseif field_number == 101
            PB.decode!(d, layers)
        else
            PB.skip(d, wire_type)
        end
    end
    return Technology(name, packages[], layers[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Technology)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.packages) && PB.encode(e, 11, x.packages)
    !isempty(x.layers) && PB.encode(e, 101, x.layers)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Technology)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.packages) && (encoded_size += PB._encoded_size(x.packages, 11))
    !isempty(x.layers) && (encoded_size += PB._encoded_size(x.layers, 101))
    return encoded_size
end
