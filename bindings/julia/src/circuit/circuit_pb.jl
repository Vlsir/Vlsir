# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-04-07T22:11:03.040
# original file: /home/thomas/Projects/HW-Design/Vlsir/protos/circuit.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Slice, var"Port.Direction", Signal, Port, Interface, ExternalModule, Connection
export Module, Instance, Package, Concat, ConnectionTarget

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractConnection" end
abstract type var"##AbstractModule" end
abstract type var"##AbstractInstance" end
abstract type var"##AbstractPackage" end
abstract type var"##AbstractConcat" end
abstract type var"##AbstractConnectionTarget" end


struct Slice
    signal::String
    top::Int64
    bot::Int64
end
PB.default_values(::Type{Slice}) = (;signal = "", top = zero(Int64), bot = zero(Int64))
PB.field_numbers(::Type{Slice}) = (;signal = 1, top = 2, bot = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Slice})
    signal = ""
    top = zero(Int64)
    bot = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            signal = PB.decode(d, String)
        elseif field_number == 2
            top = PB.decode(d, Int64)
        elseif field_number == 3
            bot = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Slice(signal, top, bot)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Slice)
    initpos = position(e.io)
    !isempty(x.signal) && PB.encode(e, 1, x.signal)
    x.top != zero(Int64) && PB.encode(e, 2, x.top)
    x.bot != zero(Int64) && PB.encode(e, 3, x.bot)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Slice)
    encoded_size = 0
    !isempty(x.signal) && (encoded_size += PB._encoded_size(x.signal, 1))
    x.top != zero(Int64) && (encoded_size += PB._encoded_size(x.top, 2))
    x.bot != zero(Int64) && (encoded_size += PB._encoded_size(x.bot, 3))
    return encoded_size
end

@enumx var"Port.Direction" INPUT=0 OUTPUT=1 INOUT=2 NONE=3

struct Signal
    name::String
    width::Int64
end
PB.default_values(::Type{Signal}) = (;name = "", width = zero(Int64))
PB.field_numbers(::Type{Signal}) = (;name = 1, width = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Signal})
    name = ""
    width = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            width = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Signal(name, width)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Signal)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.width != zero(Int64) && PB.encode(e, 2, x.width)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Signal)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.width != zero(Int64) && (encoded_size += PB._encoded_size(x.width, 2))
    return encoded_size
end

struct Port
    signal::String
    direction::var"Port.Direction".T
end
PB.default_values(::Type{Port}) = (;signal = "", direction = var"Port.Direction".INPUT)
PB.field_numbers(::Type{Port}) = (;signal = 1, direction = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Port})
    signal = ""
    direction = var"Port.Direction".INPUT
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            signal = PB.decode(d, String)
        elseif field_number == 2
            direction = PB.decode(d, var"Port.Direction".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return Port(signal, direction)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Port)
    initpos = position(e.io)
    !isempty(x.signal) && PB.encode(e, 1, x.signal)
    x.direction != var"Port.Direction".INPUT && PB.encode(e, 2, x.direction)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Port)
    encoded_size = 0
    !isempty(x.signal) && (encoded_size += PB._encoded_size(x.signal, 1))
    x.direction != var"Port.Direction".INPUT && (encoded_size += PB._encoded_size(x.direction, 2))
    return encoded_size
end

struct Interface
    name::String
    ports::Vector{Port}
end
PB.default_values(::Type{Interface}) = (;name = "", ports = Vector{Port}())
PB.field_numbers(::Type{Interface}) = (;name = 1, ports = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Interface})
    name = ""
    ports = PB.BufferedVector{Port}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 10
            PB.decode!(d, ports)
        else
            PB.skip(d, wire_type)
        end
    end
    return Interface(name, ports[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Interface)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.ports) && PB.encode(e, 10, x.ports)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Interface)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.ports) && (encoded_size += PB._encoded_size(x.ports, 10))
    return encoded_size
end

struct ExternalModule
    name::Union{Nothing,Vlsir.utils.QualifiedName}
    desc::String
    ports::Vector{Port}
    signals::Vector{Signal}
    parameters::Vector{Vlsir.utils.Param}
end
PB.default_values(::Type{ExternalModule}) = (;name = nothing, desc = "", ports = Vector{Port}(), signals = Vector{Signal}(), parameters = Vector{Vlsir.utils.Param}())
PB.field_numbers(::Type{ExternalModule}) = (;name = 1, desc = 2, ports = 3, signals = 4, parameters = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExternalModule})
    name = Ref{Union{Nothing,Vlsir.utils.QualifiedName}}(nothing)
    desc = ""
    ports = PB.BufferedVector{Port}()
    signals = PB.BufferedVector{Signal}()
    parameters = PB.BufferedVector{Vlsir.utils.Param}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            desc = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, ports)
        elseif field_number == 4
            PB.decode!(d, signals)
        elseif field_number == 5
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExternalModule(name[], desc, ports[], signals[], parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExternalModule)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.desc) && PB.encode(e, 2, x.desc)
    !isempty(x.ports) && PB.encode(e, 3, x.ports)
    !isempty(x.signals) && PB.encode(e, 4, x.signals)
    !isempty(x.parameters) && PB.encode(e, 5, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExternalModule)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.desc) && (encoded_size += PB._encoded_size(x.desc, 2))
    !isempty(x.ports) && (encoded_size += PB._encoded_size(x.ports, 3))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 4))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 5))
    return encoded_size
end

struct Connection{T1<:Union{Nothing,var"##AbstractConnectionTarget"}} <: var"##AbstractConnection"
    portname::String
    target::T1
end
PB.default_values(::Type{Connection}) = (;portname = "", target = nothing)
PB.field_numbers(::Type{Connection}) = (;portname = 1, target = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Connection})
    portname = ""
    target = Ref{Union{Nothing,ConnectionTarget}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            portname = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, target)
        else
            PB.skip(d, wire_type)
        end
    end
    return Connection(portname, target[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Connection)
    initpos = position(e.io)
    !isempty(x.portname) && PB.encode(e, 1, x.portname)
    !isnothing(x.target) && PB.encode(e, 2, x.target)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Connection)
    encoded_size = 0
    !isempty(x.portname) && (encoded_size += PB._encoded_size(x.portname, 1))
    !isnothing(x.target) && (encoded_size += PB._encoded_size(x.target, 2))
    return encoded_size
end

struct Module{T1<:Union{Nothing,var"##AbstractInstance"}} <: var"##AbstractModule"
    name::String
    ports::Vector{Port}
    signals::Vector{Signal}
    instances::Vector{T1}
    parameters::Vector{Vlsir.utils.Param}
end
PB.default_values(::Type{Module}) = (;name = "", ports = Vector{Port}(), signals = Vector{Signal}(), instances = Vector{Instance}(), parameters = Vector{Vlsir.utils.Param}())
PB.field_numbers(::Type{Module}) = (;name = 1, ports = 2, signals = 3, instances = 4, parameters = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Module})
    name = ""
    ports = PB.BufferedVector{Port}()
    signals = PB.BufferedVector{Signal}()
    instances = PB.BufferedVector{Instance}()
    parameters = PB.BufferedVector{Vlsir.utils.Param}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, ports)
        elseif field_number == 3
            PB.decode!(d, signals)
        elseif field_number == 4
            PB.decode!(d, instances)
        elseif field_number == 5
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return Module(name, ports[], signals[], instances[], parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Module)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.ports) && PB.encode(e, 2, x.ports)
    !isempty(x.signals) && PB.encode(e, 3, x.signals)
    !isempty(x.instances) && PB.encode(e, 4, x.instances)
    !isempty(x.parameters) && PB.encode(e, 5, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Module)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.ports) && (encoded_size += PB._encoded_size(x.ports, 2))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 3))
    !isempty(x.instances) && (encoded_size += PB._encoded_size(x.instances, 4))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 5))
    return encoded_size
end

struct Instance <: var"##AbstractInstance"
    name::String
    var"#module"::Union{Nothing,Vlsir.utils.Reference}
    parameters::Vector{Vlsir.utils.Param}
    connections::Vector{<:Connection}
end
PB.default_values(::Type{Instance}) = (;name = "", var"#module" = nothing, parameters = Vector{Vlsir.utils.Param}(), connections = Vector{Connection}())
PB.field_numbers(::Type{Instance}) = (;name = 1, var"#module" = 2, parameters = 3, connections = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Instance})
    name = ""
    var"#module" = Ref{Union{Nothing,Vlsir.utils.Reference}}(nothing)
    parameters = PB.BufferedVector{Vlsir.utils.Param}()
    connections = PB.BufferedVector{Connection}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, var"#module")
        elseif field_number == 3
            PB.decode!(d, parameters)
        elseif field_number == 4
            PB.decode!(d, connections)
        else
            PB.skip(d, wire_type)
        end
    end
    return Instance(name, var"#module"[], parameters[], connections[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Instance)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.var"#module") && PB.encode(e, 2, x.var"#module")
    !isempty(x.parameters) && PB.encode(e, 3, x.parameters)
    !isempty(x.connections) && PB.encode(e, 4, x.connections)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Instance)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.var"#module") && (encoded_size += PB._encoded_size(x.var"#module", 2))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 3))
    !isempty(x.connections) && (encoded_size += PB._encoded_size(x.connections, 4))
    return encoded_size
end

struct Package <: var"##AbstractPackage"
    domain::String
    modules::Vector{<:Module}
    ext_modules::Vector{ExternalModule}
    desc::String
end
PB.default_values(::Type{Package}) = (;domain = "", modules = Vector{Module}(), ext_modules = Vector{ExternalModule}(), desc = "")
PB.field_numbers(::Type{Package}) = (;domain = 1, modules = 2, ext_modules = 3, desc = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Package})
    domain = ""
    modules = PB.BufferedVector{Module}()
    ext_modules = PB.BufferedVector{ExternalModule}()
    desc = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            domain = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, modules)
        elseif field_number == 3
            PB.decode!(d, ext_modules)
        elseif field_number == 10
            desc = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Package(domain, modules[], ext_modules[], desc)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Package)
    initpos = position(e.io)
    !isempty(x.domain) && PB.encode(e, 1, x.domain)
    !isempty(x.modules) && PB.encode(e, 2, x.modules)
    !isempty(x.ext_modules) && PB.encode(e, 3, x.ext_modules)
    !isempty(x.desc) && PB.encode(e, 10, x.desc)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Package)
    encoded_size = 0
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 1))
    !isempty(x.modules) && (encoded_size += PB._encoded_size(x.modules, 2))
    !isempty(x.ext_modules) && (encoded_size += PB._encoded_size(x.ext_modules, 3))
    !isempty(x.desc) && (encoded_size += PB._encoded_size(x.desc, 10))
    return encoded_size
end

struct Concat{T1<:Union{Nothing,var"##AbstractConnectionTarget"}} <: var"##AbstractConcat"
    parts::Vector{T1}
end
PB.default_values(::Type{Concat}) = (;parts = Vector{ConnectionTarget}())
PB.field_numbers(::Type{Concat}) = (;parts = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Concat})
    parts = PB.BufferedVector{ConnectionTarget}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, parts)
        else
            PB.skip(d, wire_type)
        end
    end
    return Concat(parts[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Concat)
    initpos = position(e.io)
    !isempty(x.parts) && PB.encode(e, 1, x.parts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Concat)
    encoded_size = 0
    !isempty(x.parts) && (encoded_size += PB._encoded_size(x.parts, 1))
    return encoded_size
end

struct ConnectionTarget <: var"##AbstractConnectionTarget"
    stype::Union{Nothing,OneOf{<:Union{String,Slice,var"##AbstractConcat"}}}
end
PB.oneof_field_types(::Type{ConnectionTarget}) = (;
    stype = (;sig=String, slice=Slice, concat=Concat),
)
PB.default_values(::Type{ConnectionTarget}) = (;sig = "", slice = nothing, concat = nothing)
PB.field_numbers(::Type{ConnectionTarget}) = (;sig = 1, slice = 2, concat = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionTarget})
    stype = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            stype = OneOf(:sig, PB.decode(d, String))
        elseif field_number == 2
            stype = OneOf(:slice, PB.decode(d, Ref{Slice}))
        elseif field_number == 3
            stype = OneOf(:concat, PB.decode(d, Ref{Concat}))
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionTarget(stype)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionTarget)
    initpos = position(e.io)
    if isnothing(x.stype);
    elseif x.stype.name === :sig
        PB.encode(e, 1, x.stype[]::String)
    elseif x.stype.name === :slice
        PB.encode(e, 2, x.stype[]::Slice)
    elseif x.stype.name === :concat
        PB.encode(e, 3, x.stype[]::Concat)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionTarget)
    encoded_size = 0
    if isnothing(x.stype);
    elseif x.stype.name === :sig
        encoded_size += PB._encoded_size(x.stype[]::String, 1)
    elseif x.stype.name === :slice
        encoded_size += PB._encoded_size(x.stype[]::Slice, 2)
    elseif x.stype.name === :concat
        encoded_size += PB._encoded_size(x.stype[]::Concat, 3)
    end
    return encoded_size
end
