# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-04-07T22:11:03.262
# original file: /home/thomas/Projects/HW-Design/Vlsir/protos/spice.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export LogSweep, SimOptions, TranResult, CustomAnalysisResult, PointSweep, LibInclude
export NoiseResult, var"Save.SaveMode", DcResult, ComplexNum, var"Signal.Quantity"
export LinearSweep, OpResult, Meas, Include, Save, AcResult, Signal, Sweep, Control
export NoiseInput, TranInput, DcInput, OpInput, AcInput, CustomAnalysisInput, Spice
export SweepResult, MonteResult, SweepInput, MonteInput, SimInput, AnalysisResult
export SimResult, Analysis

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractSpice" end
abstract type var"##AbstractSweepResult" end
abstract type var"##AbstractMonteResult" end
abstract type var"##AbstractSweepInput" end
abstract type var"##AbstractMonteInput" end
abstract type var"##AbstractSimInput" end
abstract type var"##AbstractAnalysisResult" end
abstract type var"##AbstractSimResult" end
abstract type var"##AbstractAnalysis" end


struct LogSweep
    start::Float64
    stop::Float64
    npts::Float64
end
PB.default_values(::Type{LogSweep}) = (;start = zero(Float64), stop = zero(Float64), npts = zero(Float64))
PB.field_numbers(::Type{LogSweep}) = (;start = 1, stop = 2, npts = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LogSweep})
    start = zero(Float64)
    stop = zero(Float64)
    npts = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            start = PB.decode(d, Float64)
        elseif field_number == 2
            stop = PB.decode(d, Float64)
        elseif field_number == 3
            npts = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return LogSweep(start, stop, npts)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LogSweep)
    initpos = position(e.io)
    x.start != zero(Float64) && PB.encode(e, 1, x.start)
    x.stop != zero(Float64) && PB.encode(e, 2, x.stop)
    x.npts != zero(Float64) && PB.encode(e, 3, x.npts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LogSweep)
    encoded_size = 0
    x.start != zero(Float64) && (encoded_size += PB._encoded_size(x.start, 1))
    x.stop != zero(Float64) && (encoded_size += PB._encoded_size(x.stop, 2))
    x.npts != zero(Float64) && (encoded_size += PB._encoded_size(x.npts, 3))
    return encoded_size
end

struct SimOptions
    opts::Union{Nothing,google.protobuf.Struct}
end
PB.default_values(::Type{SimOptions}) = (;opts = nothing)
PB.field_numbers(::Type{SimOptions}) = (;opts = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimOptions})
    opts = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, opts)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimOptions(opts[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimOptions)
    initpos = position(e.io)
    !isnothing(x.opts) && PB.encode(e, 1, x.opts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimOptions)
    encoded_size = 0
    !isnothing(x.opts) && (encoded_size += PB._encoded_size(x.opts, 1))
    return encoded_size
end

struct TranResult
    analysis_name::String
    signals::Vector{String}
    data::Vector{Float64}
    measurements::Dict{String,Float64}
end
PB.reserved_fields(::Type{TranResult}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2, 4])
PB.default_values(::Type{TranResult}) = (;analysis_name = "", signals = Vector{String}(), data = Vector{Float64}(), measurements = Dict{String,Float64}())
PB.field_numbers(::Type{TranResult}) = (;analysis_name = 1, signals = 3, data = 5, measurements = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TranResult})
    analysis_name = ""
    signals = PB.BufferedVector{String}()
    data = PB.BufferedVector{Float64}()
    measurements = Dict{String,Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, signals)
        elseif field_number == 5
            PB.decode!(d, wire_type, data)
        elseif field_number == 10
            PB.decode!(d, measurements)
        else
            PB.skip(d, wire_type)
        end
    end
    return TranResult(analysis_name, signals[], data[], measurements)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TranResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.signals) && PB.encode(e, 3, x.signals)
    !isempty(x.data) && PB.encode(e, 5, x.data)
    !isempty(x.measurements) && PB.encode(e, 10, x.measurements)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TranResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 3))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 5))
    !isempty(x.measurements) && (encoded_size += PB._encoded_size(x.measurements, 10))
    return encoded_size
end

struct CustomAnalysisResult  end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CustomAnalysisResult})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return CustomAnalysisResult()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CustomAnalysisResult)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CustomAnalysisResult)
    encoded_size = 0
    return encoded_size
end

struct PointSweep
    points::Vector{Float64}
    stop::Float64
    npts::Float64
end
PB.default_values(::Type{PointSweep}) = (;points = Vector{Float64}(), stop = zero(Float64), npts = zero(Float64))
PB.field_numbers(::Type{PointSweep}) = (;points = 1, stop = 2, npts = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PointSweep})
    points = PB.BufferedVector{Float64}()
    stop = zero(Float64)
    npts = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, points)
        elseif field_number == 2
            stop = PB.decode(d, Float64)
        elseif field_number == 3
            npts = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return PointSweep(points[], stop, npts)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PointSweep)
    initpos = position(e.io)
    !isempty(x.points) && PB.encode(e, 1, x.points)
    x.stop != zero(Float64) && PB.encode(e, 2, x.stop)
    x.npts != zero(Float64) && PB.encode(e, 3, x.npts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PointSweep)
    encoded_size = 0
    !isempty(x.points) && (encoded_size += PB._encoded_size(x.points, 1))
    x.stop != zero(Float64) && (encoded_size += PB._encoded_size(x.stop, 2))
    x.npts != zero(Float64) && (encoded_size += PB._encoded_size(x.npts, 3))
    return encoded_size
end

struct LibInclude
    path::String
    section::String
end
PB.default_values(::Type{LibInclude}) = (;path = "", section = "")
PB.field_numbers(::Type{LibInclude}) = (;path = 1, section = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LibInclude})
    path = ""
    section = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            path = PB.decode(d, String)
        elseif field_number == 2
            section = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return LibInclude(path, section)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LibInclude)
    initpos = position(e.io)
    !isempty(x.path) && PB.encode(e, 1, x.path)
    !isempty(x.section) && PB.encode(e, 2, x.section)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LibInclude)
    encoded_size = 0
    !isempty(x.path) && (encoded_size += PB._encoded_size(x.path, 1))
    !isempty(x.section) && (encoded_size += PB._encoded_size(x.section, 2))
    return encoded_size
end

struct NoiseResult
    analysis_name::String
    signals::Vector{String}
    data::Vector{Float64}
    integrated_noise::Dict{String,Float64}
    measurements::Dict{String,Float64}
end
PB.reserved_fields(::Type{NoiseResult}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2, 4])
PB.default_values(::Type{NoiseResult}) = (;analysis_name = "", signals = Vector{String}(), data = Vector{Float64}(), integrated_noise = Dict{String,Float64}(), measurements = Dict{String,Float64}())
PB.field_numbers(::Type{NoiseResult}) = (;analysis_name = 1, signals = 3, data = 5, integrated_noise = 10, measurements = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NoiseResult})
    analysis_name = ""
    signals = PB.BufferedVector{String}()
    data = PB.BufferedVector{Float64}()
    integrated_noise = Dict{String,Float64}()
    measurements = Dict{String,Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, signals)
        elseif field_number == 5
            PB.decode!(d, wire_type, data)
        elseif field_number == 10
            PB.decode!(d, integrated_noise)
        elseif field_number == 11
            PB.decode!(d, measurements)
        else
            PB.skip(d, wire_type)
        end
    end
    return NoiseResult(analysis_name, signals[], data[], integrated_noise, measurements)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NoiseResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.signals) && PB.encode(e, 3, x.signals)
    !isempty(x.data) && PB.encode(e, 5, x.data)
    !isempty(x.integrated_noise) && PB.encode(e, 10, x.integrated_noise)
    !isempty(x.measurements) && PB.encode(e, 11, x.measurements)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NoiseResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 3))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 5))
    !isempty(x.integrated_noise) && (encoded_size += PB._encoded_size(x.integrated_noise, 10))
    !isempty(x.measurements) && (encoded_size += PB._encoded_size(x.measurements, 11))
    return encoded_size
end

@enumx var"Save.SaveMode" NONE=0 ALL=1

struct DcResult
    analysis_name::String
    indep_name::String
    signals::Vector{String}
    data::Vector{Float64}
    measurements::Dict{String,Float64}
end
PB.reserved_fields(::Type{DcResult}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.default_values(::Type{DcResult}) = (;analysis_name = "", indep_name = "", signals = Vector{String}(), data = Vector{Float64}(), measurements = Dict{String,Float64}())
PB.field_numbers(::Type{DcResult}) = (;analysis_name = 1, indep_name = 2, signals = 3, data = 5, measurements = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DcResult})
    analysis_name = ""
    indep_name = ""
    signals = PB.BufferedVector{String}()
    data = PB.BufferedVector{Float64}()
    measurements = Dict{String,Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            indep_name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, signals)
        elseif field_number == 5
            PB.decode!(d, wire_type, data)
        elseif field_number == 10
            PB.decode!(d, measurements)
        else
            PB.skip(d, wire_type)
        end
    end
    return DcResult(analysis_name, indep_name, signals[], data[], measurements)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DcResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.indep_name) && PB.encode(e, 2, x.indep_name)
    !isempty(x.signals) && PB.encode(e, 3, x.signals)
    !isempty(x.data) && PB.encode(e, 5, x.data)
    !isempty(x.measurements) && PB.encode(e, 10, x.measurements)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DcResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.indep_name) && (encoded_size += PB._encoded_size(x.indep_name, 2))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 3))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 5))
    !isempty(x.measurements) && (encoded_size += PB._encoded_size(x.measurements, 10))
    return encoded_size
end

struct ComplexNum
    re::Float64
    im::Float64
end
PB.default_values(::Type{ComplexNum}) = (;re = zero(Float64), im = zero(Float64))
PB.field_numbers(::Type{ComplexNum}) = (;re = 1, im = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ComplexNum})
    re = zero(Float64)
    im = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            re = PB.decode(d, Float64)
        elseif field_number == 2
            im = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return ComplexNum(re, im)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ComplexNum)
    initpos = position(e.io)
    x.re != zero(Float64) && PB.encode(e, 1, x.re)
    x.im != zero(Float64) && PB.encode(e, 2, x.im)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ComplexNum)
    encoded_size = 0
    x.re != zero(Float64) && (encoded_size += PB._encoded_size(x.re, 1))
    x.im != zero(Float64) && (encoded_size += PB._encoded_size(x.im, 2))
    return encoded_size
end

@enumx var"Signal.Quantity" VOLTAGE=0 CURRENT=1 NONE=3

struct LinearSweep
    start::Float64
    stop::Float64
    step::Float64
end
PB.default_values(::Type{LinearSweep}) = (;start = zero(Float64), stop = zero(Float64), step = zero(Float64))
PB.field_numbers(::Type{LinearSweep}) = (;start = 1, stop = 2, step = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearSweep})
    start = zero(Float64)
    stop = zero(Float64)
    step = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            start = PB.decode(d, Float64)
        elseif field_number == 2
            stop = PB.decode(d, Float64)
        elseif field_number == 3
            step = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearSweep(start, stop, step)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearSweep)
    initpos = position(e.io)
    x.start != zero(Float64) && PB.encode(e, 1, x.start)
    x.stop != zero(Float64) && PB.encode(e, 2, x.stop)
    x.step != zero(Float64) && PB.encode(e, 3, x.step)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearSweep)
    encoded_size = 0
    x.start != zero(Float64) && (encoded_size += PB._encoded_size(x.start, 1))
    x.stop != zero(Float64) && (encoded_size += PB._encoded_size(x.stop, 2))
    x.step != zero(Float64) && (encoded_size += PB._encoded_size(x.step, 3))
    return encoded_size
end

struct OpResult
    analysis_name::String
    signals::Vector{String}
    data::Vector{Float64}
end
PB.reserved_fields(::Type{OpResult}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2, 4])
PB.default_values(::Type{OpResult}) = (;analysis_name = "", signals = Vector{String}(), data = Vector{Float64}())
PB.field_numbers(::Type{OpResult}) = (;analysis_name = 1, signals = 3, data = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpResult})
    analysis_name = ""
    signals = PB.BufferedVector{String}()
    data = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, signals)
        elseif field_number == 5
            PB.decode!(d, wire_type, data)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpResult(analysis_name, signals[], data[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.signals) && PB.encode(e, 3, x.signals)
    !isempty(x.data) && PB.encode(e, 5, x.data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 3))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 5))
    return encoded_size
end

struct Meas
    analysis_type::String
    name::String
    expr::String
end
PB.default_values(::Type{Meas}) = (;analysis_type = "", name = "", expr = "")
PB.field_numbers(::Type{Meas}) = (;analysis_type = 1, name = 2, expr = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Meas})
    analysis_type = ""
    name = ""
    expr = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_type = PB.decode(d, String)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            expr = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Meas(analysis_type, name, expr)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Meas)
    initpos = position(e.io)
    !isempty(x.analysis_type) && PB.encode(e, 1, x.analysis_type)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.expr) && PB.encode(e, 3, x.expr)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Meas)
    encoded_size = 0
    !isempty(x.analysis_type) && (encoded_size += PB._encoded_size(x.analysis_type, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.expr) && (encoded_size += PB._encoded_size(x.expr, 3))
    return encoded_size
end

struct Include
    path::String
end
PB.default_values(::Type{Include}) = (;path = "")
PB.field_numbers(::Type{Include}) = (;path = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Include})
    path = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            path = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Include(path)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Include)
    initpos = position(e.io)
    !isempty(x.path) && PB.encode(e, 1, x.path)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Include)
    encoded_size = 0
    !isempty(x.path) && (encoded_size += PB._encoded_size(x.path, 1))
    return encoded_size
end

struct Save
    save::Union{Nothing,OneOf{<:Union{var"Save.SaveMode".T,String}}}
end
PB.oneof_field_types(::Type{Save}) = (;
    save = (;mode=var"Save.SaveMode".T, signal=String),
)
PB.default_values(::Type{Save}) = (;mode = var"Save.SaveMode".NONE, signal = "")
PB.field_numbers(::Type{Save}) = (;mode = 1, signal = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Save})
    save = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            save = OneOf(:mode, PB.decode(d, var"Save.SaveMode".T))
        elseif field_number == 2
            save = OneOf(:signal, PB.decode(d, String))
        else
            PB.skip(d, wire_type)
        end
    end
    return Save(save)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Save)
    initpos = position(e.io)
    if isnothing(x.save);
    elseif x.save.name === :mode
        PB.encode(e, 1, x.save[]::var"Save.SaveMode".T)
    elseif x.save.name === :signal
        PB.encode(e, 2, x.save[]::String)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Save)
    encoded_size = 0
    if isnothing(x.save);
    elseif x.save.name === :mode
        encoded_size += PB._encoded_size(x.save[]::var"Save.SaveMode".T, 1)
    elseif x.save.name === :signal
        encoded_size += PB._encoded_size(x.save[]::String, 2)
    end
    return encoded_size
end

struct AcResult
    analysis_name::String
    freq::Vector{Float64}
    signals::Vector{String}
    data::Vector{ComplexNum}
    measurements::Dict{String,Float64}
end
PB.reserved_fields(::Type{AcResult}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.default_values(::Type{AcResult}) = (;analysis_name = "", freq = Vector{Float64}(), signals = Vector{String}(), data = Vector{ComplexNum}(), measurements = Dict{String,Float64}())
PB.field_numbers(::Type{AcResult}) = (;analysis_name = 1, freq = 2, signals = 3, data = 5, measurements = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AcResult})
    analysis_name = ""
    freq = PB.BufferedVector{Float64}()
    signals = PB.BufferedVector{String}()
    data = PB.BufferedVector{ComplexNum}()
    measurements = Dict{String,Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, freq)
        elseif field_number == 3
            PB.decode!(d, signals)
        elseif field_number == 5
            PB.decode!(d, data)
        elseif field_number == 10
            PB.decode!(d, measurements)
        else
            PB.skip(d, wire_type)
        end
    end
    return AcResult(analysis_name, freq[], signals[], data[], measurements)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AcResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.freq) && PB.encode(e, 2, x.freq)
    !isempty(x.signals) && PB.encode(e, 3, x.signals)
    !isempty(x.data) && PB.encode(e, 5, x.data)
    !isempty(x.measurements) && PB.encode(e, 10, x.measurements)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AcResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.freq) && (encoded_size += PB._encoded_size(x.freq, 2))
    !isempty(x.signals) && (encoded_size += PB._encoded_size(x.signals, 3))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 5))
    !isempty(x.measurements) && (encoded_size += PB._encoded_size(x.measurements, 10))
    return encoded_size
end

struct Signal
    name::String
    quantity::var"Signal.Quantity".T
end
PB.default_values(::Type{Signal}) = (;name = "", quantity = var"Signal.Quantity".VOLTAGE)
PB.field_numbers(::Type{Signal}) = (;name = 1, quantity = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Signal})
    name = ""
    quantity = var"Signal.Quantity".VOLTAGE
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            quantity = PB.decode(d, var"Signal.Quantity".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return Signal(name, quantity)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Signal)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.quantity != var"Signal.Quantity".VOLTAGE && PB.encode(e, 2, x.quantity)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Signal)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.quantity != var"Signal.Quantity".VOLTAGE && (encoded_size += PB._encoded_size(x.quantity, 2))
    return encoded_size
end

struct Sweep
    tp::Union{Nothing,OneOf{<:Union{LinearSweep,LogSweep,PointSweep}}}
end
PB.oneof_field_types(::Type{Sweep}) = (;
    tp = (;linear=LinearSweep, log=LogSweep, points=PointSweep),
)
PB.default_values(::Type{Sweep}) = (;linear = nothing, log = nothing, points = nothing)
PB.field_numbers(::Type{Sweep}) = (;linear = 1, log = 2, points = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Sweep})
    tp = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tp = OneOf(:linear, PB.decode(d, Ref{LinearSweep}))
        elseif field_number == 2
            tp = OneOf(:log, PB.decode(d, Ref{LogSweep}))
        elseif field_number == 3
            tp = OneOf(:points, PB.decode(d, Ref{PointSweep}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Sweep(tp)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Sweep)
    initpos = position(e.io)
    if isnothing(x.tp);
    elseif x.tp.name === :linear
        PB.encode(e, 1, x.tp[]::LinearSweep)
    elseif x.tp.name === :log
        PB.encode(e, 2, x.tp[]::LogSweep)
    elseif x.tp.name === :points
        PB.encode(e, 3, x.tp[]::PointSweep)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Sweep)
    encoded_size = 0
    if isnothing(x.tp);
    elseif x.tp.name === :linear
        encoded_size += PB._encoded_size(x.tp[]::LinearSweep, 1)
    elseif x.tp.name === :log
        encoded_size += PB._encoded_size(x.tp[]::LogSweep, 2)
    elseif x.tp.name === :points
        encoded_size += PB._encoded_size(x.tp[]::PointSweep, 3)
    end
    return encoded_size
end

struct Control
    ctrl::Union{Nothing,OneOf{<:Union{Include,LibInclude,Save,Meas,Vlsir.utils.Param,String}}}
end
PB.oneof_field_types(::Type{Control}) = (;
    ctrl = (;include=Include, lib=LibInclude, save=Save, meas=Meas, param=Vlsir.utils.Param, literal=String),
)
PB.default_values(::Type{Control}) = (;include = nothing, lib = nothing, save = nothing, meas = nothing, param = nothing, literal = "")
PB.field_numbers(::Type{Control}) = (;include = 1, lib = 2, save = 5, meas = 6, param = 7, literal = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Control})
    ctrl = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            ctrl = OneOf(:include, PB.decode(d, Ref{Include}))
        elseif field_number == 2
            ctrl = OneOf(:lib, PB.decode(d, Ref{LibInclude}))
        elseif field_number == 5
            ctrl = OneOf(:save, PB.decode(d, Ref{Save}))
        elseif field_number == 6
            ctrl = OneOf(:meas, PB.decode(d, Ref{Meas}))
        elseif field_number == 7
            ctrl = OneOf(:param, PB.decode(d, Ref{Vlsir.utils.Param}))
        elseif field_number == 10
            ctrl = OneOf(:literal, PB.decode(d, String))
        else
            PB.skip(d, wire_type)
        end
    end
    return Control(ctrl)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Control)
    initpos = position(e.io)
    if isnothing(x.ctrl);
    elseif x.ctrl.name === :include
        PB.encode(e, 1, x.ctrl[]::Include)
    elseif x.ctrl.name === :lib
        PB.encode(e, 2, x.ctrl[]::LibInclude)
    elseif x.ctrl.name === :save
        PB.encode(e, 5, x.ctrl[]::Save)
    elseif x.ctrl.name === :meas
        PB.encode(e, 6, x.ctrl[]::Meas)
    elseif x.ctrl.name === :param
        PB.encode(e, 7, x.ctrl[]::Vlsir.utils.Param)
    elseif x.ctrl.name === :literal
        PB.encode(e, 10, x.ctrl[]::String)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Control)
    encoded_size = 0
    if isnothing(x.ctrl);
    elseif x.ctrl.name === :include
        encoded_size += PB._encoded_size(x.ctrl[]::Include, 1)
    elseif x.ctrl.name === :lib
        encoded_size += PB._encoded_size(x.ctrl[]::LibInclude, 2)
    elseif x.ctrl.name === :save
        encoded_size += PB._encoded_size(x.ctrl[]::Save, 5)
    elseif x.ctrl.name === :meas
        encoded_size += PB._encoded_size(x.ctrl[]::Meas, 6)
    elseif x.ctrl.name === :param
        encoded_size += PB._encoded_size(x.ctrl[]::Vlsir.utils.Param, 7)
    elseif x.ctrl.name === :literal
        encoded_size += PB._encoded_size(x.ctrl[]::String, 10)
    end
    return encoded_size
end

struct NoiseInput
    analysis_name::String
    output_p::String
    output_n::String
    input_source::String
    fstart::Float64
    fstop::Float64
    npts::UInt64
    ctrls::Vector{Control}
end
PB.default_values(::Type{NoiseInput}) = (;analysis_name = "", output_p = "", output_n = "", input_source = "", fstart = zero(Float64), fstop = zero(Float64), npts = zero(UInt64), ctrls = Vector{Control}())
PB.field_numbers(::Type{NoiseInput}) = (;analysis_name = 1, output_p = 2, output_n = 3, input_source = 4, fstart = 10, fstop = 11, npts = 12, ctrls = 20)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NoiseInput})
    analysis_name = ""
    output_p = ""
    output_n = ""
    input_source = ""
    fstart = zero(Float64)
    fstop = zero(Float64)
    npts = zero(UInt64)
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            output_p = PB.decode(d, String)
        elseif field_number == 3
            output_n = PB.decode(d, String)
        elseif field_number == 4
            input_source = PB.decode(d, String)
        elseif field_number == 10
            fstart = PB.decode(d, Float64)
        elseif field_number == 11
            fstop = PB.decode(d, Float64)
        elseif field_number == 12
            npts = PB.decode(d, UInt64)
        elseif field_number == 20
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return NoiseInput(analysis_name, output_p, output_n, input_source, fstart, fstop, npts, ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NoiseInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.output_p) && PB.encode(e, 2, x.output_p)
    !isempty(x.output_n) && PB.encode(e, 3, x.output_n)
    !isempty(x.input_source) && PB.encode(e, 4, x.input_source)
    x.fstart != zero(Float64) && PB.encode(e, 10, x.fstart)
    x.fstop != zero(Float64) && PB.encode(e, 11, x.fstop)
    x.npts != zero(UInt64) && PB.encode(e, 12, x.npts)
    !isempty(x.ctrls) && PB.encode(e, 20, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NoiseInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.output_p) && (encoded_size += PB._encoded_size(x.output_p, 2))
    !isempty(x.output_n) && (encoded_size += PB._encoded_size(x.output_n, 3))
    !isempty(x.input_source) && (encoded_size += PB._encoded_size(x.input_source, 4))
    x.fstart != zero(Float64) && (encoded_size += PB._encoded_size(x.fstart, 10))
    x.fstop != zero(Float64) && (encoded_size += PB._encoded_size(x.fstop, 11))
    x.npts != zero(UInt64) && (encoded_size += PB._encoded_size(x.npts, 12))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 20))
    return encoded_size
end

struct TranInput
    analysis_name::String
    tstop::Float64
    tstep::Float64
    ic::Dict{String,Float64}
    ctrls::Vector{Control}
end
PB.default_values(::Type{TranInput}) = (;analysis_name = "", tstop = zero(Float64), tstep = zero(Float64), ic = Dict{String,Float64}(), ctrls = Vector{Control}())
PB.field_numbers(::Type{TranInput}) = (;analysis_name = 1, tstop = 2, tstep = 3, ic = 4, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TranInput})
    analysis_name = ""
    tstop = zero(Float64)
    tstep = zero(Float64)
    ic = Dict{String,Float64}()
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            tstop = PB.decode(d, Float64)
        elseif field_number == 3
            tstep = PB.decode(d, Float64)
        elseif field_number == 4
            PB.decode!(d, ic)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return TranInput(analysis_name, tstop, tstep, ic, ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TranInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    x.tstop != zero(Float64) && PB.encode(e, 2, x.tstop)
    x.tstep != zero(Float64) && PB.encode(e, 3, x.tstep)
    !isempty(x.ic) && PB.encode(e, 4, x.ic)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TranInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    x.tstop != zero(Float64) && (encoded_size += PB._encoded_size(x.tstop, 2))
    x.tstep != zero(Float64) && (encoded_size += PB._encoded_size(x.tstep, 3))
    !isempty(x.ic) && (encoded_size += PB._encoded_size(x.ic, 4))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

struct DcInput
    analysis_name::String
    indep_name::String
    sweep::Union{Nothing,Sweep}
    ctrls::Vector{Control}
end
PB.default_values(::Type{DcInput}) = (;analysis_name = "", indep_name = "", sweep = nothing, ctrls = Vector{Control}())
PB.field_numbers(::Type{DcInput}) = (;analysis_name = 1, indep_name = 2, sweep = 3, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DcInput})
    analysis_name = ""
    indep_name = ""
    sweep = Ref{Union{Nothing,Sweep}}(nothing)
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            indep_name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, sweep)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return DcInput(analysis_name, indep_name, sweep[], ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DcInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.indep_name) && PB.encode(e, 2, x.indep_name)
    !isnothing(x.sweep) && PB.encode(e, 3, x.sweep)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DcInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.indep_name) && (encoded_size += PB._encoded_size(x.indep_name, 2))
    !isnothing(x.sweep) && (encoded_size += PB._encoded_size(x.sweep, 3))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

struct OpInput
    analysis_name::String
    ctrls::Vector{Control}
end
PB.default_values(::Type{OpInput}) = (;analysis_name = "", ctrls = Vector{Control}())
PB.field_numbers(::Type{OpInput}) = (;analysis_name = 1, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpInput})
    analysis_name = ""
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpInput(analysis_name, ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

struct AcInput
    analysis_name::String
    fstart::Float64
    fstop::Float64
    npts::UInt64
    ctrls::Vector{Control}
end
PB.default_values(::Type{AcInput}) = (;analysis_name = "", fstart = zero(Float64), fstop = zero(Float64), npts = zero(UInt64), ctrls = Vector{Control}())
PB.field_numbers(::Type{AcInput}) = (;analysis_name = 1, fstart = 2, fstop = 3, npts = 4, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AcInput})
    analysis_name = ""
    fstart = zero(Float64)
    fstop = zero(Float64)
    npts = zero(UInt64)
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            fstart = PB.decode(d, Float64)
        elseif field_number == 3
            fstop = PB.decode(d, Float64)
        elseif field_number == 4
            npts = PB.decode(d, UInt64)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return AcInput(analysis_name, fstart, fstop, npts, ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AcInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    x.fstart != zero(Float64) && PB.encode(e, 2, x.fstart)
    x.fstop != zero(Float64) && PB.encode(e, 3, x.fstop)
    x.npts != zero(UInt64) && PB.encode(e, 4, x.npts)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AcInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    x.fstart != zero(Float64) && (encoded_size += PB._encoded_size(x.fstart, 2))
    x.fstop != zero(Float64) && (encoded_size += PB._encoded_size(x.fstop, 3))
    x.npts != zero(UInt64) && (encoded_size += PB._encoded_size(x.npts, 4))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

struct CustomAnalysisInput
    analysis_name::String
    cmd::String
    ctrls::Vector{Control}
end
PB.default_values(::Type{CustomAnalysisInput}) = (;analysis_name = "", cmd = "", ctrls = Vector{Control}())
PB.field_numbers(::Type{CustomAnalysisInput}) = (;analysis_name = 1, cmd = 2, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CustomAnalysisInput})
    analysis_name = ""
    cmd = ""
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            cmd = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return CustomAnalysisInput(analysis_name, cmd, ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CustomAnalysisInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.cmd) && PB.encode(e, 2, x.cmd)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CustomAnalysisInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.cmd) && (encoded_size += PB._encoded_size(x.cmd, 2))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

# TODO: SERVICE
#    Spice

struct SweepResult{T1<:Union{Nothing,var"##AbstractAnalysisResult"}} <: var"##AbstractSweepResult"
    analysis_name::String
    variable::String
    sweep::Union{Nothing,Sweep}
    an::Vector{T1}
end
PB.default_values(::Type{SweepResult}) = (;analysis_name = "", variable = "", sweep = nothing, an = Vector{AnalysisResult}())
PB.field_numbers(::Type{SweepResult}) = (;analysis_name = 1, variable = 2, sweep = 3, an = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SweepResult})
    analysis_name = ""
    variable = ""
    sweep = Ref{Union{Nothing,Sweep}}(nothing)
    an = PB.BufferedVector{AnalysisResult}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            variable = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, sweep)
        elseif field_number == 4
            PB.decode!(d, an)
        else
            PB.skip(d, wire_type)
        end
    end
    return SweepResult(analysis_name, variable, sweep[], an[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SweepResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.variable) && PB.encode(e, 2, x.variable)
    !isnothing(x.sweep) && PB.encode(e, 3, x.sweep)
    !isempty(x.an) && PB.encode(e, 4, x.an)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SweepResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.variable) && (encoded_size += PB._encoded_size(x.variable, 2))
    !isnothing(x.sweep) && (encoded_size += PB._encoded_size(x.sweep, 3))
    !isempty(x.an) && (encoded_size += PB._encoded_size(x.an, 4))
    return encoded_size
end

struct MonteResult{T1<:Union{Nothing,var"##AbstractAnalysisResult"}} <: var"##AbstractMonteResult"
    analysis_name::String
    variable::String
    sweep::Union{Nothing,Sweep}
    an::Vector{T1}
end
PB.default_values(::Type{MonteResult}) = (;analysis_name = "", variable = "", sweep = nothing, an = Vector{AnalysisResult}())
PB.field_numbers(::Type{MonteResult}) = (;analysis_name = 1, variable = 2, sweep = 3, an = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MonteResult})
    analysis_name = ""
    variable = ""
    sweep = Ref{Union{Nothing,Sweep}}(nothing)
    an = PB.BufferedVector{AnalysisResult}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            variable = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, sweep)
        elseif field_number == 4
            PB.decode!(d, an)
        else
            PB.skip(d, wire_type)
        end
    end
    return MonteResult(analysis_name, variable, sweep[], an[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MonteResult)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.variable) && PB.encode(e, 2, x.variable)
    !isnothing(x.sweep) && PB.encode(e, 3, x.sweep)
    !isempty(x.an) && PB.encode(e, 4, x.an)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MonteResult)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.variable) && (encoded_size += PB._encoded_size(x.variable, 2))
    !isnothing(x.sweep) && (encoded_size += PB._encoded_size(x.sweep, 3))
    !isempty(x.an) && (encoded_size += PB._encoded_size(x.an, 4))
    return encoded_size
end

struct SweepInput{T1<:Union{Nothing,var"##AbstractAnalysis"}} <: var"##AbstractSweepInput"
    analysis_name::String
    variable::String
    sweep::Union{Nothing,Sweep}
    an::Vector{T1}
    ctrls::Vector{Control}
end
PB.default_values(::Type{SweepInput}) = (;analysis_name = "", variable = "", sweep = nothing, an = Vector{Analysis}(), ctrls = Vector{Control}())
PB.field_numbers(::Type{SweepInput}) = (;analysis_name = 1, variable = 2, sweep = 3, an = 4, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SweepInput})
    analysis_name = ""
    variable = ""
    sweep = Ref{Union{Nothing,Sweep}}(nothing)
    an = PB.BufferedVector{Analysis}()
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            variable = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, sweep)
        elseif field_number == 4
            PB.decode!(d, an)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return SweepInput(analysis_name, variable, sweep[], an[], ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SweepInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    !isempty(x.variable) && PB.encode(e, 2, x.variable)
    !isnothing(x.sweep) && PB.encode(e, 3, x.sweep)
    !isempty(x.an) && PB.encode(e, 4, x.an)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SweepInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    !isempty(x.variable) && (encoded_size += PB._encoded_size(x.variable, 2))
    !isnothing(x.sweep) && (encoded_size += PB._encoded_size(x.sweep, 3))
    !isempty(x.an) && (encoded_size += PB._encoded_size(x.an, 4))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

struct MonteInput{T1<:Union{Nothing,var"##AbstractAnalysis"}} <: var"##AbstractMonteInput"
    analysis_name::String
    npts::Int64
    seed::Int64
    an::Vector{T1}
    ctrls::Vector{Control}
end
PB.default_values(::Type{MonteInput}) = (;analysis_name = "", npts = zero(Int64), seed = zero(Int64), an = Vector{Analysis}(), ctrls = Vector{Control}())
PB.field_numbers(::Type{MonteInput}) = (;analysis_name = 1, npts = 2, seed = 3, an = 4, ctrls = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MonteInput})
    analysis_name = ""
    npts = zero(Int64)
    seed = zero(Int64)
    an = PB.BufferedVector{Analysis}()
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            analysis_name = PB.decode(d, String)
        elseif field_number == 2
            npts = PB.decode(d, Int64)
        elseif field_number == 3
            seed = PB.decode(d, Int64)
        elseif field_number == 4
            PB.decode!(d, an)
        elseif field_number == 5
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return MonteInput(analysis_name, npts, seed, an[], ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MonteInput)
    initpos = position(e.io)
    !isempty(x.analysis_name) && PB.encode(e, 1, x.analysis_name)
    x.npts != zero(Int64) && PB.encode(e, 2, x.npts)
    x.seed != zero(Int64) && PB.encode(e, 3, x.seed)
    !isempty(x.an) && PB.encode(e, 4, x.an)
    !isempty(x.ctrls) && PB.encode(e, 5, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MonteInput)
    encoded_size = 0
    !isempty(x.analysis_name) && (encoded_size += PB._encoded_size(x.analysis_name, 1))
    x.npts != zero(Int64) && (encoded_size += PB._encoded_size(x.npts, 2))
    x.seed != zero(Int64) && (encoded_size += PB._encoded_size(x.seed, 3))
    !isempty(x.an) && (encoded_size += PB._encoded_size(x.an, 4))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 5))
    return encoded_size
end

struct SimInput{T1<:Union{Nothing,var"##AbstractAnalysis"}} <: var"##AbstractSimInput"
    pkg::Union{Nothing,Vlsir.circuit.Package}
    top::String
    opts::Vector{SimOptions}
    an::Vector{T1}
    ctrls::Vector{Control}
end
PB.default_values(::Type{SimInput}) = (;pkg = nothing, top = "", opts = Vector{SimOptions}(), an = Vector{Analysis}(), ctrls = Vector{Control}())
PB.field_numbers(::Type{SimInput}) = (;pkg = 1, top = 2, opts = 10, an = 11, ctrls = 12)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimInput})
    pkg = Ref{Union{Nothing,Vlsir.circuit.Package}}(nothing)
    top = ""
    opts = PB.BufferedVector{SimOptions}()
    an = PB.BufferedVector{Analysis}()
    ctrls = PB.BufferedVector{Control}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, pkg)
        elseif field_number == 2
            top = PB.decode(d, String)
        elseif field_number == 10
            PB.decode!(d, opts)
        elseif field_number == 11
            PB.decode!(d, an)
        elseif field_number == 12
            PB.decode!(d, ctrls)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimInput(pkg[], top, opts[], an[], ctrls[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimInput)
    initpos = position(e.io)
    !isnothing(x.pkg) && PB.encode(e, 1, x.pkg)
    !isempty(x.top) && PB.encode(e, 2, x.top)
    !isempty(x.opts) && PB.encode(e, 10, x.opts)
    !isempty(x.an) && PB.encode(e, 11, x.an)
    !isempty(x.ctrls) && PB.encode(e, 12, x.ctrls)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimInput)
    encoded_size = 0
    !isnothing(x.pkg) && (encoded_size += PB._encoded_size(x.pkg, 1))
    !isempty(x.top) && (encoded_size += PB._encoded_size(x.top, 2))
    !isempty(x.opts) && (encoded_size += PB._encoded_size(x.opts, 10))
    !isempty(x.an) && (encoded_size += PB._encoded_size(x.an, 11))
    !isempty(x.ctrls) && (encoded_size += PB._encoded_size(x.ctrls, 12))
    return encoded_size
end

struct AnalysisResult <: var"##AbstractAnalysisResult"
    an::Union{Nothing,OneOf{<:Union{OpResult,DcResult,TranResult,AcResult,NoiseResult,var"##AbstractSweepResult",var"##AbstractMonteResult",CustomAnalysisResult}}}
end
PB.oneof_field_types(::Type{AnalysisResult}) = (;
    an = (;op=OpResult, dc=DcResult, tran=TranResult, ac=AcResult, noise=NoiseResult, sweep=SweepResult, monte=MonteResult, custom=CustomAnalysisResult),
)
PB.default_values(::Type{AnalysisResult}) = (;op = nothing, dc = nothing, tran = nothing, ac = nothing, noise = nothing, sweep = nothing, monte = nothing, custom = nothing)
PB.field_numbers(::Type{AnalysisResult}) = (;op = 1, dc = 2, tran = 3, ac = 4, noise = 5, sweep = 10, monte = 11, custom = 20)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AnalysisResult})
    an = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            an = OneOf(:op, PB.decode(d, Ref{OpResult}))
        elseif field_number == 2
            an = OneOf(:dc, PB.decode(d, Ref{DcResult}))
        elseif field_number == 3
            an = OneOf(:tran, PB.decode(d, Ref{TranResult}))
        elseif field_number == 4
            an = OneOf(:ac, PB.decode(d, Ref{AcResult}))
        elseif field_number == 5
            an = OneOf(:noise, PB.decode(d, Ref{NoiseResult}))
        elseif field_number == 10
            an = OneOf(:sweep, PB.decode(d, Ref{SweepResult}))
        elseif field_number == 11
            an = OneOf(:monte, PB.decode(d, Ref{MonteResult}))
        elseif field_number == 20
            an = OneOf(:custom, PB.decode(d, Ref{CustomAnalysisResult}))
        else
            PB.skip(d, wire_type)
        end
    end
    return AnalysisResult(an)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AnalysisResult)
    initpos = position(e.io)
    if isnothing(x.an);
    elseif x.an.name === :op
        PB.encode(e, 1, x.an[]::OpResult)
    elseif x.an.name === :dc
        PB.encode(e, 2, x.an[]::DcResult)
    elseif x.an.name === :tran
        PB.encode(e, 3, x.an[]::TranResult)
    elseif x.an.name === :ac
        PB.encode(e, 4, x.an[]::AcResult)
    elseif x.an.name === :noise
        PB.encode(e, 5, x.an[]::NoiseResult)
    elseif x.an.name === :sweep
        PB.encode(e, 10, x.an[]::SweepResult)
    elseif x.an.name === :monte
        PB.encode(e, 11, x.an[]::MonteResult)
    elseif x.an.name === :custom
        PB.encode(e, 20, x.an[]::CustomAnalysisResult)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::AnalysisResult)
    encoded_size = 0
    if isnothing(x.an);
    elseif x.an.name === :op
        encoded_size += PB._encoded_size(x.an[]::OpResult, 1)
    elseif x.an.name === :dc
        encoded_size += PB._encoded_size(x.an[]::DcResult, 2)
    elseif x.an.name === :tran
        encoded_size += PB._encoded_size(x.an[]::TranResult, 3)
    elseif x.an.name === :ac
        encoded_size += PB._encoded_size(x.an[]::AcResult, 4)
    elseif x.an.name === :noise
        encoded_size += PB._encoded_size(x.an[]::NoiseResult, 5)
    elseif x.an.name === :sweep
        encoded_size += PB._encoded_size(x.an[]::SweepResult, 10)
    elseif x.an.name === :monte
        encoded_size += PB._encoded_size(x.an[]::MonteResult, 11)
    elseif x.an.name === :custom
        encoded_size += PB._encoded_size(x.an[]::CustomAnalysisResult, 20)
    end
    return encoded_size
end

struct SimResult <: var"##AbstractSimResult"
    an::Vector{<:AnalysisResult}
end
PB.default_values(::Type{SimResult}) = (;an = Vector{AnalysisResult}())
PB.field_numbers(::Type{SimResult}) = (;an = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimResult})
    an = PB.BufferedVector{AnalysisResult}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, an)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimResult(an[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimResult)
    initpos = position(e.io)
    !isempty(x.an) && PB.encode(e, 1, x.an)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimResult)
    encoded_size = 0
    !isempty(x.an) && (encoded_size += PB._encoded_size(x.an, 1))
    return encoded_size
end

struct Analysis <: var"##AbstractAnalysis"
    an::Union{Nothing,OneOf{<:Union{OpInput,DcInput,TranInput,AcInput,NoiseInput,var"##AbstractSweepInput",var"##AbstractMonteInput",CustomAnalysisInput}}}
end
PB.oneof_field_types(::Type{Analysis}) = (;
    an = (;op=OpInput, dc=DcInput, tran=TranInput, ac=AcInput, noise=NoiseInput, sweep=SweepInput, monte=MonteInput, custom=CustomAnalysisInput),
)
PB.default_values(::Type{Analysis}) = (;op = nothing, dc = nothing, tran = nothing, ac = nothing, noise = nothing, sweep = nothing, monte = nothing, custom = nothing)
PB.field_numbers(::Type{Analysis}) = (;op = 1, dc = 2, tran = 3, ac = 4, noise = 5, sweep = 10, monte = 11, custom = 20)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Analysis})
    an = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            an = OneOf(:op, PB.decode(d, Ref{OpInput}))
        elseif field_number == 2
            an = OneOf(:dc, PB.decode(d, Ref{DcInput}))
        elseif field_number == 3
            an = OneOf(:tran, PB.decode(d, Ref{TranInput}))
        elseif field_number == 4
            an = OneOf(:ac, PB.decode(d, Ref{AcInput}))
        elseif field_number == 5
            an = OneOf(:noise, PB.decode(d, Ref{NoiseInput}))
        elseif field_number == 10
            an = OneOf(:sweep, PB.decode(d, Ref{SweepInput}))
        elseif field_number == 11
            an = OneOf(:monte, PB.decode(d, Ref{MonteInput}))
        elseif field_number == 20
            an = OneOf(:custom, PB.decode(d, Ref{CustomAnalysisInput}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Analysis(an)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Analysis)
    initpos = position(e.io)
    if isnothing(x.an);
    elseif x.an.name === :op
        PB.encode(e, 1, x.an[]::OpInput)
    elseif x.an.name === :dc
        PB.encode(e, 2, x.an[]::DcInput)
    elseif x.an.name === :tran
        PB.encode(e, 3, x.an[]::TranInput)
    elseif x.an.name === :ac
        PB.encode(e, 4, x.an[]::AcInput)
    elseif x.an.name === :noise
        PB.encode(e, 5, x.an[]::NoiseInput)
    elseif x.an.name === :sweep
        PB.encode(e, 10, x.an[]::SweepInput)
    elseif x.an.name === :monte
        PB.encode(e, 11, x.an[]::MonteInput)
    elseif x.an.name === :custom
        PB.encode(e, 20, x.an[]::CustomAnalysisInput)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Analysis)
    encoded_size = 0
    if isnothing(x.an);
    elseif x.an.name === :op
        encoded_size += PB._encoded_size(x.an[]::OpInput, 1)
    elseif x.an.name === :dc
        encoded_size += PB._encoded_size(x.an[]::DcInput, 2)
    elseif x.an.name === :tran
        encoded_size += PB._encoded_size(x.an[]::TranInput, 3)
    elseif x.an.name === :ac
        encoded_size += PB._encoded_size(x.an[]::AcInput, 4)
    elseif x.an.name === :noise
        encoded_size += PB._encoded_size(x.an[]::NoiseInput, 5)
    elseif x.an.name === :sweep
        encoded_size += PB._encoded_size(x.an[]::SweepInput, 10)
    elseif x.an.name === :monte
        encoded_size += PB._encoded_size(x.an[]::MonteInput, 11)
    elseif x.an.name === :custom
        encoded_size += PB._encoded_size(x.an[]::CustomAnalysisInput, 20)
    end
    return encoded_size
end
