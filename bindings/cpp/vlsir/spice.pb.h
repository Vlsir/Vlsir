// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spice.proto

#ifndef PROTOBUF_INCLUDED_spice_2eproto
#define PROTOBUF_INCLUDED_spice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
#include "circuit.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_spice_2eproto 

namespace protobuf_spice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[38];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_spice_2eproto
namespace vlsir {
namespace spice {
class AcInput;
class AcInputDefaultTypeInternal;
extern AcInputDefaultTypeInternal _AcInput_default_instance_;
class AcResult;
class AcResultDefaultTypeInternal;
extern AcResultDefaultTypeInternal _AcResult_default_instance_;
class AcResult_MeasurementsEntry_DoNotUse;
class AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _AcResult_MeasurementsEntry_DoNotUse_default_instance_;
class Analysis;
class AnalysisDefaultTypeInternal;
extern AnalysisDefaultTypeInternal _Analysis_default_instance_;
class AnalysisResult;
class AnalysisResultDefaultTypeInternal;
extern AnalysisResultDefaultTypeInternal _AnalysisResult_default_instance_;
class ComplexNum;
class ComplexNumDefaultTypeInternal;
extern ComplexNumDefaultTypeInternal _ComplexNum_default_instance_;
class Control;
class ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class CustomAnalysisInput;
class CustomAnalysisInputDefaultTypeInternal;
extern CustomAnalysisInputDefaultTypeInternal _CustomAnalysisInput_default_instance_;
class CustomAnalysisResult;
class CustomAnalysisResultDefaultTypeInternal;
extern CustomAnalysisResultDefaultTypeInternal _CustomAnalysisResult_default_instance_;
class DcInput;
class DcInputDefaultTypeInternal;
extern DcInputDefaultTypeInternal _DcInput_default_instance_;
class DcResult;
class DcResultDefaultTypeInternal;
extern DcResultDefaultTypeInternal _DcResult_default_instance_;
class DcResult_MeasurementsEntry_DoNotUse;
class DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _DcResult_MeasurementsEntry_DoNotUse_default_instance_;
class Include;
class IncludeDefaultTypeInternal;
extern IncludeDefaultTypeInternal _Include_default_instance_;
class LibInclude;
class LibIncludeDefaultTypeInternal;
extern LibIncludeDefaultTypeInternal _LibInclude_default_instance_;
class LinearSweep;
class LinearSweepDefaultTypeInternal;
extern LinearSweepDefaultTypeInternal _LinearSweep_default_instance_;
class LogSweep;
class LogSweepDefaultTypeInternal;
extern LogSweepDefaultTypeInternal _LogSweep_default_instance_;
class Meas;
class MeasDefaultTypeInternal;
extern MeasDefaultTypeInternal _Meas_default_instance_;
class MonteInput;
class MonteInputDefaultTypeInternal;
extern MonteInputDefaultTypeInternal _MonteInput_default_instance_;
class MonteResult;
class MonteResultDefaultTypeInternal;
extern MonteResultDefaultTypeInternal _MonteResult_default_instance_;
class NoiseInput;
class NoiseInputDefaultTypeInternal;
extern NoiseInputDefaultTypeInternal _NoiseInput_default_instance_;
class NoiseResult;
class NoiseResultDefaultTypeInternal;
extern NoiseResultDefaultTypeInternal _NoiseResult_default_instance_;
class NoiseResult_IntegratedNoiseEntry_DoNotUse;
class NoiseResult_IntegratedNoiseEntry_DoNotUseDefaultTypeInternal;
extern NoiseResult_IntegratedNoiseEntry_DoNotUseDefaultTypeInternal _NoiseResult_IntegratedNoiseEntry_DoNotUse_default_instance_;
class NoiseResult_MeasurementsEntry_DoNotUse;
class NoiseResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern NoiseResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _NoiseResult_MeasurementsEntry_DoNotUse_default_instance_;
class OpInput;
class OpInputDefaultTypeInternal;
extern OpInputDefaultTypeInternal _OpInput_default_instance_;
class OpResult;
class OpResultDefaultTypeInternal;
extern OpResultDefaultTypeInternal _OpResult_default_instance_;
class PointSweep;
class PointSweepDefaultTypeInternal;
extern PointSweepDefaultTypeInternal _PointSweep_default_instance_;
class Save;
class SaveDefaultTypeInternal;
extern SaveDefaultTypeInternal _Save_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class SimInput;
class SimInputDefaultTypeInternal;
extern SimInputDefaultTypeInternal _SimInput_default_instance_;
class SimOptions;
class SimOptionsDefaultTypeInternal;
extern SimOptionsDefaultTypeInternal _SimOptions_default_instance_;
class SimResult;
class SimResultDefaultTypeInternal;
extern SimResultDefaultTypeInternal _SimResult_default_instance_;
class Sweep;
class SweepDefaultTypeInternal;
extern SweepDefaultTypeInternal _Sweep_default_instance_;
class SweepInput;
class SweepInputDefaultTypeInternal;
extern SweepInputDefaultTypeInternal _SweepInput_default_instance_;
class SweepResult;
class SweepResultDefaultTypeInternal;
extern SweepResultDefaultTypeInternal _SweepResult_default_instance_;
class TranInput;
class TranInputDefaultTypeInternal;
extern TranInputDefaultTypeInternal _TranInput_default_instance_;
class TranInput_IcEntry_DoNotUse;
class TranInput_IcEntry_DoNotUseDefaultTypeInternal;
extern TranInput_IcEntry_DoNotUseDefaultTypeInternal _TranInput_IcEntry_DoNotUse_default_instance_;
class TranResult;
class TranResultDefaultTypeInternal;
extern TranResultDefaultTypeInternal _TranResult_default_instance_;
class TranResult_MeasurementsEntry_DoNotUse;
class TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _TranResult_MeasurementsEntry_DoNotUse_default_instance_;
}  // namespace spice
}  // namespace vlsir
namespace google {
namespace protobuf {
template<> ::vlsir::spice::AcInput* Arena::CreateMaybeMessage<::vlsir::spice::AcInput>(Arena*);
template<> ::vlsir::spice::AcResult* Arena::CreateMaybeMessage<::vlsir::spice::AcResult>(Arena*);
template<> ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::Analysis* Arena::CreateMaybeMessage<::vlsir::spice::Analysis>(Arena*);
template<> ::vlsir::spice::AnalysisResult* Arena::CreateMaybeMessage<::vlsir::spice::AnalysisResult>(Arena*);
template<> ::vlsir::spice::ComplexNum* Arena::CreateMaybeMessage<::vlsir::spice::ComplexNum>(Arena*);
template<> ::vlsir::spice::Control* Arena::CreateMaybeMessage<::vlsir::spice::Control>(Arena*);
template<> ::vlsir::spice::CustomAnalysisInput* Arena::CreateMaybeMessage<::vlsir::spice::CustomAnalysisInput>(Arena*);
template<> ::vlsir::spice::CustomAnalysisResult* Arena::CreateMaybeMessage<::vlsir::spice::CustomAnalysisResult>(Arena*);
template<> ::vlsir::spice::DcInput* Arena::CreateMaybeMessage<::vlsir::spice::DcInput>(Arena*);
template<> ::vlsir::spice::DcResult* Arena::CreateMaybeMessage<::vlsir::spice::DcResult>(Arena*);
template<> ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::Include* Arena::CreateMaybeMessage<::vlsir::spice::Include>(Arena*);
template<> ::vlsir::spice::LibInclude* Arena::CreateMaybeMessage<::vlsir::spice::LibInclude>(Arena*);
template<> ::vlsir::spice::LinearSweep* Arena::CreateMaybeMessage<::vlsir::spice::LinearSweep>(Arena*);
template<> ::vlsir::spice::LogSweep* Arena::CreateMaybeMessage<::vlsir::spice::LogSweep>(Arena*);
template<> ::vlsir::spice::Meas* Arena::CreateMaybeMessage<::vlsir::spice::Meas>(Arena*);
template<> ::vlsir::spice::MonteInput* Arena::CreateMaybeMessage<::vlsir::spice::MonteInput>(Arena*);
template<> ::vlsir::spice::MonteResult* Arena::CreateMaybeMessage<::vlsir::spice::MonteResult>(Arena*);
template<> ::vlsir::spice::NoiseInput* Arena::CreateMaybeMessage<::vlsir::spice::NoiseInput>(Arena*);
template<> ::vlsir::spice::NoiseResult* Arena::CreateMaybeMessage<::vlsir::spice::NoiseResult>(Arena*);
template<> ::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::OpInput* Arena::CreateMaybeMessage<::vlsir::spice::OpInput>(Arena*);
template<> ::vlsir::spice::OpResult* Arena::CreateMaybeMessage<::vlsir::spice::OpResult>(Arena*);
template<> ::vlsir::spice::PointSweep* Arena::CreateMaybeMessage<::vlsir::spice::PointSweep>(Arena*);
template<> ::vlsir::spice::Save* Arena::CreateMaybeMessage<::vlsir::spice::Save>(Arena*);
template<> ::vlsir::spice::Signal* Arena::CreateMaybeMessage<::vlsir::spice::Signal>(Arena*);
template<> ::vlsir::spice::SimInput* Arena::CreateMaybeMessage<::vlsir::spice::SimInput>(Arena*);
template<> ::vlsir::spice::SimOptions* Arena::CreateMaybeMessage<::vlsir::spice::SimOptions>(Arena*);
template<> ::vlsir::spice::SimResult* Arena::CreateMaybeMessage<::vlsir::spice::SimResult>(Arena*);
template<> ::vlsir::spice::Sweep* Arena::CreateMaybeMessage<::vlsir::spice::Sweep>(Arena*);
template<> ::vlsir::spice::SweepInput* Arena::CreateMaybeMessage<::vlsir::spice::SweepInput>(Arena*);
template<> ::vlsir::spice::SweepResult* Arena::CreateMaybeMessage<::vlsir::spice::SweepResult>(Arena*);
template<> ::vlsir::spice::TranInput* Arena::CreateMaybeMessage<::vlsir::spice::TranInput>(Arena*);
template<> ::vlsir::spice::TranInput_IcEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::TranInput_IcEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::TranResult* Arena::CreateMaybeMessage<::vlsir::spice::TranResult>(Arena*);
template<> ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vlsir {
namespace spice {

enum Save_SaveMode {
  Save_SaveMode_NONE = 0,
  Save_SaveMode_ALL = 1,
  Save_SaveMode_Save_SaveMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Save_SaveMode_Save_SaveMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Save_SaveMode_IsValid(int value);
const Save_SaveMode Save_SaveMode_SaveMode_MIN = Save_SaveMode_NONE;
const Save_SaveMode Save_SaveMode_SaveMode_MAX = Save_SaveMode_ALL;
const int Save_SaveMode_SaveMode_ARRAYSIZE = Save_SaveMode_SaveMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Save_SaveMode_descriptor();
inline const ::std::string& Save_SaveMode_Name(Save_SaveMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Save_SaveMode_descriptor(), value);
}
inline bool Save_SaveMode_Parse(
    const ::std::string& name, Save_SaveMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Save_SaveMode>(
    Save_SaveMode_descriptor(), name, value);
}
enum Signal_Quantity {
  Signal_Quantity_VOLTAGE = 0,
  Signal_Quantity_CURRENT = 1,
  Signal_Quantity_NONE = 3,
  Signal_Quantity_Signal_Quantity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signal_Quantity_Signal_Quantity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signal_Quantity_IsValid(int value);
const Signal_Quantity Signal_Quantity_Quantity_MIN = Signal_Quantity_VOLTAGE;
const Signal_Quantity Signal_Quantity_Quantity_MAX = Signal_Quantity_NONE;
const int Signal_Quantity_Quantity_ARRAYSIZE = Signal_Quantity_Quantity_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Quantity_descriptor();
inline const ::std::string& Signal_Quantity_Name(Signal_Quantity value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Quantity_descriptor(), value);
}
inline bool Signal_Quantity_Parse(
    const ::std::string& name, Signal_Quantity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Quantity>(
    Signal_Quantity_descriptor(), name, value);
}
// ===================================================================

class SimInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimInput) */ {
 public:
  SimInput();
  virtual ~SimInput();

  SimInput(const SimInput& from);

  inline SimInput& operator=(const SimInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimInput(SimInput&& from) noexcept
    : SimInput() {
    *this = ::std::move(from);
  }

  inline SimInput& operator=(SimInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimInput* internal_default_instance() {
    return reinterpret_cast<const SimInput*>(
               &_SimInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SimInput* other);
  friend void swap(SimInput& a, SimInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimInput* New() const final {
    return CreateMaybeMessage<SimInput>(NULL);
  }

  SimInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimInput& from);
  void MergeFrom(const SimInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.SimOptions opts = 10;
  int opts_size() const;
  void clear_opts();
  static const int kOptsFieldNumber = 10;
  ::vlsir::spice::SimOptions* mutable_opts(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::SimOptions >*
      mutable_opts();
  const ::vlsir::spice::SimOptions& opts(int index) const;
  ::vlsir::spice::SimOptions* add_opts();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::SimOptions >&
      opts() const;

  // repeated .vlsir.spice.Analysis an = 11;
  int an_size() const;
  void clear_an();
  static const int kAnFieldNumber = 11;
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 12;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 12;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string top = 2;
  void clear_top();
  static const int kTopFieldNumber = 2;
  const ::std::string& top() const;
  void set_top(const ::std::string& value);
  #if LANG_CXX11
  void set_top(::std::string&& value);
  #endif
  void set_top(const char* value);
  void set_top(const char* value, size_t size);
  ::std::string* mutable_top();
  ::std::string* release_top();
  void set_allocated_top(::std::string* top);

  // .vlsir.circuit.Package pkg = 1;
  bool has_pkg() const;
  void clear_pkg();
  static const int kPkgFieldNumber = 1;
  private:
  const ::vlsir::circuit::Package& _internal_pkg() const;
  public:
  const ::vlsir::circuit::Package& pkg() const;
  ::vlsir::circuit::Package* release_pkg();
  ::vlsir::circuit::Package* mutable_pkg();
  void set_allocated_pkg(::vlsir::circuit::Package* pkg);

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::SimOptions > opts_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr top_;
  ::vlsir::circuit::Package* pkg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimResult) */ {
 public:
  SimResult();
  virtual ~SimResult();

  SimResult(const SimResult& from);

  inline SimResult& operator=(const SimResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimResult(SimResult&& from) noexcept
    : SimResult() {
    *this = ::std::move(from);
  }

  inline SimResult& operator=(SimResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimResult* internal_default_instance() {
    return reinterpret_cast<const SimResult*>(
               &_SimResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SimResult* other);
  friend void swap(SimResult& a, SimResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimResult* New() const final {
    return CreateMaybeMessage<SimResult>(NULL);
  }

  SimResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimResult& from);
  void MergeFrom(const SimResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.AnalysisResult an = 1;
  int an_size() const;
  void clear_an();
  static const int kAnFieldNumber = 1;
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimOptions) */ {
 public:
  SimOptions();
  virtual ~SimOptions();

  SimOptions(const SimOptions& from);

  inline SimOptions& operator=(const SimOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimOptions(SimOptions&& from) noexcept
    : SimOptions() {
    *this = ::std::move(from);
  }

  inline SimOptions& operator=(SimOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimOptions* internal_default_instance() {
    return reinterpret_cast<const SimOptions*>(
               &_SimOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SimOptions* other);
  friend void swap(SimOptions& a, SimOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimOptions* New() const final {
    return CreateMaybeMessage<SimOptions>(NULL);
  }

  SimOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimOptions& from);
  void MergeFrom(const SimOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double temp = 1;
  void clear_temp();
  static const int kTempFieldNumber = 1;
  double temp() const;
  void set_temp(double value);

  // double tnom = 2;
  void clear_tnom();
  static const int kTnomFieldNumber = 2;
  double tnom() const;
  void set_tnom(double value);

  // double gmin = 3;
  void clear_gmin();
  static const int kGminFieldNumber = 3;
  double gmin() const;
  void set_gmin(double value);

  // double iabstol = 4;
  void clear_iabstol();
  static const int kIabstolFieldNumber = 4;
  double iabstol() const;
  void set_iabstol(double value);

  // double reltol = 5;
  void clear_reltol();
  static const int kReltolFieldNumber = 5;
  double reltol() const;
  void set_reltol(double value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double temp_;
  double tnom_;
  double gmin_;
  double iabstol_;
  double reltol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Analysis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Analysis) */ {
 public:
  Analysis();
  virtual ~Analysis();

  Analysis(const Analysis& from);

  inline Analysis& operator=(const Analysis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Analysis(Analysis&& from) noexcept
    : Analysis() {
    *this = ::std::move(from);
  }

  inline Analysis& operator=(Analysis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Analysis& default_instance();

  enum AnCase {
    kOp = 1,
    kDc = 2,
    kTran = 3,
    kAc = 4,
    kNoise = 5,
    kSweep = 10,
    kMonte = 11,
    kCustom = 20,
    AN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Analysis* internal_default_instance() {
    return reinterpret_cast<const Analysis*>(
               &_Analysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Analysis* other);
  friend void swap(Analysis& a, Analysis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Analysis* New() const final {
    return CreateMaybeMessage<Analysis>(NULL);
  }

  Analysis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Analysis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Analysis& from);
  void MergeFrom(const Analysis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Analysis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vlsir.spice.OpInput op = 1;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 1;
  private:
  const ::vlsir::spice::OpInput& _internal_op() const;
  public:
  const ::vlsir::spice::OpInput& op() const;
  ::vlsir::spice::OpInput* release_op();
  ::vlsir::spice::OpInput* mutable_op();
  void set_allocated_op(::vlsir::spice::OpInput* op);

  // .vlsir.spice.DcInput dc = 2;
  bool has_dc() const;
  void clear_dc();
  static const int kDcFieldNumber = 2;
  private:
  const ::vlsir::spice::DcInput& _internal_dc() const;
  public:
  const ::vlsir::spice::DcInput& dc() const;
  ::vlsir::spice::DcInput* release_dc();
  ::vlsir::spice::DcInput* mutable_dc();
  void set_allocated_dc(::vlsir::spice::DcInput* dc);

  // .vlsir.spice.TranInput tran = 3;
  bool has_tran() const;
  void clear_tran();
  static const int kTranFieldNumber = 3;
  private:
  const ::vlsir::spice::TranInput& _internal_tran() const;
  public:
  const ::vlsir::spice::TranInput& tran() const;
  ::vlsir::spice::TranInput* release_tran();
  ::vlsir::spice::TranInput* mutable_tran();
  void set_allocated_tran(::vlsir::spice::TranInput* tran);

  // .vlsir.spice.AcInput ac = 4;
  bool has_ac() const;
  void clear_ac();
  static const int kAcFieldNumber = 4;
  private:
  const ::vlsir::spice::AcInput& _internal_ac() const;
  public:
  const ::vlsir::spice::AcInput& ac() const;
  ::vlsir::spice::AcInput* release_ac();
  ::vlsir::spice::AcInput* mutable_ac();
  void set_allocated_ac(::vlsir::spice::AcInput* ac);

  // .vlsir.spice.NoiseInput noise = 5;
  bool has_noise() const;
  void clear_noise();
  static const int kNoiseFieldNumber = 5;
  private:
  const ::vlsir::spice::NoiseInput& _internal_noise() const;
  public:
  const ::vlsir::spice::NoiseInput& noise() const;
  ::vlsir::spice::NoiseInput* release_noise();
  ::vlsir::spice::NoiseInput* mutable_noise();
  void set_allocated_noise(::vlsir::spice::NoiseInput* noise);

  // .vlsir.spice.SweepInput sweep = 10;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 10;
  private:
  const ::vlsir::spice::SweepInput& _internal_sweep() const;
  public:
  const ::vlsir::spice::SweepInput& sweep() const;
  ::vlsir::spice::SweepInput* release_sweep();
  ::vlsir::spice::SweepInput* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::SweepInput* sweep);

  // .vlsir.spice.MonteInput monte = 11;
  bool has_monte() const;
  void clear_monte();
  static const int kMonteFieldNumber = 11;
  private:
  const ::vlsir::spice::MonteInput& _internal_monte() const;
  public:
  const ::vlsir::spice::MonteInput& monte() const;
  ::vlsir::spice::MonteInput* release_monte();
  ::vlsir::spice::MonteInput* mutable_monte();
  void set_allocated_monte(::vlsir::spice::MonteInput* monte);

  // .vlsir.spice.CustomAnalysisInput custom = 20;
  bool has_custom() const;
  void clear_custom();
  static const int kCustomFieldNumber = 20;
  private:
  const ::vlsir::spice::CustomAnalysisInput& _internal_custom() const;
  public:
  const ::vlsir::spice::CustomAnalysisInput& custom() const;
  ::vlsir::spice::CustomAnalysisInput* release_custom();
  ::vlsir::spice::CustomAnalysisInput* mutable_custom();
  void set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom);

  void clear_an();
  AnCase an_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Analysis)
 private:
  void set_has_op();
  void set_has_dc();
  void set_has_tran();
  void set_has_ac();
  void set_has_noise();
  void set_has_sweep();
  void set_has_monte();
  void set_has_custom();

  inline bool has_an() const;
  inline void clear_has_an();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union AnUnion {
    AnUnion() {}
    ::vlsir::spice::OpInput* op_;
    ::vlsir::spice::DcInput* dc_;
    ::vlsir::spice::TranInput* tran_;
    ::vlsir::spice::AcInput* ac_;
    ::vlsir::spice::NoiseInput* noise_;
    ::vlsir::spice::SweepInput* sweep_;
    ::vlsir::spice::MonteInput* monte_;
    ::vlsir::spice::CustomAnalysisInput* custom_;
  } an_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnalysisResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AnalysisResult) */ {
 public:
  AnalysisResult();
  virtual ~AnalysisResult();

  AnalysisResult(const AnalysisResult& from);

  inline AnalysisResult& operator=(const AnalysisResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalysisResult(AnalysisResult&& from) noexcept
    : AnalysisResult() {
    *this = ::std::move(from);
  }

  inline AnalysisResult& operator=(AnalysisResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisResult& default_instance();

  enum AnCase {
    kOp = 1,
    kDc = 2,
    kTran = 3,
    kAc = 4,
    kNoise = 5,
    kSweep = 10,
    kMonte = 11,
    kCustom = 20,
    AN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalysisResult* internal_default_instance() {
    return reinterpret_cast<const AnalysisResult*>(
               &_AnalysisResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AnalysisResult* other);
  friend void swap(AnalysisResult& a, AnalysisResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalysisResult* New() const final {
    return CreateMaybeMessage<AnalysisResult>(NULL);
  }

  AnalysisResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalysisResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalysisResult& from);
  void MergeFrom(const AnalysisResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vlsir.spice.OpResult op = 1;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 1;
  private:
  const ::vlsir::spice::OpResult& _internal_op() const;
  public:
  const ::vlsir::spice::OpResult& op() const;
  ::vlsir::spice::OpResult* release_op();
  ::vlsir::spice::OpResult* mutable_op();
  void set_allocated_op(::vlsir::spice::OpResult* op);

  // .vlsir.spice.DcResult dc = 2;
  bool has_dc() const;
  void clear_dc();
  static const int kDcFieldNumber = 2;
  private:
  const ::vlsir::spice::DcResult& _internal_dc() const;
  public:
  const ::vlsir::spice::DcResult& dc() const;
  ::vlsir::spice::DcResult* release_dc();
  ::vlsir::spice::DcResult* mutable_dc();
  void set_allocated_dc(::vlsir::spice::DcResult* dc);

  // .vlsir.spice.TranResult tran = 3;
  bool has_tran() const;
  void clear_tran();
  static const int kTranFieldNumber = 3;
  private:
  const ::vlsir::spice::TranResult& _internal_tran() const;
  public:
  const ::vlsir::spice::TranResult& tran() const;
  ::vlsir::spice::TranResult* release_tran();
  ::vlsir::spice::TranResult* mutable_tran();
  void set_allocated_tran(::vlsir::spice::TranResult* tran);

  // .vlsir.spice.AcResult ac = 4;
  bool has_ac() const;
  void clear_ac();
  static const int kAcFieldNumber = 4;
  private:
  const ::vlsir::spice::AcResult& _internal_ac() const;
  public:
  const ::vlsir::spice::AcResult& ac() const;
  ::vlsir::spice::AcResult* release_ac();
  ::vlsir::spice::AcResult* mutable_ac();
  void set_allocated_ac(::vlsir::spice::AcResult* ac);

  // .vlsir.spice.NoiseResult noise = 5;
  bool has_noise() const;
  void clear_noise();
  static const int kNoiseFieldNumber = 5;
  private:
  const ::vlsir::spice::NoiseResult& _internal_noise() const;
  public:
  const ::vlsir::spice::NoiseResult& noise() const;
  ::vlsir::spice::NoiseResult* release_noise();
  ::vlsir::spice::NoiseResult* mutable_noise();
  void set_allocated_noise(::vlsir::spice::NoiseResult* noise);

  // .vlsir.spice.SweepResult sweep = 10;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 10;
  private:
  const ::vlsir::spice::SweepResult& _internal_sweep() const;
  public:
  const ::vlsir::spice::SweepResult& sweep() const;
  ::vlsir::spice::SweepResult* release_sweep();
  ::vlsir::spice::SweepResult* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::SweepResult* sweep);

  // .vlsir.spice.MonteResult monte = 11;
  bool has_monte() const;
  void clear_monte();
  static const int kMonteFieldNumber = 11;
  private:
  const ::vlsir::spice::MonteResult& _internal_monte() const;
  public:
  const ::vlsir::spice::MonteResult& monte() const;
  ::vlsir::spice::MonteResult* release_monte();
  ::vlsir::spice::MonteResult* mutable_monte();
  void set_allocated_monte(::vlsir::spice::MonteResult* monte);

  // .vlsir.spice.CustomAnalysisResult custom = 20;
  bool has_custom() const;
  void clear_custom();
  static const int kCustomFieldNumber = 20;
  private:
  const ::vlsir::spice::CustomAnalysisResult& _internal_custom() const;
  public:
  const ::vlsir::spice::CustomAnalysisResult& custom() const;
  ::vlsir::spice::CustomAnalysisResult* release_custom();
  ::vlsir::spice::CustomAnalysisResult* mutable_custom();
  void set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom);

  void clear_an();
  AnCase an_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.AnalysisResult)
 private:
  void set_has_op();
  void set_has_dc();
  void set_has_tran();
  void set_has_ac();
  void set_has_noise();
  void set_has_sweep();
  void set_has_monte();
  void set_has_custom();

  inline bool has_an() const;
  inline void clear_has_an();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union AnUnion {
    AnUnion() {}
    ::vlsir::spice::OpResult* op_;
    ::vlsir::spice::DcResult* dc_;
    ::vlsir::spice::TranResult* tran_;
    ::vlsir::spice::AcResult* ac_;
    ::vlsir::spice::NoiseResult* noise_;
    ::vlsir::spice::SweepResult* sweep_;
    ::vlsir::spice::MonteResult* monte_;
    ::vlsir::spice::CustomAnalysisResult* custom_;
  } an_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.OpInput) */ {
 public:
  OpInput();
  virtual ~OpInput();

  OpInput(const OpInput& from);

  inline OpInput& operator=(const OpInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpInput(OpInput&& from) noexcept
    : OpInput() {
    *this = ::std::move(from);
  }

  inline OpInput& operator=(OpInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpInput* internal_default_instance() {
    return reinterpret_cast<const OpInput*>(
               &_OpInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OpInput* other);
  friend void swap(OpInput& a, OpInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpInput* New() const final {
    return CreateMaybeMessage<OpInput>(NULL);
  }

  OpInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpInput& from);
  void MergeFrom(const OpInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // @@protoc_insertion_point(class_scope:vlsir.spice.OpInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.OpResult) */ {
 public:
  OpResult();
  virtual ~OpResult();

  OpResult(const OpResult& from);

  inline OpResult& operator=(const OpResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpResult(OpResult&& from) noexcept
    : OpResult() {
    *this = ::std::move(from);
  }

  inline OpResult& operator=(OpResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpResult* internal_default_instance() {
    return reinterpret_cast<const OpResult*>(
               &_OpResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OpResult* other);
  friend void swap(OpResult& a, OpResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpResult* New() const final {
    return CreateMaybeMessage<OpResult>(NULL);
  }

  OpResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpResult& from);
  void MergeFrom(const OpResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string signals = 3;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 3;
  const ::std::string& signals(int index) const;
  ::std::string* mutable_signals(int index);
  void set_signals(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signals(int index, ::std::string&& value);
  #endif
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  ::std::string* add_signals();
  void add_signals(const ::std::string& value);
  #if LANG_CXX11
  void add_signals(::std::string&& value);
  #endif
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signals() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signals();

  // repeated double data = 5;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string raw = 6;
  void clear_raw();
  static const int kRawFieldNumber = 6;
  const ::std::string& raw() const;
  void set_raw(const ::std::string& value);
  #if LANG_CXX11
  void set_raw(::std::string&& value);
  #endif
  void set_raw(const char* value);
  void set_raw(const char* value, size_t size);
  ::std::string* mutable_raw();
  ::std::string* release_raw();
  void set_allocated_raw(::std::string* raw);

  // @@protoc_insertion_point(class_scope:vlsir.spice.OpResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signals_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr raw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DcInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.DcInput) */ {
 public:
  DcInput();
  virtual ~DcInput();

  DcInput(const DcInput& from);

  inline DcInput& operator=(const DcInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DcInput(DcInput&& from) noexcept
    : DcInput() {
    *this = ::std::move(from);
  }

  inline DcInput& operator=(DcInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DcInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DcInput* internal_default_instance() {
    return reinterpret_cast<const DcInput*>(
               &_DcInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DcInput* other);
  friend void swap(DcInput& a, DcInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DcInput* New() const final {
    return CreateMaybeMessage<DcInput>(NULL);
  }

  DcInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DcInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DcInput& from);
  void MergeFrom(const DcInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DcInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string indep_name = 2;
  void clear_indep_name();
  static const int kIndepNameFieldNumber = 2;
  const ::std::string& indep_name() const;
  void set_indep_name(const ::std::string& value);
  #if LANG_CXX11
  void set_indep_name(::std::string&& value);
  #endif
  void set_indep_name(const char* value);
  void set_indep_name(const char* value, size_t size);
  ::std::string* mutable_indep_name();
  ::std::string* release_indep_name();
  void set_allocated_indep_name(::std::string* indep_name);

  // string raw = 6;
  void clear_raw();
  static const int kRawFieldNumber = 6;
  const ::std::string& raw() const;
  void set_raw(const ::std::string& value);
  #if LANG_CXX11
  void set_raw(::std::string&& value);
  #endif
  void set_raw(const char* value);
  void set_raw(const char* value, size_t size);
  ::std::string* mutable_raw();
  ::std::string* release_raw();
  void set_allocated_raw(::std::string* raw);

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 3;
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  public:
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);

  // @@protoc_insertion_point(class_scope:vlsir.spice.DcInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr indep_name_;
  ::google::protobuf::internal::ArenaStringPtr raw_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DcResult_MeasurementsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<DcResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<DcResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  DcResult_MeasurementsEntry_DoNotUse();
  DcResult_MeasurementsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const DcResult_MeasurementsEntry_DoNotUse& other);
  static const DcResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DcResult_MeasurementsEntry_DoNotUse*>(&_DcResult_MeasurementsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class DcResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.DcResult) */ {
 public:
  DcResult();
  virtual ~DcResult();

  DcResult(const DcResult& from);

  inline DcResult& operator=(const DcResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DcResult(DcResult&& from) noexcept
    : DcResult() {
    *this = ::std::move(from);
  }

  inline DcResult& operator=(DcResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DcResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DcResult* internal_default_instance() {
    return reinterpret_cast<const DcResult*>(
               &_DcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DcResult* other);
  friend void swap(DcResult& a, DcResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DcResult* New() const final {
    return CreateMaybeMessage<DcResult>(NULL);
  }

  DcResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DcResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DcResult& from);
  void MergeFrom(const DcResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DcResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string signals = 3;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 3;
  const ::std::string& signals(int index) const;
  ::std::string* mutable_signals(int index);
  void set_signals(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signals(int index, ::std::string&& value);
  #endif
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  ::std::string* add_signals();
  void add_signals(const ::std::string& value);
  #if LANG_CXX11
  void add_signals(::std::string&& value);
  #endif
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signals() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signals();

  // repeated double data = 5;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // map<string, double> measurements = 10;
  int measurements_size() const;
  void clear_measurements();
  static const int kMeasurementsFieldNumber = 10;
  const ::google::protobuf::Map< ::std::string, double >&
      measurements() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string indep_name = 2;
  void clear_indep_name();
  static const int kIndepNameFieldNumber = 2;
  const ::std::string& indep_name() const;
  void set_indep_name(const ::std::string& value);
  #if LANG_CXX11
  void set_indep_name(::std::string&& value);
  #endif
  void set_indep_name(const char* value);
  void set_indep_name(const char* value, size_t size);
  ::std::string* mutable_indep_name();
  ::std::string* release_indep_name();
  void set_allocated_indep_name(::std::string* indep_name);

  // @@protoc_insertion_point(class_scope:vlsir.spice.DcResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signals_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::internal::MapField<
      DcResult_MeasurementsEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr indep_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TranInput_IcEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TranInput_IcEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TranInput_IcEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  TranInput_IcEntry_DoNotUse();
  TranInput_IcEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TranInput_IcEntry_DoNotUse& other);
  static const TranInput_IcEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TranInput_IcEntry_DoNotUse*>(&_TranInput_IcEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TranInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.TranInput) */ {
 public:
  TranInput();
  virtual ~TranInput();

  TranInput(const TranInput& from);

  inline TranInput& operator=(const TranInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TranInput(TranInput&& from) noexcept
    : TranInput() {
    *this = ::std::move(from);
  }

  inline TranInput& operator=(TranInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TranInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TranInput* internal_default_instance() {
    return reinterpret_cast<const TranInput*>(
               &_TranInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(TranInput* other);
  friend void swap(TranInput& a, TranInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TranInput* New() const final {
    return CreateMaybeMessage<TranInput>(NULL);
  }

  TranInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TranInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TranInput& from);
  void MergeFrom(const TranInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, double> ic = 4;
  int ic_size() const;
  void clear_ic();
  static const int kIcFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, double >&
      ic() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_ic();

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string raw = 6;
  void clear_raw();
  static const int kRawFieldNumber = 6;
  const ::std::string& raw() const;
  void set_raw(const ::std::string& value);
  #if LANG_CXX11
  void set_raw(::std::string&& value);
  #endif
  void set_raw(const char* value);
  void set_raw(const char* value, size_t size);
  ::std::string* mutable_raw();
  ::std::string* release_raw();
  void set_allocated_raw(::std::string* raw);

  // double tstop = 2;
  void clear_tstop();
  static const int kTstopFieldNumber = 2;
  double tstop() const;
  void set_tstop(double value);

  // double tstep = 3;
  void clear_tstep();
  static const int kTstepFieldNumber = 3;
  double tstep() const;
  void set_tstep(double value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.TranInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TranInput_IcEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > ic_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr raw_;
  double tstop_;
  double tstep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TranResult_MeasurementsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TranResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TranResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  TranResult_MeasurementsEntry_DoNotUse();
  TranResult_MeasurementsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TranResult_MeasurementsEntry_DoNotUse& other);
  static const TranResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TranResult_MeasurementsEntry_DoNotUse*>(&_TranResult_MeasurementsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TranResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.TranResult) */ {
 public:
  TranResult();
  virtual ~TranResult();

  TranResult(const TranResult& from);

  inline TranResult& operator=(const TranResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TranResult(TranResult&& from) noexcept
    : TranResult() {
    *this = ::std::move(from);
  }

  inline TranResult& operator=(TranResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TranResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TranResult* internal_default_instance() {
    return reinterpret_cast<const TranResult*>(
               &_TranResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TranResult* other);
  friend void swap(TranResult& a, TranResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TranResult* New() const final {
    return CreateMaybeMessage<TranResult>(NULL);
  }

  TranResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TranResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TranResult& from);
  void MergeFrom(const TranResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string signals = 3;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 3;
  const ::std::string& signals(int index) const;
  ::std::string* mutable_signals(int index);
  void set_signals(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signals(int index, ::std::string&& value);
  #endif
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  ::std::string* add_signals();
  void add_signals(const ::std::string& value);
  #if LANG_CXX11
  void add_signals(::std::string&& value);
  #endif
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signals() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signals();

  // repeated double data = 5;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // map<string, double> measurements = 10;
  int measurements_size() const;
  void clear_measurements();
  static const int kMeasurementsFieldNumber = 10;
  const ::google::protobuf::Map< ::std::string, double >&
      measurements() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // @@protoc_insertion_point(class_scope:vlsir.spice.TranResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signals_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::internal::MapField<
      TranResult_MeasurementsEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ComplexNum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.ComplexNum) */ {
 public:
  ComplexNum();
  virtual ~ComplexNum();

  ComplexNum(const ComplexNum& from);

  inline ComplexNum& operator=(const ComplexNum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComplexNum(ComplexNum&& from) noexcept
    : ComplexNum() {
    *this = ::std::move(from);
  }

  inline ComplexNum& operator=(ComplexNum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexNum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComplexNum* internal_default_instance() {
    return reinterpret_cast<const ComplexNum*>(
               &_ComplexNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ComplexNum* other);
  friend void swap(ComplexNum& a, ComplexNum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComplexNum* New() const final {
    return CreateMaybeMessage<ComplexNum>(NULL);
  }

  ComplexNum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ComplexNum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ComplexNum& from);
  void MergeFrom(const ComplexNum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplexNum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double re = 1;
  void clear_re();
  static const int kReFieldNumber = 1;
  double re() const;
  void set_re(double value);

  // double im = 2;
  void clear_im();
  static const int kImFieldNumber = 2;
  double im() const;
  void set_im(double value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.ComplexNum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double re_;
  double im_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AcInput) */ {
 public:
  AcInput();
  virtual ~AcInput();

  AcInput(const AcInput& from);

  inline AcInput& operator=(const AcInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AcInput(AcInput&& from) noexcept
    : AcInput() {
    *this = ::std::move(from);
  }

  inline AcInput& operator=(AcInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AcInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcInput* internal_default_instance() {
    return reinterpret_cast<const AcInput*>(
               &_AcInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(AcInput* other);
  friend void swap(AcInput& a, AcInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcInput* New() const final {
    return CreateMaybeMessage<AcInput>(NULL);
  }

  AcInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AcInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AcInput& from);
  void MergeFrom(const AcInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string raw = 6;
  void clear_raw();
  static const int kRawFieldNumber = 6;
  const ::std::string& raw() const;
  void set_raw(const ::std::string& value);
  #if LANG_CXX11
  void set_raw(::std::string&& value);
  #endif
  void set_raw(const char* value);
  void set_raw(const char* value, size_t size);
  ::std::string* mutable_raw();
  ::std::string* release_raw();
  void set_allocated_raw(::std::string* raw);

  // double fstart = 2;
  void clear_fstart();
  static const int kFstartFieldNumber = 2;
  double fstart() const;
  void set_fstart(double value);

  // double fstop = 3;
  void clear_fstop();
  static const int kFstopFieldNumber = 3;
  double fstop() const;
  void set_fstop(double value);

  // uint64 npts = 4;
  void clear_npts();
  static const int kNptsFieldNumber = 4;
  ::google::protobuf::uint64 npts() const;
  void set_npts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.AcInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr raw_;
  double fstart_;
  double fstop_;
  ::google::protobuf::uint64 npts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcResult_MeasurementsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AcResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<AcResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  AcResult_MeasurementsEntry_DoNotUse();
  AcResult_MeasurementsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AcResult_MeasurementsEntry_DoNotUse& other);
  static const AcResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AcResult_MeasurementsEntry_DoNotUse*>(&_AcResult_MeasurementsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AcResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AcResult) */ {
 public:
  AcResult();
  virtual ~AcResult();

  AcResult(const AcResult& from);

  inline AcResult& operator=(const AcResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AcResult(AcResult&& from) noexcept
    : AcResult() {
    *this = ::std::move(from);
  }

  inline AcResult& operator=(AcResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AcResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcResult* internal_default_instance() {
    return reinterpret_cast<const AcResult*>(
               &_AcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(AcResult* other);
  friend void swap(AcResult& a, AcResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcResult* New() const final {
    return CreateMaybeMessage<AcResult>(NULL);
  }

  AcResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AcResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AcResult& from);
  void MergeFrom(const AcResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated double freq = 2;
  int freq_size() const;
  void clear_freq();
  static const int kFreqFieldNumber = 2;
  double freq(int index) const;
  void set_freq(int index, double value);
  void add_freq(double value);
  const ::google::protobuf::RepeatedField< double >&
      freq() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_freq();

  // repeated string signals = 3;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 3;
  const ::std::string& signals(int index) const;
  ::std::string* mutable_signals(int index);
  void set_signals(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signals(int index, ::std::string&& value);
  #endif
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  ::std::string* add_signals();
  void add_signals(const ::std::string& value);
  #if LANG_CXX11
  void add_signals(::std::string&& value);
  #endif
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signals() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signals();

  // repeated .vlsir.spice.ComplexNum data = 5;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  ::vlsir::spice::ComplexNum* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::ComplexNum >*
      mutable_data();
  const ::vlsir::spice::ComplexNum& data(int index) const;
  ::vlsir::spice::ComplexNum* add_data();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::ComplexNum >&
      data() const;

  // map<string, double> measurements = 10;
  int measurements_size() const;
  void clear_measurements();
  static const int kMeasurementsFieldNumber = 10;
  const ::google::protobuf::Map< ::std::string, double >&
      measurements() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // @@protoc_insertion_point(class_scope:vlsir.spice.AcResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > freq_;
  mutable int _freq_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signals_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::ComplexNum > data_;
  ::google::protobuf::internal::MapField<
      AcResult_MeasurementsEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NoiseInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.NoiseInput) */ {
 public:
  NoiseInput();
  virtual ~NoiseInput();

  NoiseInput(const NoiseInput& from);

  inline NoiseInput& operator=(const NoiseInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NoiseInput(NoiseInput&& from) noexcept
    : NoiseInput() {
    *this = ::std::move(from);
  }

  inline NoiseInput& operator=(NoiseInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoiseInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NoiseInput* internal_default_instance() {
    return reinterpret_cast<const NoiseInput*>(
               &_NoiseInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(NoiseInput* other);
  friend void swap(NoiseInput& a, NoiseInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NoiseInput* New() const final {
    return CreateMaybeMessage<NoiseInput>(NULL);
  }

  NoiseInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NoiseInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NoiseInput& from);
  void MergeFrom(const NoiseInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoiseInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Control ctrls = 20;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 20;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string output_p = 2;
  void clear_output_p();
  static const int kOutputPFieldNumber = 2;
  const ::std::string& output_p() const;
  void set_output_p(const ::std::string& value);
  #if LANG_CXX11
  void set_output_p(::std::string&& value);
  #endif
  void set_output_p(const char* value);
  void set_output_p(const char* value, size_t size);
  ::std::string* mutable_output_p();
  ::std::string* release_output_p();
  void set_allocated_output_p(::std::string* output_p);

  // string output_n = 3;
  void clear_output_n();
  static const int kOutputNFieldNumber = 3;
  const ::std::string& output_n() const;
  void set_output_n(const ::std::string& value);
  #if LANG_CXX11
  void set_output_n(::std::string&& value);
  #endif
  void set_output_n(const char* value);
  void set_output_n(const char* value, size_t size);
  ::std::string* mutable_output_n();
  ::std::string* release_output_n();
  void set_allocated_output_n(::std::string* output_n);

  // string input_source = 4;
  void clear_input_source();
  static const int kInputSourceFieldNumber = 4;
  const ::std::string& input_source() const;
  void set_input_source(const ::std::string& value);
  #if LANG_CXX11
  void set_input_source(::std::string&& value);
  #endif
  void set_input_source(const char* value);
  void set_input_source(const char* value, size_t size);
  ::std::string* mutable_input_source();
  ::std::string* release_input_source();
  void set_allocated_input_source(::std::string* input_source);

  // string raw = 6;
  void clear_raw();
  static const int kRawFieldNumber = 6;
  const ::std::string& raw() const;
  void set_raw(const ::std::string& value);
  #if LANG_CXX11
  void set_raw(::std::string&& value);
  #endif
  void set_raw(const char* value);
  void set_raw(const char* value, size_t size);
  ::std::string* mutable_raw();
  ::std::string* release_raw();
  void set_allocated_raw(::std::string* raw);

  // double fstart = 10;
  void clear_fstart();
  static const int kFstartFieldNumber = 10;
  double fstart() const;
  void set_fstart(double value);

  // double fstop = 11;
  void clear_fstop();
  static const int kFstopFieldNumber = 11;
  double fstop() const;
  void set_fstop(double value);

  // uint64 npts = 12;
  void clear_npts();
  static const int kNptsFieldNumber = 12;
  ::google::protobuf::uint64 npts() const;
  void set_npts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.NoiseInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr output_p_;
  ::google::protobuf::internal::ArenaStringPtr output_n_;
  ::google::protobuf::internal::ArenaStringPtr input_source_;
  ::google::protobuf::internal::ArenaStringPtr raw_;
  double fstart_;
  double fstop_;
  ::google::protobuf::uint64 npts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NoiseResult_IntegratedNoiseEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<NoiseResult_IntegratedNoiseEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<NoiseResult_IntegratedNoiseEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  NoiseResult_IntegratedNoiseEntry_DoNotUse();
  NoiseResult_IntegratedNoiseEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const NoiseResult_IntegratedNoiseEntry_DoNotUse& other);
  static const NoiseResult_IntegratedNoiseEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NoiseResult_IntegratedNoiseEntry_DoNotUse*>(&_NoiseResult_IntegratedNoiseEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class NoiseResult_MeasurementsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<NoiseResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<NoiseResult_MeasurementsEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  NoiseResult_MeasurementsEntry_DoNotUse();
  NoiseResult_MeasurementsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const NoiseResult_MeasurementsEntry_DoNotUse& other);
  static const NoiseResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NoiseResult_MeasurementsEntry_DoNotUse*>(&_NoiseResult_MeasurementsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class NoiseResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.NoiseResult) */ {
 public:
  NoiseResult();
  virtual ~NoiseResult();

  NoiseResult(const NoiseResult& from);

  inline NoiseResult& operator=(const NoiseResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NoiseResult(NoiseResult&& from) noexcept
    : NoiseResult() {
    *this = ::std::move(from);
  }

  inline NoiseResult& operator=(NoiseResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoiseResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NoiseResult* internal_default_instance() {
    return reinterpret_cast<const NoiseResult*>(
               &_NoiseResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(NoiseResult* other);
  friend void swap(NoiseResult& a, NoiseResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NoiseResult* New() const final {
    return CreateMaybeMessage<NoiseResult>(NULL);
  }

  NoiseResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NoiseResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NoiseResult& from);
  void MergeFrom(const NoiseResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoiseResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string signals = 3;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 3;
  const ::std::string& signals(int index) const;
  ::std::string* mutable_signals(int index);
  void set_signals(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signals(int index, ::std::string&& value);
  #endif
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  ::std::string* add_signals();
  void add_signals(const ::std::string& value);
  #if LANG_CXX11
  void add_signals(::std::string&& value);
  #endif
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signals() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signals();

  // repeated double data = 5;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // map<string, double> integrated_noise = 10;
  int integrated_noise_size() const;
  void clear_integrated_noise();
  static const int kIntegratedNoiseFieldNumber = 10;
  const ::google::protobuf::Map< ::std::string, double >&
      integrated_noise() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_integrated_noise();

  // map<string, double> measurements = 11;
  int measurements_size() const;
  void clear_measurements();
  static const int kMeasurementsFieldNumber = 11;
  const ::google::protobuf::Map< ::std::string, double >&
      measurements() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // @@protoc_insertion_point(class_scope:vlsir.spice.NoiseResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signals_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::internal::MapField<
      NoiseResult_IntegratedNoiseEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > integrated_noise_;
  ::google::protobuf::internal::MapField<
      NoiseResult_MeasurementsEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SweepInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SweepInput) */ {
 public:
  SweepInput();
  virtual ~SweepInput();

  SweepInput(const SweepInput& from);

  inline SweepInput& operator=(const SweepInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SweepInput(SweepInput&& from) noexcept
    : SweepInput() {
    *this = ::std::move(from);
  }

  inline SweepInput& operator=(SweepInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SweepInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SweepInput* internal_default_instance() {
    return reinterpret_cast<const SweepInput*>(
               &_SweepInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(SweepInput* other);
  friend void swap(SweepInput& a, SweepInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SweepInput* New() const final {
    return CreateMaybeMessage<SweepInput>(NULL);
  }

  SweepInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SweepInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SweepInput& from);
  void MergeFrom(const SweepInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SweepInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Analysis an = 4;
  int an_size() const;
  void clear_an();
  static const int kAnFieldNumber = 4;
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string variable = 2;
  void clear_variable();
  static const int kVariableFieldNumber = 2;
  const ::std::string& variable() const;
  void set_variable(const ::std::string& value);
  #if LANG_CXX11
  void set_variable(::std::string&& value);
  #endif
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  ::std::string* mutable_variable();
  ::std::string* release_variable();
  void set_allocated_variable(::std::string* variable);

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 3;
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  public:
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);

  // @@protoc_insertion_point(class_scope:vlsir.spice.SweepInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SweepResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SweepResult) */ {
 public:
  SweepResult();
  virtual ~SweepResult();

  SweepResult(const SweepResult& from);

  inline SweepResult& operator=(const SweepResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SweepResult(SweepResult&& from) noexcept
    : SweepResult() {
    *this = ::std::move(from);
  }

  inline SweepResult& operator=(SweepResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SweepResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SweepResult* internal_default_instance() {
    return reinterpret_cast<const SweepResult*>(
               &_SweepResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(SweepResult* other);
  friend void swap(SweepResult& a, SweepResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SweepResult* New() const final {
    return CreateMaybeMessage<SweepResult>(NULL);
  }

  SweepResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SweepResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SweepResult& from);
  void MergeFrom(const SweepResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SweepResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.AnalysisResult an = 4;
  int an_size() const;
  void clear_an();
  static const int kAnFieldNumber = 4;
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string variable = 2;
  void clear_variable();
  static const int kVariableFieldNumber = 2;
  const ::std::string& variable() const;
  void set_variable(const ::std::string& value);
  #if LANG_CXX11
  void set_variable(::std::string&& value);
  #endif
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  ::std::string* mutable_variable();
  ::std::string* release_variable();
  void set_allocated_variable(::std::string* variable);

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 3;
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  public:
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);

  // @@protoc_insertion_point(class_scope:vlsir.spice.SweepResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonteInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.MonteInput) */ {
 public:
  MonteInput();
  virtual ~MonteInput();

  MonteInput(const MonteInput& from);

  inline MonteInput& operator=(const MonteInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonteInput(MonteInput&& from) noexcept
    : MonteInput() {
    *this = ::std::move(from);
  }

  inline MonteInput& operator=(MonteInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonteInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonteInput* internal_default_instance() {
    return reinterpret_cast<const MonteInput*>(
               &_MonteInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(MonteInput* other);
  friend void swap(MonteInput& a, MonteInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonteInput* New() const final {
    return CreateMaybeMessage<MonteInput>(NULL);
  }

  MonteInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonteInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonteInput& from);
  void MergeFrom(const MonteInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonteInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Analysis an = 4;
  int an_size() const;
  void clear_an();
  static const int kAnFieldNumber = 4;
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // int64 npts = 2;
  void clear_npts();
  static const int kNptsFieldNumber = 2;
  ::google::protobuf::int64 npts() const;
  void set_npts(::google::protobuf::int64 value);

  // int64 seed = 3;
  void clear_seed();
  static const int kSeedFieldNumber = 3;
  ::google::protobuf::int64 seed() const;
  void set_seed(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.MonteInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::int64 npts_;
  ::google::protobuf::int64 seed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonteResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.MonteResult) */ {
 public:
  MonteResult();
  virtual ~MonteResult();

  MonteResult(const MonteResult& from);

  inline MonteResult& operator=(const MonteResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonteResult(MonteResult&& from) noexcept
    : MonteResult() {
    *this = ::std::move(from);
  }

  inline MonteResult& operator=(MonteResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonteResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonteResult* internal_default_instance() {
    return reinterpret_cast<const MonteResult*>(
               &_MonteResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(MonteResult* other);
  friend void swap(MonteResult& a, MonteResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonteResult* New() const final {
    return CreateMaybeMessage<MonteResult>(NULL);
  }

  MonteResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonteResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonteResult& from);
  void MergeFrom(const MonteResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonteResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.AnalysisResult an = 4;
  int an_size() const;
  void clear_an();
  static const int kAnFieldNumber = 4;
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string variable = 2;
  void clear_variable();
  static const int kVariableFieldNumber = 2;
  const ::std::string& variable() const;
  void set_variable(const ::std::string& value);
  #if LANG_CXX11
  void set_variable(::std::string&& value);
  #endif
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  ::std::string* mutable_variable();
  ::std::string* release_variable();
  void set_allocated_variable(::std::string* variable);

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 3;
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  public:
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);

  // @@protoc_insertion_point(class_scope:vlsir.spice.MonteResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CustomAnalysisInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.CustomAnalysisInput) */ {
 public:
  CustomAnalysisInput();
  virtual ~CustomAnalysisInput();

  CustomAnalysisInput(const CustomAnalysisInput& from);

  inline CustomAnalysisInput& operator=(const CustomAnalysisInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomAnalysisInput(CustomAnalysisInput&& from) noexcept
    : CustomAnalysisInput() {
    *this = ::std::move(from);
  }

  inline CustomAnalysisInput& operator=(CustomAnalysisInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomAnalysisInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomAnalysisInput* internal_default_instance() {
    return reinterpret_cast<const CustomAnalysisInput*>(
               &_CustomAnalysisInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CustomAnalysisInput* other);
  friend void swap(CustomAnalysisInput& a, CustomAnalysisInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomAnalysisInput* New() const final {
    return CreateMaybeMessage<CustomAnalysisInput>(NULL);
  }

  CustomAnalysisInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomAnalysisInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomAnalysisInput& from);
  void MergeFrom(const CustomAnalysisInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomAnalysisInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  void clear_ctrls();
  static const int kCtrlsFieldNumber = 5;
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  static const int kAnalysisNameFieldNumber = 1;
  const ::std::string& analysis_name() const;
  void set_analysis_name(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_name(::std::string&& value);
  #endif
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  ::std::string* mutable_analysis_name();
  ::std::string* release_analysis_name();
  void set_allocated_analysis_name(::std::string* analysis_name);

  // string cmd = 2;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  const ::std::string& cmd() const;
  void set_cmd(const ::std::string& value);
  #if LANG_CXX11
  void set_cmd(::std::string&& value);
  #endif
  void set_cmd(const char* value);
  void set_cmd(const char* value, size_t size);
  ::std::string* mutable_cmd();
  ::std::string* release_cmd();
  void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:vlsir.spice.CustomAnalysisInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::google::protobuf::internal::ArenaStringPtr analysis_name_;
  ::google::protobuf::internal::ArenaStringPtr cmd_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CustomAnalysisResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.CustomAnalysisResult) */ {
 public:
  CustomAnalysisResult();
  virtual ~CustomAnalysisResult();

  CustomAnalysisResult(const CustomAnalysisResult& from);

  inline CustomAnalysisResult& operator=(const CustomAnalysisResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomAnalysisResult(CustomAnalysisResult&& from) noexcept
    : CustomAnalysisResult() {
    *this = ::std::move(from);
  }

  inline CustomAnalysisResult& operator=(CustomAnalysisResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomAnalysisResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomAnalysisResult* internal_default_instance() {
    return reinterpret_cast<const CustomAnalysisResult*>(
               &_CustomAnalysisResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CustomAnalysisResult* other);
  friend void swap(CustomAnalysisResult& a, CustomAnalysisResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomAnalysisResult* New() const final {
    return CreateMaybeMessage<CustomAnalysisResult>(NULL);
  }

  CustomAnalysisResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomAnalysisResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomAnalysisResult& from);
  void MergeFrom(const CustomAnalysisResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomAnalysisResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vlsir.spice.CustomAnalysisResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sweep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Sweep) */ {
 public:
  Sweep();
  virtual ~Sweep();

  Sweep(const Sweep& from);

  inline Sweep& operator=(const Sweep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sweep(Sweep&& from) noexcept
    : Sweep() {
    *this = ::std::move(from);
  }

  inline Sweep& operator=(Sweep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sweep& default_instance();

  enum TpCase {
    kLinear = 1,
    kLog = 2,
    kPoints = 3,
    TP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sweep* internal_default_instance() {
    return reinterpret_cast<const Sweep*>(
               &_Sweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Sweep* other);
  friend void swap(Sweep& a, Sweep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sweep* New() const final {
    return CreateMaybeMessage<Sweep>(NULL);
  }

  Sweep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sweep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sweep& from);
  void MergeFrom(const Sweep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sweep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vlsir.spice.LinearSweep linear = 1;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  private:
  const ::vlsir::spice::LinearSweep& _internal_linear() const;
  public:
  const ::vlsir::spice::LinearSweep& linear() const;
  ::vlsir::spice::LinearSweep* release_linear();
  ::vlsir::spice::LinearSweep* mutable_linear();
  void set_allocated_linear(::vlsir::spice::LinearSweep* linear);

  // .vlsir.spice.LogSweep log = 2;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 2;
  private:
  const ::vlsir::spice::LogSweep& _internal_log() const;
  public:
  const ::vlsir::spice::LogSweep& log() const;
  ::vlsir::spice::LogSweep* release_log();
  ::vlsir::spice::LogSweep* mutable_log();
  void set_allocated_log(::vlsir::spice::LogSweep* log);

  // .vlsir.spice.PointSweep points = 3;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  private:
  const ::vlsir::spice::PointSweep& _internal_points() const;
  public:
  const ::vlsir::spice::PointSweep& points() const;
  ::vlsir::spice::PointSweep* release_points();
  ::vlsir::spice::PointSweep* mutable_points();
  void set_allocated_points(::vlsir::spice::PointSweep* points);

  void clear_tp();
  TpCase tp_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Sweep)
 private:
  void set_has_linear();
  void set_has_log();
  void set_has_points();

  inline bool has_tp() const;
  inline void clear_has_tp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TpUnion {
    TpUnion() {}
    ::vlsir::spice::LinearSweep* linear_;
    ::vlsir::spice::LogSweep* log_;
    ::vlsir::spice::PointSweep* points_;
  } tp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinearSweep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LinearSweep) */ {
 public:
  LinearSweep();
  virtual ~LinearSweep();

  LinearSweep(const LinearSweep& from);

  inline LinearSweep& operator=(const LinearSweep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinearSweep(LinearSweep&& from) noexcept
    : LinearSweep() {
    *this = ::std::move(from);
  }

  inline LinearSweep& operator=(LinearSweep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearSweep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinearSweep* internal_default_instance() {
    return reinterpret_cast<const LinearSweep*>(
               &_LinearSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(LinearSweep* other);
  friend void swap(LinearSweep& a, LinearSweep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinearSweep* New() const final {
    return CreateMaybeMessage<LinearSweep>(NULL);
  }

  LinearSweep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinearSweep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinearSweep& from);
  void MergeFrom(const LinearSweep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearSweep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  double start() const;
  void set_start(double value);

  // double stop = 2;
  void clear_stop();
  static const int kStopFieldNumber = 2;
  double stop() const;
  void set_stop(double value);

  // double step = 3;
  void clear_step();
  static const int kStepFieldNumber = 3;
  double step() const;
  void set_step(double value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.LinearSweep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double start_;
  double stop_;
  double step_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogSweep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LogSweep) */ {
 public:
  LogSweep();
  virtual ~LogSweep();

  LogSweep(const LogSweep& from);

  inline LogSweep& operator=(const LogSweep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogSweep(LogSweep&& from) noexcept
    : LogSweep() {
    *this = ::std::move(from);
  }

  inline LogSweep& operator=(LogSweep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogSweep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogSweep* internal_default_instance() {
    return reinterpret_cast<const LogSweep*>(
               &_LogSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(LogSweep* other);
  friend void swap(LogSweep& a, LogSweep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogSweep* New() const final {
    return CreateMaybeMessage<LogSweep>(NULL);
  }

  LogSweep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogSweep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogSweep& from);
  void MergeFrom(const LogSweep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSweep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  double start() const;
  void set_start(double value);

  // double stop = 2;
  void clear_stop();
  static const int kStopFieldNumber = 2;
  double stop() const;
  void set_stop(double value);

  // double npts = 3;
  void clear_npts();
  static const int kNptsFieldNumber = 3;
  double npts() const;
  void set_npts(double value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.LogSweep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double start_;
  double stop_;
  double npts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointSweep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.PointSweep) */ {
 public:
  PointSweep();
  virtual ~PointSweep();

  PointSweep(const PointSweep& from);

  inline PointSweep& operator=(const PointSweep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointSweep(PointSweep&& from) noexcept
    : PointSweep() {
    *this = ::std::move(from);
  }

  inline PointSweep& operator=(PointSweep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointSweep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointSweep* internal_default_instance() {
    return reinterpret_cast<const PointSweep*>(
               &_PointSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(PointSweep* other);
  friend void swap(PointSweep& a, PointSweep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointSweep* New() const final {
    return CreateMaybeMessage<PointSweep>(NULL);
  }

  PointSweep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointSweep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointSweep& from);
  void MergeFrom(const PointSweep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointSweep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  double points(int index) const;
  void set_points(int index, double value);
  void add_points(double value);
  const ::google::protobuf::RepeatedField< double >&
      points() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_points();

  // double stop = 2;
  void clear_stop();
  static const int kStopFieldNumber = 2;
  double stop() const;
  void set_stop(double value);

  // double npts = 3;
  void clear_npts();
  static const int kNptsFieldNumber = 3;
  double npts() const;
  void set_npts(double value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.PointSweep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > points_;
  mutable int _points_cached_byte_size_;
  double stop_;
  double npts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Control) */ {
 public:
  Control();
  virtual ~Control();

  Control(const Control& from);

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(Control&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Control& default_instance();

  enum CtrlCase {
    kInclude = 1,
    kLib = 2,
    kSave = 5,
    kMeas = 6,
    kParam = 7,
    kLiteral = 10,
    CTRL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(Control* other);
  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Control* New() const final {
    return CreateMaybeMessage<Control>(NULL);
  }

  Control* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vlsir.spice.Include include = 1;
  bool has_include() const;
  void clear_include();
  static const int kIncludeFieldNumber = 1;
  private:
  const ::vlsir::spice::Include& _internal_include() const;
  public:
  const ::vlsir::spice::Include& include() const;
  ::vlsir::spice::Include* release_include();
  ::vlsir::spice::Include* mutable_include();
  void set_allocated_include(::vlsir::spice::Include* include);

  // .vlsir.spice.LibInclude lib = 2;
  bool has_lib() const;
  void clear_lib();
  static const int kLibFieldNumber = 2;
  private:
  const ::vlsir::spice::LibInclude& _internal_lib() const;
  public:
  const ::vlsir::spice::LibInclude& lib() const;
  ::vlsir::spice::LibInclude* release_lib();
  ::vlsir::spice::LibInclude* mutable_lib();
  void set_allocated_lib(::vlsir::spice::LibInclude* lib);

  // .vlsir.spice.Save save = 5;
  bool has_save() const;
  void clear_save();
  static const int kSaveFieldNumber = 5;
  private:
  const ::vlsir::spice::Save& _internal_save() const;
  public:
  const ::vlsir::spice::Save& save() const;
  ::vlsir::spice::Save* release_save();
  ::vlsir::spice::Save* mutable_save();
  void set_allocated_save(::vlsir::spice::Save* save);

  // .vlsir.spice.Meas meas = 6;
  bool has_meas() const;
  void clear_meas();
  static const int kMeasFieldNumber = 6;
  private:
  const ::vlsir::spice::Meas& _internal_meas() const;
  public:
  const ::vlsir::spice::Meas& meas() const;
  ::vlsir::spice::Meas* release_meas();
  ::vlsir::spice::Meas* mutable_meas();
  void set_allocated_meas(::vlsir::spice::Meas* meas);

  // .vlsir.utils.Param param = 7;
  bool has_param() const;
  void clear_param();
  static const int kParamFieldNumber = 7;
  private:
  const ::vlsir::utils::Param& _internal_param() const;
  public:
  const ::vlsir::utils::Param& param() const;
  ::vlsir::utils::Param* release_param();
  ::vlsir::utils::Param* mutable_param();
  void set_allocated_param(::vlsir::utils::Param* param);

  // string literal = 10;
  private:
  bool has_literal() const;
  public:
  void clear_literal();
  static const int kLiteralFieldNumber = 10;
  const ::std::string& literal() const;
  void set_literal(const ::std::string& value);
  #if LANG_CXX11
  void set_literal(::std::string&& value);
  #endif
  void set_literal(const char* value);
  void set_literal(const char* value, size_t size);
  ::std::string* mutable_literal();
  ::std::string* release_literal();
  void set_allocated_literal(::std::string* literal);

  void clear_ctrl();
  CtrlCase ctrl_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Control)
 private:
  void set_has_include();
  void set_has_lib();
  void set_has_save();
  void set_has_meas();
  void set_has_param();
  void set_has_literal();

  inline bool has_ctrl() const;
  inline void clear_has_ctrl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union CtrlUnion {
    CtrlUnion() {}
    ::vlsir::spice::Include* include_;
    ::vlsir::spice::LibInclude* lib_;
    ::vlsir::spice::Save* save_;
    ::vlsir::spice::Meas* meas_;
    ::vlsir::utils::Param* param_;
    ::google::protobuf::internal::ArenaStringPtr literal_;
  } ctrl_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Save : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Save) */ {
 public:
  Save();
  virtual ~Save();

  Save(const Save& from);

  inline Save& operator=(const Save& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Save(Save&& from) noexcept
    : Save() {
    *this = ::std::move(from);
  }

  inline Save& operator=(Save&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Save& default_instance();

  enum SaveCase {
    kMode = 1,
    kSignal = 2,
    SAVE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Save* internal_default_instance() {
    return reinterpret_cast<const Save*>(
               &_Save_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(Save* other);
  friend void swap(Save& a, Save& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Save* New() const final {
    return CreateMaybeMessage<Save>(NULL);
  }

  Save* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Save>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Save& from);
  void MergeFrom(const Save& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Save* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Save_SaveMode SaveMode;
  static const SaveMode NONE =
    Save_SaveMode_NONE;
  static const SaveMode ALL =
    Save_SaveMode_ALL;
  static inline bool SaveMode_IsValid(int value) {
    return Save_SaveMode_IsValid(value);
  }
  static const SaveMode SaveMode_MIN =
    Save_SaveMode_SaveMode_MIN;
  static const SaveMode SaveMode_MAX =
    Save_SaveMode_SaveMode_MAX;
  static const int SaveMode_ARRAYSIZE =
    Save_SaveMode_SaveMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SaveMode_descriptor() {
    return Save_SaveMode_descriptor();
  }
  static inline const ::std::string& SaveMode_Name(SaveMode value) {
    return Save_SaveMode_Name(value);
  }
  static inline bool SaveMode_Parse(const ::std::string& name,
      SaveMode* value) {
    return Save_SaveMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .vlsir.spice.Save.SaveMode mode = 1;
  private:
  bool has_mode() const;
  public:
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::vlsir::spice::Save_SaveMode mode() const;
  void set_mode(::vlsir::spice::Save_SaveMode value);

  // string signal = 2;
  private:
  bool has_signal() const;
  public:
  void clear_signal();
  static const int kSignalFieldNumber = 2;
  const ::std::string& signal() const;
  void set_signal(const ::std::string& value);
  #if LANG_CXX11
  void set_signal(::std::string&& value);
  #endif
  void set_signal(const char* value);
  void set_signal(const char* value, size_t size);
  ::std::string* mutable_signal();
  ::std::string* release_signal();
  void set_allocated_signal(::std::string* signal);

  void clear_save();
  SaveCase save_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Save)
 private:
  void set_has_mode();
  void set_has_signal();

  inline bool has_save() const;
  inline void clear_has_save();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SaveUnion {
    SaveUnion() {}
    int mode_;
    ::google::protobuf::internal::ArenaStringPtr signal_;
  } save_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Include : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Include) */ {
 public:
  Include();
  virtual ~Include();

  Include(const Include& from);

  inline Include& operator=(const Include& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Include(Include&& from) noexcept
    : Include() {
    *this = ::std::move(from);
  }

  inline Include& operator=(Include&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Include& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Include* internal_default_instance() {
    return reinterpret_cast<const Include*>(
               &_Include_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Include* other);
  friend void swap(Include& a, Include& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Include* New() const final {
    return CreateMaybeMessage<Include>(NULL);
  }

  Include* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Include>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Include& from);
  void MergeFrom(const Include& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Include* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:vlsir.spice.Include)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LibInclude : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LibInclude) */ {
 public:
  LibInclude();
  virtual ~LibInclude();

  LibInclude(const LibInclude& from);

  inline LibInclude& operator=(const LibInclude& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LibInclude(LibInclude&& from) noexcept
    : LibInclude() {
    *this = ::std::move(from);
  }

  inline LibInclude& operator=(LibInclude&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LibInclude& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LibInclude* internal_default_instance() {
    return reinterpret_cast<const LibInclude*>(
               &_LibInclude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(LibInclude* other);
  friend void swap(LibInclude& a, LibInclude& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LibInclude* New() const final {
    return CreateMaybeMessage<LibInclude>(NULL);
  }

  LibInclude* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LibInclude>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LibInclude& from);
  void MergeFrom(const LibInclude& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibInclude* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string section = 2;
  void clear_section();
  static const int kSectionFieldNumber = 2;
  const ::std::string& section() const;
  void set_section(const ::std::string& value);
  #if LANG_CXX11
  void set_section(::std::string&& value);
  #endif
  void set_section(const char* value);
  void set_section(const char* value, size_t size);
  ::std::string* mutable_section();
  ::std::string* release_section();
  void set_allocated_section(::std::string* section);

  // @@protoc_insertion_point(class_scope:vlsir.spice.LibInclude)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr section_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Meas : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Meas) */ {
 public:
  Meas();
  virtual ~Meas();

  Meas(const Meas& from);

  inline Meas& operator=(const Meas& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Meas(Meas&& from) noexcept
    : Meas() {
    *this = ::std::move(from);
  }

  inline Meas& operator=(Meas&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Meas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Meas* internal_default_instance() {
    return reinterpret_cast<const Meas*>(
               &_Meas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(Meas* other);
  friend void swap(Meas& a, Meas& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Meas* New() const final {
    return CreateMaybeMessage<Meas>(NULL);
  }

  Meas* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Meas>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Meas& from);
  void MergeFrom(const Meas& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Meas* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string analysis_type = 1;
  void clear_analysis_type();
  static const int kAnalysisTypeFieldNumber = 1;
  const ::std::string& analysis_type() const;
  void set_analysis_type(const ::std::string& value);
  #if LANG_CXX11
  void set_analysis_type(::std::string&& value);
  #endif
  void set_analysis_type(const char* value);
  void set_analysis_type(const char* value, size_t size);
  ::std::string* mutable_analysis_type();
  ::std::string* release_analysis_type();
  void set_allocated_analysis_type(::std::string* analysis_type);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string expr = 3;
  void clear_expr();
  static const int kExprFieldNumber = 3;
  const ::std::string& expr() const;
  void set_expr(const ::std::string& value);
  #if LANG_CXX11
  void set_expr(::std::string&& value);
  #endif
  void set_expr(const char* value);
  void set_expr(const char* value, size_t size);
  ::std::string* mutable_expr();
  ::std::string* release_expr();
  void set_allocated_expr(::std::string* expr);

  // @@protoc_insertion_point(class_scope:vlsir.spice.Meas)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr analysis_type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr expr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(NULL);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signal_Quantity Quantity;
  static const Quantity VOLTAGE =
    Signal_Quantity_VOLTAGE;
  static const Quantity CURRENT =
    Signal_Quantity_CURRENT;
  static const Quantity NONE =
    Signal_Quantity_NONE;
  static inline bool Quantity_IsValid(int value) {
    return Signal_Quantity_IsValid(value);
  }
  static const Quantity Quantity_MIN =
    Signal_Quantity_Quantity_MIN;
  static const Quantity Quantity_MAX =
    Signal_Quantity_Quantity_MAX;
  static const int Quantity_ARRAYSIZE =
    Signal_Quantity_Quantity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Quantity_descriptor() {
    return Signal_Quantity_descriptor();
  }
  static inline const ::std::string& Quantity_Name(Quantity value) {
    return Signal_Quantity_Name(value);
  }
  static inline bool Quantity_Parse(const ::std::string& name,
      Quantity* value) {
    return Signal_Quantity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .vlsir.spice.Signal.Quantity quantity = 2;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  ::vlsir::spice::Signal_Quantity quantity() const;
  void set_quantity(::vlsir::spice::Signal_Quantity value);

  // @@protoc_insertion_point(class_scope:vlsir.spice.Signal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int quantity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_spice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimInput

// .vlsir.circuit.Package pkg = 1;
inline bool SimInput::has_pkg() const {
  return this != internal_default_instance() && pkg_ != NULL;
}
inline const ::vlsir::circuit::Package& SimInput::_internal_pkg() const {
  return *pkg_;
}
inline const ::vlsir::circuit::Package& SimInput::pkg() const {
  const ::vlsir::circuit::Package* p = pkg_;
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.pkg)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::circuit::Package*>(
      &::vlsir::circuit::_Package_default_instance_);
}
inline ::vlsir::circuit::Package* SimInput::release_pkg() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimInput.pkg)
  
  ::vlsir::circuit::Package* temp = pkg_;
  pkg_ = NULL;
  return temp;
}
inline ::vlsir::circuit::Package* SimInput::mutable_pkg() {
  
  if (pkg_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Package>(GetArenaNoVirtual());
    pkg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.pkg)
  return pkg_;
}
inline void SimInput::set_allocated_pkg(::vlsir::circuit::Package* pkg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pkg_);
  }
  if (pkg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pkg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pkg, submessage_arena);
    }
    
  } else {
    
  }
  pkg_ = pkg;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimInput.pkg)
}

// string top = 2;
inline void SimInput::clear_top() {
  top_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimInput::top() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.top)
  return top_.GetNoArena();
}
inline void SimInput::set_top(const ::std::string& value) {
  
  top_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimInput.top)
}
#if LANG_CXX11
inline void SimInput::set_top(::std::string&& value) {
  
  top_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SimInput.top)
}
#endif
inline void SimInput::set_top(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  top_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SimInput.top)
}
inline void SimInput::set_top(const char* value, size_t size) {
  
  top_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SimInput.top)
}
inline ::std::string* SimInput::mutable_top() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.top)
  return top_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimInput::release_top() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimInput.top)
  
  return top_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimInput::set_allocated_top(::std::string* top) {
  if (top != NULL) {
    
  } else {
    
  }
  top_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), top);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimInput.top)
}

// repeated .vlsir.spice.SimOptions opts = 10;
inline int SimInput::opts_size() const {
  return opts_.size();
}
inline void SimInput::clear_opts() {
  opts_.Clear();
}
inline ::vlsir::spice::SimOptions* SimInput::mutable_opts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.opts)
  return opts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::SimOptions >*
SimInput::mutable_opts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.opts)
  return &opts_;
}
inline const ::vlsir::spice::SimOptions& SimInput::opts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.opts)
  return opts_.Get(index);
}
inline ::vlsir::spice::SimOptions* SimInput::add_opts() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.opts)
  return opts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::SimOptions >&
SimInput::opts() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.opts)
  return opts_;
}

// repeated .vlsir.spice.Analysis an = 11;
inline int SimInput::an_size() const {
  return an_.size();
}
inline void SimInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* SimInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.an)
  return an_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >*
SimInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& SimInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.an)
  return an_.Get(index);
}
inline ::vlsir::spice::Analysis* SimInput::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.an)
  return an_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >&
SimInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 12;
inline int SimInput::ctrls_size() const {
  return ctrls_.size();
}
inline void SimInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* SimInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
SimInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& SimInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* SimInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
SimInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// SimResult

// repeated .vlsir.spice.AnalysisResult an = 1;
inline int SimResult::an_size() const {
  return an_.size();
}
inline void SimResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* SimResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimResult.an)
  return an_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
SimResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& SimResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimResult.an)
  return an_.Get(index);
}
inline ::vlsir::spice::AnalysisResult* SimResult::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimResult.an)
  return an_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
SimResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimResult.an)
  return an_;
}

// -------------------------------------------------------------------

// SimOptions

// double temp = 1;
inline void SimOptions::clear_temp() {
  temp_ = 0;
}
inline double SimOptions::temp() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.temp)
  return temp_;
}
inline void SimOptions::set_temp(double value) {
  
  temp_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.temp)
}

// double tnom = 2;
inline void SimOptions::clear_tnom() {
  tnom_ = 0;
}
inline double SimOptions::tnom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.tnom)
  return tnom_;
}
inline void SimOptions::set_tnom(double value) {
  
  tnom_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.tnom)
}

// double gmin = 3;
inline void SimOptions::clear_gmin() {
  gmin_ = 0;
}
inline double SimOptions::gmin() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.gmin)
  return gmin_;
}
inline void SimOptions::set_gmin(double value) {
  
  gmin_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.gmin)
}

// double iabstol = 4;
inline void SimOptions::clear_iabstol() {
  iabstol_ = 0;
}
inline double SimOptions::iabstol() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.iabstol)
  return iabstol_;
}
inline void SimOptions::set_iabstol(double value) {
  
  iabstol_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.iabstol)
}

// double reltol = 5;
inline void SimOptions::clear_reltol() {
  reltol_ = 0;
}
inline double SimOptions::reltol() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.reltol)
  return reltol_;
}
inline void SimOptions::set_reltol(double value) {
  
  reltol_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.reltol)
}

// -------------------------------------------------------------------

// Analysis

// .vlsir.spice.OpInput op = 1;
inline bool Analysis::has_op() const {
  return an_case() == kOp;
}
inline void Analysis::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void Analysis::clear_op() {
  if (has_op()) {
    delete an_.op_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::OpInput& Analysis::_internal_op() const {
  return *an_.op_;
}
inline ::vlsir::spice::OpInput* Analysis::release_op() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.op)
  if (has_op()) {
    clear_has_an();
      ::vlsir::spice::OpInput* temp = an_.op_;
    an_.op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::OpInput& Analysis::op() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.op)
  return has_op()
      ? *an_.op_
      : *reinterpret_cast< ::vlsir::spice::OpInput*>(&::vlsir::spice::_OpInput_default_instance_);
}
inline ::vlsir::spice::OpInput* Analysis::mutable_op() {
  if (!has_op()) {
    clear_an();
    set_has_op();
    an_.op_ = CreateMaybeMessage< ::vlsir::spice::OpInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.op)
  return an_.op_;
}

// .vlsir.spice.DcInput dc = 2;
inline bool Analysis::has_dc() const {
  return an_case() == kDc;
}
inline void Analysis::set_has_dc() {
  _oneof_case_[0] = kDc;
}
inline void Analysis::clear_dc() {
  if (has_dc()) {
    delete an_.dc_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::DcInput& Analysis::_internal_dc() const {
  return *an_.dc_;
}
inline ::vlsir::spice::DcInput* Analysis::release_dc() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.dc)
  if (has_dc()) {
    clear_has_an();
      ::vlsir::spice::DcInput* temp = an_.dc_;
    an_.dc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::DcInput& Analysis::dc() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.dc)
  return has_dc()
      ? *an_.dc_
      : *reinterpret_cast< ::vlsir::spice::DcInput*>(&::vlsir::spice::_DcInput_default_instance_);
}
inline ::vlsir::spice::DcInput* Analysis::mutable_dc() {
  if (!has_dc()) {
    clear_an();
    set_has_dc();
    an_.dc_ = CreateMaybeMessage< ::vlsir::spice::DcInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.dc)
  return an_.dc_;
}

// .vlsir.spice.TranInput tran = 3;
inline bool Analysis::has_tran() const {
  return an_case() == kTran;
}
inline void Analysis::set_has_tran() {
  _oneof_case_[0] = kTran;
}
inline void Analysis::clear_tran() {
  if (has_tran()) {
    delete an_.tran_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::TranInput& Analysis::_internal_tran() const {
  return *an_.tran_;
}
inline ::vlsir::spice::TranInput* Analysis::release_tran() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.tran)
  if (has_tran()) {
    clear_has_an();
      ::vlsir::spice::TranInput* temp = an_.tran_;
    an_.tran_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::TranInput& Analysis::tran() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.tran)
  return has_tran()
      ? *an_.tran_
      : *reinterpret_cast< ::vlsir::spice::TranInput*>(&::vlsir::spice::_TranInput_default_instance_);
}
inline ::vlsir::spice::TranInput* Analysis::mutable_tran() {
  if (!has_tran()) {
    clear_an();
    set_has_tran();
    an_.tran_ = CreateMaybeMessage< ::vlsir::spice::TranInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.tran)
  return an_.tran_;
}

// .vlsir.spice.AcInput ac = 4;
inline bool Analysis::has_ac() const {
  return an_case() == kAc;
}
inline void Analysis::set_has_ac() {
  _oneof_case_[0] = kAc;
}
inline void Analysis::clear_ac() {
  if (has_ac()) {
    delete an_.ac_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::AcInput& Analysis::_internal_ac() const {
  return *an_.ac_;
}
inline ::vlsir::spice::AcInput* Analysis::release_ac() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.ac)
  if (has_ac()) {
    clear_has_an();
      ::vlsir::spice::AcInput* temp = an_.ac_;
    an_.ac_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::AcInput& Analysis::ac() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.ac)
  return has_ac()
      ? *an_.ac_
      : *reinterpret_cast< ::vlsir::spice::AcInput*>(&::vlsir::spice::_AcInput_default_instance_);
}
inline ::vlsir::spice::AcInput* Analysis::mutable_ac() {
  if (!has_ac()) {
    clear_an();
    set_has_ac();
    an_.ac_ = CreateMaybeMessage< ::vlsir::spice::AcInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.ac)
  return an_.ac_;
}

// .vlsir.spice.NoiseInput noise = 5;
inline bool Analysis::has_noise() const {
  return an_case() == kNoise;
}
inline void Analysis::set_has_noise() {
  _oneof_case_[0] = kNoise;
}
inline void Analysis::clear_noise() {
  if (has_noise()) {
    delete an_.noise_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::NoiseInput& Analysis::_internal_noise() const {
  return *an_.noise_;
}
inline ::vlsir::spice::NoiseInput* Analysis::release_noise() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.noise)
  if (has_noise()) {
    clear_has_an();
      ::vlsir::spice::NoiseInput* temp = an_.noise_;
    an_.noise_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::NoiseInput& Analysis::noise() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.noise)
  return has_noise()
      ? *an_.noise_
      : *reinterpret_cast< ::vlsir::spice::NoiseInput*>(&::vlsir::spice::_NoiseInput_default_instance_);
}
inline ::vlsir::spice::NoiseInput* Analysis::mutable_noise() {
  if (!has_noise()) {
    clear_an();
    set_has_noise();
    an_.noise_ = CreateMaybeMessage< ::vlsir::spice::NoiseInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.noise)
  return an_.noise_;
}

// .vlsir.spice.SweepInput sweep = 10;
inline bool Analysis::has_sweep() const {
  return an_case() == kSweep;
}
inline void Analysis::set_has_sweep() {
  _oneof_case_[0] = kSweep;
}
inline void Analysis::clear_sweep() {
  if (has_sweep()) {
    delete an_.sweep_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::SweepInput& Analysis::_internal_sweep() const {
  return *an_.sweep_;
}
inline ::vlsir::spice::SweepInput* Analysis::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.sweep)
  if (has_sweep()) {
    clear_has_an();
      ::vlsir::spice::SweepInput* temp = an_.sweep_;
    an_.sweep_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::SweepInput& Analysis::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.sweep)
  return has_sweep()
      ? *an_.sweep_
      : *reinterpret_cast< ::vlsir::spice::SweepInput*>(&::vlsir::spice::_SweepInput_default_instance_);
}
inline ::vlsir::spice::SweepInput* Analysis::mutable_sweep() {
  if (!has_sweep()) {
    clear_an();
    set_has_sweep();
    an_.sweep_ = CreateMaybeMessage< ::vlsir::spice::SweepInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.sweep)
  return an_.sweep_;
}

// .vlsir.spice.MonteInput monte = 11;
inline bool Analysis::has_monte() const {
  return an_case() == kMonte;
}
inline void Analysis::set_has_monte() {
  _oneof_case_[0] = kMonte;
}
inline void Analysis::clear_monte() {
  if (has_monte()) {
    delete an_.monte_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::MonteInput& Analysis::_internal_monte() const {
  return *an_.monte_;
}
inline ::vlsir::spice::MonteInput* Analysis::release_monte() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.monte)
  if (has_monte()) {
    clear_has_an();
      ::vlsir::spice::MonteInput* temp = an_.monte_;
    an_.monte_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::MonteInput& Analysis::monte() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.monte)
  return has_monte()
      ? *an_.monte_
      : *reinterpret_cast< ::vlsir::spice::MonteInput*>(&::vlsir::spice::_MonteInput_default_instance_);
}
inline ::vlsir::spice::MonteInput* Analysis::mutable_monte() {
  if (!has_monte()) {
    clear_an();
    set_has_monte();
    an_.monte_ = CreateMaybeMessage< ::vlsir::spice::MonteInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.monte)
  return an_.monte_;
}

// .vlsir.spice.CustomAnalysisInput custom = 20;
inline bool Analysis::has_custom() const {
  return an_case() == kCustom;
}
inline void Analysis::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void Analysis::clear_custom() {
  if (has_custom()) {
    delete an_.custom_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::CustomAnalysisInput& Analysis::_internal_custom() const {
  return *an_.custom_;
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::release_custom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.custom)
  if (has_custom()) {
    clear_has_an();
      ::vlsir::spice::CustomAnalysisInput* temp = an_.custom_;
    an_.custom_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::CustomAnalysisInput& Analysis::custom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.custom)
  return has_custom()
      ? *an_.custom_
      : *reinterpret_cast< ::vlsir::spice::CustomAnalysisInput*>(&::vlsir::spice::_CustomAnalysisInput_default_instance_);
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::mutable_custom() {
  if (!has_custom()) {
    clear_an();
    set_has_custom();
    an_.custom_ = CreateMaybeMessage< ::vlsir::spice::CustomAnalysisInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.custom)
  return an_.custom_;
}

inline bool Analysis::has_an() const {
  return an_case() != AN_NOT_SET;
}
inline void Analysis::clear_has_an() {
  _oneof_case_[0] = AN_NOT_SET;
}
inline Analysis::AnCase Analysis::an_case() const {
  return Analysis::AnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnalysisResult

// .vlsir.spice.OpResult op = 1;
inline bool AnalysisResult::has_op() const {
  return an_case() == kOp;
}
inline void AnalysisResult::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void AnalysisResult::clear_op() {
  if (has_op()) {
    delete an_.op_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::OpResult& AnalysisResult::_internal_op() const {
  return *an_.op_;
}
inline ::vlsir::spice::OpResult* AnalysisResult::release_op() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.op)
  if (has_op()) {
    clear_has_an();
      ::vlsir::spice::OpResult* temp = an_.op_;
    an_.op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::OpResult& AnalysisResult::op() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.op)
  return has_op()
      ? *an_.op_
      : *reinterpret_cast< ::vlsir::spice::OpResult*>(&::vlsir::spice::_OpResult_default_instance_);
}
inline ::vlsir::spice::OpResult* AnalysisResult::mutable_op() {
  if (!has_op()) {
    clear_an();
    set_has_op();
    an_.op_ = CreateMaybeMessage< ::vlsir::spice::OpResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.op)
  return an_.op_;
}

// .vlsir.spice.DcResult dc = 2;
inline bool AnalysisResult::has_dc() const {
  return an_case() == kDc;
}
inline void AnalysisResult::set_has_dc() {
  _oneof_case_[0] = kDc;
}
inline void AnalysisResult::clear_dc() {
  if (has_dc()) {
    delete an_.dc_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::DcResult& AnalysisResult::_internal_dc() const {
  return *an_.dc_;
}
inline ::vlsir::spice::DcResult* AnalysisResult::release_dc() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.dc)
  if (has_dc()) {
    clear_has_an();
      ::vlsir::spice::DcResult* temp = an_.dc_;
    an_.dc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::DcResult& AnalysisResult::dc() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.dc)
  return has_dc()
      ? *an_.dc_
      : *reinterpret_cast< ::vlsir::spice::DcResult*>(&::vlsir::spice::_DcResult_default_instance_);
}
inline ::vlsir::spice::DcResult* AnalysisResult::mutable_dc() {
  if (!has_dc()) {
    clear_an();
    set_has_dc();
    an_.dc_ = CreateMaybeMessage< ::vlsir::spice::DcResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.dc)
  return an_.dc_;
}

// .vlsir.spice.TranResult tran = 3;
inline bool AnalysisResult::has_tran() const {
  return an_case() == kTran;
}
inline void AnalysisResult::set_has_tran() {
  _oneof_case_[0] = kTran;
}
inline void AnalysisResult::clear_tran() {
  if (has_tran()) {
    delete an_.tran_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::TranResult& AnalysisResult::_internal_tran() const {
  return *an_.tran_;
}
inline ::vlsir::spice::TranResult* AnalysisResult::release_tran() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.tran)
  if (has_tran()) {
    clear_has_an();
      ::vlsir::spice::TranResult* temp = an_.tran_;
    an_.tran_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::TranResult& AnalysisResult::tran() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.tran)
  return has_tran()
      ? *an_.tran_
      : *reinterpret_cast< ::vlsir::spice::TranResult*>(&::vlsir::spice::_TranResult_default_instance_);
}
inline ::vlsir::spice::TranResult* AnalysisResult::mutable_tran() {
  if (!has_tran()) {
    clear_an();
    set_has_tran();
    an_.tran_ = CreateMaybeMessage< ::vlsir::spice::TranResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.tran)
  return an_.tran_;
}

// .vlsir.spice.AcResult ac = 4;
inline bool AnalysisResult::has_ac() const {
  return an_case() == kAc;
}
inline void AnalysisResult::set_has_ac() {
  _oneof_case_[0] = kAc;
}
inline void AnalysisResult::clear_ac() {
  if (has_ac()) {
    delete an_.ac_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::AcResult& AnalysisResult::_internal_ac() const {
  return *an_.ac_;
}
inline ::vlsir::spice::AcResult* AnalysisResult::release_ac() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.ac)
  if (has_ac()) {
    clear_has_an();
      ::vlsir::spice::AcResult* temp = an_.ac_;
    an_.ac_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::AcResult& AnalysisResult::ac() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.ac)
  return has_ac()
      ? *an_.ac_
      : *reinterpret_cast< ::vlsir::spice::AcResult*>(&::vlsir::spice::_AcResult_default_instance_);
}
inline ::vlsir::spice::AcResult* AnalysisResult::mutable_ac() {
  if (!has_ac()) {
    clear_an();
    set_has_ac();
    an_.ac_ = CreateMaybeMessage< ::vlsir::spice::AcResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.ac)
  return an_.ac_;
}

// .vlsir.spice.NoiseResult noise = 5;
inline bool AnalysisResult::has_noise() const {
  return an_case() == kNoise;
}
inline void AnalysisResult::set_has_noise() {
  _oneof_case_[0] = kNoise;
}
inline void AnalysisResult::clear_noise() {
  if (has_noise()) {
    delete an_.noise_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::NoiseResult& AnalysisResult::_internal_noise() const {
  return *an_.noise_;
}
inline ::vlsir::spice::NoiseResult* AnalysisResult::release_noise() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.noise)
  if (has_noise()) {
    clear_has_an();
      ::vlsir::spice::NoiseResult* temp = an_.noise_;
    an_.noise_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::NoiseResult& AnalysisResult::noise() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.noise)
  return has_noise()
      ? *an_.noise_
      : *reinterpret_cast< ::vlsir::spice::NoiseResult*>(&::vlsir::spice::_NoiseResult_default_instance_);
}
inline ::vlsir::spice::NoiseResult* AnalysisResult::mutable_noise() {
  if (!has_noise()) {
    clear_an();
    set_has_noise();
    an_.noise_ = CreateMaybeMessage< ::vlsir::spice::NoiseResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.noise)
  return an_.noise_;
}

// .vlsir.spice.SweepResult sweep = 10;
inline bool AnalysisResult::has_sweep() const {
  return an_case() == kSweep;
}
inline void AnalysisResult::set_has_sweep() {
  _oneof_case_[0] = kSweep;
}
inline void AnalysisResult::clear_sweep() {
  if (has_sweep()) {
    delete an_.sweep_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::SweepResult& AnalysisResult::_internal_sweep() const {
  return *an_.sweep_;
}
inline ::vlsir::spice::SweepResult* AnalysisResult::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.sweep)
  if (has_sweep()) {
    clear_has_an();
      ::vlsir::spice::SweepResult* temp = an_.sweep_;
    an_.sweep_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::SweepResult& AnalysisResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.sweep)
  return has_sweep()
      ? *an_.sweep_
      : *reinterpret_cast< ::vlsir::spice::SweepResult*>(&::vlsir::spice::_SweepResult_default_instance_);
}
inline ::vlsir::spice::SweepResult* AnalysisResult::mutable_sweep() {
  if (!has_sweep()) {
    clear_an();
    set_has_sweep();
    an_.sweep_ = CreateMaybeMessage< ::vlsir::spice::SweepResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.sweep)
  return an_.sweep_;
}

// .vlsir.spice.MonteResult monte = 11;
inline bool AnalysisResult::has_monte() const {
  return an_case() == kMonte;
}
inline void AnalysisResult::set_has_monte() {
  _oneof_case_[0] = kMonte;
}
inline void AnalysisResult::clear_monte() {
  if (has_monte()) {
    delete an_.monte_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::MonteResult& AnalysisResult::_internal_monte() const {
  return *an_.monte_;
}
inline ::vlsir::spice::MonteResult* AnalysisResult::release_monte() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.monte)
  if (has_monte()) {
    clear_has_an();
      ::vlsir::spice::MonteResult* temp = an_.monte_;
    an_.monte_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::MonteResult& AnalysisResult::monte() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.monte)
  return has_monte()
      ? *an_.monte_
      : *reinterpret_cast< ::vlsir::spice::MonteResult*>(&::vlsir::spice::_MonteResult_default_instance_);
}
inline ::vlsir::spice::MonteResult* AnalysisResult::mutable_monte() {
  if (!has_monte()) {
    clear_an();
    set_has_monte();
    an_.monte_ = CreateMaybeMessage< ::vlsir::spice::MonteResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.monte)
  return an_.monte_;
}

// .vlsir.spice.CustomAnalysisResult custom = 20;
inline bool AnalysisResult::has_custom() const {
  return an_case() == kCustom;
}
inline void AnalysisResult::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void AnalysisResult::clear_custom() {
  if (has_custom()) {
    delete an_.custom_;
    clear_has_an();
  }
}
inline const ::vlsir::spice::CustomAnalysisResult& AnalysisResult::_internal_custom() const {
  return *an_.custom_;
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::release_custom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.custom)
  if (has_custom()) {
    clear_has_an();
      ::vlsir::spice::CustomAnalysisResult* temp = an_.custom_;
    an_.custom_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::CustomAnalysisResult& AnalysisResult::custom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.custom)
  return has_custom()
      ? *an_.custom_
      : *reinterpret_cast< ::vlsir::spice::CustomAnalysisResult*>(&::vlsir::spice::_CustomAnalysisResult_default_instance_);
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::mutable_custom() {
  if (!has_custom()) {
    clear_an();
    set_has_custom();
    an_.custom_ = CreateMaybeMessage< ::vlsir::spice::CustomAnalysisResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.custom)
  return an_.custom_;
}

inline bool AnalysisResult::has_an() const {
  return an_case() != AN_NOT_SET;
}
inline void AnalysisResult::clear_has_an() {
  _oneof_case_[0] = AN_NOT_SET;
}
inline AnalysisResult::AnCase AnalysisResult::an_case() const {
  return AnalysisResult::AnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpInput

// string analysis_name = 1;
inline void OpInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void OpInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpInput.analysis_name)
}
#if LANG_CXX11
inline void OpInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.OpInput.analysis_name)
}
#endif
inline void OpInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpInput.analysis_name)
}
inline void OpInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpInput.analysis_name)
}
inline ::std::string* OpInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpInput.analysis_name)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int OpInput::ctrls_size() const {
  return ctrls_.size();
}
inline void OpInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* OpInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
OpInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& OpInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* OpInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.OpInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
OpInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// OpResult

// string analysis_name = 1;
inline void OpResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void OpResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.analysis_name)
}
#if LANG_CXX11
inline void OpResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.OpResult.analysis_name)
}
#endif
inline void OpResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpResult.analysis_name)
}
inline void OpResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpResult.analysis_name)
}
inline ::std::string* OpResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpResult.analysis_name)
}

// repeated string signals = 3;
inline int OpResult::signals_size() const {
  return signals_.size();
}
inline void OpResult::clear_signals() {
  signals_.Clear();
}
inline const ::std::string& OpResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.signals)
  return signals_.Get(index);
}
inline ::std::string* OpResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.signals)
  return signals_.Mutable(index);
}
inline void OpResult::set_signals(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.signals)
  signals_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OpResult::set_signals(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OpResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpResult.signals)
}
inline void OpResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpResult.signals)
}
inline ::std::string* OpResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.OpResult.signals)
  return signals_.Add();
}
inline void OpResult::add_signals(const ::std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.signals)
}
#if LANG_CXX11
inline void OpResult::add_signals(::std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.signals)
}
#endif
inline void OpResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.OpResult.signals)
}
inline void OpResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.OpResult.signals)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpResult.signals)
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int OpResult::data_size() const {
  return data_.size();
}
inline void OpResult::clear_data() {
  data_.Clear();
}
inline double OpResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.data)
  return data_.Get(index);
}
inline void OpResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.data)
}
inline void OpResult::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.data)
}
inline const ::google::protobuf::RepeatedField< double >&
OpResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpResult.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
OpResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpResult.data)
  return &data_;
}

// string raw = 6;
inline void OpResult::clear_raw() {
  raw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpResult::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.raw)
  return raw_.GetNoArena();
}
inline void OpResult::set_raw(const ::std::string& value) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.raw)
}
#if LANG_CXX11
inline void OpResult::set_raw(::std::string&& value) {
  
  raw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.OpResult.raw)
}
#endif
inline void OpResult::set_raw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpResult.raw)
}
inline void OpResult::set_raw(const char* value, size_t size) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpResult.raw)
}
inline ::std::string* OpResult::mutable_raw() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.raw)
  return raw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpResult::release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpResult.raw)
  
  return raw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpResult::set_allocated_raw(::std::string* raw) {
  if (raw != NULL) {
    
  } else {
    
  }
  raw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpResult.raw)
}

// -------------------------------------------------------------------

// DcInput

// string analysis_name = 1;
inline void DcInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DcInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void DcInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.analysis_name)
}
#if LANG_CXX11
inline void DcInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcInput.analysis_name)
}
#endif
inline void DcInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcInput.analysis_name)
}
inline void DcInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcInput.analysis_name)
}
inline ::std::string* DcInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DcInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DcInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.analysis_name)
}

// string indep_name = 2;
inline void DcInput::clear_indep_name() {
  indep_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DcInput::indep_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.indep_name)
  return indep_name_.GetNoArena();
}
inline void DcInput::set_indep_name(const ::std::string& value) {
  
  indep_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.indep_name)
}
#if LANG_CXX11
inline void DcInput::set_indep_name(::std::string&& value) {
  
  indep_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcInput.indep_name)
}
#endif
inline void DcInput::set_indep_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  indep_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcInput.indep_name)
}
inline void DcInput::set_indep_name(const char* value, size_t size) {
  
  indep_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcInput.indep_name)
}
inline ::std::string* DcInput::mutable_indep_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.indep_name)
  return indep_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DcInput::release_indep_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.indep_name)
  
  return indep_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DcInput::set_allocated_indep_name(::std::string* indep_name) {
  if (indep_name != NULL) {
    
  } else {
    
  }
  indep_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), indep_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.indep_name)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool DcInput::has_sweep() const {
  return this != internal_default_instance() && sweep_ != NULL;
}
inline void DcInput::clear_sweep() {
  if (GetArenaNoVirtual() == NULL && sweep_ != NULL) {
    delete sweep_;
  }
  sweep_ = NULL;
}
inline const ::vlsir::spice::Sweep& DcInput::_internal_sweep() const {
  return *sweep_;
}
inline const ::vlsir::spice::Sweep& DcInput::sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.sweep)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline ::vlsir::spice::Sweep* DcInput::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = NULL;
  return temp;
}
inline ::vlsir::spice::Sweep* DcInput::mutable_sweep() {
  
  if (sweep_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaNoVirtual());
    sweep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.sweep)
  return sweep_;
}
inline void DcInput::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sweep_;
  }
  if (sweep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sweep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.sweep)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int DcInput::ctrls_size() const {
  return ctrls_.size();
}
inline void DcInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* DcInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
DcInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& DcInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* DcInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.DcInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
DcInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcInput.ctrls)
  return ctrls_;
}

// string raw = 6;
inline void DcInput::clear_raw() {
  raw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DcInput::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.raw)
  return raw_.GetNoArena();
}
inline void DcInput::set_raw(const ::std::string& value) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.raw)
}
#if LANG_CXX11
inline void DcInput::set_raw(::std::string&& value) {
  
  raw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcInput.raw)
}
#endif
inline void DcInput::set_raw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcInput.raw)
}
inline void DcInput::set_raw(const char* value, size_t size) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcInput.raw)
}
inline ::std::string* DcInput::mutable_raw() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.raw)
  return raw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DcInput::release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.raw)
  
  return raw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DcInput::set_allocated_raw(::std::string* raw) {
  if (raw != NULL) {
    
  } else {
    
  }
  raw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.raw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DcResult

// string analysis_name = 1;
inline void DcResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DcResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void DcResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.analysis_name)
}
#if LANG_CXX11
inline void DcResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcResult.analysis_name)
}
#endif
inline void DcResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcResult.analysis_name)
}
inline void DcResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcResult.analysis_name)
}
inline ::std::string* DcResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DcResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DcResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.analysis_name)
}

// string indep_name = 2;
inline void DcResult::clear_indep_name() {
  indep_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DcResult::indep_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.indep_name)
  return indep_name_.GetNoArena();
}
inline void DcResult::set_indep_name(const ::std::string& value) {
  
  indep_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.indep_name)
}
#if LANG_CXX11
inline void DcResult::set_indep_name(::std::string&& value) {
  
  indep_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcResult.indep_name)
}
#endif
inline void DcResult::set_indep_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  indep_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcResult.indep_name)
}
inline void DcResult::set_indep_name(const char* value, size_t size) {
  
  indep_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcResult.indep_name)
}
inline ::std::string* DcResult::mutable_indep_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.indep_name)
  return indep_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DcResult::release_indep_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.indep_name)
  
  return indep_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DcResult::set_allocated_indep_name(::std::string* indep_name) {
  if (indep_name != NULL) {
    
  } else {
    
  }
  indep_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), indep_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.indep_name)
}

// repeated string signals = 3;
inline int DcResult::signals_size() const {
  return signals_.size();
}
inline void DcResult::clear_signals() {
  signals_.Clear();
}
inline const ::std::string& DcResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.signals)
  return signals_.Get(index);
}
inline ::std::string* DcResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.signals)
  return signals_.Mutable(index);
}
inline void DcResult::set_signals(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.signals)
  signals_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DcResult::set_signals(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DcResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcResult.signals)
}
inline void DcResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcResult.signals)
}
inline ::std::string* DcResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.DcResult.signals)
  return signals_.Add();
}
inline void DcResult::add_signals(const ::std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.signals)
}
#if LANG_CXX11
inline void DcResult::add_signals(::std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.signals)
}
#endif
inline void DcResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.DcResult.signals)
}
inline void DcResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.DcResult.signals)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DcResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcResult.signals)
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DcResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int DcResult::data_size() const {
  return data_.size();
}
inline void DcResult::clear_data() {
  data_.Clear();
}
inline double DcResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.data)
  return data_.Get(index);
}
inline void DcResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.data)
}
inline void DcResult::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.data)
}
inline const ::google::protobuf::RepeatedField< double >&
DcResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcResult.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
DcResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcResult.data)
  return &data_;
}

// map<string, double> measurements = 10;
inline int DcResult::measurements_size() const {
  return measurements_.size();
}
inline void DcResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
DcResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.DcResult.measurements)
  return measurements_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
DcResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.DcResult.measurements)
  return measurements_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TranInput

// string analysis_name = 1;
inline void TranInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TranInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void TranInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.analysis_name)
}
#if LANG_CXX11
inline void TranInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.TranInput.analysis_name)
}
#endif
inline void TranInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranInput.analysis_name)
}
inline void TranInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranInput.analysis_name)
}
inline ::std::string* TranInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranInput.analysis_name)
}

// double tstop = 2;
inline void TranInput::clear_tstop() {
  tstop_ = 0;
}
inline double TranInput::tstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.tstop)
  return tstop_;
}
inline void TranInput::set_tstop(double value) {
  
  tstop_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.tstop)
}

// double tstep = 3;
inline void TranInput::clear_tstep() {
  tstep_ = 0;
}
inline double TranInput::tstep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.tstep)
  return tstep_;
}
inline void TranInput::set_tstep(double value) {
  
  tstep_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.tstep)
}

// map<string, double> ic = 4;
inline int TranInput::ic_size() const {
  return ic_.size();
}
inline void TranInput::clear_ic() {
  ic_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
TranInput::ic() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.TranInput.ic)
  return ic_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
TranInput::mutable_ic() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.TranInput.ic)
  return ic_.MutableMap();
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int TranInput::ctrls_size() const {
  return ctrls_.size();
}
inline void TranInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* TranInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
TranInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& TranInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* TranInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.TranInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
TranInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranInput.ctrls)
  return ctrls_;
}

// string raw = 6;
inline void TranInput::clear_raw() {
  raw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TranInput::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.raw)
  return raw_.GetNoArena();
}
inline void TranInput::set_raw(const ::std::string& value) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.raw)
}
#if LANG_CXX11
inline void TranInput::set_raw(::std::string&& value) {
  
  raw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.TranInput.raw)
}
#endif
inline void TranInput::set_raw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranInput.raw)
}
inline void TranInput::set_raw(const char* value, size_t size) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranInput.raw)
}
inline ::std::string* TranInput::mutable_raw() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.raw)
  return raw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranInput::release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranInput.raw)
  
  return raw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranInput::set_allocated_raw(::std::string* raw) {
  if (raw != NULL) {
    
  } else {
    
  }
  raw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranInput.raw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TranResult

// string analysis_name = 1;
inline void TranResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TranResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void TranResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.analysis_name)
}
#if LANG_CXX11
inline void TranResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.TranResult.analysis_name)
}
#endif
inline void TranResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranResult.analysis_name)
}
inline void TranResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranResult.analysis_name)
}
inline ::std::string* TranResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranResult.analysis_name)
}

// repeated string signals = 3;
inline int TranResult::signals_size() const {
  return signals_.size();
}
inline void TranResult::clear_signals() {
  signals_.Clear();
}
inline const ::std::string& TranResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.signals)
  return signals_.Get(index);
}
inline ::std::string* TranResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranResult.signals)
  return signals_.Mutable(index);
}
inline void TranResult::set_signals(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.signals)
  signals_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TranResult::set_signals(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TranResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranResult.signals)
}
inline void TranResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranResult.signals)
}
inline ::std::string* TranResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.TranResult.signals)
  return signals_.Add();
}
inline void TranResult::add_signals(const ::std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.signals)
}
#if LANG_CXX11
inline void TranResult::add_signals(::std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.signals)
}
#endif
inline void TranResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.TranResult.signals)
}
inline void TranResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.TranResult.signals)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TranResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranResult.signals)
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TranResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int TranResult::data_size() const {
  return data_.size();
}
inline void TranResult::clear_data() {
  data_.Clear();
}
inline double TranResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.data)
  return data_.Get(index);
}
inline void TranResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.data)
}
inline void TranResult::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.data)
}
inline const ::google::protobuf::RepeatedField< double >&
TranResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranResult.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
TranResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranResult.data)
  return &data_;
}

// map<string, double> measurements = 10;
inline int TranResult::measurements_size() const {
  return measurements_.size();
}
inline void TranResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
TranResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.TranResult.measurements)
  return measurements_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
TranResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.TranResult.measurements)
  return measurements_.MutableMap();
}

// -------------------------------------------------------------------

// ComplexNum

// double re = 1;
inline void ComplexNum::clear_re() {
  re_ = 0;
}
inline double ComplexNum::re() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.ComplexNum.re)
  return re_;
}
inline void ComplexNum::set_re(double value) {
  
  re_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.ComplexNum.re)
}

// double im = 2;
inline void ComplexNum::clear_im() {
  im_ = 0;
}
inline double ComplexNum::im() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.ComplexNum.im)
  return im_;
}
inline void ComplexNum::set_im(double value) {
  
  im_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.ComplexNum.im)
}

// -------------------------------------------------------------------

// AcInput

// string analysis_name = 1;
inline void AcInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AcInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void AcInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.analysis_name)
}
#if LANG_CXX11
inline void AcInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.AcInput.analysis_name)
}
#endif
inline void AcInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcInput.analysis_name)
}
inline void AcInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcInput.analysis_name)
}
inline ::std::string* AcInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcInput.analysis_name)
}

// double fstart = 2;
inline void AcInput::clear_fstart() {
  fstart_ = 0;
}
inline double AcInput::fstart() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.fstart)
  return fstart_;
}
inline void AcInput::set_fstart(double value) {
  
  fstart_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.fstart)
}

// double fstop = 3;
inline void AcInput::clear_fstop() {
  fstop_ = 0;
}
inline double AcInput::fstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.fstop)
  return fstop_;
}
inline void AcInput::set_fstop(double value) {
  
  fstop_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.fstop)
}

// uint64 npts = 4;
inline void AcInput::clear_npts() {
  npts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AcInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.npts)
  return npts_;
}
inline void AcInput::set_npts(::google::protobuf::uint64 value) {
  
  npts_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.npts)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int AcInput::ctrls_size() const {
  return ctrls_.size();
}
inline void AcInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* AcInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
AcInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& AcInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* AcInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.AcInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
AcInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcInput.ctrls)
  return ctrls_;
}

// string raw = 6;
inline void AcInput::clear_raw() {
  raw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AcInput::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.raw)
  return raw_.GetNoArena();
}
inline void AcInput::set_raw(const ::std::string& value) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.raw)
}
#if LANG_CXX11
inline void AcInput::set_raw(::std::string&& value) {
  
  raw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.AcInput.raw)
}
#endif
inline void AcInput::set_raw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcInput.raw)
}
inline void AcInput::set_raw(const char* value, size_t size) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcInput.raw)
}
inline ::std::string* AcInput::mutable_raw() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.raw)
  return raw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcInput::release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcInput.raw)
  
  return raw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcInput::set_allocated_raw(::std::string* raw) {
  if (raw != NULL) {
    
  } else {
    
  }
  raw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcInput.raw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AcResult

// string analysis_name = 1;
inline void AcResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AcResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void AcResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.analysis_name)
}
#if LANG_CXX11
inline void AcResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.AcResult.analysis_name)
}
#endif
inline void AcResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcResult.analysis_name)
}
inline void AcResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcResult.analysis_name)
}
inline ::std::string* AcResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcResult.analysis_name)
}

// repeated double freq = 2;
inline int AcResult::freq_size() const {
  return freq_.size();
}
inline void AcResult::clear_freq() {
  freq_.Clear();
}
inline double AcResult::freq(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.freq)
  return freq_.Get(index);
}
inline void AcResult::set_freq(int index, double value) {
  freq_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.freq)
}
inline void AcResult::add_freq(double value) {
  freq_.Add(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.freq)
}
inline const ::google::protobuf::RepeatedField< double >&
AcResult::freq() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.freq)
  return freq_;
}
inline ::google::protobuf::RepeatedField< double >*
AcResult::mutable_freq() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.freq)
  return &freq_;
}

// repeated string signals = 3;
inline int AcResult::signals_size() const {
  return signals_.size();
}
inline void AcResult::clear_signals() {
  signals_.Clear();
}
inline const ::std::string& AcResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.signals)
  return signals_.Get(index);
}
inline ::std::string* AcResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.signals)
  return signals_.Mutable(index);
}
inline void AcResult::set_signals(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.signals)
  signals_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AcResult::set_signals(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AcResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcResult.signals)
}
inline void AcResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcResult.signals)
}
inline ::std::string* AcResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.AcResult.signals)
  return signals_.Add();
}
inline void AcResult::add_signals(const ::std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.signals)
}
#if LANG_CXX11
inline void AcResult::add_signals(::std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.signals)
}
#endif
inline void AcResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.AcResult.signals)
}
inline void AcResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.AcResult.signals)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AcResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.signals)
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AcResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.signals)
  return &signals_;
}

// repeated .vlsir.spice.ComplexNum data = 5;
inline int AcResult::data_size() const {
  return data_.size();
}
inline void AcResult::clear_data() {
  data_.Clear();
}
inline ::vlsir::spice::ComplexNum* AcResult::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::ComplexNum >*
AcResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.data)
  return &data_;
}
inline const ::vlsir::spice::ComplexNum& AcResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.data)
  return data_.Get(index);
}
inline ::vlsir::spice::ComplexNum* AcResult::add_data() {
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::ComplexNum >&
AcResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.data)
  return data_;
}

// map<string, double> measurements = 10;
inline int AcResult::measurements_size() const {
  return measurements_.size();
}
inline void AcResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
AcResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.AcResult.measurements)
  return measurements_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
AcResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.AcResult.measurements)
  return measurements_.MutableMap();
}

// -------------------------------------------------------------------

// NoiseInput

// string analysis_name = 1;
inline void NoiseInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NoiseInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void NoiseInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.analysis_name)
}
#if LANG_CXX11
inline void NoiseInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.NoiseInput.analysis_name)
}
#endif
inline void NoiseInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseInput.analysis_name)
}
inline void NoiseInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseInput.analysis_name)
}
inline ::std::string* NoiseInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NoiseInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.NoiseInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NoiseInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.NoiseInput.analysis_name)
}

// string output_p = 2;
inline void NoiseInput::clear_output_p() {
  output_p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NoiseInput::output_p() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.output_p)
  return output_p_.GetNoArena();
}
inline void NoiseInput::set_output_p(const ::std::string& value) {
  
  output_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.output_p)
}
#if LANG_CXX11
inline void NoiseInput::set_output_p(::std::string&& value) {
  
  output_p_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.NoiseInput.output_p)
}
#endif
inline void NoiseInput::set_output_p(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  output_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseInput.output_p)
}
inline void NoiseInput::set_output_p(const char* value, size_t size) {
  
  output_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseInput.output_p)
}
inline ::std::string* NoiseInput::mutable_output_p() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseInput.output_p)
  return output_p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NoiseInput::release_output_p() {
  // @@protoc_insertion_point(field_release:vlsir.spice.NoiseInput.output_p)
  
  return output_p_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NoiseInput::set_allocated_output_p(::std::string* output_p) {
  if (output_p != NULL) {
    
  } else {
    
  }
  output_p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_p);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.NoiseInput.output_p)
}

// string output_n = 3;
inline void NoiseInput::clear_output_n() {
  output_n_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NoiseInput::output_n() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.output_n)
  return output_n_.GetNoArena();
}
inline void NoiseInput::set_output_n(const ::std::string& value) {
  
  output_n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.output_n)
}
#if LANG_CXX11
inline void NoiseInput::set_output_n(::std::string&& value) {
  
  output_n_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.NoiseInput.output_n)
}
#endif
inline void NoiseInput::set_output_n(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  output_n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseInput.output_n)
}
inline void NoiseInput::set_output_n(const char* value, size_t size) {
  
  output_n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseInput.output_n)
}
inline ::std::string* NoiseInput::mutable_output_n() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseInput.output_n)
  return output_n_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NoiseInput::release_output_n() {
  // @@protoc_insertion_point(field_release:vlsir.spice.NoiseInput.output_n)
  
  return output_n_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NoiseInput::set_allocated_output_n(::std::string* output_n) {
  if (output_n != NULL) {
    
  } else {
    
  }
  output_n_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_n);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.NoiseInput.output_n)
}

// string input_source = 4;
inline void NoiseInput::clear_input_source() {
  input_source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NoiseInput::input_source() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.input_source)
  return input_source_.GetNoArena();
}
inline void NoiseInput::set_input_source(const ::std::string& value) {
  
  input_source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.input_source)
}
#if LANG_CXX11
inline void NoiseInput::set_input_source(::std::string&& value) {
  
  input_source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.NoiseInput.input_source)
}
#endif
inline void NoiseInput::set_input_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseInput.input_source)
}
inline void NoiseInput::set_input_source(const char* value, size_t size) {
  
  input_source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseInput.input_source)
}
inline ::std::string* NoiseInput::mutable_input_source() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseInput.input_source)
  return input_source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NoiseInput::release_input_source() {
  // @@protoc_insertion_point(field_release:vlsir.spice.NoiseInput.input_source)
  
  return input_source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NoiseInput::set_allocated_input_source(::std::string* input_source) {
  if (input_source != NULL) {
    
  } else {
    
  }
  input_source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_source);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.NoiseInput.input_source)
}

// double fstart = 10;
inline void NoiseInput::clear_fstart() {
  fstart_ = 0;
}
inline double NoiseInput::fstart() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.fstart)
  return fstart_;
}
inline void NoiseInput::set_fstart(double value) {
  
  fstart_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.fstart)
}

// double fstop = 11;
inline void NoiseInput::clear_fstop() {
  fstop_ = 0;
}
inline double NoiseInput::fstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.fstop)
  return fstop_;
}
inline void NoiseInput::set_fstop(double value) {
  
  fstop_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.fstop)
}

// uint64 npts = 12;
inline void NoiseInput::clear_npts() {
  npts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NoiseInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.npts)
  return npts_;
}
inline void NoiseInput::set_npts(::google::protobuf::uint64 value) {
  
  npts_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.npts)
}

// repeated .vlsir.spice.Control ctrls = 20;
inline int NoiseInput::ctrls_size() const {
  return ctrls_.size();
}
inline void NoiseInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* NoiseInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
NoiseInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.NoiseInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& NoiseInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* NoiseInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.NoiseInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
NoiseInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.NoiseInput.ctrls)
  return ctrls_;
}

// string raw = 6;
inline void NoiseInput::clear_raw() {
  raw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NoiseInput::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseInput.raw)
  return raw_.GetNoArena();
}
inline void NoiseInput::set_raw(const ::std::string& value) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseInput.raw)
}
#if LANG_CXX11
inline void NoiseInput::set_raw(::std::string&& value) {
  
  raw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.NoiseInput.raw)
}
#endif
inline void NoiseInput::set_raw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseInput.raw)
}
inline void NoiseInput::set_raw(const char* value, size_t size) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseInput.raw)
}
inline ::std::string* NoiseInput::mutable_raw() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseInput.raw)
  return raw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NoiseInput::release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.spice.NoiseInput.raw)
  
  return raw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NoiseInput::set_allocated_raw(::std::string* raw) {
  if (raw != NULL) {
    
  } else {
    
  }
  raw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.NoiseInput.raw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NoiseResult

// string analysis_name = 1;
inline void NoiseResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NoiseResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void NoiseResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseResult.analysis_name)
}
#if LANG_CXX11
inline void NoiseResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.NoiseResult.analysis_name)
}
#endif
inline void NoiseResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseResult.analysis_name)
}
inline void NoiseResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseResult.analysis_name)
}
inline ::std::string* NoiseResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NoiseResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.NoiseResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NoiseResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.NoiseResult.analysis_name)
}

// repeated string signals = 3;
inline int NoiseResult::signals_size() const {
  return signals_.size();
}
inline void NoiseResult::clear_signals() {
  signals_.Clear();
}
inline const ::std::string& NoiseResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseResult.signals)
  return signals_.Get(index);
}
inline ::std::string* NoiseResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.NoiseResult.signals)
  return signals_.Mutable(index);
}
inline void NoiseResult::set_signals(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseResult.signals)
  signals_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NoiseResult::set_signals(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NoiseResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.NoiseResult.signals)
}
inline void NoiseResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.NoiseResult.signals)
}
inline ::std::string* NoiseResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.NoiseResult.signals)
  return signals_.Add();
}
inline void NoiseResult::add_signals(const ::std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.NoiseResult.signals)
}
#if LANG_CXX11
inline void NoiseResult::add_signals(::std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.NoiseResult.signals)
}
#endif
inline void NoiseResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.NoiseResult.signals)
}
inline void NoiseResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.NoiseResult.signals)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NoiseResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.NoiseResult.signals)
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NoiseResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.NoiseResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int NoiseResult::data_size() const {
  return data_.size();
}
inline void NoiseResult::clear_data() {
  data_.Clear();
}
inline double NoiseResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.NoiseResult.data)
  return data_.Get(index);
}
inline void NoiseResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.NoiseResult.data)
}
inline void NoiseResult::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.NoiseResult.data)
}
inline const ::google::protobuf::RepeatedField< double >&
NoiseResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.NoiseResult.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
NoiseResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.NoiseResult.data)
  return &data_;
}

// map<string, double> integrated_noise = 10;
inline int NoiseResult::integrated_noise_size() const {
  return integrated_noise_.size();
}
inline void NoiseResult::clear_integrated_noise() {
  integrated_noise_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
NoiseResult::integrated_noise() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.NoiseResult.integrated_noise)
  return integrated_noise_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
NoiseResult::mutable_integrated_noise() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.NoiseResult.integrated_noise)
  return integrated_noise_.MutableMap();
}

// map<string, double> measurements = 11;
inline int NoiseResult::measurements_size() const {
  return measurements_.size();
}
inline void NoiseResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
NoiseResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.NoiseResult.measurements)
  return measurements_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
NoiseResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.NoiseResult.measurements)
  return measurements_.MutableMap();
}

// -------------------------------------------------------------------

// SweepInput

// string analysis_name = 1;
inline void SweepInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SweepInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void SweepInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepInput.analysis_name)
}
#if LANG_CXX11
inline void SweepInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepInput.analysis_name)
}
#endif
inline void SweepInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepInput.analysis_name)
}
inline void SweepInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepInput.analysis_name)
}
inline ::std::string* SweepInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SweepInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SweepInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.analysis_name)
}

// string variable = 2;
inline void SweepInput::clear_variable() {
  variable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SweepInput::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.variable)
  return variable_.GetNoArena();
}
inline void SweepInput::set_variable(const ::std::string& value) {
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepInput.variable)
}
#if LANG_CXX11
inline void SweepInput::set_variable(::std::string&& value) {
  
  variable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepInput.variable)
}
#endif
inline void SweepInput::set_variable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepInput.variable)
}
inline void SweepInput::set_variable(const char* value, size_t size) {
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepInput.variable)
}
inline ::std::string* SweepInput::mutable_variable() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.variable)
  return variable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SweepInput::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.variable)
  
  return variable_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SweepInput::set_allocated_variable(::std::string* variable) {
  if (variable != NULL) {
    
  } else {
    
  }
  variable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool SweepInput::has_sweep() const {
  return this != internal_default_instance() && sweep_ != NULL;
}
inline void SweepInput::clear_sweep() {
  if (GetArenaNoVirtual() == NULL && sweep_ != NULL) {
    delete sweep_;
  }
  sweep_ = NULL;
}
inline const ::vlsir::spice::Sweep& SweepInput::_internal_sweep() const {
  return *sweep_;
}
inline const ::vlsir::spice::Sweep& SweepInput::sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.sweep)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline ::vlsir::spice::Sweep* SweepInput::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = NULL;
  return temp;
}
inline ::vlsir::spice::Sweep* SweepInput::mutable_sweep() {
  
  if (sweep_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaNoVirtual());
    sweep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.sweep)
  return sweep_;
}
inline void SweepInput::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sweep_;
  }
  if (sweep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sweep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.sweep)
}

// repeated .vlsir.spice.Analysis an = 4;
inline int SweepInput::an_size() const {
  return an_.size();
}
inline void SweepInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* SweepInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.an)
  return an_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >*
SweepInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& SweepInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.an)
  return an_.Get(index);
}
inline ::vlsir::spice::Analysis* SweepInput::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepInput.an)
  return an_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >&
SweepInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int SweepInput::ctrls_size() const {
  return ctrls_.size();
}
inline void SweepInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* SweepInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
SweepInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& SweepInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* SweepInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
SweepInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// SweepResult

// string analysis_name = 1;
inline void SweepResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SweepResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void SweepResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepResult.analysis_name)
}
#if LANG_CXX11
inline void SweepResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepResult.analysis_name)
}
#endif
inline void SweepResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepResult.analysis_name)
}
inline void SweepResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepResult.analysis_name)
}
inline ::std::string* SweepResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SweepResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SweepResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.analysis_name)
}

// string variable = 2;
inline void SweepResult::clear_variable() {
  variable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SweepResult::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.variable)
  return variable_.GetNoArena();
}
inline void SweepResult::set_variable(const ::std::string& value) {
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepResult.variable)
}
#if LANG_CXX11
inline void SweepResult::set_variable(::std::string&& value) {
  
  variable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepResult.variable)
}
#endif
inline void SweepResult::set_variable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepResult.variable)
}
inline void SweepResult::set_variable(const char* value, size_t size) {
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepResult.variable)
}
inline ::std::string* SweepResult::mutable_variable() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.variable)
  return variable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SweepResult::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.variable)
  
  return variable_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SweepResult::set_allocated_variable(::std::string* variable) {
  if (variable != NULL) {
    
  } else {
    
  }
  variable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool SweepResult::has_sweep() const {
  return this != internal_default_instance() && sweep_ != NULL;
}
inline void SweepResult::clear_sweep() {
  if (GetArenaNoVirtual() == NULL && sweep_ != NULL) {
    delete sweep_;
  }
  sweep_ = NULL;
}
inline const ::vlsir::spice::Sweep& SweepResult::_internal_sweep() const {
  return *sweep_;
}
inline const ::vlsir::spice::Sweep& SweepResult::sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.sweep)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline ::vlsir::spice::Sweep* SweepResult::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = NULL;
  return temp;
}
inline ::vlsir::spice::Sweep* SweepResult::mutable_sweep() {
  
  if (sweep_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaNoVirtual());
    sweep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.sweep)
  return sweep_;
}
inline void SweepResult::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sweep_;
  }
  if (sweep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sweep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.sweep)
}

// repeated .vlsir.spice.AnalysisResult an = 4;
inline int SweepResult::an_size() const {
  return an_.size();
}
inline void SweepResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* SweepResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.an)
  return an_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
SweepResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& SweepResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.an)
  return an_.Get(index);
}
inline ::vlsir::spice::AnalysisResult* SweepResult::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepResult.an)
  return an_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
SweepResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepResult.an)
  return an_;
}

// -------------------------------------------------------------------

// MonteInput

// string analysis_name = 1;
inline void MonteInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MonteInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void MonteInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.analysis_name)
}
#if LANG_CXX11
inline void MonteInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.MonteInput.analysis_name)
}
#endif
inline void MonteInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.MonteInput.analysis_name)
}
inline void MonteInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.MonteInput.analysis_name)
}
inline ::std::string* MonteInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MonteInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MonteInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteInput.analysis_name)
}

// int64 npts = 2;
inline void MonteInput::clear_npts() {
  npts_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MonteInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.npts)
  return npts_;
}
inline void MonteInput::set_npts(::google::protobuf::int64 value) {
  
  npts_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.npts)
}

// int64 seed = 3;
inline void MonteInput::clear_seed() {
  seed_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MonteInput::seed() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.seed)
  return seed_;
}
inline void MonteInput::set_seed(::google::protobuf::int64 value) {
  
  seed_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.seed)
}

// repeated .vlsir.spice.Analysis an = 4;
inline int MonteInput::an_size() const {
  return an_.size();
}
inline void MonteInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* MonteInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.an)
  return an_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >*
MonteInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& MonteInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.an)
  return an_.Get(index);
}
inline ::vlsir::spice::Analysis* MonteInput::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteInput.an)
  return an_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Analysis >&
MonteInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int MonteInput::ctrls_size() const {
  return ctrls_.size();
}
inline void MonteInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* MonteInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
MonteInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& MonteInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* MonteInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
MonteInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// MonteResult

// string analysis_name = 1;
inline void MonteResult::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MonteResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void MonteResult::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteResult.analysis_name)
}
#if LANG_CXX11
inline void MonteResult::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.MonteResult.analysis_name)
}
#endif
inline void MonteResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.MonteResult.analysis_name)
}
inline void MonteResult::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.MonteResult.analysis_name)
}
inline ::std::string* MonteResult::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MonteResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MonteResult::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.analysis_name)
}

// string variable = 2;
inline void MonteResult::clear_variable() {
  variable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MonteResult::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.variable)
  return variable_.GetNoArena();
}
inline void MonteResult::set_variable(const ::std::string& value) {
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteResult.variable)
}
#if LANG_CXX11
inline void MonteResult::set_variable(::std::string&& value) {
  
  variable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.MonteResult.variable)
}
#endif
inline void MonteResult::set_variable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.MonteResult.variable)
}
inline void MonteResult::set_variable(const char* value, size_t size) {
  
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.MonteResult.variable)
}
inline ::std::string* MonteResult::mutable_variable() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.variable)
  return variable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MonteResult::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.variable)
  
  return variable_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MonteResult::set_allocated_variable(::std::string* variable) {
  if (variable != NULL) {
    
  } else {
    
  }
  variable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool MonteResult::has_sweep() const {
  return this != internal_default_instance() && sweep_ != NULL;
}
inline void MonteResult::clear_sweep() {
  if (GetArenaNoVirtual() == NULL && sweep_ != NULL) {
    delete sweep_;
  }
  sweep_ = NULL;
}
inline const ::vlsir::spice::Sweep& MonteResult::_internal_sweep() const {
  return *sweep_;
}
inline const ::vlsir::spice::Sweep& MonteResult::sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.sweep)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline ::vlsir::spice::Sweep* MonteResult::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = NULL;
  return temp;
}
inline ::vlsir::spice::Sweep* MonteResult::mutable_sweep() {
  
  if (sweep_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArenaNoVirtual());
    sweep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.sweep)
  return sweep_;
}
inline void MonteResult::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sweep_;
  }
  if (sweep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sweep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.sweep)
}

// repeated .vlsir.spice.AnalysisResult an = 4;
inline int MonteResult::an_size() const {
  return an_.size();
}
inline void MonteResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* MonteResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.an)
  return an_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
MonteResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& MonteResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.an)
  return an_.Get(index);
}
inline ::vlsir::spice::AnalysisResult* MonteResult::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteResult.an)
  return an_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
MonteResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteResult.an)
  return an_;
}

// -------------------------------------------------------------------

// CustomAnalysisInput

// string analysis_name = 1;
inline void CustomAnalysisInput::clear_analysis_name() {
  analysis_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomAnalysisInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.analysis_name)
  return analysis_name_.GetNoArena();
}
inline void CustomAnalysisInput::set_analysis_name(const ::std::string& value) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.CustomAnalysisInput.analysis_name)
}
#if LANG_CXX11
inline void CustomAnalysisInput::set_analysis_name(::std::string&& value) {
  
  analysis_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.CustomAnalysisInput.analysis_name)
}
#endif
inline void CustomAnalysisInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline void CustomAnalysisInput::set_analysis_name(const char* value, size_t size) {
  
  analysis_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline ::std::string* CustomAnalysisInput::mutable_analysis_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.analysis_name)
  return analysis_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomAnalysisInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.CustomAnalysisInput.analysis_name)
  
  return analysis_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomAnalysisInput::set_allocated_analysis_name(::std::string* analysis_name) {
  if (analysis_name != NULL) {
    
  } else {
    
  }
  analysis_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.CustomAnalysisInput.analysis_name)
}

// string cmd = 2;
inline void CustomAnalysisInput::clear_cmd() {
  cmd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomAnalysisInput::cmd() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.cmd)
  return cmd_.GetNoArena();
}
inline void CustomAnalysisInput::set_cmd(const ::std::string& value) {
  
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.CustomAnalysisInput.cmd)
}
#if LANG_CXX11
inline void CustomAnalysisInput::set_cmd(::std::string&& value) {
  
  cmd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.CustomAnalysisInput.cmd)
}
#endif
inline void CustomAnalysisInput::set_cmd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.CustomAnalysisInput.cmd)
}
inline void CustomAnalysisInput::set_cmd(const char* value, size_t size) {
  
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.CustomAnalysisInput.cmd)
}
inline ::std::string* CustomAnalysisInput::mutable_cmd() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.cmd)
  return cmd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomAnalysisInput::release_cmd() {
  // @@protoc_insertion_point(field_release:vlsir.spice.CustomAnalysisInput.cmd)
  
  return cmd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomAnalysisInput::set_allocated_cmd(::std::string* cmd) {
  if (cmd != NULL) {
    
  } else {
    
  }
  cmd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmd);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.CustomAnalysisInput.cmd)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int CustomAnalysisInput::ctrls_size() const {
  return ctrls_.size();
}
inline void CustomAnalysisInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* CustomAnalysisInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >*
CustomAnalysisInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.CustomAnalysisInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& CustomAnalysisInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_.Get(index);
}
inline ::vlsir::spice::Control* CustomAnalysisInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::spice::Control >&
CustomAnalysisInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// CustomAnalysisResult

// -------------------------------------------------------------------

// Sweep

// .vlsir.spice.LinearSweep linear = 1;
inline bool Sweep::has_linear() const {
  return tp_case() == kLinear;
}
inline void Sweep::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void Sweep::clear_linear() {
  if (has_linear()) {
    delete tp_.linear_;
    clear_has_tp();
  }
}
inline const ::vlsir::spice::LinearSweep& Sweep::_internal_linear() const {
  return *tp_.linear_;
}
inline ::vlsir::spice::LinearSweep* Sweep::release_linear() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.linear)
  if (has_linear()) {
    clear_has_tp();
      ::vlsir::spice::LinearSweep* temp = tp_.linear_;
    tp_.linear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::LinearSweep& Sweep::linear() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.linear)
  return has_linear()
      ? *tp_.linear_
      : *reinterpret_cast< ::vlsir::spice::LinearSweep*>(&::vlsir::spice::_LinearSweep_default_instance_);
}
inline ::vlsir::spice::LinearSweep* Sweep::mutable_linear() {
  if (!has_linear()) {
    clear_tp();
    set_has_linear();
    tp_.linear_ = CreateMaybeMessage< ::vlsir::spice::LinearSweep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.linear)
  return tp_.linear_;
}

// .vlsir.spice.LogSweep log = 2;
inline bool Sweep::has_log() const {
  return tp_case() == kLog;
}
inline void Sweep::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void Sweep::clear_log() {
  if (has_log()) {
    delete tp_.log_;
    clear_has_tp();
  }
}
inline const ::vlsir::spice::LogSweep& Sweep::_internal_log() const {
  return *tp_.log_;
}
inline ::vlsir::spice::LogSweep* Sweep::release_log() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.log)
  if (has_log()) {
    clear_has_tp();
      ::vlsir::spice::LogSweep* temp = tp_.log_;
    tp_.log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::LogSweep& Sweep::log() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.log)
  return has_log()
      ? *tp_.log_
      : *reinterpret_cast< ::vlsir::spice::LogSweep*>(&::vlsir::spice::_LogSweep_default_instance_);
}
inline ::vlsir::spice::LogSweep* Sweep::mutable_log() {
  if (!has_log()) {
    clear_tp();
    set_has_log();
    tp_.log_ = CreateMaybeMessage< ::vlsir::spice::LogSweep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.log)
  return tp_.log_;
}

// .vlsir.spice.PointSweep points = 3;
inline bool Sweep::has_points() const {
  return tp_case() == kPoints;
}
inline void Sweep::set_has_points() {
  _oneof_case_[0] = kPoints;
}
inline void Sweep::clear_points() {
  if (has_points()) {
    delete tp_.points_;
    clear_has_tp();
  }
}
inline const ::vlsir::spice::PointSweep& Sweep::_internal_points() const {
  return *tp_.points_;
}
inline ::vlsir::spice::PointSweep* Sweep::release_points() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.points)
  if (has_points()) {
    clear_has_tp();
      ::vlsir::spice::PointSweep* temp = tp_.points_;
    tp_.points_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::PointSweep& Sweep::points() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.points)
  return has_points()
      ? *tp_.points_
      : *reinterpret_cast< ::vlsir::spice::PointSweep*>(&::vlsir::spice::_PointSweep_default_instance_);
}
inline ::vlsir::spice::PointSweep* Sweep::mutable_points() {
  if (!has_points()) {
    clear_tp();
    set_has_points();
    tp_.points_ = CreateMaybeMessage< ::vlsir::spice::PointSweep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.points)
  return tp_.points_;
}

inline bool Sweep::has_tp() const {
  return tp_case() != TP_NOT_SET;
}
inline void Sweep::clear_has_tp() {
  _oneof_case_[0] = TP_NOT_SET;
}
inline Sweep::TpCase Sweep::tp_case() const {
  return Sweep::TpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinearSweep

// double start = 1;
inline void LinearSweep::clear_start() {
  start_ = 0;
}
inline double LinearSweep::start() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.start)
  return start_;
}
inline void LinearSweep::set_start(double value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.start)
}

// double stop = 2;
inline void LinearSweep::clear_stop() {
  stop_ = 0;
}
inline double LinearSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.stop)
  return stop_;
}
inline void LinearSweep::set_stop(double value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.stop)
}

// double step = 3;
inline void LinearSweep::clear_step() {
  step_ = 0;
}
inline double LinearSweep::step() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.step)
  return step_;
}
inline void LinearSweep::set_step(double value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.step)
}

// -------------------------------------------------------------------

// LogSweep

// double start = 1;
inline void LogSweep::clear_start() {
  start_ = 0;
}
inline double LogSweep::start() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.start)
  return start_;
}
inline void LogSweep::set_start(double value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.start)
}

// double stop = 2;
inline void LogSweep::clear_stop() {
  stop_ = 0;
}
inline double LogSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.stop)
  return stop_;
}
inline void LogSweep::set_stop(double value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.stop)
}

// double npts = 3;
inline void LogSweep::clear_npts() {
  npts_ = 0;
}
inline double LogSweep::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.npts)
  return npts_;
}
inline void LogSweep::set_npts(double value) {
  
  npts_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.npts)
}

// -------------------------------------------------------------------

// PointSweep

// repeated double points = 1;
inline int PointSweep::points_size() const {
  return points_.size();
}
inline void PointSweep::clear_points() {
  points_.Clear();
}
inline double PointSweep::points(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.points)
  return points_.Get(index);
}
inline void PointSweep::set_points(int index, double value) {
  points_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.points)
}
inline void PointSweep::add_points(double value) {
  points_.Add(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.PointSweep.points)
}
inline const ::google::protobuf::RepeatedField< double >&
PointSweep::points() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.PointSweep.points)
  return points_;
}
inline ::google::protobuf::RepeatedField< double >*
PointSweep::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.PointSweep.points)
  return &points_;
}

// double stop = 2;
inline void PointSweep::clear_stop() {
  stop_ = 0;
}
inline double PointSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.stop)
  return stop_;
}
inline void PointSweep::set_stop(double value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.stop)
}

// double npts = 3;
inline void PointSweep::clear_npts() {
  npts_ = 0;
}
inline double PointSweep::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.npts)
  return npts_;
}
inline void PointSweep::set_npts(double value) {
  
  npts_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.npts)
}

// -------------------------------------------------------------------

// Control

// .vlsir.spice.Include include = 1;
inline bool Control::has_include() const {
  return ctrl_case() == kInclude;
}
inline void Control::set_has_include() {
  _oneof_case_[0] = kInclude;
}
inline void Control::clear_include() {
  if (has_include()) {
    delete ctrl_.include_;
    clear_has_ctrl();
  }
}
inline const ::vlsir::spice::Include& Control::_internal_include() const {
  return *ctrl_.include_;
}
inline ::vlsir::spice::Include* Control::release_include() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.include)
  if (has_include()) {
    clear_has_ctrl();
      ::vlsir::spice::Include* temp = ctrl_.include_;
    ctrl_.include_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::Include& Control::include() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.include)
  return has_include()
      ? *ctrl_.include_
      : *reinterpret_cast< ::vlsir::spice::Include*>(&::vlsir::spice::_Include_default_instance_);
}
inline ::vlsir::spice::Include* Control::mutable_include() {
  if (!has_include()) {
    clear_ctrl();
    set_has_include();
    ctrl_.include_ = CreateMaybeMessage< ::vlsir::spice::Include >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.include)
  return ctrl_.include_;
}

// .vlsir.spice.LibInclude lib = 2;
inline bool Control::has_lib() const {
  return ctrl_case() == kLib;
}
inline void Control::set_has_lib() {
  _oneof_case_[0] = kLib;
}
inline void Control::clear_lib() {
  if (has_lib()) {
    delete ctrl_.lib_;
    clear_has_ctrl();
  }
}
inline const ::vlsir::spice::LibInclude& Control::_internal_lib() const {
  return *ctrl_.lib_;
}
inline ::vlsir::spice::LibInclude* Control::release_lib() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.lib)
  if (has_lib()) {
    clear_has_ctrl();
      ::vlsir::spice::LibInclude* temp = ctrl_.lib_;
    ctrl_.lib_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::LibInclude& Control::lib() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.lib)
  return has_lib()
      ? *ctrl_.lib_
      : *reinterpret_cast< ::vlsir::spice::LibInclude*>(&::vlsir::spice::_LibInclude_default_instance_);
}
inline ::vlsir::spice::LibInclude* Control::mutable_lib() {
  if (!has_lib()) {
    clear_ctrl();
    set_has_lib();
    ctrl_.lib_ = CreateMaybeMessage< ::vlsir::spice::LibInclude >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.lib)
  return ctrl_.lib_;
}

// .vlsir.spice.Save save = 5;
inline bool Control::has_save() const {
  return ctrl_case() == kSave;
}
inline void Control::set_has_save() {
  _oneof_case_[0] = kSave;
}
inline void Control::clear_save() {
  if (has_save()) {
    delete ctrl_.save_;
    clear_has_ctrl();
  }
}
inline const ::vlsir::spice::Save& Control::_internal_save() const {
  return *ctrl_.save_;
}
inline ::vlsir::spice::Save* Control::release_save() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.save)
  if (has_save()) {
    clear_has_ctrl();
      ::vlsir::spice::Save* temp = ctrl_.save_;
    ctrl_.save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::Save& Control::save() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.save)
  return has_save()
      ? *ctrl_.save_
      : *reinterpret_cast< ::vlsir::spice::Save*>(&::vlsir::spice::_Save_default_instance_);
}
inline ::vlsir::spice::Save* Control::mutable_save() {
  if (!has_save()) {
    clear_ctrl();
    set_has_save();
    ctrl_.save_ = CreateMaybeMessage< ::vlsir::spice::Save >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.save)
  return ctrl_.save_;
}

// .vlsir.spice.Meas meas = 6;
inline bool Control::has_meas() const {
  return ctrl_case() == kMeas;
}
inline void Control::set_has_meas() {
  _oneof_case_[0] = kMeas;
}
inline void Control::clear_meas() {
  if (has_meas()) {
    delete ctrl_.meas_;
    clear_has_ctrl();
  }
}
inline const ::vlsir::spice::Meas& Control::_internal_meas() const {
  return *ctrl_.meas_;
}
inline ::vlsir::spice::Meas* Control::release_meas() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.meas)
  if (has_meas()) {
    clear_has_ctrl();
      ::vlsir::spice::Meas* temp = ctrl_.meas_;
    ctrl_.meas_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::spice::Meas& Control::meas() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.meas)
  return has_meas()
      ? *ctrl_.meas_
      : *reinterpret_cast< ::vlsir::spice::Meas*>(&::vlsir::spice::_Meas_default_instance_);
}
inline ::vlsir::spice::Meas* Control::mutable_meas() {
  if (!has_meas()) {
    clear_ctrl();
    set_has_meas();
    ctrl_.meas_ = CreateMaybeMessage< ::vlsir::spice::Meas >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.meas)
  return ctrl_.meas_;
}

// .vlsir.utils.Param param = 7;
inline bool Control::has_param() const {
  return ctrl_case() == kParam;
}
inline void Control::set_has_param() {
  _oneof_case_[0] = kParam;
}
inline const ::vlsir::utils::Param& Control::_internal_param() const {
  return *ctrl_.param_;
}
inline ::vlsir::utils::Param* Control::release_param() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.param)
  if (has_param()) {
    clear_has_ctrl();
      ::vlsir::utils::Param* temp = ctrl_.param_;
    ctrl_.param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::utils::Param& Control::param() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.param)
  return has_param()
      ? *ctrl_.param_
      : *reinterpret_cast< ::vlsir::utils::Param*>(&::vlsir::utils::_Param_default_instance_);
}
inline ::vlsir::utils::Param* Control::mutable_param() {
  if (!has_param()) {
    clear_ctrl();
    set_has_param();
    ctrl_.param_ = CreateMaybeMessage< ::vlsir::utils::Param >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.param)
  return ctrl_.param_;
}

// string literal = 10;
inline bool Control::has_literal() const {
  return ctrl_case() == kLiteral;
}
inline void Control::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Control::clear_literal() {
  if (has_literal()) {
    ctrl_.literal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ctrl();
  }
}
inline const ::std::string& Control::literal() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.literal)
  if (has_literal()) {
    return ctrl_.literal_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Control::set_literal(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Control.literal)
  if (!has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Control.literal)
}
#if LANG_CXX11
inline void Control::set_literal(::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Control.literal)
  if (!has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Control.literal)
}
#endif
inline void Control::set_literal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Control.literal)
}
inline void Control::set_literal(const char* value, size_t size) {
  if (!has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Control.literal)
}
inline ::std::string* Control::mutable_literal() {
  if (!has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.literal)
  return ctrl_.literal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Control::release_literal() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.literal)
  if (has_literal()) {
    clear_has_ctrl();
    return ctrl_.literal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Control::set_allocated_literal(::std::string* literal) {
  if (!has_literal()) {
    ctrl_.literal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_ctrl();
  if (literal != NULL) {
    set_has_literal();
    ctrl_.literal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), literal);
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.literal)
}

inline bool Control::has_ctrl() const {
  return ctrl_case() != CTRL_NOT_SET;
}
inline void Control::clear_has_ctrl() {
  _oneof_case_[0] = CTRL_NOT_SET;
}
inline Control::CtrlCase Control::ctrl_case() const {
  return Control::CtrlCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Save

// .vlsir.spice.Save.SaveMode mode = 1;
inline bool Save::has_mode() const {
  return save_case() == kMode;
}
inline void Save::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void Save::clear_mode() {
  if (has_mode()) {
    save_.mode_ = 0;
    clear_has_save();
  }
}
inline ::vlsir::spice::Save_SaveMode Save::mode() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Save.mode)
  if (has_mode()) {
    return static_cast< ::vlsir::spice::Save_SaveMode >(save_.mode_);
  }
  return static_cast< ::vlsir::spice::Save_SaveMode >(0);
}
inline void Save::set_mode(::vlsir::spice::Save_SaveMode value) {
  if (!has_mode()) {
    clear_save();
    set_has_mode();
  }
  save_.mode_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.mode)
}

// string signal = 2;
inline bool Save::has_signal() const {
  return save_case() == kSignal;
}
inline void Save::set_has_signal() {
  _oneof_case_[0] = kSignal;
}
inline void Save::clear_signal() {
  if (has_signal()) {
    save_.signal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_save();
  }
}
inline const ::std::string& Save::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Save.signal)
  if (has_signal()) {
    return save_.signal_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Save::set_signal(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.signal)
  if (!has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.signal)
}
#if LANG_CXX11
inline void Save::set_signal(::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.signal)
  if (!has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Save.signal)
}
#endif
inline void Save::set_signal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Save.signal)
}
inline void Save::set_signal(const char* value, size_t size) {
  if (!has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Save.signal)
}
inline ::std::string* Save::mutable_signal() {
  if (!has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Save.signal)
  return save_.signal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Save::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Save.signal)
  if (has_signal()) {
    clear_has_save();
    return save_.signal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Save::set_allocated_signal(::std::string* signal) {
  if (!has_signal()) {
    save_.signal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_save();
  if (signal != NULL) {
    set_has_signal();
    save_.signal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signal);
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Save.signal)
}

inline bool Save::has_save() const {
  return save_case() != SAVE_NOT_SET;
}
inline void Save::clear_has_save() {
  _oneof_case_[0] = SAVE_NOT_SET;
}
inline Save::SaveCase Save::save_case() const {
  return Save::SaveCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Include

// string path = 1;
inline void Include::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Include::path() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Include.path)
  return path_.GetNoArena();
}
inline void Include::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Include.path)
}
#if LANG_CXX11
inline void Include::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Include.path)
}
#endif
inline void Include::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Include.path)
}
inline void Include::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Include.path)
}
inline ::std::string* Include::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Include.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Include::release_path() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Include.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Include::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Include.path)
}

// -------------------------------------------------------------------

// LibInclude

// string path = 1;
inline void LibInclude::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInclude::path() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LibInclude.path)
  return path_.GetNoArena();
}
inline void LibInclude::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LibInclude.path)
}
#if LANG_CXX11
inline void LibInclude::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.LibInclude.path)
}
#endif
inline void LibInclude::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.LibInclude.path)
}
inline void LibInclude::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.LibInclude.path)
}
inline ::std::string* LibInclude::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.LibInclude.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInclude::release_path() {
  // @@protoc_insertion_point(field_release:vlsir.spice.LibInclude.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInclude::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.LibInclude.path)
}

// string section = 2;
inline void LibInclude::clear_section() {
  section_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInclude::section() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LibInclude.section)
  return section_.GetNoArena();
}
inline void LibInclude::set_section(const ::std::string& value) {
  
  section_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LibInclude.section)
}
#if LANG_CXX11
inline void LibInclude::set_section(::std::string&& value) {
  
  section_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.LibInclude.section)
}
#endif
inline void LibInclude::set_section(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  section_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.LibInclude.section)
}
inline void LibInclude::set_section(const char* value, size_t size) {
  
  section_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.LibInclude.section)
}
inline ::std::string* LibInclude::mutable_section() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.LibInclude.section)
  return section_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInclude::release_section() {
  // @@protoc_insertion_point(field_release:vlsir.spice.LibInclude.section)
  
  return section_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInclude::set_allocated_section(::std::string* section) {
  if (section != NULL) {
    
  } else {
    
  }
  section_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.LibInclude.section)
}

// -------------------------------------------------------------------

// Meas

// string analysis_type = 1;
inline void Meas::clear_analysis_type() {
  analysis_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Meas::analysis_type() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.analysis_type)
  return analysis_type_.GetNoArena();
}
inline void Meas::set_analysis_type(const ::std::string& value) {
  
  analysis_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.analysis_type)
}
#if LANG_CXX11
inline void Meas::set_analysis_type(::std::string&& value) {
  
  analysis_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Meas.analysis_type)
}
#endif
inline void Meas::set_analysis_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analysis_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Meas.analysis_type)
}
inline void Meas::set_analysis_type(const char* value, size_t size) {
  
  analysis_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Meas.analysis_type)
}
inline ::std::string* Meas::mutable_analysis_type() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.analysis_type)
  return analysis_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Meas::release_analysis_type() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.analysis_type)
  
  return analysis_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meas::set_allocated_analysis_type(::std::string* analysis_type) {
  if (analysis_type != NULL) {
    
  } else {
    
  }
  analysis_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analysis_type);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.analysis_type)
}

// string name = 2;
inline void Meas::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Meas::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.name)
  return name_.GetNoArena();
}
inline void Meas::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.name)
}
#if LANG_CXX11
inline void Meas::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Meas.name)
}
#endif
inline void Meas::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Meas.name)
}
inline void Meas::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Meas.name)
}
inline ::std::string* Meas::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Meas::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meas::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.name)
}

// string expr = 3;
inline void Meas::clear_expr() {
  expr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Meas::expr() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.expr)
  return expr_.GetNoArena();
}
inline void Meas::set_expr(const ::std::string& value) {
  
  expr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.expr)
}
#if LANG_CXX11
inline void Meas::set_expr(::std::string&& value) {
  
  expr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Meas.expr)
}
#endif
inline void Meas::set_expr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  expr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Meas.expr)
}
inline void Meas::set_expr(const char* value, size_t size) {
  
  expr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Meas.expr)
}
inline ::std::string* Meas::mutable_expr() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.expr)
  return expr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Meas::release_expr() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.expr)
  
  return expr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meas::set_allocated_expr(::std::string* expr) {
  if (expr != NULL) {
    
  } else {
    
  }
  expr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), expr);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.expr)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Signal.name)
  return name_.GetNoArena();
}
inline void Signal::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Signal.name)
}
#if LANG_CXX11
inline void Signal::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Signal.name)
}
#endif
inline void Signal::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Signal.name)
}
inline void Signal::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Signal.name)
}
inline ::std::string* Signal::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Signal.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Signal.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Signal.name)
}

// .vlsir.spice.Signal.Quantity quantity = 2;
inline void Signal::clear_quantity() {
  quantity_ = 0;
}
inline ::vlsir::spice::Signal_Quantity Signal::quantity() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Signal.quantity)
  return static_cast< ::vlsir::spice::Signal_Quantity >(quantity_);
}
inline void Signal::set_quantity(::vlsir::spice::Signal_Quantity value) {
  
  quantity_ = value;
  // @@protoc_insertion_point(field_set:vlsir.spice.Signal.quantity)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spice
}  // namespace vlsir

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vlsir::spice::Save_SaveMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::spice::Save_SaveMode>() {
  return ::vlsir::spice::Save_SaveMode_descriptor();
}
template <> struct is_proto_enum< ::vlsir::spice::Signal_Quantity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::spice::Signal_Quantity>() {
  return ::vlsir::spice::Signal_Quantity_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_spice_2eproto
