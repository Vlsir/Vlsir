// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spice.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_spice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_spice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "utils.pb.h"
#include "circuit.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_spice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spice_2eproto;
namespace vlsir {
namespace spice {
class AcInput;
class AcInputDefaultTypeInternal;
extern AcInputDefaultTypeInternal _AcInput_default_instance_;
class AcResult;
class AcResultDefaultTypeInternal;
extern AcResultDefaultTypeInternal _AcResult_default_instance_;
class AcResult_MeasurementsEntry_DoNotUse;
class AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _AcResult_MeasurementsEntry_DoNotUse_default_instance_;
class Analysis;
class AnalysisDefaultTypeInternal;
extern AnalysisDefaultTypeInternal _Analysis_default_instance_;
class AnalysisResult;
class AnalysisResultDefaultTypeInternal;
extern AnalysisResultDefaultTypeInternal _AnalysisResult_default_instance_;
class ComplexNum;
class ComplexNumDefaultTypeInternal;
extern ComplexNumDefaultTypeInternal _ComplexNum_default_instance_;
class Control;
class ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class CustomAnalysisInput;
class CustomAnalysisInputDefaultTypeInternal;
extern CustomAnalysisInputDefaultTypeInternal _CustomAnalysisInput_default_instance_;
class CustomAnalysisResult;
class CustomAnalysisResultDefaultTypeInternal;
extern CustomAnalysisResultDefaultTypeInternal _CustomAnalysisResult_default_instance_;
class DcInput;
class DcInputDefaultTypeInternal;
extern DcInputDefaultTypeInternal _DcInput_default_instance_;
class DcResult;
class DcResultDefaultTypeInternal;
extern DcResultDefaultTypeInternal _DcResult_default_instance_;
class DcResult_MeasurementsEntry_DoNotUse;
class DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _DcResult_MeasurementsEntry_DoNotUse_default_instance_;
class Include;
class IncludeDefaultTypeInternal;
extern IncludeDefaultTypeInternal _Include_default_instance_;
class LibInclude;
class LibIncludeDefaultTypeInternal;
extern LibIncludeDefaultTypeInternal _LibInclude_default_instance_;
class LinearSweep;
class LinearSweepDefaultTypeInternal;
extern LinearSweepDefaultTypeInternal _LinearSweep_default_instance_;
class LogSweep;
class LogSweepDefaultTypeInternal;
extern LogSweepDefaultTypeInternal _LogSweep_default_instance_;
class Meas;
class MeasDefaultTypeInternal;
extern MeasDefaultTypeInternal _Meas_default_instance_;
class MonteInput;
class MonteInputDefaultTypeInternal;
extern MonteInputDefaultTypeInternal _MonteInput_default_instance_;
class MonteResult;
class MonteResultDefaultTypeInternal;
extern MonteResultDefaultTypeInternal _MonteResult_default_instance_;
class OpInput;
class OpInputDefaultTypeInternal;
extern OpInputDefaultTypeInternal _OpInput_default_instance_;
class OpResult;
class OpResultDefaultTypeInternal;
extern OpResultDefaultTypeInternal _OpResult_default_instance_;
class PointSweep;
class PointSweepDefaultTypeInternal;
extern PointSweepDefaultTypeInternal _PointSweep_default_instance_;
class Save;
class SaveDefaultTypeInternal;
extern SaveDefaultTypeInternal _Save_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class SimInput;
class SimInputDefaultTypeInternal;
extern SimInputDefaultTypeInternal _SimInput_default_instance_;
class SimOptions;
class SimOptionsDefaultTypeInternal;
extern SimOptionsDefaultTypeInternal _SimOptions_default_instance_;
class SimResult;
class SimResultDefaultTypeInternal;
extern SimResultDefaultTypeInternal _SimResult_default_instance_;
class Sweep;
class SweepDefaultTypeInternal;
extern SweepDefaultTypeInternal _Sweep_default_instance_;
class SweepInput;
class SweepInputDefaultTypeInternal;
extern SweepInputDefaultTypeInternal _SweepInput_default_instance_;
class SweepResult;
class SweepResultDefaultTypeInternal;
extern SweepResultDefaultTypeInternal _SweepResult_default_instance_;
class TranInput;
class TranInputDefaultTypeInternal;
extern TranInputDefaultTypeInternal _TranInput_default_instance_;
class TranInput_IcEntry_DoNotUse;
class TranInput_IcEntry_DoNotUseDefaultTypeInternal;
extern TranInput_IcEntry_DoNotUseDefaultTypeInternal _TranInput_IcEntry_DoNotUse_default_instance_;
class TranResult;
class TranResultDefaultTypeInternal;
extern TranResultDefaultTypeInternal _TranResult_default_instance_;
class TranResult_MeasurementsEntry_DoNotUse;
class TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal;
extern TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _TranResult_MeasurementsEntry_DoNotUse_default_instance_;
}  // namespace spice
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::spice::AcInput* Arena::CreateMaybeMessage<::vlsir::spice::AcInput>(Arena*);
template<> ::vlsir::spice::AcResult* Arena::CreateMaybeMessage<::vlsir::spice::AcResult>(Arena*);
template<> ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::Analysis* Arena::CreateMaybeMessage<::vlsir::spice::Analysis>(Arena*);
template<> ::vlsir::spice::AnalysisResult* Arena::CreateMaybeMessage<::vlsir::spice::AnalysisResult>(Arena*);
template<> ::vlsir::spice::ComplexNum* Arena::CreateMaybeMessage<::vlsir::spice::ComplexNum>(Arena*);
template<> ::vlsir::spice::Control* Arena::CreateMaybeMessage<::vlsir::spice::Control>(Arena*);
template<> ::vlsir::spice::CustomAnalysisInput* Arena::CreateMaybeMessage<::vlsir::spice::CustomAnalysisInput>(Arena*);
template<> ::vlsir::spice::CustomAnalysisResult* Arena::CreateMaybeMessage<::vlsir::spice::CustomAnalysisResult>(Arena*);
template<> ::vlsir::spice::DcInput* Arena::CreateMaybeMessage<::vlsir::spice::DcInput>(Arena*);
template<> ::vlsir::spice::DcResult* Arena::CreateMaybeMessage<::vlsir::spice::DcResult>(Arena*);
template<> ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::Include* Arena::CreateMaybeMessage<::vlsir::spice::Include>(Arena*);
template<> ::vlsir::spice::LibInclude* Arena::CreateMaybeMessage<::vlsir::spice::LibInclude>(Arena*);
template<> ::vlsir::spice::LinearSweep* Arena::CreateMaybeMessage<::vlsir::spice::LinearSweep>(Arena*);
template<> ::vlsir::spice::LogSweep* Arena::CreateMaybeMessage<::vlsir::spice::LogSweep>(Arena*);
template<> ::vlsir::spice::Meas* Arena::CreateMaybeMessage<::vlsir::spice::Meas>(Arena*);
template<> ::vlsir::spice::MonteInput* Arena::CreateMaybeMessage<::vlsir::spice::MonteInput>(Arena*);
template<> ::vlsir::spice::MonteResult* Arena::CreateMaybeMessage<::vlsir::spice::MonteResult>(Arena*);
template<> ::vlsir::spice::OpInput* Arena::CreateMaybeMessage<::vlsir::spice::OpInput>(Arena*);
template<> ::vlsir::spice::OpResult* Arena::CreateMaybeMessage<::vlsir::spice::OpResult>(Arena*);
template<> ::vlsir::spice::PointSweep* Arena::CreateMaybeMessage<::vlsir::spice::PointSweep>(Arena*);
template<> ::vlsir::spice::Save* Arena::CreateMaybeMessage<::vlsir::spice::Save>(Arena*);
template<> ::vlsir::spice::Signal* Arena::CreateMaybeMessage<::vlsir::spice::Signal>(Arena*);
template<> ::vlsir::spice::SimInput* Arena::CreateMaybeMessage<::vlsir::spice::SimInput>(Arena*);
template<> ::vlsir::spice::SimOptions* Arena::CreateMaybeMessage<::vlsir::spice::SimOptions>(Arena*);
template<> ::vlsir::spice::SimResult* Arena::CreateMaybeMessage<::vlsir::spice::SimResult>(Arena*);
template<> ::vlsir::spice::Sweep* Arena::CreateMaybeMessage<::vlsir::spice::Sweep>(Arena*);
template<> ::vlsir::spice::SweepInput* Arena::CreateMaybeMessage<::vlsir::spice::SweepInput>(Arena*);
template<> ::vlsir::spice::SweepResult* Arena::CreateMaybeMessage<::vlsir::spice::SweepResult>(Arena*);
template<> ::vlsir::spice::TranInput* Arena::CreateMaybeMessage<::vlsir::spice::TranInput>(Arena*);
template<> ::vlsir::spice::TranInput_IcEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::TranInput_IcEntry_DoNotUse>(Arena*);
template<> ::vlsir::spice::TranResult* Arena::CreateMaybeMessage<::vlsir::spice::TranResult>(Arena*);
template<> ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace spice {

enum Save_SaveMode : int {
  Save_SaveMode_NONE = 0,
  Save_SaveMode_ALL = 1,
  Save_SaveMode_Save_SaveMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Save_SaveMode_Save_SaveMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Save_SaveMode_IsValid(int value);
constexpr Save_SaveMode Save_SaveMode_SaveMode_MIN = Save_SaveMode_NONE;
constexpr Save_SaveMode Save_SaveMode_SaveMode_MAX = Save_SaveMode_ALL;
constexpr int Save_SaveMode_SaveMode_ARRAYSIZE = Save_SaveMode_SaveMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Save_SaveMode_descriptor();
template<typename T>
inline const std::string& Save_SaveMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Save_SaveMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Save_SaveMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Save_SaveMode_descriptor(), enum_t_value);
}
inline bool Save_SaveMode_Parse(
    const std::string& name, Save_SaveMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Save_SaveMode>(
    Save_SaveMode_descriptor(), name, value);
}
enum Signal_Quantity : int {
  Signal_Quantity_VOLTAGE = 0,
  Signal_Quantity_CURRENT = 1,
  Signal_Quantity_NONE = 3,
  Signal_Quantity_Signal_Quantity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Signal_Quantity_Signal_Quantity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Signal_Quantity_IsValid(int value);
constexpr Signal_Quantity Signal_Quantity_Quantity_MIN = Signal_Quantity_VOLTAGE;
constexpr Signal_Quantity Signal_Quantity_Quantity_MAX = Signal_Quantity_NONE;
constexpr int Signal_Quantity_Quantity_ARRAYSIZE = Signal_Quantity_Quantity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Signal_Quantity_descriptor();
template<typename T>
inline const std::string& Signal_Quantity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Signal_Quantity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Signal_Quantity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Signal_Quantity_descriptor(), enum_t_value);
}
inline bool Signal_Quantity_Parse(
    const std::string& name, Signal_Quantity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Signal_Quantity>(
    Signal_Quantity_descriptor(), name, value);
}
// ===================================================================

class SimInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimInput) */ {
 public:
  inline SimInput() : SimInput(nullptr) {};
  virtual ~SimInput();

  SimInput(const SimInput& from);
  SimInput(SimInput&& from) noexcept
    : SimInput() {
    *this = ::std::move(from);
  }

  inline SimInput& operator=(const SimInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimInput& operator=(SimInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimInput* internal_default_instance() {
    return reinterpret_cast<const SimInput*>(
               &_SimInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SimInput& a, SimInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SimInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimInput* New() const final {
    return CreateMaybeMessage<SimInput>(nullptr);
  }

  SimInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimInput& from);
  void MergeFrom(const SimInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SimInput";
  }
  protected:
  explicit SimInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptsFieldNumber = 10,
    kAnFieldNumber = 11,
    kCtrlsFieldNumber = 12,
    kTopFieldNumber = 2,
    kPkgFieldNumber = 1,
  };
  // repeated .vlsir.spice.SimOptions opts = 10;
  int opts_size() const;
  private:
  int _internal_opts_size() const;
  public:
  void clear_opts();
  ::vlsir::spice::SimOptions* mutable_opts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::SimOptions >*
      mutable_opts();
  private:
  const ::vlsir::spice::SimOptions& _internal_opts(int index) const;
  ::vlsir::spice::SimOptions* _internal_add_opts();
  public:
  const ::vlsir::spice::SimOptions& opts(int index) const;
  ::vlsir::spice::SimOptions* add_opts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::SimOptions >&
      opts() const;

  // repeated .vlsir.spice.Analysis an = 11;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  private:
  const ::vlsir::spice::Analysis& _internal_an(int index) const;
  ::vlsir::spice::Analysis* _internal_add_an();
  public:
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 12;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string top = 2;
  void clear_top();
  const std::string& top() const;
  void set_top(const std::string& value);
  void set_top(std::string&& value);
  void set_top(const char* value);
  void set_top(const char* value, size_t size);
  std::string* mutable_top();
  std::string* release_top();
  void set_allocated_top(std::string* top);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_top();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_top(
      std::string* top);
  private:
  const std::string& _internal_top() const;
  void _internal_set_top(const std::string& value);
  std::string* _internal_mutable_top();
  public:

  // .vlsir.circuit.Package pkg = 1;
  bool has_pkg() const;
  private:
  bool _internal_has_pkg() const;
  public:
  void clear_pkg();
  const ::vlsir::circuit::Package& pkg() const;
  ::vlsir::circuit::Package* release_pkg();
  ::vlsir::circuit::Package* mutable_pkg();
  void set_allocated_pkg(::vlsir::circuit::Package* pkg);
  private:
  const ::vlsir::circuit::Package& _internal_pkg() const;
  ::vlsir::circuit::Package* _internal_mutable_pkg();
  public:
  void unsafe_arena_set_allocated_pkg(
      ::vlsir::circuit::Package* pkg);
  ::vlsir::circuit::Package* unsafe_arena_release_pkg();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::SimOptions > opts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr top_;
  ::vlsir::circuit::Package* pkg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SimResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimResult) */ {
 public:
  inline SimResult() : SimResult(nullptr) {};
  virtual ~SimResult();

  SimResult(const SimResult& from);
  SimResult(SimResult&& from) noexcept
    : SimResult() {
    *this = ::std::move(from);
  }

  inline SimResult& operator=(const SimResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimResult& operator=(SimResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimResult* internal_default_instance() {
    return reinterpret_cast<const SimResult*>(
               &_SimResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SimResult& a, SimResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SimResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimResult* New() const final {
    return CreateMaybeMessage<SimResult>(nullptr);
  }

  SimResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimResult& from);
  void MergeFrom(const SimResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SimResult";
  }
  protected:
  explicit SimResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 1,
  };
  // repeated .vlsir.spice.AnalysisResult an = 1;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  private:
  const ::vlsir::spice::AnalysisResult& _internal_an(int index) const;
  ::vlsir::spice::AnalysisResult* _internal_add_an();
  public:
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SimOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SimOptions) */ {
 public:
  inline SimOptions() : SimOptions(nullptr) {};
  virtual ~SimOptions();

  SimOptions(const SimOptions& from);
  SimOptions(SimOptions&& from) noexcept
    : SimOptions() {
    *this = ::std::move(from);
  }

  inline SimOptions& operator=(const SimOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimOptions& operator=(SimOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimOptions* internal_default_instance() {
    return reinterpret_cast<const SimOptions*>(
               &_SimOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SimOptions& a, SimOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SimOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimOptions* New() const final {
    return CreateMaybeMessage<SimOptions>(nullptr);
  }

  SimOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimOptions& from);
  void MergeFrom(const SimOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SimOptions";
  }
  protected:
  explicit SimOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTempFieldNumber = 1,
    kTnomFieldNumber = 2,
    kGminFieldNumber = 3,
    kIabstolFieldNumber = 4,
    kReltolFieldNumber = 5,
  };
  // double temp = 1;
  void clear_temp();
  double temp() const;
  void set_temp(double value);
  private:
  double _internal_temp() const;
  void _internal_set_temp(double value);
  public:

  // double tnom = 2;
  void clear_tnom();
  double tnom() const;
  void set_tnom(double value);
  private:
  double _internal_tnom() const;
  void _internal_set_tnom(double value);
  public:

  // double gmin = 3;
  void clear_gmin();
  double gmin() const;
  void set_gmin(double value);
  private:
  double _internal_gmin() const;
  void _internal_set_gmin(double value);
  public:

  // double iabstol = 4;
  void clear_iabstol();
  double iabstol() const;
  void set_iabstol(double value);
  private:
  double _internal_iabstol() const;
  void _internal_set_iabstol(double value);
  public:

  // double reltol = 5;
  void clear_reltol();
  double reltol() const;
  void set_reltol(double value);
  private:
  double _internal_reltol() const;
  void _internal_set_reltol(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.SimOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double temp_;
  double tnom_;
  double gmin_;
  double iabstol_;
  double reltol_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Analysis PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Analysis) */ {
 public:
  inline Analysis() : Analysis(nullptr) {};
  virtual ~Analysis();

  Analysis(const Analysis& from);
  Analysis(Analysis&& from) noexcept
    : Analysis() {
    *this = ::std::move(from);
  }

  inline Analysis& operator=(const Analysis& from) {
    CopyFrom(from);
    return *this;
  }
  inline Analysis& operator=(Analysis&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Analysis& default_instance();

  enum AnCase {
    kOp = 1,
    kDc = 2,
    kTran = 3,
    kAc = 4,
    kSweep = 10,
    kMonte = 11,
    kCustom = 20,
    AN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Analysis* internal_default_instance() {
    return reinterpret_cast<const Analysis*>(
               &_Analysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Analysis& a, Analysis& b) {
    a.Swap(&b);
  }
  inline void Swap(Analysis* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Analysis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Analysis* New() const final {
    return CreateMaybeMessage<Analysis>(nullptr);
  }

  Analysis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Analysis>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Analysis& from);
  void MergeFrom(const Analysis& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Analysis* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Analysis";
  }
  protected:
  explicit Analysis(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kDcFieldNumber = 2,
    kTranFieldNumber = 3,
    kAcFieldNumber = 4,
    kSweepFieldNumber = 10,
    kMonteFieldNumber = 11,
    kCustomFieldNumber = 20,
  };
  // .vlsir.spice.OpInput op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::vlsir::spice::OpInput& op() const;
  ::vlsir::spice::OpInput* release_op();
  ::vlsir::spice::OpInput* mutable_op();
  void set_allocated_op(::vlsir::spice::OpInput* op);
  private:
  const ::vlsir::spice::OpInput& _internal_op() const;
  ::vlsir::spice::OpInput* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::vlsir::spice::OpInput* op);
  ::vlsir::spice::OpInput* unsafe_arena_release_op();

  // .vlsir.spice.DcInput dc = 2;
  bool has_dc() const;
  private:
  bool _internal_has_dc() const;
  public:
  void clear_dc();
  const ::vlsir::spice::DcInput& dc() const;
  ::vlsir::spice::DcInput* release_dc();
  ::vlsir::spice::DcInput* mutable_dc();
  void set_allocated_dc(::vlsir::spice::DcInput* dc);
  private:
  const ::vlsir::spice::DcInput& _internal_dc() const;
  ::vlsir::spice::DcInput* _internal_mutable_dc();
  public:
  void unsafe_arena_set_allocated_dc(
      ::vlsir::spice::DcInput* dc);
  ::vlsir::spice::DcInput* unsafe_arena_release_dc();

  // .vlsir.spice.TranInput tran = 3;
  bool has_tran() const;
  private:
  bool _internal_has_tran() const;
  public:
  void clear_tran();
  const ::vlsir::spice::TranInput& tran() const;
  ::vlsir::spice::TranInput* release_tran();
  ::vlsir::spice::TranInput* mutable_tran();
  void set_allocated_tran(::vlsir::spice::TranInput* tran);
  private:
  const ::vlsir::spice::TranInput& _internal_tran() const;
  ::vlsir::spice::TranInput* _internal_mutable_tran();
  public:
  void unsafe_arena_set_allocated_tran(
      ::vlsir::spice::TranInput* tran);
  ::vlsir::spice::TranInput* unsafe_arena_release_tran();

  // .vlsir.spice.AcInput ac = 4;
  bool has_ac() const;
  private:
  bool _internal_has_ac() const;
  public:
  void clear_ac();
  const ::vlsir::spice::AcInput& ac() const;
  ::vlsir::spice::AcInput* release_ac();
  ::vlsir::spice::AcInput* mutable_ac();
  void set_allocated_ac(::vlsir::spice::AcInput* ac);
  private:
  const ::vlsir::spice::AcInput& _internal_ac() const;
  ::vlsir::spice::AcInput* _internal_mutable_ac();
  public:
  void unsafe_arena_set_allocated_ac(
      ::vlsir::spice::AcInput* ac);
  ::vlsir::spice::AcInput* unsafe_arena_release_ac();

  // .vlsir.spice.SweepInput sweep = 10;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::SweepInput& sweep() const;
  ::vlsir::spice::SweepInput* release_sweep();
  ::vlsir::spice::SweepInput* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::SweepInput* sweep);
  private:
  const ::vlsir::spice::SweepInput& _internal_sweep() const;
  ::vlsir::spice::SweepInput* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::SweepInput* sweep);
  ::vlsir::spice::SweepInput* unsafe_arena_release_sweep();

  // .vlsir.spice.MonteInput monte = 11;
  bool has_monte() const;
  private:
  bool _internal_has_monte() const;
  public:
  void clear_monte();
  const ::vlsir::spice::MonteInput& monte() const;
  ::vlsir::spice::MonteInput* release_monte();
  ::vlsir::spice::MonteInput* mutable_monte();
  void set_allocated_monte(::vlsir::spice::MonteInput* monte);
  private:
  const ::vlsir::spice::MonteInput& _internal_monte() const;
  ::vlsir::spice::MonteInput* _internal_mutable_monte();
  public:
  void unsafe_arena_set_allocated_monte(
      ::vlsir::spice::MonteInput* monte);
  ::vlsir::spice::MonteInput* unsafe_arena_release_monte();

  // .vlsir.spice.CustomAnalysisInput custom = 20;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::vlsir::spice::CustomAnalysisInput& custom() const;
  ::vlsir::spice::CustomAnalysisInput* release_custom();
  ::vlsir::spice::CustomAnalysisInput* mutable_custom();
  void set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom);
  private:
  const ::vlsir::spice::CustomAnalysisInput& _internal_custom() const;
  ::vlsir::spice::CustomAnalysisInput* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::vlsir::spice::CustomAnalysisInput* custom);
  ::vlsir::spice::CustomAnalysisInput* unsafe_arena_release_custom();

  void clear_an();
  AnCase an_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Analysis)
 private:
  class _Internal;
  void set_has_op();
  void set_has_dc();
  void set_has_tran();
  void set_has_ac();
  void set_has_sweep();
  void set_has_monte();
  void set_has_custom();

  inline bool has_an() const;
  inline void clear_has_an();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union AnUnion {
    AnUnion() {}
    ::vlsir::spice::OpInput* op_;
    ::vlsir::spice::DcInput* dc_;
    ::vlsir::spice::TranInput* tran_;
    ::vlsir::spice::AcInput* ac_;
    ::vlsir::spice::SweepInput* sweep_;
    ::vlsir::spice::MonteInput* monte_;
    ::vlsir::spice::CustomAnalysisInput* custom_;
  } an_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class AnalysisResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AnalysisResult) */ {
 public:
  inline AnalysisResult() : AnalysisResult(nullptr) {};
  virtual ~AnalysisResult();

  AnalysisResult(const AnalysisResult& from);
  AnalysisResult(AnalysisResult&& from) noexcept
    : AnalysisResult() {
    *this = ::std::move(from);
  }

  inline AnalysisResult& operator=(const AnalysisResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalysisResult& operator=(AnalysisResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnalysisResult& default_instance();

  enum AnCase {
    kOp = 1,
    kDc = 2,
    kTran = 3,
    kAc = 4,
    kSweep = 10,
    kMonte = 11,
    kCustom = 20,
    AN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalysisResult* internal_default_instance() {
    return reinterpret_cast<const AnalysisResult*>(
               &_AnalysisResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AnalysisResult& a, AnalysisResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalysisResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalysisResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnalysisResult* New() const final {
    return CreateMaybeMessage<AnalysisResult>(nullptr);
  }

  AnalysisResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnalysisResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnalysisResult& from);
  void MergeFrom(const AnalysisResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.AnalysisResult";
  }
  protected:
  explicit AnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kDcFieldNumber = 2,
    kTranFieldNumber = 3,
    kAcFieldNumber = 4,
    kSweepFieldNumber = 10,
    kMonteFieldNumber = 11,
    kCustomFieldNumber = 20,
  };
  // .vlsir.spice.OpResult op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::vlsir::spice::OpResult& op() const;
  ::vlsir::spice::OpResult* release_op();
  ::vlsir::spice::OpResult* mutable_op();
  void set_allocated_op(::vlsir::spice::OpResult* op);
  private:
  const ::vlsir::spice::OpResult& _internal_op() const;
  ::vlsir::spice::OpResult* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::vlsir::spice::OpResult* op);
  ::vlsir::spice::OpResult* unsafe_arena_release_op();

  // .vlsir.spice.DcResult dc = 2;
  bool has_dc() const;
  private:
  bool _internal_has_dc() const;
  public:
  void clear_dc();
  const ::vlsir::spice::DcResult& dc() const;
  ::vlsir::spice::DcResult* release_dc();
  ::vlsir::spice::DcResult* mutable_dc();
  void set_allocated_dc(::vlsir::spice::DcResult* dc);
  private:
  const ::vlsir::spice::DcResult& _internal_dc() const;
  ::vlsir::spice::DcResult* _internal_mutable_dc();
  public:
  void unsafe_arena_set_allocated_dc(
      ::vlsir::spice::DcResult* dc);
  ::vlsir::spice::DcResult* unsafe_arena_release_dc();

  // .vlsir.spice.TranResult tran = 3;
  bool has_tran() const;
  private:
  bool _internal_has_tran() const;
  public:
  void clear_tran();
  const ::vlsir::spice::TranResult& tran() const;
  ::vlsir::spice::TranResult* release_tran();
  ::vlsir::spice::TranResult* mutable_tran();
  void set_allocated_tran(::vlsir::spice::TranResult* tran);
  private:
  const ::vlsir::spice::TranResult& _internal_tran() const;
  ::vlsir::spice::TranResult* _internal_mutable_tran();
  public:
  void unsafe_arena_set_allocated_tran(
      ::vlsir::spice::TranResult* tran);
  ::vlsir::spice::TranResult* unsafe_arena_release_tran();

  // .vlsir.spice.AcResult ac = 4;
  bool has_ac() const;
  private:
  bool _internal_has_ac() const;
  public:
  void clear_ac();
  const ::vlsir::spice::AcResult& ac() const;
  ::vlsir::spice::AcResult* release_ac();
  ::vlsir::spice::AcResult* mutable_ac();
  void set_allocated_ac(::vlsir::spice::AcResult* ac);
  private:
  const ::vlsir::spice::AcResult& _internal_ac() const;
  ::vlsir::spice::AcResult* _internal_mutable_ac();
  public:
  void unsafe_arena_set_allocated_ac(
      ::vlsir::spice::AcResult* ac);
  ::vlsir::spice::AcResult* unsafe_arena_release_ac();

  // .vlsir.spice.SweepResult sweep = 10;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::SweepResult& sweep() const;
  ::vlsir::spice::SweepResult* release_sweep();
  ::vlsir::spice::SweepResult* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::SweepResult* sweep);
  private:
  const ::vlsir::spice::SweepResult& _internal_sweep() const;
  ::vlsir::spice::SweepResult* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::SweepResult* sweep);
  ::vlsir::spice::SweepResult* unsafe_arena_release_sweep();

  // .vlsir.spice.MonteResult monte = 11;
  bool has_monte() const;
  private:
  bool _internal_has_monte() const;
  public:
  void clear_monte();
  const ::vlsir::spice::MonteResult& monte() const;
  ::vlsir::spice::MonteResult* release_monte();
  ::vlsir::spice::MonteResult* mutable_monte();
  void set_allocated_monte(::vlsir::spice::MonteResult* monte);
  private:
  const ::vlsir::spice::MonteResult& _internal_monte() const;
  ::vlsir::spice::MonteResult* _internal_mutable_monte();
  public:
  void unsafe_arena_set_allocated_monte(
      ::vlsir::spice::MonteResult* monte);
  ::vlsir::spice::MonteResult* unsafe_arena_release_monte();

  // .vlsir.spice.CustomAnalysisResult custom = 20;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::vlsir::spice::CustomAnalysisResult& custom() const;
  ::vlsir::spice::CustomAnalysisResult* release_custom();
  ::vlsir::spice::CustomAnalysisResult* mutable_custom();
  void set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom);
  private:
  const ::vlsir::spice::CustomAnalysisResult& _internal_custom() const;
  ::vlsir::spice::CustomAnalysisResult* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::vlsir::spice::CustomAnalysisResult* custom);
  ::vlsir::spice::CustomAnalysisResult* unsafe_arena_release_custom();

  void clear_an();
  AnCase an_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.AnalysisResult)
 private:
  class _Internal;
  void set_has_op();
  void set_has_dc();
  void set_has_tran();
  void set_has_ac();
  void set_has_sweep();
  void set_has_monte();
  void set_has_custom();

  inline bool has_an() const;
  inline void clear_has_an();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union AnUnion {
    AnUnion() {}
    ::vlsir::spice::OpResult* op_;
    ::vlsir::spice::DcResult* dc_;
    ::vlsir::spice::TranResult* tran_;
    ::vlsir::spice::AcResult* ac_;
    ::vlsir::spice::SweepResult* sweep_;
    ::vlsir::spice::MonteResult* monte_;
    ::vlsir::spice::CustomAnalysisResult* custom_;
  } an_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class OpInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.OpInput) */ {
 public:
  inline OpInput() : OpInput(nullptr) {};
  virtual ~OpInput();

  OpInput(const OpInput& from);
  OpInput(OpInput&& from) noexcept
    : OpInput() {
    *this = ::std::move(from);
  }

  inline OpInput& operator=(const OpInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpInput& operator=(OpInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpInput* internal_default_instance() {
    return reinterpret_cast<const OpInput*>(
               &_OpInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OpInput& a, OpInput& b) {
    a.Swap(&b);
  }
  inline void Swap(OpInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpInput* New() const final {
    return CreateMaybeMessage<OpInput>(nullptr);
  }

  OpInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpInput& from);
  void MergeFrom(const OpInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.OpInput";
  }
  protected:
  explicit OpInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
  };
  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.OpInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class OpResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.OpResult) */ {
 public:
  inline OpResult() : OpResult(nullptr) {};
  virtual ~OpResult();

  OpResult(const OpResult& from);
  OpResult(OpResult&& from) noexcept
    : OpResult() {
    *this = ::std::move(from);
  }

  inline OpResult& operator=(const OpResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpResult& operator=(OpResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpResult* internal_default_instance() {
    return reinterpret_cast<const OpResult*>(
               &_OpResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OpResult& a, OpResult& b) {
    a.Swap(&b);
  }
  inline void Swap(OpResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpResult* New() const final {
    return CreateMaybeMessage<OpResult>(nullptr);
  }

  OpResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpResult& from);
  void MergeFrom(const OpResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.OpResult";
  }
  protected:
  explicit OpResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 3,
    kDataFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
  };
  // repeated string signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  const std::string& signals(int index) const;
  std::string* mutable_signals(int index);
  void set_signals(int index, const std::string& value);
  void set_signals(int index, std::string&& value);
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  std::string* add_signals();
  void add_signals(const std::string& value);
  void add_signals(std::string&& value);
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signals();
  private:
  const std::string& _internal_signals(int index) const;
  std::string* _internal_add_signals();
  public:

  // repeated double data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.OpResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class DcInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.DcInput) */ {
 public:
  inline DcInput() : DcInput(nullptr) {};
  virtual ~DcInput();

  DcInput(const DcInput& from);
  DcInput(DcInput&& from) noexcept
    : DcInput() {
    *this = ::std::move(from);
  }

  inline DcInput& operator=(const DcInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DcInput& operator=(DcInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DcInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DcInput* internal_default_instance() {
    return reinterpret_cast<const DcInput*>(
               &_DcInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DcInput& a, DcInput& b) {
    a.Swap(&b);
  }
  inline void Swap(DcInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DcInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DcInput* New() const final {
    return CreateMaybeMessage<DcInput>(nullptr);
  }

  DcInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DcInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DcInput& from);
  void MergeFrom(const DcInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DcInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.DcInput";
  }
  protected:
  explicit DcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kIndepNameFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string indep_name = 2;
  void clear_indep_name();
  const std::string& indep_name() const;
  void set_indep_name(const std::string& value);
  void set_indep_name(std::string&& value);
  void set_indep_name(const char* value);
  void set_indep_name(const char* value, size_t size);
  std::string* mutable_indep_name();
  std::string* release_indep_name();
  void set_allocated_indep_name(std::string* indep_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_indep_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_indep_name(
      std::string* indep_name);
  private:
  const std::string& _internal_indep_name() const;
  void _internal_set_indep_name(const std::string& value);
  std::string* _internal_mutable_indep_name();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.DcInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indep_name_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class DcResult_MeasurementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  DcResult_MeasurementsEntry_DoNotUse();
  DcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DcResult_MeasurementsEntry_DoNotUse& other);
  static const DcResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DcResult_MeasurementsEntry_DoNotUse*>(&_DcResult_MeasurementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.DcResult.MeasurementsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class DcResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.DcResult) */ {
 public:
  inline DcResult() : DcResult(nullptr) {};
  virtual ~DcResult();

  DcResult(const DcResult& from);
  DcResult(DcResult&& from) noexcept
    : DcResult() {
    *this = ::std::move(from);
  }

  inline DcResult& operator=(const DcResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DcResult& operator=(DcResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DcResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DcResult* internal_default_instance() {
    return reinterpret_cast<const DcResult*>(
               &_DcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DcResult& a, DcResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DcResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DcResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DcResult* New() const final {
    return CreateMaybeMessage<DcResult>(nullptr);
  }

  DcResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DcResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DcResult& from);
  void MergeFrom(const DcResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DcResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.DcResult";
  }
  protected:
  explicit DcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 3,
    kDataFieldNumber = 5,
    kMeasurementsFieldNumber = 10,
    kAnalysisNameFieldNumber = 1,
    kIndepNameFieldNumber = 2,
  };
  // repeated string signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  const std::string& signals(int index) const;
  std::string* mutable_signals(int index);
  void set_signals(int index, const std::string& value);
  void set_signals(int index, std::string&& value);
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  std::string* add_signals();
  void add_signals(const std::string& value);
  void add_signals(std::string&& value);
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signals();
  private:
  const std::string& _internal_signals(int index) const;
  std::string* _internal_add_signals();
  public:

  // repeated double data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // map<string, double> measurements = 10;
  int measurements_size() const;
  private:
  int _internal_measurements_size() const;
  public:
  void clear_measurements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_measurements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string indep_name = 2;
  void clear_indep_name();
  const std::string& indep_name() const;
  void set_indep_name(const std::string& value);
  void set_indep_name(std::string&& value);
  void set_indep_name(const char* value);
  void set_indep_name(const char* value, size_t size);
  std::string* mutable_indep_name();
  std::string* release_indep_name();
  void set_allocated_indep_name(std::string* indep_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_indep_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_indep_name(
      std::string* indep_name);
  private:
  const std::string& _internal_indep_name() const;
  void _internal_set_indep_name(const std::string& value);
  std::string* _internal_mutable_indep_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.DcResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DcResult_MeasurementsEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indep_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class TranInput_IcEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranInput_IcEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranInput_IcEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  TranInput_IcEntry_DoNotUse();
  TranInput_IcEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TranInput_IcEntry_DoNotUse& other);
  static const TranInput_IcEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TranInput_IcEntry_DoNotUse*>(&_TranInput_IcEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.TranInput.IcEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[10];
  }

  public:
};

// -------------------------------------------------------------------

class TranInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.TranInput) */ {
 public:
  inline TranInput() : TranInput(nullptr) {};
  virtual ~TranInput();

  TranInput(const TranInput& from);
  TranInput(TranInput&& from) noexcept
    : TranInput() {
    *this = ::std::move(from);
  }

  inline TranInput& operator=(const TranInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranInput& operator=(TranInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TranInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TranInput* internal_default_instance() {
    return reinterpret_cast<const TranInput*>(
               &_TranInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TranInput& a, TranInput& b) {
    a.Swap(&b);
  }
  inline void Swap(TranInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranInput* New() const final {
    return CreateMaybeMessage<TranInput>(nullptr);
  }

  TranInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TranInput& from);
  void MergeFrom(const TranInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.TranInput";
  }
  protected:
  explicit TranInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIcFieldNumber = 4,
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kTstopFieldNumber = 2,
    kTstepFieldNumber = 3,
  };
  // map<string, double> ic = 4;
  int ic_size() const;
  private:
  int _internal_ic_size() const;
  public:
  void clear_ic();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_ic() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_ic();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      ic() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_ic();

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // double tstop = 2;
  void clear_tstop();
  double tstop() const;
  void set_tstop(double value);
  private:
  double _internal_tstop() const;
  void _internal_set_tstop(double value);
  public:

  // double tstep = 3;
  void clear_tstep();
  double tstep() const;
  void set_tstep(double value);
  private:
  double _internal_tstep() const;
  void _internal_set_tstep(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.TranInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TranInput_IcEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > ic_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  double tstop_;
  double tstep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class TranResult_MeasurementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TranResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  TranResult_MeasurementsEntry_DoNotUse();
  TranResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TranResult_MeasurementsEntry_DoNotUse& other);
  static const TranResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TranResult_MeasurementsEntry_DoNotUse*>(&_TranResult_MeasurementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.TranResult.MeasurementsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[12];
  }

  public:
};

// -------------------------------------------------------------------

class TranResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.TranResult) */ {
 public:
  inline TranResult() : TranResult(nullptr) {};
  virtual ~TranResult();

  TranResult(const TranResult& from);
  TranResult(TranResult&& from) noexcept
    : TranResult() {
    *this = ::std::move(from);
  }

  inline TranResult& operator=(const TranResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranResult& operator=(TranResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TranResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TranResult* internal_default_instance() {
    return reinterpret_cast<const TranResult*>(
               &_TranResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TranResult& a, TranResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TranResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranResult* New() const final {
    return CreateMaybeMessage<TranResult>(nullptr);
  }

  TranResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TranResult& from);
  void MergeFrom(const TranResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.TranResult";
  }
  protected:
  explicit TranResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 3,
    kDataFieldNumber = 5,
    kMeasurementsFieldNumber = 10,
    kAnalysisNameFieldNumber = 1,
  };
  // repeated string signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  const std::string& signals(int index) const;
  std::string* mutable_signals(int index);
  void set_signals(int index, const std::string& value);
  void set_signals(int index, std::string&& value);
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  std::string* add_signals();
  void add_signals(const std::string& value);
  void add_signals(std::string&& value);
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signals();
  private:
  const std::string& _internal_signals(int index) const;
  std::string* _internal_add_signals();
  public:

  // repeated double data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // map<string, double> measurements = 10;
  int measurements_size() const;
  private:
  int _internal_measurements_size() const;
  public:
  void clear_measurements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_measurements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.TranResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TranResult_MeasurementsEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class ComplexNum PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.ComplexNum) */ {
 public:
  inline ComplexNum() : ComplexNum(nullptr) {};
  virtual ~ComplexNum();

  ComplexNum(const ComplexNum& from);
  ComplexNum(ComplexNum&& from) noexcept
    : ComplexNum() {
    *this = ::std::move(from);
  }

  inline ComplexNum& operator=(const ComplexNum& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComplexNum& operator=(ComplexNum&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ComplexNum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComplexNum* internal_default_instance() {
    return reinterpret_cast<const ComplexNum*>(
               &_ComplexNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ComplexNum& a, ComplexNum& b) {
    a.Swap(&b);
  }
  inline void Swap(ComplexNum* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComplexNum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComplexNum* New() const final {
    return CreateMaybeMessage<ComplexNum>(nullptr);
  }

  ComplexNum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComplexNum>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ComplexNum& from);
  void MergeFrom(const ComplexNum& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplexNum* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.ComplexNum";
  }
  protected:
  explicit ComplexNum(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReFieldNumber = 1,
    kImFieldNumber = 2,
  };
  // double re = 1;
  void clear_re();
  double re() const;
  void set_re(double value);
  private:
  double _internal_re() const;
  void _internal_set_re(double value);
  public:

  // double im = 2;
  void clear_im();
  double im() const;
  void set_im(double value);
  private:
  double _internal_im() const;
  void _internal_set_im(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.ComplexNum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double re_;
  double im_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class AcInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AcInput) */ {
 public:
  inline AcInput() : AcInput(nullptr) {};
  virtual ~AcInput();

  AcInput(const AcInput& from);
  AcInput(AcInput&& from) noexcept
    : AcInput() {
    *this = ::std::move(from);
  }

  inline AcInput& operator=(const AcInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcInput& operator=(AcInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcInput* internal_default_instance() {
    return reinterpret_cast<const AcInput*>(
               &_AcInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AcInput& a, AcInput& b) {
    a.Swap(&b);
  }
  inline void Swap(AcInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcInput* New() const final {
    return CreateMaybeMessage<AcInput>(nullptr);
  }

  AcInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcInput& from);
  void MergeFrom(const AcInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.AcInput";
  }
  protected:
  explicit AcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kFstartFieldNumber = 2,
    kFstopFieldNumber = 3,
    kNptsFieldNumber = 4,
  };
  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // double fstart = 2;
  void clear_fstart();
  double fstart() const;
  void set_fstart(double value);
  private:
  double _internal_fstart() const;
  void _internal_set_fstart(double value);
  public:

  // double fstop = 3;
  void clear_fstop();
  double fstop() const;
  void set_fstop(double value);
  private:
  double _internal_fstop() const;
  void _internal_set_fstop(double value);
  public:

  // uint64 npts = 4;
  void clear_npts();
  ::PROTOBUF_NAMESPACE_ID::uint64 npts() const;
  void set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_npts() const;
  void _internal_set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.AcInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  double fstart_;
  double fstop_;
  ::PROTOBUF_NAMESPACE_ID::uint64 npts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class AcResult_MeasurementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AcResult_MeasurementsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  AcResult_MeasurementsEntry_DoNotUse();
  AcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AcResult_MeasurementsEntry_DoNotUse& other);
  static const AcResult_MeasurementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AcResult_MeasurementsEntry_DoNotUse*>(&_AcResult_MeasurementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.spice.AcResult.MeasurementsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[16];
  }

  public:
};

// -------------------------------------------------------------------

class AcResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.AcResult) */ {
 public:
  inline AcResult() : AcResult(nullptr) {};
  virtual ~AcResult();

  AcResult(const AcResult& from);
  AcResult(AcResult&& from) noexcept
    : AcResult() {
    *this = ::std::move(from);
  }

  inline AcResult& operator=(const AcResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcResult& operator=(AcResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcResult* internal_default_instance() {
    return reinterpret_cast<const AcResult*>(
               &_AcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AcResult& a, AcResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AcResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcResult* New() const final {
    return CreateMaybeMessage<AcResult>(nullptr);
  }

  AcResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcResult& from);
  void MergeFrom(const AcResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.AcResult";
  }
  protected:
  explicit AcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFreqFieldNumber = 2,
    kSignalsFieldNumber = 3,
    kDataFieldNumber = 5,
    kMeasurementsFieldNumber = 10,
    kAnalysisNameFieldNumber = 1,
  };
  // repeated double freq = 2;
  int freq_size() const;
  private:
  int _internal_freq_size() const;
  public:
  void clear_freq();
  private:
  double _internal_freq(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_freq() const;
  void _internal_add_freq(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_freq();
  public:
  double freq(int index) const;
  void set_freq(int index, double value);
  void add_freq(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      freq() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_freq();

  // repeated string signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  const std::string& signals(int index) const;
  std::string* mutable_signals(int index);
  void set_signals(int index, const std::string& value);
  void set_signals(int index, std::string&& value);
  void set_signals(int index, const char* value);
  void set_signals(int index, const char* value, size_t size);
  std::string* add_signals();
  void add_signals(const std::string& value);
  void add_signals(std::string&& value);
  void add_signals(const char* value);
  void add_signals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signals();
  private:
  const std::string& _internal_signals(int index) const;
  std::string* _internal_add_signals();
  public:

  // repeated .vlsir.spice.ComplexNum data = 5;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::vlsir::spice::ComplexNum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >*
      mutable_data();
  private:
  const ::vlsir::spice::ComplexNum& _internal_data(int index) const;
  ::vlsir::spice::ComplexNum* _internal_add_data();
  public:
  const ::vlsir::spice::ComplexNum& data(int index) const;
  ::vlsir::spice::ComplexNum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >&
      data() const;

  // map<string, double> measurements = 10;
  int measurements_size() const;
  private:
  int _internal_measurements_size() const;
  public:
  void clear_measurements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_measurements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      measurements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_measurements();

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.AcResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > freq_;
  mutable std::atomic<int> _freq_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AcResult_MeasurementsEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > measurements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SweepInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SweepInput) */ {
 public:
  inline SweepInput() : SweepInput(nullptr) {};
  virtual ~SweepInput();

  SweepInput(const SweepInput& from);
  SweepInput(SweepInput&& from) noexcept
    : SweepInput() {
    *this = ::std::move(from);
  }

  inline SweepInput& operator=(const SweepInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SweepInput& operator=(SweepInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SweepInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SweepInput* internal_default_instance() {
    return reinterpret_cast<const SweepInput*>(
               &_SweepInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SweepInput& a, SweepInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SweepInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SweepInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SweepInput* New() const final {
    return CreateMaybeMessage<SweepInput>(nullptr);
  }

  SweepInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SweepInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SweepInput& from);
  void MergeFrom(const SweepInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SweepInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SweepInput";
  }
  protected:
  explicit SweepInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kVariableFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.Analysis an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  private:
  const ::vlsir::spice::Analysis& _internal_an(int index) const;
  ::vlsir::spice::Analysis* _internal_add_an();
  public:
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string variable = 2;
  void clear_variable();
  const std::string& variable() const;
  void set_variable(const std::string& value);
  void set_variable(std::string&& value);
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  std::string* mutable_variable();
  std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_variable();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_variable(
      std::string* variable);
  private:
  const std::string& _internal_variable() const;
  void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SweepInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class SweepResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.SweepResult) */ {
 public:
  inline SweepResult() : SweepResult(nullptr) {};
  virtual ~SweepResult();

  SweepResult(const SweepResult& from);
  SweepResult(SweepResult&& from) noexcept
    : SweepResult() {
    *this = ::std::move(from);
  }

  inline SweepResult& operator=(const SweepResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SweepResult& operator=(SweepResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SweepResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SweepResult* internal_default_instance() {
    return reinterpret_cast<const SweepResult*>(
               &_SweepResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SweepResult& a, SweepResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SweepResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SweepResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SweepResult* New() const final {
    return CreateMaybeMessage<SweepResult>(nullptr);
  }

  SweepResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SweepResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SweepResult& from);
  void MergeFrom(const SweepResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SweepResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.SweepResult";
  }
  protected:
  explicit SweepResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kAnalysisNameFieldNumber = 1,
    kVariableFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.AnalysisResult an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  private:
  const ::vlsir::spice::AnalysisResult& _internal_an(int index) const;
  ::vlsir::spice::AnalysisResult* _internal_add_an();
  public:
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string variable = 2;
  void clear_variable();
  const std::string& variable() const;
  void set_variable(const std::string& value);
  void set_variable(std::string&& value);
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  std::string* mutable_variable();
  std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_variable();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_variable(
      std::string* variable);
  private:
  const std::string& _internal_variable() const;
  void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.SweepResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class MonteInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.MonteInput) */ {
 public:
  inline MonteInput() : MonteInput(nullptr) {};
  virtual ~MonteInput();

  MonteInput(const MonteInput& from);
  MonteInput(MonteInput&& from) noexcept
    : MonteInput() {
    *this = ::std::move(from);
  }

  inline MonteInput& operator=(const MonteInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonteInput& operator=(MonteInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MonteInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonteInput* internal_default_instance() {
    return reinterpret_cast<const MonteInput*>(
               &_MonteInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MonteInput& a, MonteInput& b) {
    a.Swap(&b);
  }
  inline void Swap(MonteInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonteInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonteInput* New() const final {
    return CreateMaybeMessage<MonteInput>(nullptr);
  }

  MonteInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonteInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MonteInput& from);
  void MergeFrom(const MonteInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonteInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.MonteInput";
  }
  protected:
  explicit MonteInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kNptsFieldNumber = 2,
    kSeedFieldNumber = 3,
  };
  // repeated .vlsir.spice.Analysis an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::Analysis* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
      mutable_an();
  private:
  const ::vlsir::spice::Analysis& _internal_an(int index) const;
  ::vlsir::spice::Analysis* _internal_add_an();
  public:
  const ::vlsir::spice::Analysis& an(int index) const;
  ::vlsir::spice::Analysis* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
      an() const;

  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // int64 npts = 2;
  void clear_npts();
  ::PROTOBUF_NAMESPACE_ID::int64 npts() const;
  void set_npts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_npts() const;
  void _internal_set_npts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 seed = 3;
  void clear_seed();
  ::PROTOBUF_NAMESPACE_ID::int64 seed() const;
  void set_seed(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seed() const;
  void _internal_set_seed(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.MonteInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis > an_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 npts_;
  ::PROTOBUF_NAMESPACE_ID::int64 seed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class MonteResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.MonteResult) */ {
 public:
  inline MonteResult() : MonteResult(nullptr) {};
  virtual ~MonteResult();

  MonteResult(const MonteResult& from);
  MonteResult(MonteResult&& from) noexcept
    : MonteResult() {
    *this = ::std::move(from);
  }

  inline MonteResult& operator=(const MonteResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonteResult& operator=(MonteResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MonteResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonteResult* internal_default_instance() {
    return reinterpret_cast<const MonteResult*>(
               &_MonteResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MonteResult& a, MonteResult& b) {
    a.Swap(&b);
  }
  inline void Swap(MonteResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonteResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonteResult* New() const final {
    return CreateMaybeMessage<MonteResult>(nullptr);
  }

  MonteResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonteResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MonteResult& from);
  void MergeFrom(const MonteResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonteResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.MonteResult";
  }
  protected:
  explicit MonteResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnFieldNumber = 4,
    kAnalysisNameFieldNumber = 1,
    kVariableFieldNumber = 2,
    kSweepFieldNumber = 3,
  };
  // repeated .vlsir.spice.AnalysisResult an = 4;
  int an_size() const;
  private:
  int _internal_an_size() const;
  public:
  void clear_an();
  ::vlsir::spice::AnalysisResult* mutable_an(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
      mutable_an();
  private:
  const ::vlsir::spice::AnalysisResult& _internal_an(int index) const;
  ::vlsir::spice::AnalysisResult* _internal_add_an();
  public:
  const ::vlsir::spice::AnalysisResult& an(int index) const;
  ::vlsir::spice::AnalysisResult* add_an();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
      an() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string variable = 2;
  void clear_variable();
  const std::string& variable() const;
  void set_variable(const std::string& value);
  void set_variable(std::string&& value);
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  std::string* mutable_variable();
  std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_variable();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_variable(
      std::string* variable);
  private:
  const std::string& _internal_variable() const;
  void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // .vlsir.spice.Sweep sweep = 3;
  bool has_sweep() const;
  private:
  bool _internal_has_sweep() const;
  public:
  void clear_sweep();
  const ::vlsir::spice::Sweep& sweep() const;
  ::vlsir::spice::Sweep* release_sweep();
  ::vlsir::spice::Sweep* mutable_sweep();
  void set_allocated_sweep(::vlsir::spice::Sweep* sweep);
  private:
  const ::vlsir::spice::Sweep& _internal_sweep() const;
  ::vlsir::spice::Sweep* _internal_mutable_sweep();
  public:
  void unsafe_arena_set_allocated_sweep(
      ::vlsir::spice::Sweep* sweep);
  ::vlsir::spice::Sweep* unsafe_arena_release_sweep();

  // @@protoc_insertion_point(class_scope:vlsir.spice.MonteResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult > an_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::vlsir::spice::Sweep* sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class CustomAnalysisInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.CustomAnalysisInput) */ {
 public:
  inline CustomAnalysisInput() : CustomAnalysisInput(nullptr) {};
  virtual ~CustomAnalysisInput();

  CustomAnalysisInput(const CustomAnalysisInput& from);
  CustomAnalysisInput(CustomAnalysisInput&& from) noexcept
    : CustomAnalysisInput() {
    *this = ::std::move(from);
  }

  inline CustomAnalysisInput& operator=(const CustomAnalysisInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomAnalysisInput& operator=(CustomAnalysisInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomAnalysisInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomAnalysisInput* internal_default_instance() {
    return reinterpret_cast<const CustomAnalysisInput*>(
               &_CustomAnalysisInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CustomAnalysisInput& a, CustomAnalysisInput& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomAnalysisInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomAnalysisInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomAnalysisInput* New() const final {
    return CreateMaybeMessage<CustomAnalysisInput>(nullptr);
  }

  CustomAnalysisInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomAnalysisInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomAnalysisInput& from);
  void MergeFrom(const CustomAnalysisInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomAnalysisInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.CustomAnalysisInput";
  }
  protected:
  explicit CustomAnalysisInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlsFieldNumber = 5,
    kAnalysisNameFieldNumber = 1,
    kCmdFieldNumber = 2,
  };
  // repeated .vlsir.spice.Control ctrls = 5;
  int ctrls_size() const;
  private:
  int _internal_ctrls_size() const;
  public:
  void clear_ctrls();
  ::vlsir::spice::Control* mutable_ctrls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
      mutable_ctrls();
  private:
  const ::vlsir::spice::Control& _internal_ctrls(int index) const;
  ::vlsir::spice::Control* _internal_add_ctrls();
  public:
  const ::vlsir::spice::Control& ctrls(int index) const;
  ::vlsir::spice::Control* add_ctrls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
      ctrls() const;

  // string analysis_name = 1;
  void clear_analysis_name();
  const std::string& analysis_name() const;
  void set_analysis_name(const std::string& value);
  void set_analysis_name(std::string&& value);
  void set_analysis_name(const char* value);
  void set_analysis_name(const char* value, size_t size);
  std::string* mutable_analysis_name();
  std::string* release_analysis_name();
  void set_allocated_analysis_name(std::string* analysis_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_name(
      std::string* analysis_name);
  private:
  const std::string& _internal_analysis_name() const;
  void _internal_set_analysis_name(const std::string& value);
  std::string* _internal_mutable_analysis_name();
  public:

  // string cmd = 2;
  void clear_cmd();
  const std::string& cmd() const;
  void set_cmd(const std::string& value);
  void set_cmd(std::string&& value);
  void set_cmd(const char* value);
  void set_cmd(const char* value, size_t size);
  std::string* mutable_cmd();
  std::string* release_cmd();
  void set_allocated_cmd(std::string* cmd);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_cmd();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_cmd(
      std::string* cmd);
  private:
  const std::string& _internal_cmd() const;
  void _internal_set_cmd(const std::string& value);
  std::string* _internal_mutable_cmd();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.CustomAnalysisInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control > ctrls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class CustomAnalysisResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.CustomAnalysisResult) */ {
 public:
  inline CustomAnalysisResult() : CustomAnalysisResult(nullptr) {};
  virtual ~CustomAnalysisResult();

  CustomAnalysisResult(const CustomAnalysisResult& from);
  CustomAnalysisResult(CustomAnalysisResult&& from) noexcept
    : CustomAnalysisResult() {
    *this = ::std::move(from);
  }

  inline CustomAnalysisResult& operator=(const CustomAnalysisResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomAnalysisResult& operator=(CustomAnalysisResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomAnalysisResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomAnalysisResult* internal_default_instance() {
    return reinterpret_cast<const CustomAnalysisResult*>(
               &_CustomAnalysisResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CustomAnalysisResult& a, CustomAnalysisResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomAnalysisResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomAnalysisResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomAnalysisResult* New() const final {
    return CreateMaybeMessage<CustomAnalysisResult>(nullptr);
  }

  CustomAnalysisResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomAnalysisResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomAnalysisResult& from);
  void MergeFrom(const CustomAnalysisResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomAnalysisResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.CustomAnalysisResult";
  }
  protected:
  explicit CustomAnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vlsir.spice.CustomAnalysisResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Sweep PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Sweep) */ {
 public:
  inline Sweep() : Sweep(nullptr) {};
  virtual ~Sweep();

  Sweep(const Sweep& from);
  Sweep(Sweep&& from) noexcept
    : Sweep() {
    *this = ::std::move(from);
  }

  inline Sweep& operator=(const Sweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sweep& operator=(Sweep&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sweep& default_instance();

  enum TpCase {
    kLinear = 1,
    kLog = 2,
    kPoints = 3,
    TP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sweep* internal_default_instance() {
    return reinterpret_cast<const Sweep*>(
               &_Sweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Sweep& a, Sweep& b) {
    a.Swap(&b);
  }
  inline void Swap(Sweep* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sweep* New() const final {
    return CreateMaybeMessage<Sweep>(nullptr);
  }

  Sweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sweep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sweep& from);
  void MergeFrom(const Sweep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Sweep";
  }
  protected:
  explicit Sweep(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kLogFieldNumber = 2,
    kPointsFieldNumber = 3,
  };
  // .vlsir.spice.LinearSweep linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::vlsir::spice::LinearSweep& linear() const;
  ::vlsir::spice::LinearSweep* release_linear();
  ::vlsir::spice::LinearSweep* mutable_linear();
  void set_allocated_linear(::vlsir::spice::LinearSweep* linear);
  private:
  const ::vlsir::spice::LinearSweep& _internal_linear() const;
  ::vlsir::spice::LinearSweep* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::vlsir::spice::LinearSweep* linear);
  ::vlsir::spice::LinearSweep* unsafe_arena_release_linear();

  // .vlsir.spice.LogSweep log = 2;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::vlsir::spice::LogSweep& log() const;
  ::vlsir::spice::LogSweep* release_log();
  ::vlsir::spice::LogSweep* mutable_log();
  void set_allocated_log(::vlsir::spice::LogSweep* log);
  private:
  const ::vlsir::spice::LogSweep& _internal_log() const;
  ::vlsir::spice::LogSweep* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::vlsir::spice::LogSweep* log);
  ::vlsir::spice::LogSweep* unsafe_arena_release_log();

  // .vlsir.spice.PointSweep points = 3;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::vlsir::spice::PointSweep& points() const;
  ::vlsir::spice::PointSweep* release_points();
  ::vlsir::spice::PointSweep* mutable_points();
  void set_allocated_points(::vlsir::spice::PointSweep* points);
  private:
  const ::vlsir::spice::PointSweep& _internal_points() const;
  ::vlsir::spice::PointSweep* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::vlsir::spice::PointSweep* points);
  ::vlsir::spice::PointSweep* unsafe_arena_release_points();

  void clear_tp();
  TpCase tp_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Sweep)
 private:
  class _Internal;
  void set_has_linear();
  void set_has_log();
  void set_has_points();

  inline bool has_tp() const;
  inline void clear_has_tp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TpUnion {
    TpUnion() {}
    ::vlsir::spice::LinearSweep* linear_;
    ::vlsir::spice::LogSweep* log_;
    ::vlsir::spice::PointSweep* points_;
  } tp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class LinearSweep PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LinearSweep) */ {
 public:
  inline LinearSweep() : LinearSweep(nullptr) {};
  virtual ~LinearSweep();

  LinearSweep(const LinearSweep& from);
  LinearSweep(LinearSweep&& from) noexcept
    : LinearSweep() {
    *this = ::std::move(from);
  }

  inline LinearSweep& operator=(const LinearSweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearSweep& operator=(LinearSweep&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LinearSweep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinearSweep* internal_default_instance() {
    return reinterpret_cast<const LinearSweep*>(
               &_LinearSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LinearSweep& a, LinearSweep& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearSweep* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearSweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinearSweep* New() const final {
    return CreateMaybeMessage<LinearSweep>(nullptr);
  }

  LinearSweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinearSweep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LinearSweep& from);
  void MergeFrom(const LinearSweep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearSweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.LinearSweep";
  }
  protected:
  explicit LinearSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kStopFieldNumber = 2,
    kStepFieldNumber = 3,
  };
  // double start = 1;
  void clear_start();
  double start() const;
  void set_start(double value);
  private:
  double _internal_start() const;
  void _internal_set_start(double value);
  public:

  // double stop = 2;
  void clear_stop();
  double stop() const;
  void set_stop(double value);
  private:
  double _internal_stop() const;
  void _internal_set_stop(double value);
  public:

  // double step = 3;
  void clear_step();
  double step() const;
  void set_step(double value);
  private:
  double _internal_step() const;
  void _internal_set_step(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.LinearSweep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double start_;
  double stop_;
  double step_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class LogSweep PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LogSweep) */ {
 public:
  inline LogSweep() : LogSweep(nullptr) {};
  virtual ~LogSweep();

  LogSweep(const LogSweep& from);
  LogSweep(LogSweep&& from) noexcept
    : LogSweep() {
    *this = ::std::move(from);
  }

  inline LogSweep& operator=(const LogSweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSweep& operator=(LogSweep&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogSweep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogSweep* internal_default_instance() {
    return reinterpret_cast<const LogSweep*>(
               &_LogSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LogSweep& a, LogSweep& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSweep* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogSweep* New() const final {
    return CreateMaybeMessage<LogSweep>(nullptr);
  }

  LogSweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogSweep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogSweep& from);
  void MergeFrom(const LogSweep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.LogSweep";
  }
  protected:
  explicit LogSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kStopFieldNumber = 2,
    kNptsFieldNumber = 3,
  };
  // double start = 1;
  void clear_start();
  double start() const;
  void set_start(double value);
  private:
  double _internal_start() const;
  void _internal_set_start(double value);
  public:

  // double stop = 2;
  void clear_stop();
  double stop() const;
  void set_stop(double value);
  private:
  double _internal_stop() const;
  void _internal_set_stop(double value);
  public:

  // double npts = 3;
  void clear_npts();
  double npts() const;
  void set_npts(double value);
  private:
  double _internal_npts() const;
  void _internal_set_npts(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.LogSweep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double start_;
  double stop_;
  double npts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class PointSweep PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.PointSweep) */ {
 public:
  inline PointSweep() : PointSweep(nullptr) {};
  virtual ~PointSweep();

  PointSweep(const PointSweep& from);
  PointSweep(PointSweep&& from) noexcept
    : PointSweep() {
    *this = ::std::move(from);
  }

  inline PointSweep& operator=(const PointSweep& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointSweep& operator=(PointSweep&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PointSweep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointSweep* internal_default_instance() {
    return reinterpret_cast<const PointSweep*>(
               &_PointSweep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PointSweep& a, PointSweep& b) {
    a.Swap(&b);
  }
  inline void Swap(PointSweep* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointSweep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointSweep* New() const final {
    return CreateMaybeMessage<PointSweep>(nullptr);
  }

  PointSweep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointSweep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PointSweep& from);
  void MergeFrom(const PointSweep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointSweep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.PointSweep";
  }
  protected:
  explicit PointSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kStopFieldNumber = 2,
    kNptsFieldNumber = 3,
  };
  // repeated double points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  private:
  double _internal_points(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_points() const;
  void _internal_add_points(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_points();
  public:
  double points(int index) const;
  void set_points(int index, double value);
  void add_points(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_points();

  // double stop = 2;
  void clear_stop();
  double stop() const;
  void set_stop(double value);
  private:
  double _internal_stop() const;
  void _internal_set_stop(double value);
  public:

  // double npts = 3;
  void clear_npts();
  double npts() const;
  void set_npts(double value);
  private:
  double _internal_npts() const;
  void _internal_set_npts(double value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.PointSweep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > points_;
  mutable std::atomic<int> _points_cached_byte_size_;
  double stop_;
  double npts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Control PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Control) */ {
 public:
  inline Control() : Control(nullptr) {};
  virtual ~Control();

  Control(const Control& from);
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control& operator=(Control&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Control& default_instance();

  enum CtrlCase {
    kInclude = 1,
    kLib = 2,
    kSave = 5,
    kMeas = 6,
    kParam = 7,
    kLiteral = 10,
    CTRL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }
  inline void Swap(Control* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control* New() const final {
    return CreateMaybeMessage<Control>(nullptr);
  }

  Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Control";
  }
  protected:
  explicit Control(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeFieldNumber = 1,
    kLibFieldNumber = 2,
    kSaveFieldNumber = 5,
    kMeasFieldNumber = 6,
    kParamFieldNumber = 7,
    kLiteralFieldNumber = 10,
  };
  // .vlsir.spice.Include include = 1;
  bool has_include() const;
  private:
  bool _internal_has_include() const;
  public:
  void clear_include();
  const ::vlsir::spice::Include& include() const;
  ::vlsir::spice::Include* release_include();
  ::vlsir::spice::Include* mutable_include();
  void set_allocated_include(::vlsir::spice::Include* include);
  private:
  const ::vlsir::spice::Include& _internal_include() const;
  ::vlsir::spice::Include* _internal_mutable_include();
  public:
  void unsafe_arena_set_allocated_include(
      ::vlsir::spice::Include* include);
  ::vlsir::spice::Include* unsafe_arena_release_include();

  // .vlsir.spice.LibInclude lib = 2;
  bool has_lib() const;
  private:
  bool _internal_has_lib() const;
  public:
  void clear_lib();
  const ::vlsir::spice::LibInclude& lib() const;
  ::vlsir::spice::LibInclude* release_lib();
  ::vlsir::spice::LibInclude* mutable_lib();
  void set_allocated_lib(::vlsir::spice::LibInclude* lib);
  private:
  const ::vlsir::spice::LibInclude& _internal_lib() const;
  ::vlsir::spice::LibInclude* _internal_mutable_lib();
  public:
  void unsafe_arena_set_allocated_lib(
      ::vlsir::spice::LibInclude* lib);
  ::vlsir::spice::LibInclude* unsafe_arena_release_lib();

  // .vlsir.spice.Save save = 5;
  bool has_save() const;
  private:
  bool _internal_has_save() const;
  public:
  void clear_save();
  const ::vlsir::spice::Save& save() const;
  ::vlsir::spice::Save* release_save();
  ::vlsir::spice::Save* mutable_save();
  void set_allocated_save(::vlsir::spice::Save* save);
  private:
  const ::vlsir::spice::Save& _internal_save() const;
  ::vlsir::spice::Save* _internal_mutable_save();
  public:
  void unsafe_arena_set_allocated_save(
      ::vlsir::spice::Save* save);
  ::vlsir::spice::Save* unsafe_arena_release_save();

  // .vlsir.spice.Meas meas = 6;
  bool has_meas() const;
  private:
  bool _internal_has_meas() const;
  public:
  void clear_meas();
  const ::vlsir::spice::Meas& meas() const;
  ::vlsir::spice::Meas* release_meas();
  ::vlsir::spice::Meas* mutable_meas();
  void set_allocated_meas(::vlsir::spice::Meas* meas);
  private:
  const ::vlsir::spice::Meas& _internal_meas() const;
  ::vlsir::spice::Meas* _internal_mutable_meas();
  public:
  void unsafe_arena_set_allocated_meas(
      ::vlsir::spice::Meas* meas);
  ::vlsir::spice::Meas* unsafe_arena_release_meas();

  // .vlsir.utils.Param param = 7;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::vlsir::utils::Param& param() const;
  ::vlsir::utils::Param* release_param();
  ::vlsir::utils::Param* mutable_param();
  void set_allocated_param(::vlsir::utils::Param* param);
  private:
  const ::vlsir::utils::Param& _internal_param() const;
  ::vlsir::utils::Param* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::vlsir::utils::Param* param);
  ::vlsir::utils::Param* unsafe_arena_release_param();

  // string literal = 10;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const std::string& literal() const;
  void set_literal(const std::string& value);
  void set_literal(std::string&& value);
  void set_literal(const char* value);
  void set_literal(const char* value, size_t size);
  std::string* mutable_literal();
  std::string* release_literal();
  void set_allocated_literal(std::string* literal);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_literal();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_literal(
      std::string* literal);
  private:
  const std::string& _internal_literal() const;
  void _internal_set_literal(const std::string& value);
  std::string* _internal_mutable_literal();
  public:

  void clear_ctrl();
  CtrlCase ctrl_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Control)
 private:
  class _Internal;
  void set_has_include();
  void set_has_lib();
  void set_has_save();
  void set_has_meas();
  void set_has_param();
  void set_has_literal();

  inline bool has_ctrl() const;
  inline void clear_has_ctrl();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CtrlUnion {
    CtrlUnion() {}
    ::vlsir::spice::Include* include_;
    ::vlsir::spice::LibInclude* lib_;
    ::vlsir::spice::Save* save_;
    ::vlsir::spice::Meas* meas_;
    ::vlsir::utils::Param* param_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr literal_;
  } ctrl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Save PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Save) */ {
 public:
  inline Save() : Save(nullptr) {};
  virtual ~Save();

  Save(const Save& from);
  Save(Save&& from) noexcept
    : Save() {
    *this = ::std::move(from);
  }

  inline Save& operator=(const Save& from) {
    CopyFrom(from);
    return *this;
  }
  inline Save& operator=(Save&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Save& default_instance();

  enum SaveCase {
    kMode = 1,
    kSignal = 2,
    SAVE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Save* internal_default_instance() {
    return reinterpret_cast<const Save*>(
               &_Save_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Save& a, Save& b) {
    a.Swap(&b);
  }
  inline void Swap(Save* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Save* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Save* New() const final {
    return CreateMaybeMessage<Save>(nullptr);
  }

  Save* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Save>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Save& from);
  void MergeFrom(const Save& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Save* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Save";
  }
  protected:
  explicit Save(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Save_SaveMode SaveMode;
  static constexpr SaveMode NONE =
    Save_SaveMode_NONE;
  static constexpr SaveMode ALL =
    Save_SaveMode_ALL;
  static inline bool SaveMode_IsValid(int value) {
    return Save_SaveMode_IsValid(value);
  }
  static constexpr SaveMode SaveMode_MIN =
    Save_SaveMode_SaveMode_MIN;
  static constexpr SaveMode SaveMode_MAX =
    Save_SaveMode_SaveMode_MAX;
  static constexpr int SaveMode_ARRAYSIZE =
    Save_SaveMode_SaveMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SaveMode_descriptor() {
    return Save_SaveMode_descriptor();
  }
  template<typename T>
  static inline const std::string& SaveMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SaveMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SaveMode_Name.");
    return Save_SaveMode_Name(enum_t_value);
  }
  static inline bool SaveMode_Parse(const std::string& name,
      SaveMode* value) {
    return Save_SaveMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
    kSignalFieldNumber = 2,
  };
  // .vlsir.spice.Save.SaveMode mode = 1;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::vlsir::spice::Save_SaveMode mode() const;
  void set_mode(::vlsir::spice::Save_SaveMode value);
  private:
  ::vlsir::spice::Save_SaveMode _internal_mode() const;
  void _internal_set_mode(::vlsir::spice::Save_SaveMode value);
  public:

  // string signal = 2;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  const std::string& signal() const;
  void set_signal(const std::string& value);
  void set_signal(std::string&& value);
  void set_signal(const char* value);
  void set_signal(const char* value, size_t size);
  std::string* mutable_signal();
  std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signal();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signal(
      std::string* signal);
  private:
  const std::string& _internal_signal() const;
  void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  void clear_save();
  SaveCase save_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.spice.Save)
 private:
  class _Internal;
  void set_has_mode();
  void set_has_signal();

  inline bool has_save() const;
  inline void clear_has_save();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SaveUnion {
    SaveUnion() {}
    int mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  } save_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Include PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Include) */ {
 public:
  inline Include() : Include(nullptr) {};
  virtual ~Include();

  Include(const Include& from);
  Include(Include&& from) noexcept
    : Include() {
    *this = ::std::move(from);
  }

  inline Include& operator=(const Include& from) {
    CopyFrom(from);
    return *this;
  }
  inline Include& operator=(Include&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Include& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Include* internal_default_instance() {
    return reinterpret_cast<const Include*>(
               &_Include_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Include& a, Include& b) {
    a.Swap(&b);
  }
  inline void Swap(Include* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Include* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Include* New() const final {
    return CreateMaybeMessage<Include>(nullptr);
  }

  Include* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Include>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Include& from);
  void MergeFrom(const Include& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Include* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Include";
  }
  protected:
  explicit Include(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Include)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class LibInclude PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.LibInclude) */ {
 public:
  inline LibInclude() : LibInclude(nullptr) {};
  virtual ~LibInclude();

  LibInclude(const LibInclude& from);
  LibInclude(LibInclude&& from) noexcept
    : LibInclude() {
    *this = ::std::move(from);
  }

  inline LibInclude& operator=(const LibInclude& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibInclude& operator=(LibInclude&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LibInclude& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LibInclude* internal_default_instance() {
    return reinterpret_cast<const LibInclude*>(
               &_LibInclude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LibInclude& a, LibInclude& b) {
    a.Swap(&b);
  }
  inline void Swap(LibInclude* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibInclude* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LibInclude* New() const final {
    return CreateMaybeMessage<LibInclude>(nullptr);
  }

  LibInclude* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LibInclude>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LibInclude& from);
  void MergeFrom(const LibInclude& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibInclude* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.LibInclude";
  }
  protected:
  explicit LibInclude(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kSectionFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string section = 2;
  void clear_section();
  const std::string& section() const;
  void set_section(const std::string& value);
  void set_section(std::string&& value);
  void set_section(const char* value);
  void set_section(const char* value, size_t size);
  std::string* mutable_section();
  std::string* release_section();
  void set_allocated_section(std::string* section);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_section();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_section(
      std::string* section);
  private:
  const std::string& _internal_section() const;
  void _internal_set_section(const std::string& value);
  std::string* _internal_mutable_section();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.LibInclude)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr section_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Meas PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Meas) */ {
 public:
  inline Meas() : Meas(nullptr) {};
  virtual ~Meas();

  Meas(const Meas& from);
  Meas(Meas&& from) noexcept
    : Meas() {
    *this = ::std::move(from);
  }

  inline Meas& operator=(const Meas& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meas& operator=(Meas&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Meas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Meas* internal_default_instance() {
    return reinterpret_cast<const Meas*>(
               &_Meas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Meas& a, Meas& b) {
    a.Swap(&b);
  }
  inline void Swap(Meas* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meas* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Meas* New() const final {
    return CreateMaybeMessage<Meas>(nullptr);
  }

  Meas* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Meas>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Meas& from);
  void MergeFrom(const Meas& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Meas* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Meas";
  }
  protected:
  explicit Meas(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnalysisTypeFieldNumber = 1,
    kNameFieldNumber = 2,
    kExprFieldNumber = 3,
  };
  // string analysis_type = 1;
  void clear_analysis_type();
  const std::string& analysis_type() const;
  void set_analysis_type(const std::string& value);
  void set_analysis_type(std::string&& value);
  void set_analysis_type(const char* value);
  void set_analysis_type(const char* value, size_t size);
  std::string* mutable_analysis_type();
  std::string* release_analysis_type();
  void set_allocated_analysis_type(std::string* analysis_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_analysis_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_analysis_type(
      std::string* analysis_type);
  private:
  const std::string& _internal_analysis_type() const;
  void _internal_set_analysis_type(const std::string& value);
  std::string* _internal_mutable_analysis_type();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string expr = 3;
  void clear_expr();
  const std::string& expr() const;
  void set_expr(const std::string& value);
  void set_expr(std::string&& value);
  void set_expr(const char* value);
  void set_expr(const char* value, size_t size);
  std::string* mutable_expr();
  std::string* release_expr();
  void set_allocated_expr(std::string* expr);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_expr();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_expr(
      std::string* expr);
  private:
  const std::string& _internal_expr() const;
  void _internal_set_expr(const std::string& value);
  std::string* _internal_mutable_expr();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Meas)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// -------------------------------------------------------------------

class Signal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.spice.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {};
  virtual ~Signal();

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(nullptr);
  }

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.spice.Signal";
  }
  protected:
  explicit Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_spice_2eproto);
    return ::descriptor_table_spice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Signal_Quantity Quantity;
  static constexpr Quantity VOLTAGE =
    Signal_Quantity_VOLTAGE;
  static constexpr Quantity CURRENT =
    Signal_Quantity_CURRENT;
  static constexpr Quantity NONE =
    Signal_Quantity_NONE;
  static inline bool Quantity_IsValid(int value) {
    return Signal_Quantity_IsValid(value);
  }
  static constexpr Quantity Quantity_MIN =
    Signal_Quantity_Quantity_MIN;
  static constexpr Quantity Quantity_MAX =
    Signal_Quantity_Quantity_MAX;
  static constexpr int Quantity_ARRAYSIZE =
    Signal_Quantity_Quantity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Quantity_descriptor() {
    return Signal_Quantity_descriptor();
  }
  template<typename T>
  static inline const std::string& Quantity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Quantity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Quantity_Name.");
    return Signal_Quantity_Name(enum_t_value);
  }
  static inline bool Quantity_Parse(const std::string& name,
      Quantity* value) {
    return Signal_Quantity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.spice.Signal.Quantity quantity = 2;
  void clear_quantity();
  ::vlsir::spice::Signal_Quantity quantity() const;
  void set_quantity(::vlsir::spice::Signal_Quantity value);
  private:
  ::vlsir::spice::Signal_Quantity _internal_quantity() const;
  void _internal_set_quantity(::vlsir::spice::Signal_Quantity value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.spice.Signal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int quantity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimInput

// .vlsir.circuit.Package pkg = 1;
inline bool SimInput::_internal_has_pkg() const {
  return this != internal_default_instance() && pkg_ != nullptr;
}
inline bool SimInput::has_pkg() const {
  return _internal_has_pkg();
}
inline const ::vlsir::circuit::Package& SimInput::_internal_pkg() const {
  const ::vlsir::circuit::Package* p = pkg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::circuit::Package*>(
      &::vlsir::circuit::_Package_default_instance_);
}
inline const ::vlsir::circuit::Package& SimInput::pkg() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.pkg)
  return _internal_pkg();
}
inline void SimInput::unsafe_arena_set_allocated_pkg(
    ::vlsir::circuit::Package* pkg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pkg_);
  }
  pkg_ = pkg;
  if (pkg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimInput.pkg)
}
inline ::vlsir::circuit::Package* SimInput::release_pkg() {
  auto temp = unsafe_arena_release_pkg();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::circuit::Package* SimInput::unsafe_arena_release_pkg() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimInput.pkg)
  
  ::vlsir::circuit::Package* temp = pkg_;
  pkg_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Package* SimInput::_internal_mutable_pkg() {
  
  if (pkg_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Package>(GetArena());
    pkg_ = p;
  }
  return pkg_;
}
inline ::vlsir::circuit::Package* SimInput::mutable_pkg() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.pkg)
  return _internal_mutable_pkg();
}
inline void SimInput::set_allocated_pkg(::vlsir::circuit::Package* pkg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pkg_);
  }
  if (pkg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pkg)->GetArena();
    if (message_arena != submessage_arena) {
      pkg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pkg, submessage_arena);
    }
    
  } else {
    
  }
  pkg_ = pkg;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimInput.pkg)
}

// string top = 2;
inline void SimInput::clear_top() {
  top_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SimInput::top() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.top)
  return _internal_top();
}
inline void SimInput::set_top(const std::string& value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimInput.top)
}
inline std::string* SimInput::mutable_top() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.top)
  return _internal_mutable_top();
}
inline const std::string& SimInput::_internal_top() const {
  return top_.Get();
}
inline void SimInput::_internal_set_top(const std::string& value) {
  
  top_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SimInput::set_top(std::string&& value) {
  
  top_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SimInput.top)
}
inline void SimInput::set_top(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  top_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SimInput.top)
}
inline void SimInput::set_top(const char* value,
    size_t size) {
  
  top_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SimInput.top)
}
inline std::string* SimInput::_internal_mutable_top() {
  
  return top_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SimInput::release_top() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SimInput.top)
  return top_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SimInput::set_allocated_top(std::string* top) {
  if (top != nullptr) {
    
  } else {
    
  }
  top_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), top,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SimInput.top)
}
inline std::string* SimInput::unsafe_arena_release_top() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.SimInput.top)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return top_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SimInput::unsafe_arena_set_allocated_top(
    std::string* top) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (top != nullptr) {
    
  } else {
    
  }
  top_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      top, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SimInput.top)
}

// repeated .vlsir.spice.SimOptions opts = 10;
inline int SimInput::_internal_opts_size() const {
  return opts_.size();
}
inline int SimInput::opts_size() const {
  return _internal_opts_size();
}
inline void SimInput::clear_opts() {
  opts_.Clear();
}
inline ::vlsir::spice::SimOptions* SimInput::mutable_opts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.opts)
  return opts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::SimOptions >*
SimInput::mutable_opts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.opts)
  return &opts_;
}
inline const ::vlsir::spice::SimOptions& SimInput::_internal_opts(int index) const {
  return opts_.Get(index);
}
inline const ::vlsir::spice::SimOptions& SimInput::opts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.opts)
  return _internal_opts(index);
}
inline ::vlsir::spice::SimOptions* SimInput::_internal_add_opts() {
  return opts_.Add();
}
inline ::vlsir::spice::SimOptions* SimInput::add_opts() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.opts)
  return _internal_add_opts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::SimOptions >&
SimInput::opts() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.opts)
  return opts_;
}

// repeated .vlsir.spice.Analysis an = 11;
inline int SimInput::_internal_an_size() const {
  return an_.size();
}
inline int SimInput::an_size() const {
  return _internal_an_size();
}
inline void SimInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* SimInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
SimInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& SimInput::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::Analysis& SimInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.an)
  return _internal_an(index);
}
inline ::vlsir::spice::Analysis* SimInput::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::Analysis* SimInput::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.an)
  return _internal_add_an();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
SimInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 12;
inline int SimInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int SimInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void SimInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* SimInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
SimInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& SimInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& SimInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* SimInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* SimInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
SimInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// SimResult

// repeated .vlsir.spice.AnalysisResult an = 1;
inline int SimResult::_internal_an_size() const {
  return an_.size();
}
inline int SimResult::an_size() const {
  return _internal_an_size();
}
inline void SimResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* SimResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SimResult.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
SimResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SimResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& SimResult::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::AnalysisResult& SimResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimResult.an)
  return _internal_an(index);
}
inline ::vlsir::spice::AnalysisResult* SimResult::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::AnalysisResult* SimResult::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SimResult.an)
  return _internal_add_an();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
SimResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SimResult.an)
  return an_;
}

// -------------------------------------------------------------------

// SimOptions

// double temp = 1;
inline void SimOptions::clear_temp() {
  temp_ = 0;
}
inline double SimOptions::_internal_temp() const {
  return temp_;
}
inline double SimOptions::temp() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.temp)
  return _internal_temp();
}
inline void SimOptions::_internal_set_temp(double value) {
  
  temp_ = value;
}
inline void SimOptions::set_temp(double value) {
  _internal_set_temp(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.temp)
}

// double tnom = 2;
inline void SimOptions::clear_tnom() {
  tnom_ = 0;
}
inline double SimOptions::_internal_tnom() const {
  return tnom_;
}
inline double SimOptions::tnom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.tnom)
  return _internal_tnom();
}
inline void SimOptions::_internal_set_tnom(double value) {
  
  tnom_ = value;
}
inline void SimOptions::set_tnom(double value) {
  _internal_set_tnom(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.tnom)
}

// double gmin = 3;
inline void SimOptions::clear_gmin() {
  gmin_ = 0;
}
inline double SimOptions::_internal_gmin() const {
  return gmin_;
}
inline double SimOptions::gmin() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.gmin)
  return _internal_gmin();
}
inline void SimOptions::_internal_set_gmin(double value) {
  
  gmin_ = value;
}
inline void SimOptions::set_gmin(double value) {
  _internal_set_gmin(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.gmin)
}

// double iabstol = 4;
inline void SimOptions::clear_iabstol() {
  iabstol_ = 0;
}
inline double SimOptions::_internal_iabstol() const {
  return iabstol_;
}
inline double SimOptions::iabstol() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.iabstol)
  return _internal_iabstol();
}
inline void SimOptions::_internal_set_iabstol(double value) {
  
  iabstol_ = value;
}
inline void SimOptions::set_iabstol(double value) {
  _internal_set_iabstol(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.iabstol)
}

// double reltol = 5;
inline void SimOptions::clear_reltol() {
  reltol_ = 0;
}
inline double SimOptions::_internal_reltol() const {
  return reltol_;
}
inline double SimOptions::reltol() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SimOptions.reltol)
  return _internal_reltol();
}
inline void SimOptions::_internal_set_reltol(double value) {
  
  reltol_ = value;
}
inline void SimOptions::set_reltol(double value) {
  _internal_set_reltol(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SimOptions.reltol)
}

// -------------------------------------------------------------------

// Analysis

// .vlsir.spice.OpInput op = 1;
inline bool Analysis::_internal_has_op() const {
  return an_case() == kOp;
}
inline bool Analysis::has_op() const {
  return _internal_has_op();
}
inline void Analysis::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void Analysis::clear_op() {
  if (_internal_has_op()) {
    if (GetArena() == nullptr) {
      delete an_.op_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::OpInput* Analysis::release_op() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.op)
  if (_internal_has_op()) {
    clear_has_an();
      ::vlsir::spice::OpInput* temp = an_.op_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::OpInput& Analysis::_internal_op() const {
  return _internal_has_op()
      ? *an_.op_
      : *reinterpret_cast< ::vlsir::spice::OpInput*>(&::vlsir::spice::_OpInput_default_instance_);
}
inline const ::vlsir::spice::OpInput& Analysis::op() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.op)
  return _internal_op();
}
inline ::vlsir::spice::OpInput* Analysis::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.op)
  if (_internal_has_op()) {
    clear_has_an();
    ::vlsir::spice::OpInput* temp = an_.op_;
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_op(::vlsir::spice::OpInput* op) {
  clear_an();
  if (op) {
    set_has_op();
    an_.op_ = op;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.op)
}
inline ::vlsir::spice::OpInput* Analysis::_internal_mutable_op() {
  if (!_internal_has_op()) {
    clear_an();
    set_has_op();
    an_.op_ = CreateMaybeMessage< ::vlsir::spice::OpInput >(GetArena());
  }
  return an_.op_;
}
inline ::vlsir::spice::OpInput* Analysis::mutable_op() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.op)
  return _internal_mutable_op();
}

// .vlsir.spice.DcInput dc = 2;
inline bool Analysis::_internal_has_dc() const {
  return an_case() == kDc;
}
inline bool Analysis::has_dc() const {
  return _internal_has_dc();
}
inline void Analysis::set_has_dc() {
  _oneof_case_[0] = kDc;
}
inline void Analysis::clear_dc() {
  if (_internal_has_dc()) {
    if (GetArena() == nullptr) {
      delete an_.dc_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::DcInput* Analysis::release_dc() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.dc)
  if (_internal_has_dc()) {
    clear_has_an();
      ::vlsir::spice::DcInput* temp = an_.dc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::DcInput& Analysis::_internal_dc() const {
  return _internal_has_dc()
      ? *an_.dc_
      : *reinterpret_cast< ::vlsir::spice::DcInput*>(&::vlsir::spice::_DcInput_default_instance_);
}
inline const ::vlsir::spice::DcInput& Analysis::dc() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.dc)
  return _internal_dc();
}
inline ::vlsir::spice::DcInput* Analysis::unsafe_arena_release_dc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.dc)
  if (_internal_has_dc()) {
    clear_has_an();
    ::vlsir::spice::DcInput* temp = an_.dc_;
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_dc(::vlsir::spice::DcInput* dc) {
  clear_an();
  if (dc) {
    set_has_dc();
    an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.dc)
}
inline ::vlsir::spice::DcInput* Analysis::_internal_mutable_dc() {
  if (!_internal_has_dc()) {
    clear_an();
    set_has_dc();
    an_.dc_ = CreateMaybeMessage< ::vlsir::spice::DcInput >(GetArena());
  }
  return an_.dc_;
}
inline ::vlsir::spice::DcInput* Analysis::mutable_dc() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.dc)
  return _internal_mutable_dc();
}

// .vlsir.spice.TranInput tran = 3;
inline bool Analysis::_internal_has_tran() const {
  return an_case() == kTran;
}
inline bool Analysis::has_tran() const {
  return _internal_has_tran();
}
inline void Analysis::set_has_tran() {
  _oneof_case_[0] = kTran;
}
inline void Analysis::clear_tran() {
  if (_internal_has_tran()) {
    if (GetArena() == nullptr) {
      delete an_.tran_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::TranInput* Analysis::release_tran() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.tran)
  if (_internal_has_tran()) {
    clear_has_an();
      ::vlsir::spice::TranInput* temp = an_.tran_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::TranInput& Analysis::_internal_tran() const {
  return _internal_has_tran()
      ? *an_.tran_
      : *reinterpret_cast< ::vlsir::spice::TranInput*>(&::vlsir::spice::_TranInput_default_instance_);
}
inline const ::vlsir::spice::TranInput& Analysis::tran() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.tran)
  return _internal_tran();
}
inline ::vlsir::spice::TranInput* Analysis::unsafe_arena_release_tran() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.tran)
  if (_internal_has_tran()) {
    clear_has_an();
    ::vlsir::spice::TranInput* temp = an_.tran_;
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_tran(::vlsir::spice::TranInput* tran) {
  clear_an();
  if (tran) {
    set_has_tran();
    an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.tran)
}
inline ::vlsir::spice::TranInput* Analysis::_internal_mutable_tran() {
  if (!_internal_has_tran()) {
    clear_an();
    set_has_tran();
    an_.tran_ = CreateMaybeMessage< ::vlsir::spice::TranInput >(GetArena());
  }
  return an_.tran_;
}
inline ::vlsir::spice::TranInput* Analysis::mutable_tran() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.tran)
  return _internal_mutable_tran();
}

// .vlsir.spice.AcInput ac = 4;
inline bool Analysis::_internal_has_ac() const {
  return an_case() == kAc;
}
inline bool Analysis::has_ac() const {
  return _internal_has_ac();
}
inline void Analysis::set_has_ac() {
  _oneof_case_[0] = kAc;
}
inline void Analysis::clear_ac() {
  if (_internal_has_ac()) {
    if (GetArena() == nullptr) {
      delete an_.ac_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::AcInput* Analysis::release_ac() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.ac)
  if (_internal_has_ac()) {
    clear_has_an();
      ::vlsir::spice::AcInput* temp = an_.ac_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::AcInput& Analysis::_internal_ac() const {
  return _internal_has_ac()
      ? *an_.ac_
      : *reinterpret_cast< ::vlsir::spice::AcInput*>(&::vlsir::spice::_AcInput_default_instance_);
}
inline const ::vlsir::spice::AcInput& Analysis::ac() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.ac)
  return _internal_ac();
}
inline ::vlsir::spice::AcInput* Analysis::unsafe_arena_release_ac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.ac)
  if (_internal_has_ac()) {
    clear_has_an();
    ::vlsir::spice::AcInput* temp = an_.ac_;
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_ac(::vlsir::spice::AcInput* ac) {
  clear_an();
  if (ac) {
    set_has_ac();
    an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.ac)
}
inline ::vlsir::spice::AcInput* Analysis::_internal_mutable_ac() {
  if (!_internal_has_ac()) {
    clear_an();
    set_has_ac();
    an_.ac_ = CreateMaybeMessage< ::vlsir::spice::AcInput >(GetArena());
  }
  return an_.ac_;
}
inline ::vlsir::spice::AcInput* Analysis::mutable_ac() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.ac)
  return _internal_mutable_ac();
}

// .vlsir.spice.SweepInput sweep = 10;
inline bool Analysis::_internal_has_sweep() const {
  return an_case() == kSweep;
}
inline bool Analysis::has_sweep() const {
  return _internal_has_sweep();
}
inline void Analysis::set_has_sweep() {
  _oneof_case_[0] = kSweep;
}
inline void Analysis::clear_sweep() {
  if (_internal_has_sweep()) {
    if (GetArena() == nullptr) {
      delete an_.sweep_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::SweepInput* Analysis::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
      ::vlsir::spice::SweepInput* temp = an_.sweep_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::SweepInput& Analysis::_internal_sweep() const {
  return _internal_has_sweep()
      ? *an_.sweep_
      : *reinterpret_cast< ::vlsir::spice::SweepInput*>(&::vlsir::spice::_SweepInput_default_instance_);
}
inline const ::vlsir::spice::SweepInput& Analysis::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.sweep)
  return _internal_sweep();
}
inline ::vlsir::spice::SweepInput* Analysis::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
    ::vlsir::spice::SweepInput* temp = an_.sweep_;
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_sweep(::vlsir::spice::SweepInput* sweep) {
  clear_an();
  if (sweep) {
    set_has_sweep();
    an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.sweep)
}
inline ::vlsir::spice::SweepInput* Analysis::_internal_mutable_sweep() {
  if (!_internal_has_sweep()) {
    clear_an();
    set_has_sweep();
    an_.sweep_ = CreateMaybeMessage< ::vlsir::spice::SweepInput >(GetArena());
  }
  return an_.sweep_;
}
inline ::vlsir::spice::SweepInput* Analysis::mutable_sweep() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.sweep)
  return _internal_mutable_sweep();
}

// .vlsir.spice.MonteInput monte = 11;
inline bool Analysis::_internal_has_monte() const {
  return an_case() == kMonte;
}
inline bool Analysis::has_monte() const {
  return _internal_has_monte();
}
inline void Analysis::set_has_monte() {
  _oneof_case_[0] = kMonte;
}
inline void Analysis::clear_monte() {
  if (_internal_has_monte()) {
    if (GetArena() == nullptr) {
      delete an_.monte_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::MonteInput* Analysis::release_monte() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.monte)
  if (_internal_has_monte()) {
    clear_has_an();
      ::vlsir::spice::MonteInput* temp = an_.monte_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::MonteInput& Analysis::_internal_monte() const {
  return _internal_has_monte()
      ? *an_.monte_
      : *reinterpret_cast< ::vlsir::spice::MonteInput*>(&::vlsir::spice::_MonteInput_default_instance_);
}
inline const ::vlsir::spice::MonteInput& Analysis::monte() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.monte)
  return _internal_monte();
}
inline ::vlsir::spice::MonteInput* Analysis::unsafe_arena_release_monte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.monte)
  if (_internal_has_monte()) {
    clear_has_an();
    ::vlsir::spice::MonteInput* temp = an_.monte_;
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_monte(::vlsir::spice::MonteInput* monte) {
  clear_an();
  if (monte) {
    set_has_monte();
    an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.monte)
}
inline ::vlsir::spice::MonteInput* Analysis::_internal_mutable_monte() {
  if (!_internal_has_monte()) {
    clear_an();
    set_has_monte();
    an_.monte_ = CreateMaybeMessage< ::vlsir::spice::MonteInput >(GetArena());
  }
  return an_.monte_;
}
inline ::vlsir::spice::MonteInput* Analysis::mutable_monte() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.monte)
  return _internal_mutable_monte();
}

// .vlsir.spice.CustomAnalysisInput custom = 20;
inline bool Analysis::_internal_has_custom() const {
  return an_case() == kCustom;
}
inline bool Analysis::has_custom() const {
  return _internal_has_custom();
}
inline void Analysis::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void Analysis::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArena() == nullptr) {
      delete an_.custom_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::release_custom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Analysis.custom)
  if (_internal_has_custom()) {
    clear_has_an();
      ::vlsir::spice::CustomAnalysisInput* temp = an_.custom_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::CustomAnalysisInput& Analysis::_internal_custom() const {
  return _internal_has_custom()
      ? *an_.custom_
      : *reinterpret_cast< ::vlsir::spice::CustomAnalysisInput*>(&::vlsir::spice::_CustomAnalysisInput_default_instance_);
}
inline const ::vlsir::spice::CustomAnalysisInput& Analysis::custom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Analysis.custom)
  return _internal_custom();
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Analysis.custom)
  if (_internal_has_custom()) {
    clear_has_an();
    ::vlsir::spice::CustomAnalysisInput* temp = an_.custom_;
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Analysis::unsafe_arena_set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom) {
  clear_an();
  if (custom) {
    set_has_custom();
    an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Analysis.custom)
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_an();
    set_has_custom();
    an_.custom_ = CreateMaybeMessage< ::vlsir::spice::CustomAnalysisInput >(GetArena());
  }
  return an_.custom_;
}
inline ::vlsir::spice::CustomAnalysisInput* Analysis::mutable_custom() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Analysis.custom)
  return _internal_mutable_custom();
}

inline bool Analysis::has_an() const {
  return an_case() != AN_NOT_SET;
}
inline void Analysis::clear_has_an() {
  _oneof_case_[0] = AN_NOT_SET;
}
inline Analysis::AnCase Analysis::an_case() const {
  return Analysis::AnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnalysisResult

// .vlsir.spice.OpResult op = 1;
inline bool AnalysisResult::_internal_has_op() const {
  return an_case() == kOp;
}
inline bool AnalysisResult::has_op() const {
  return _internal_has_op();
}
inline void AnalysisResult::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void AnalysisResult::clear_op() {
  if (_internal_has_op()) {
    if (GetArena() == nullptr) {
      delete an_.op_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::OpResult* AnalysisResult::release_op() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.op)
  if (_internal_has_op()) {
    clear_has_an();
      ::vlsir::spice::OpResult* temp = an_.op_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::OpResult& AnalysisResult::_internal_op() const {
  return _internal_has_op()
      ? *an_.op_
      : *reinterpret_cast< ::vlsir::spice::OpResult*>(&::vlsir::spice::_OpResult_default_instance_);
}
inline const ::vlsir::spice::OpResult& AnalysisResult::op() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.op)
  return _internal_op();
}
inline ::vlsir::spice::OpResult* AnalysisResult::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.op)
  if (_internal_has_op()) {
    clear_has_an();
    ::vlsir::spice::OpResult* temp = an_.op_;
    an_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_op(::vlsir::spice::OpResult* op) {
  clear_an();
  if (op) {
    set_has_op();
    an_.op_ = op;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.op)
}
inline ::vlsir::spice::OpResult* AnalysisResult::_internal_mutable_op() {
  if (!_internal_has_op()) {
    clear_an();
    set_has_op();
    an_.op_ = CreateMaybeMessage< ::vlsir::spice::OpResult >(GetArena());
  }
  return an_.op_;
}
inline ::vlsir::spice::OpResult* AnalysisResult::mutable_op() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.op)
  return _internal_mutable_op();
}

// .vlsir.spice.DcResult dc = 2;
inline bool AnalysisResult::_internal_has_dc() const {
  return an_case() == kDc;
}
inline bool AnalysisResult::has_dc() const {
  return _internal_has_dc();
}
inline void AnalysisResult::set_has_dc() {
  _oneof_case_[0] = kDc;
}
inline void AnalysisResult::clear_dc() {
  if (_internal_has_dc()) {
    if (GetArena() == nullptr) {
      delete an_.dc_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::DcResult* AnalysisResult::release_dc() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.dc)
  if (_internal_has_dc()) {
    clear_has_an();
      ::vlsir::spice::DcResult* temp = an_.dc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::DcResult& AnalysisResult::_internal_dc() const {
  return _internal_has_dc()
      ? *an_.dc_
      : *reinterpret_cast< ::vlsir::spice::DcResult*>(&::vlsir::spice::_DcResult_default_instance_);
}
inline const ::vlsir::spice::DcResult& AnalysisResult::dc() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.dc)
  return _internal_dc();
}
inline ::vlsir::spice::DcResult* AnalysisResult::unsafe_arena_release_dc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.dc)
  if (_internal_has_dc()) {
    clear_has_an();
    ::vlsir::spice::DcResult* temp = an_.dc_;
    an_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_dc(::vlsir::spice::DcResult* dc) {
  clear_an();
  if (dc) {
    set_has_dc();
    an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.dc)
}
inline ::vlsir::spice::DcResult* AnalysisResult::_internal_mutable_dc() {
  if (!_internal_has_dc()) {
    clear_an();
    set_has_dc();
    an_.dc_ = CreateMaybeMessage< ::vlsir::spice::DcResult >(GetArena());
  }
  return an_.dc_;
}
inline ::vlsir::spice::DcResult* AnalysisResult::mutable_dc() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.dc)
  return _internal_mutable_dc();
}

// .vlsir.spice.TranResult tran = 3;
inline bool AnalysisResult::_internal_has_tran() const {
  return an_case() == kTran;
}
inline bool AnalysisResult::has_tran() const {
  return _internal_has_tran();
}
inline void AnalysisResult::set_has_tran() {
  _oneof_case_[0] = kTran;
}
inline void AnalysisResult::clear_tran() {
  if (_internal_has_tran()) {
    if (GetArena() == nullptr) {
      delete an_.tran_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::TranResult* AnalysisResult::release_tran() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.tran)
  if (_internal_has_tran()) {
    clear_has_an();
      ::vlsir::spice::TranResult* temp = an_.tran_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::TranResult& AnalysisResult::_internal_tran() const {
  return _internal_has_tran()
      ? *an_.tran_
      : *reinterpret_cast< ::vlsir::spice::TranResult*>(&::vlsir::spice::_TranResult_default_instance_);
}
inline const ::vlsir::spice::TranResult& AnalysisResult::tran() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.tran)
  return _internal_tran();
}
inline ::vlsir::spice::TranResult* AnalysisResult::unsafe_arena_release_tran() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.tran)
  if (_internal_has_tran()) {
    clear_has_an();
    ::vlsir::spice::TranResult* temp = an_.tran_;
    an_.tran_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_tran(::vlsir::spice::TranResult* tran) {
  clear_an();
  if (tran) {
    set_has_tran();
    an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.tran)
}
inline ::vlsir::spice::TranResult* AnalysisResult::_internal_mutable_tran() {
  if (!_internal_has_tran()) {
    clear_an();
    set_has_tran();
    an_.tran_ = CreateMaybeMessage< ::vlsir::spice::TranResult >(GetArena());
  }
  return an_.tran_;
}
inline ::vlsir::spice::TranResult* AnalysisResult::mutable_tran() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.tran)
  return _internal_mutable_tran();
}

// .vlsir.spice.AcResult ac = 4;
inline bool AnalysisResult::_internal_has_ac() const {
  return an_case() == kAc;
}
inline bool AnalysisResult::has_ac() const {
  return _internal_has_ac();
}
inline void AnalysisResult::set_has_ac() {
  _oneof_case_[0] = kAc;
}
inline void AnalysisResult::clear_ac() {
  if (_internal_has_ac()) {
    if (GetArena() == nullptr) {
      delete an_.ac_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::AcResult* AnalysisResult::release_ac() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.ac)
  if (_internal_has_ac()) {
    clear_has_an();
      ::vlsir::spice::AcResult* temp = an_.ac_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::AcResult& AnalysisResult::_internal_ac() const {
  return _internal_has_ac()
      ? *an_.ac_
      : *reinterpret_cast< ::vlsir::spice::AcResult*>(&::vlsir::spice::_AcResult_default_instance_);
}
inline const ::vlsir::spice::AcResult& AnalysisResult::ac() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.ac)
  return _internal_ac();
}
inline ::vlsir::spice::AcResult* AnalysisResult::unsafe_arena_release_ac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.ac)
  if (_internal_has_ac()) {
    clear_has_an();
    ::vlsir::spice::AcResult* temp = an_.ac_;
    an_.ac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_ac(::vlsir::spice::AcResult* ac) {
  clear_an();
  if (ac) {
    set_has_ac();
    an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.ac)
}
inline ::vlsir::spice::AcResult* AnalysisResult::_internal_mutable_ac() {
  if (!_internal_has_ac()) {
    clear_an();
    set_has_ac();
    an_.ac_ = CreateMaybeMessage< ::vlsir::spice::AcResult >(GetArena());
  }
  return an_.ac_;
}
inline ::vlsir::spice::AcResult* AnalysisResult::mutable_ac() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.ac)
  return _internal_mutable_ac();
}

// .vlsir.spice.SweepResult sweep = 10;
inline bool AnalysisResult::_internal_has_sweep() const {
  return an_case() == kSweep;
}
inline bool AnalysisResult::has_sweep() const {
  return _internal_has_sweep();
}
inline void AnalysisResult::set_has_sweep() {
  _oneof_case_[0] = kSweep;
}
inline void AnalysisResult::clear_sweep() {
  if (_internal_has_sweep()) {
    if (GetArena() == nullptr) {
      delete an_.sweep_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::SweepResult* AnalysisResult::release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
      ::vlsir::spice::SweepResult* temp = an_.sweep_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::SweepResult& AnalysisResult::_internal_sweep() const {
  return _internal_has_sweep()
      ? *an_.sweep_
      : *reinterpret_cast< ::vlsir::spice::SweepResult*>(&::vlsir::spice::_SweepResult_default_instance_);
}
inline const ::vlsir::spice::SweepResult& AnalysisResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.sweep)
  return _internal_sweep();
}
inline ::vlsir::spice::SweepResult* AnalysisResult::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.sweep)
  if (_internal_has_sweep()) {
    clear_has_an();
    ::vlsir::spice::SweepResult* temp = an_.sweep_;
    an_.sweep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_sweep(::vlsir::spice::SweepResult* sweep) {
  clear_an();
  if (sweep) {
    set_has_sweep();
    an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.sweep)
}
inline ::vlsir::spice::SweepResult* AnalysisResult::_internal_mutable_sweep() {
  if (!_internal_has_sweep()) {
    clear_an();
    set_has_sweep();
    an_.sweep_ = CreateMaybeMessage< ::vlsir::spice::SweepResult >(GetArena());
  }
  return an_.sweep_;
}
inline ::vlsir::spice::SweepResult* AnalysisResult::mutable_sweep() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.sweep)
  return _internal_mutable_sweep();
}

// .vlsir.spice.MonteResult monte = 11;
inline bool AnalysisResult::_internal_has_monte() const {
  return an_case() == kMonte;
}
inline bool AnalysisResult::has_monte() const {
  return _internal_has_monte();
}
inline void AnalysisResult::set_has_monte() {
  _oneof_case_[0] = kMonte;
}
inline void AnalysisResult::clear_monte() {
  if (_internal_has_monte()) {
    if (GetArena() == nullptr) {
      delete an_.monte_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::MonteResult* AnalysisResult::release_monte() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.monte)
  if (_internal_has_monte()) {
    clear_has_an();
      ::vlsir::spice::MonteResult* temp = an_.monte_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::MonteResult& AnalysisResult::_internal_monte() const {
  return _internal_has_monte()
      ? *an_.monte_
      : *reinterpret_cast< ::vlsir::spice::MonteResult*>(&::vlsir::spice::_MonteResult_default_instance_);
}
inline const ::vlsir::spice::MonteResult& AnalysisResult::monte() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.monte)
  return _internal_monte();
}
inline ::vlsir::spice::MonteResult* AnalysisResult::unsafe_arena_release_monte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.monte)
  if (_internal_has_monte()) {
    clear_has_an();
    ::vlsir::spice::MonteResult* temp = an_.monte_;
    an_.monte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_monte(::vlsir::spice::MonteResult* monte) {
  clear_an();
  if (monte) {
    set_has_monte();
    an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.monte)
}
inline ::vlsir::spice::MonteResult* AnalysisResult::_internal_mutable_monte() {
  if (!_internal_has_monte()) {
    clear_an();
    set_has_monte();
    an_.monte_ = CreateMaybeMessage< ::vlsir::spice::MonteResult >(GetArena());
  }
  return an_.monte_;
}
inline ::vlsir::spice::MonteResult* AnalysisResult::mutable_monte() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.monte)
  return _internal_mutable_monte();
}

// .vlsir.spice.CustomAnalysisResult custom = 20;
inline bool AnalysisResult::_internal_has_custom() const {
  return an_case() == kCustom;
}
inline bool AnalysisResult::has_custom() const {
  return _internal_has_custom();
}
inline void AnalysisResult::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void AnalysisResult::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArena() == nullptr) {
      delete an_.custom_;
    }
    clear_has_an();
  }
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::release_custom() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AnalysisResult.custom)
  if (_internal_has_custom()) {
    clear_has_an();
      ::vlsir::spice::CustomAnalysisResult* temp = an_.custom_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::CustomAnalysisResult& AnalysisResult::_internal_custom() const {
  return _internal_has_custom()
      ? *an_.custom_
      : *reinterpret_cast< ::vlsir::spice::CustomAnalysisResult*>(&::vlsir::spice::_CustomAnalysisResult_default_instance_);
}
inline const ::vlsir::spice::CustomAnalysisResult& AnalysisResult::custom() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AnalysisResult.custom)
  return _internal_custom();
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AnalysisResult.custom)
  if (_internal_has_custom()) {
    clear_has_an();
    ::vlsir::spice::CustomAnalysisResult* temp = an_.custom_;
    an_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalysisResult::unsafe_arena_set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom) {
  clear_an();
  if (custom) {
    set_has_custom();
    an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AnalysisResult.custom)
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_an();
    set_has_custom();
    an_.custom_ = CreateMaybeMessage< ::vlsir::spice::CustomAnalysisResult >(GetArena());
  }
  return an_.custom_;
}
inline ::vlsir::spice::CustomAnalysisResult* AnalysisResult::mutable_custom() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AnalysisResult.custom)
  return _internal_mutable_custom();
}

inline bool AnalysisResult::has_an() const {
  return an_case() != AN_NOT_SET;
}
inline void AnalysisResult::clear_has_an() {
  _oneof_case_[0] = AN_NOT_SET;
}
inline AnalysisResult::AnCase AnalysisResult::an_case() const {
  return AnalysisResult::AnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpInput

// string analysis_name = 1;
inline void OpInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& OpInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpInput.analysis_name)
  return _internal_analysis_name();
}
inline void OpInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpInput.analysis_name)
}
inline std::string* OpInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& OpInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void OpInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OpInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.OpInput.analysis_name)
}
inline void OpInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpInput.analysis_name)
}
inline void OpInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpInput.analysis_name)
}
inline std::string* OpInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OpInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OpInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpInput.analysis_name)
}
inline std::string* OpInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.OpInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void OpInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.OpInput.analysis_name)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int OpInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int OpInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void OpInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* OpInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
OpInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& OpInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& OpInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* OpInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* OpInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.OpInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
OpInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// OpResult

// string analysis_name = 1;
inline void OpResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& OpResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.analysis_name)
  return _internal_analysis_name();
}
inline void OpResult::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.analysis_name)
}
inline std::string* OpResult::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& OpResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void OpResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OpResult::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.OpResult.analysis_name)
}
inline void OpResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpResult.analysis_name)
}
inline void OpResult::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpResult.analysis_name)
}
inline std::string* OpResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OpResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.OpResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OpResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.OpResult.analysis_name)
}
inline std::string* OpResult::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.OpResult.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void OpResult::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.OpResult.analysis_name)
}

// repeated string signals = 3;
inline int OpResult::_internal_signals_size() const {
  return signals_.size();
}
inline int OpResult::signals_size() const {
  return _internal_signals_size();
}
inline void OpResult::clear_signals() {
  signals_.Clear();
}
inline std::string* OpResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.OpResult.signals)
  return _internal_add_signals();
}
inline const std::string& OpResult::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const std::string& OpResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.signals)
  return _internal_signals(index);
}
inline std::string* OpResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.OpResult.signals)
  return signals_.Mutable(index);
}
inline void OpResult::set_signals(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.signals)
  signals_.Mutable(index)->assign(value);
}
inline void OpResult::set_signals(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
inline void OpResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.OpResult.signals)
}
inline void OpResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.OpResult.signals)
}
inline std::string* OpResult::_internal_add_signals() {
  return signals_.Add();
}
inline void OpResult::add_signals(const std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.signals)
}
inline void OpResult::add_signals(std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.signals)
}
inline void OpResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.OpResult.signals)
}
inline void OpResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.OpResult.signals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpResult.signals)
  return signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int OpResult::_internal_data_size() const {
  return data_.size();
}
inline int OpResult::data_size() const {
  return _internal_data_size();
}
inline void OpResult::clear_data() {
  data_.Clear();
}
inline double OpResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline double OpResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.OpResult.data)
  return _internal_data(index);
}
inline void OpResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.OpResult.data)
}
inline void OpResult::_internal_add_data(double value) {
  data_.Add(value);
}
inline void OpResult::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.OpResult.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
OpResult::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
OpResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.OpResult.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
OpResult::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
OpResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.OpResult.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// DcInput

// string analysis_name = 1;
inline void DcInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DcInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.analysis_name)
  return _internal_analysis_name();
}
inline void DcInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.analysis_name)
}
inline std::string* DcInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& DcInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void DcInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DcInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcInput.analysis_name)
}
inline void DcInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcInput.analysis_name)
}
inline void DcInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcInput.analysis_name)
}
inline std::string* DcInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DcInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DcInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.analysis_name)
}
inline std::string* DcInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.DcInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DcInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcInput.analysis_name)
}

// string indep_name = 2;
inline void DcInput::clear_indep_name() {
  indep_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DcInput::indep_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.indep_name)
  return _internal_indep_name();
}
inline void DcInput::set_indep_name(const std::string& value) {
  _internal_set_indep_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcInput.indep_name)
}
inline std::string* DcInput::mutable_indep_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.indep_name)
  return _internal_mutable_indep_name();
}
inline const std::string& DcInput::_internal_indep_name() const {
  return indep_name_.Get();
}
inline void DcInput::_internal_set_indep_name(const std::string& value) {
  
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DcInput::set_indep_name(std::string&& value) {
  
  indep_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcInput.indep_name)
}
inline void DcInput::set_indep_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcInput.indep_name)
}
inline void DcInput::set_indep_name(const char* value,
    size_t size) {
  
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcInput.indep_name)
}
inline std::string* DcInput::_internal_mutable_indep_name() {
  
  return indep_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DcInput::release_indep_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.indep_name)
  return indep_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DcInput::set_allocated_indep_name(std::string* indep_name) {
  if (indep_name != nullptr) {
    
  } else {
    
  }
  indep_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indep_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.indep_name)
}
inline std::string* DcInput::unsafe_arena_release_indep_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.DcInput.indep_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return indep_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DcInput::unsafe_arena_set_allocated_indep_name(
    std::string* indep_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (indep_name != nullptr) {
    
  } else {
    
  }
  indep_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      indep_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcInput.indep_name)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool DcInput::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool DcInput::has_sweep() const {
  return _internal_has_sweep();
}
inline void DcInput::clear_sweep() {
  if (GetArena() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& DcInput::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& DcInput::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.sweep)
  return _internal_sweep();
}
inline void DcInput::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcInput.sweep)
}
inline ::vlsir::spice::Sweep* DcInput::release_sweep() {
  auto temp = unsafe_arena_release_sweep();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::spice::Sweep* DcInput::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcInput.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* DcInput::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArena());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* DcInput::mutable_sweep() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.sweep)
  return _internal_mutable_sweep();
}
inline void DcInput::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcInput.sweep)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int DcInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int DcInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void DcInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* DcInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
DcInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& DcInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& DcInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* DcInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* DcInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.DcInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
DcInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DcResult

// string analysis_name = 1;
inline void DcResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DcResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.analysis_name)
  return _internal_analysis_name();
}
inline void DcResult::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.analysis_name)
}
inline std::string* DcResult::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& DcResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void DcResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DcResult::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcResult.analysis_name)
}
inline void DcResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcResult.analysis_name)
}
inline void DcResult::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcResult.analysis_name)
}
inline std::string* DcResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DcResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DcResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.analysis_name)
}
inline std::string* DcResult::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.DcResult.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DcResult::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcResult.analysis_name)
}

// string indep_name = 2;
inline void DcResult::clear_indep_name() {
  indep_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DcResult::indep_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.indep_name)
  return _internal_indep_name();
}
inline void DcResult::set_indep_name(const std::string& value) {
  _internal_set_indep_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.indep_name)
}
inline std::string* DcResult::mutable_indep_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.indep_name)
  return _internal_mutable_indep_name();
}
inline const std::string& DcResult::_internal_indep_name() const {
  return indep_name_.Get();
}
inline void DcResult::_internal_set_indep_name(const std::string& value) {
  
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DcResult::set_indep_name(std::string&& value) {
  
  indep_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.DcResult.indep_name)
}
inline void DcResult::set_indep_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcResult.indep_name)
}
inline void DcResult::set_indep_name(const char* value,
    size_t size) {
  
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcResult.indep_name)
}
inline std::string* DcResult::_internal_mutable_indep_name() {
  
  return indep_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DcResult::release_indep_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.DcResult.indep_name)
  return indep_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DcResult::set_allocated_indep_name(std::string* indep_name) {
  if (indep_name != nullptr) {
    
  } else {
    
  }
  indep_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indep_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.DcResult.indep_name)
}
inline std::string* DcResult::unsafe_arena_release_indep_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.DcResult.indep_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return indep_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DcResult::unsafe_arena_set_allocated_indep_name(
    std::string* indep_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (indep_name != nullptr) {
    
  } else {
    
  }
  indep_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      indep_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.DcResult.indep_name)
}

// repeated string signals = 3;
inline int DcResult::_internal_signals_size() const {
  return signals_.size();
}
inline int DcResult::signals_size() const {
  return _internal_signals_size();
}
inline void DcResult::clear_signals() {
  signals_.Clear();
}
inline std::string* DcResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.DcResult.signals)
  return _internal_add_signals();
}
inline const std::string& DcResult::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const std::string& DcResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.signals)
  return _internal_signals(index);
}
inline std::string* DcResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.DcResult.signals)
  return signals_.Mutable(index);
}
inline void DcResult::set_signals(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.signals)
  signals_.Mutable(index)->assign(value);
}
inline void DcResult::set_signals(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
inline void DcResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.DcResult.signals)
}
inline void DcResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.DcResult.signals)
}
inline std::string* DcResult::_internal_add_signals() {
  return signals_.Add();
}
inline void DcResult::add_signals(const std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.signals)
}
inline void DcResult::add_signals(std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.signals)
}
inline void DcResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.DcResult.signals)
}
inline void DcResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.DcResult.signals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DcResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcResult.signals)
  return signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DcResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int DcResult::_internal_data_size() const {
  return data_.size();
}
inline int DcResult::data_size() const {
  return _internal_data_size();
}
inline void DcResult::clear_data() {
  data_.Clear();
}
inline double DcResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline double DcResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.DcResult.data)
  return _internal_data(index);
}
inline void DcResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.DcResult.data)
}
inline void DcResult::_internal_add_data(double value) {
  data_.Add(value);
}
inline void DcResult::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.DcResult.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DcResult::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DcResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.DcResult.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DcResult::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DcResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.DcResult.data)
  return _internal_mutable_data();
}

// map<string, double> measurements = 10;
inline int DcResult::_internal_measurements_size() const {
  return measurements_.size();
}
inline int DcResult::measurements_size() const {
  return _internal_measurements_size();
}
inline void DcResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
DcResult::_internal_measurements() const {
  return measurements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
DcResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.DcResult.measurements)
  return _internal_measurements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
DcResult::_internal_mutable_measurements() {
  return measurements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
DcResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.DcResult.measurements)
  return _internal_mutable_measurements();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TranInput

// string analysis_name = 1;
inline void TranInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TranInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.analysis_name)
  return _internal_analysis_name();
}
inline void TranInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.analysis_name)
}
inline std::string* TranInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& TranInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void TranInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TranInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.TranInput.analysis_name)
}
inline void TranInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranInput.analysis_name)
}
inline void TranInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranInput.analysis_name)
}
inline std::string* TranInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TranInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TranInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranInput.analysis_name)
}
inline std::string* TranInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.TranInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TranInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.TranInput.analysis_name)
}

// double tstop = 2;
inline void TranInput::clear_tstop() {
  tstop_ = 0;
}
inline double TranInput::_internal_tstop() const {
  return tstop_;
}
inline double TranInput::tstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.tstop)
  return _internal_tstop();
}
inline void TranInput::_internal_set_tstop(double value) {
  
  tstop_ = value;
}
inline void TranInput::set_tstop(double value) {
  _internal_set_tstop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.tstop)
}

// double tstep = 3;
inline void TranInput::clear_tstep() {
  tstep_ = 0;
}
inline double TranInput::_internal_tstep() const {
  return tstep_;
}
inline double TranInput::tstep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.tstep)
  return _internal_tstep();
}
inline void TranInput::_internal_set_tstep(double value) {
  
  tstep_ = value;
}
inline void TranInput::set_tstep(double value) {
  _internal_set_tstep(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranInput.tstep)
}

// map<string, double> ic = 4;
inline int TranInput::_internal_ic_size() const {
  return ic_.size();
}
inline int TranInput::ic_size() const {
  return _internal_ic_size();
}
inline void TranInput::clear_ic() {
  ic_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranInput::_internal_ic() const {
  return ic_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranInput::ic() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.TranInput.ic)
  return _internal_ic();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranInput::_internal_mutable_ic() {
  return ic_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranInput::mutable_ic() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.TranInput.ic)
  return _internal_mutable_ic();
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int TranInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int TranInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void TranInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* TranInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
TranInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& TranInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& TranInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* TranInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* TranInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.TranInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
TranInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TranResult

// string analysis_name = 1;
inline void TranResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TranResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.analysis_name)
  return _internal_analysis_name();
}
inline void TranResult::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.analysis_name)
}
inline std::string* TranResult::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranResult.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& TranResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void TranResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TranResult::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.TranResult.analysis_name)
}
inline void TranResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranResult.analysis_name)
}
inline void TranResult::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranResult.analysis_name)
}
inline std::string* TranResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TranResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.TranResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TranResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.TranResult.analysis_name)
}
inline std::string* TranResult::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.TranResult.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TranResult::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.TranResult.analysis_name)
}

// repeated string signals = 3;
inline int TranResult::_internal_signals_size() const {
  return signals_.size();
}
inline int TranResult::signals_size() const {
  return _internal_signals_size();
}
inline void TranResult::clear_signals() {
  signals_.Clear();
}
inline std::string* TranResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.TranResult.signals)
  return _internal_add_signals();
}
inline const std::string& TranResult::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const std::string& TranResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.signals)
  return _internal_signals(index);
}
inline std::string* TranResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.TranResult.signals)
  return signals_.Mutable(index);
}
inline void TranResult::set_signals(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.signals)
  signals_.Mutable(index)->assign(value);
}
inline void TranResult::set_signals(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
inline void TranResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.TranResult.signals)
}
inline void TranResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.TranResult.signals)
}
inline std::string* TranResult::_internal_add_signals() {
  return signals_.Add();
}
inline void TranResult::add_signals(const std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.signals)
}
inline void TranResult::add_signals(std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.signals)
}
inline void TranResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.TranResult.signals)
}
inline void TranResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.TranResult.signals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TranResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranResult.signals)
  return signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TranResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranResult.signals)
  return &signals_;
}

// repeated double data = 5;
inline int TranResult::_internal_data_size() const {
  return data_.size();
}
inline int TranResult::data_size() const {
  return _internal_data_size();
}
inline void TranResult::clear_data() {
  data_.Clear();
}
inline double TranResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline double TranResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.TranResult.data)
  return _internal_data(index);
}
inline void TranResult::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.TranResult.data)
}
inline void TranResult::_internal_add_data(double value) {
  data_.Add(value);
}
inline void TranResult::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.TranResult.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TranResult::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TranResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.TranResult.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TranResult::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TranResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.TranResult.data)
  return _internal_mutable_data();
}

// map<string, double> measurements = 10;
inline int TranResult::_internal_measurements_size() const {
  return measurements_.size();
}
inline int TranResult::measurements_size() const {
  return _internal_measurements_size();
}
inline void TranResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranResult::_internal_measurements() const {
  return measurements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TranResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.TranResult.measurements)
  return _internal_measurements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranResult::_internal_mutable_measurements() {
  return measurements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TranResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.TranResult.measurements)
  return _internal_mutable_measurements();
}

// -------------------------------------------------------------------

// ComplexNum

// double re = 1;
inline void ComplexNum::clear_re() {
  re_ = 0;
}
inline double ComplexNum::_internal_re() const {
  return re_;
}
inline double ComplexNum::re() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.ComplexNum.re)
  return _internal_re();
}
inline void ComplexNum::_internal_set_re(double value) {
  
  re_ = value;
}
inline void ComplexNum::set_re(double value) {
  _internal_set_re(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.ComplexNum.re)
}

// double im = 2;
inline void ComplexNum::clear_im() {
  im_ = 0;
}
inline double ComplexNum::_internal_im() const {
  return im_;
}
inline double ComplexNum::im() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.ComplexNum.im)
  return _internal_im();
}
inline void ComplexNum::_internal_set_im(double value) {
  
  im_ = value;
}
inline void ComplexNum::set_im(double value) {
  _internal_set_im(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.ComplexNum.im)
}

// -------------------------------------------------------------------

// AcInput

// string analysis_name = 1;
inline void AcInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AcInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.analysis_name)
  return _internal_analysis_name();
}
inline void AcInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.analysis_name)
}
inline std::string* AcInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& AcInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void AcInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AcInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.AcInput.analysis_name)
}
inline void AcInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcInput.analysis_name)
}
inline void AcInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcInput.analysis_name)
}
inline std::string* AcInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AcInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AcInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcInput.analysis_name)
}
inline std::string* AcInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AcInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AcInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AcInput.analysis_name)
}

// double fstart = 2;
inline void AcInput::clear_fstart() {
  fstart_ = 0;
}
inline double AcInput::_internal_fstart() const {
  return fstart_;
}
inline double AcInput::fstart() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.fstart)
  return _internal_fstart();
}
inline void AcInput::_internal_set_fstart(double value) {
  
  fstart_ = value;
}
inline void AcInput::set_fstart(double value) {
  _internal_set_fstart(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.fstart)
}

// double fstop = 3;
inline void AcInput::clear_fstop() {
  fstop_ = 0;
}
inline double AcInput::_internal_fstop() const {
  return fstop_;
}
inline double AcInput::fstop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.fstop)
  return _internal_fstop();
}
inline void AcInput::_internal_set_fstop(double value) {
  
  fstop_ = value;
}
inline void AcInput::set_fstop(double value) {
  _internal_set_fstop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.fstop)
}

// uint64 npts = 4;
inline void AcInput::clear_npts() {
  npts_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AcInput::_internal_npts() const {
  return npts_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AcInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.npts)
  return _internal_npts();
}
inline void AcInput::_internal_set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  npts_ = value;
}
inline void AcInput::set_npts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcInput.npts)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int AcInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int AcInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void AcInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* AcInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
AcInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& AcInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& AcInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* AcInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* AcInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.AcInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
AcInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AcResult

// string analysis_name = 1;
inline void AcResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AcResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.analysis_name)
  return _internal_analysis_name();
}
inline void AcResult::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.analysis_name)
}
inline std::string* AcResult::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& AcResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void AcResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AcResult::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.AcResult.analysis_name)
}
inline void AcResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcResult.analysis_name)
}
inline void AcResult::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcResult.analysis_name)
}
inline std::string* AcResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AcResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.AcResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AcResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AcResult.analysis_name)
}
inline std::string* AcResult::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.AcResult.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AcResult::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.AcResult.analysis_name)
}

// repeated double freq = 2;
inline int AcResult::_internal_freq_size() const {
  return freq_.size();
}
inline int AcResult::freq_size() const {
  return _internal_freq_size();
}
inline void AcResult::clear_freq() {
  freq_.Clear();
}
inline double AcResult::_internal_freq(int index) const {
  return freq_.Get(index);
}
inline double AcResult::freq(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.freq)
  return _internal_freq(index);
}
inline void AcResult::set_freq(int index, double value) {
  freq_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.freq)
}
inline void AcResult::_internal_add_freq(double value) {
  freq_.Add(value);
}
inline void AcResult::add_freq(double value) {
  _internal_add_freq(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.freq)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcResult::_internal_freq() const {
  return freq_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcResult::freq() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.freq)
  return _internal_freq();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcResult::_internal_mutable_freq() {
  return &freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcResult::mutable_freq() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.freq)
  return _internal_mutable_freq();
}

// repeated string signals = 3;
inline int AcResult::_internal_signals_size() const {
  return signals_.size();
}
inline int AcResult::signals_size() const {
  return _internal_signals_size();
}
inline void AcResult::clear_signals() {
  signals_.Clear();
}
inline std::string* AcResult::add_signals() {
  // @@protoc_insertion_point(field_add_mutable:vlsir.spice.AcResult.signals)
  return _internal_add_signals();
}
inline const std::string& AcResult::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const std::string& AcResult::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.signals)
  return _internal_signals(index);
}
inline std::string* AcResult::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.signals)
  return signals_.Mutable(index);
}
inline void AcResult::set_signals(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.signals)
  signals_.Mutable(index)->assign(value);
}
inline void AcResult::set_signals(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.AcResult.signals)
  signals_.Mutable(index)->assign(std::move(value));
}
inline void AcResult::set_signals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vlsir.spice.AcResult.signals)
}
inline void AcResult::set_signals(int index, const char* value, size_t size) {
  signals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.AcResult.signals)
}
inline std::string* AcResult::_internal_add_signals() {
  return signals_.Add();
}
inline void AcResult::add_signals(const std::string& value) {
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.signals)
}
inline void AcResult::add_signals(std::string&& value) {
  signals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.signals)
}
inline void AcResult::add_signals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vlsir.spice.AcResult.signals)
}
inline void AcResult::add_signals(const char* value, size_t size) {
  signals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vlsir.spice.AcResult.signals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AcResult::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.signals)
  return signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AcResult::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.signals)
  return &signals_;
}

// repeated .vlsir.spice.ComplexNum data = 5;
inline int AcResult::_internal_data_size() const {
  return data_.size();
}
inline int AcResult::data_size() const {
  return _internal_data_size();
}
inline void AcResult::clear_data() {
  data_.Clear();
}
inline ::vlsir::spice::ComplexNum* AcResult::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.AcResult.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >*
AcResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.AcResult.data)
  return &data_;
}
inline const ::vlsir::spice::ComplexNum& AcResult::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::vlsir::spice::ComplexNum& AcResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.AcResult.data)
  return _internal_data(index);
}
inline ::vlsir::spice::ComplexNum* AcResult::_internal_add_data() {
  return data_.Add();
}
inline ::vlsir::spice::ComplexNum* AcResult::add_data() {
  // @@protoc_insertion_point(field_add:vlsir.spice.AcResult.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::ComplexNum >&
AcResult::data() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.AcResult.data)
  return data_;
}

// map<string, double> measurements = 10;
inline int AcResult::_internal_measurements_size() const {
  return measurements_.size();
}
inline int AcResult::measurements_size() const {
  return _internal_measurements_size();
}
inline void AcResult::clear_measurements() {
  measurements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AcResult::_internal_measurements() const {
  return measurements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AcResult::measurements() const {
  // @@protoc_insertion_point(field_map:vlsir.spice.AcResult.measurements)
  return _internal_measurements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AcResult::_internal_mutable_measurements() {
  return measurements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AcResult::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.spice.AcResult.measurements)
  return _internal_mutable_measurements();
}

// -------------------------------------------------------------------

// SweepInput

// string analysis_name = 1;
inline void SweepInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SweepInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.analysis_name)
  return _internal_analysis_name();
}
inline void SweepInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepInput.analysis_name)
}
inline std::string* SweepInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& SweepInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void SweepInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SweepInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepInput.analysis_name)
}
inline void SweepInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepInput.analysis_name)
}
inline void SweepInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepInput.analysis_name)
}
inline std::string* SweepInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SweepInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SweepInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.analysis_name)
}
inline std::string* SweepInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.SweepInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SweepInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepInput.analysis_name)
}

// string variable = 2;
inline void SweepInput::clear_variable() {
  variable_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SweepInput::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.variable)
  return _internal_variable();
}
inline void SweepInput::set_variable(const std::string& value) {
  _internal_set_variable(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepInput.variable)
}
inline std::string* SweepInput::mutable_variable() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.variable)
  return _internal_mutable_variable();
}
inline const std::string& SweepInput::_internal_variable() const {
  return variable_.Get();
}
inline void SweepInput::_internal_set_variable(const std::string& value) {
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SweepInput::set_variable(std::string&& value) {
  
  variable_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepInput.variable)
}
inline void SweepInput::set_variable(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepInput.variable)
}
inline void SweepInput::set_variable(const char* value,
    size_t size) {
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepInput.variable)
}
inline std::string* SweepInput::_internal_mutable_variable() {
  
  return variable_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SweepInput::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.variable)
  return variable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SweepInput::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.variable)
}
inline std::string* SweepInput::unsafe_arena_release_variable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.SweepInput.variable)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return variable_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SweepInput::unsafe_arena_set_allocated_variable(
    std::string* variable) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      variable, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepInput.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool SweepInput::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool SweepInput::has_sweep() const {
  return _internal_has_sweep();
}
inline void SweepInput::clear_sweep() {
  if (GetArena() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& SweepInput::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& SweepInput::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.sweep)
  return _internal_sweep();
}
inline void SweepInput::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepInput.sweep)
}
inline ::vlsir::spice::Sweep* SweepInput::release_sweep() {
  auto temp = unsafe_arena_release_sweep();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::spice::Sweep* SweepInput::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepInput.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* SweepInput::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArena());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* SweepInput::mutable_sweep() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.sweep)
  return _internal_mutable_sweep();
}
inline void SweepInput::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepInput.sweep)
}

// repeated .vlsir.spice.Analysis an = 4;
inline int SweepInput::_internal_an_size() const {
  return an_.size();
}
inline int SweepInput::an_size() const {
  return _internal_an_size();
}
inline void SweepInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* SweepInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
SweepInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& SweepInput::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::Analysis& SweepInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.an)
  return _internal_an(index);
}
inline ::vlsir::spice::Analysis* SweepInput::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::Analysis* SweepInput::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepInput.an)
  return _internal_add_an();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
SweepInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int SweepInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int SweepInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void SweepInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* SweepInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
SweepInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& SweepInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& SweepInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* SweepInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* SweepInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
SweepInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// SweepResult

// string analysis_name = 1;
inline void SweepResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SweepResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.analysis_name)
  return _internal_analysis_name();
}
inline void SweepResult::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepResult.analysis_name)
}
inline std::string* SweepResult::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& SweepResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void SweepResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SweepResult::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepResult.analysis_name)
}
inline void SweepResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepResult.analysis_name)
}
inline void SweepResult::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepResult.analysis_name)
}
inline std::string* SweepResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SweepResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SweepResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.analysis_name)
}
inline std::string* SweepResult::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.SweepResult.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SweepResult::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepResult.analysis_name)
}

// string variable = 2;
inline void SweepResult::clear_variable() {
  variable_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SweepResult::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.variable)
  return _internal_variable();
}
inline void SweepResult::set_variable(const std::string& value) {
  _internal_set_variable(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.SweepResult.variable)
}
inline std::string* SweepResult::mutable_variable() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.variable)
  return _internal_mutable_variable();
}
inline const std::string& SweepResult::_internal_variable() const {
  return variable_.Get();
}
inline void SweepResult::_internal_set_variable(const std::string& value) {
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SweepResult::set_variable(std::string&& value) {
  
  variable_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.SweepResult.variable)
}
inline void SweepResult::set_variable(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.SweepResult.variable)
}
inline void SweepResult::set_variable(const char* value,
    size_t size) {
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.SweepResult.variable)
}
inline std::string* SweepResult::_internal_mutable_variable() {
  
  return variable_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SweepResult::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.variable)
  return variable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SweepResult::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.variable)
}
inline std::string* SweepResult::unsafe_arena_release_variable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.SweepResult.variable)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return variable_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SweepResult::unsafe_arena_set_allocated_variable(
    std::string* variable) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      variable, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepResult.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool SweepResult::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool SweepResult::has_sweep() const {
  return _internal_has_sweep();
}
inline void SweepResult::clear_sweep() {
  if (GetArena() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& SweepResult::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& SweepResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.sweep)
  return _internal_sweep();
}
inline void SweepResult::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.SweepResult.sweep)
}
inline ::vlsir::spice::Sweep* SweepResult::release_sweep() {
  auto temp = unsafe_arena_release_sweep();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::spice::Sweep* SweepResult::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.SweepResult.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* SweepResult::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArena());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* SweepResult::mutable_sweep() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.sweep)
  return _internal_mutable_sweep();
}
inline void SweepResult::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.SweepResult.sweep)
}

// repeated .vlsir.spice.AnalysisResult an = 4;
inline int SweepResult::_internal_an_size() const {
  return an_.size();
}
inline int SweepResult::an_size() const {
  return _internal_an_size();
}
inline void SweepResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* SweepResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.SweepResult.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
SweepResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.SweepResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& SweepResult::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::AnalysisResult& SweepResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.SweepResult.an)
  return _internal_an(index);
}
inline ::vlsir::spice::AnalysisResult* SweepResult::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::AnalysisResult* SweepResult::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.SweepResult.an)
  return _internal_add_an();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
SweepResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.SweepResult.an)
  return an_;
}

// -------------------------------------------------------------------

// MonteInput

// string analysis_name = 1;
inline void MonteInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MonteInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.analysis_name)
  return _internal_analysis_name();
}
inline void MonteInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.analysis_name)
}
inline std::string* MonteInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& MonteInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void MonteInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MonteInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.MonteInput.analysis_name)
}
inline void MonteInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.MonteInput.analysis_name)
}
inline void MonteInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.MonteInput.analysis_name)
}
inline std::string* MonteInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MonteInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MonteInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteInput.analysis_name)
}
inline std::string* MonteInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.MonteInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MonteInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.MonteInput.analysis_name)
}

// int64 npts = 2;
inline void MonteInput::clear_npts() {
  npts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::_internal_npts() const {
  return npts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.npts)
  return _internal_npts();
}
inline void MonteInput::_internal_set_npts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  npts_ = value;
}
inline void MonteInput::set_npts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.npts)
}

// int64 seed = 3;
inline void MonteInput::clear_seed() {
  seed_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::_internal_seed() const {
  return seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MonteInput::seed() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.seed)
  return _internal_seed();
}
inline void MonteInput::_internal_set_seed(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seed_ = value;
}
inline void MonteInput::set_seed(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteInput.seed)
}

// repeated .vlsir.spice.Analysis an = 4;
inline int MonteInput::_internal_an_size() const {
  return an_.size();
}
inline int MonteInput::an_size() const {
  return _internal_an_size();
}
inline void MonteInput::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::Analysis* MonteInput::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >*
MonteInput::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteInput.an)
  return &an_;
}
inline const ::vlsir::spice::Analysis& MonteInput::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::Analysis& MonteInput::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.an)
  return _internal_an(index);
}
inline ::vlsir::spice::Analysis* MonteInput::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::Analysis* MonteInput::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteInput.an)
  return _internal_add_an();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Analysis >&
MonteInput::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteInput.an)
  return an_;
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int MonteInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int MonteInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void MonteInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* MonteInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
MonteInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& MonteInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& MonteInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* MonteInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* MonteInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
MonteInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// MonteResult

// string analysis_name = 1;
inline void MonteResult::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MonteResult::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.analysis_name)
  return _internal_analysis_name();
}
inline void MonteResult::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteResult.analysis_name)
}
inline std::string* MonteResult::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& MonteResult::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void MonteResult::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MonteResult::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.MonteResult.analysis_name)
}
inline void MonteResult::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.MonteResult.analysis_name)
}
inline void MonteResult::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.MonteResult.analysis_name)
}
inline std::string* MonteResult::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MonteResult::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MonteResult::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.analysis_name)
}
inline std::string* MonteResult::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.MonteResult.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MonteResult::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.MonteResult.analysis_name)
}

// string variable = 2;
inline void MonteResult::clear_variable() {
  variable_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MonteResult::variable() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.variable)
  return _internal_variable();
}
inline void MonteResult::set_variable(const std::string& value) {
  _internal_set_variable(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.MonteResult.variable)
}
inline std::string* MonteResult::mutable_variable() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.variable)
  return _internal_mutable_variable();
}
inline const std::string& MonteResult::_internal_variable() const {
  return variable_.Get();
}
inline void MonteResult::_internal_set_variable(const std::string& value) {
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MonteResult::set_variable(std::string&& value) {
  
  variable_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.MonteResult.variable)
}
inline void MonteResult::set_variable(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.MonteResult.variable)
}
inline void MonteResult::set_variable(const char* value,
    size_t size) {
  
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.MonteResult.variable)
}
inline std::string* MonteResult::_internal_mutable_variable() {
  
  return variable_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MonteResult::release_variable() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.variable)
  return variable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MonteResult::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.variable)
}
inline std::string* MonteResult::unsafe_arena_release_variable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.MonteResult.variable)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return variable_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MonteResult::unsafe_arena_set_allocated_variable(
    std::string* variable) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (variable != nullptr) {
    
  } else {
    
  }
  variable_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      variable, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.MonteResult.variable)
}

// .vlsir.spice.Sweep sweep = 3;
inline bool MonteResult::_internal_has_sweep() const {
  return this != internal_default_instance() && sweep_ != nullptr;
}
inline bool MonteResult::has_sweep() const {
  return _internal_has_sweep();
}
inline void MonteResult::clear_sweep() {
  if (GetArena() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
}
inline const ::vlsir::spice::Sweep& MonteResult::_internal_sweep() const {
  const ::vlsir::spice::Sweep* p = sweep_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::spice::Sweep*>(
      &::vlsir::spice::_Sweep_default_instance_);
}
inline const ::vlsir::spice::Sweep& MonteResult::sweep() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.sweep)
  return _internal_sweep();
}
inline void MonteResult::unsafe_arena_set_allocated_sweep(
    ::vlsir::spice::Sweep* sweep) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sweep_);
  }
  sweep_ = sweep;
  if (sweep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.MonteResult.sweep)
}
inline ::vlsir::spice::Sweep* MonteResult::release_sweep() {
  auto temp = unsafe_arena_release_sweep();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::spice::Sweep* MonteResult::unsafe_arena_release_sweep() {
  // @@protoc_insertion_point(field_release:vlsir.spice.MonteResult.sweep)
  
  ::vlsir::spice::Sweep* temp = sweep_;
  sweep_ = nullptr;
  return temp;
}
inline ::vlsir::spice::Sweep* MonteResult::_internal_mutable_sweep() {
  
  if (sweep_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::spice::Sweep>(GetArena());
    sweep_ = p;
  }
  return sweep_;
}
inline ::vlsir::spice::Sweep* MonteResult::mutable_sweep() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.sweep)
  return _internal_mutable_sweep();
}
inline void MonteResult::set_allocated_sweep(::vlsir::spice::Sweep* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sweep_;
  }
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    
  } else {
    
  }
  sweep_ = sweep;
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.MonteResult.sweep)
}

// repeated .vlsir.spice.AnalysisResult an = 4;
inline int MonteResult::_internal_an_size() const {
  return an_.size();
}
inline int MonteResult::an_size() const {
  return _internal_an_size();
}
inline void MonteResult::clear_an() {
  an_.Clear();
}
inline ::vlsir::spice::AnalysisResult* MonteResult::mutable_an(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.MonteResult.an)
  return an_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >*
MonteResult::mutable_an() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.MonteResult.an)
  return &an_;
}
inline const ::vlsir::spice::AnalysisResult& MonteResult::_internal_an(int index) const {
  return an_.Get(index);
}
inline const ::vlsir::spice::AnalysisResult& MonteResult::an(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.MonteResult.an)
  return _internal_an(index);
}
inline ::vlsir::spice::AnalysisResult* MonteResult::_internal_add_an() {
  return an_.Add();
}
inline ::vlsir::spice::AnalysisResult* MonteResult::add_an() {
  // @@protoc_insertion_point(field_add:vlsir.spice.MonteResult.an)
  return _internal_add_an();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::AnalysisResult >&
MonteResult::an() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.MonteResult.an)
  return an_;
}

// -------------------------------------------------------------------

// CustomAnalysisInput

// string analysis_name = 1;
inline void CustomAnalysisInput::clear_analysis_name() {
  analysis_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CustomAnalysisInput::analysis_name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.analysis_name)
  return _internal_analysis_name();
}
inline void CustomAnalysisInput::set_analysis_name(const std::string& value) {
  _internal_set_analysis_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline std::string* CustomAnalysisInput::mutable_analysis_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.analysis_name)
  return _internal_mutable_analysis_name();
}
inline const std::string& CustomAnalysisInput::_internal_analysis_name() const {
  return analysis_name_.Get();
}
inline void CustomAnalysisInput::_internal_set_analysis_name(const std::string& value) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CustomAnalysisInput::set_analysis_name(std::string&& value) {
  
  analysis_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline void CustomAnalysisInput::set_analysis_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline void CustomAnalysisInput::set_analysis_name(const char* value,
    size_t size) {
  
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline std::string* CustomAnalysisInput::_internal_mutable_analysis_name() {
  
  return analysis_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CustomAnalysisInput::release_analysis_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.CustomAnalysisInput.analysis_name)
  return analysis_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomAnalysisInput::set_allocated_analysis_name(std::string* analysis_name) {
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.CustomAnalysisInput.analysis_name)
}
inline std::string* CustomAnalysisInput::unsafe_arena_release_analysis_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.CustomAnalysisInput.analysis_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CustomAnalysisInput::unsafe_arena_set_allocated_analysis_name(
    std::string* analysis_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_name != nullptr) {
    
  } else {
    
  }
  analysis_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.CustomAnalysisInput.analysis_name)
}

// string cmd = 2;
inline void CustomAnalysisInput::clear_cmd() {
  cmd_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CustomAnalysisInput::cmd() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.cmd)
  return _internal_cmd();
}
inline void CustomAnalysisInput::set_cmd(const std::string& value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.CustomAnalysisInput.cmd)
}
inline std::string* CustomAnalysisInput::mutable_cmd() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.cmd)
  return _internal_mutable_cmd();
}
inline const std::string& CustomAnalysisInput::_internal_cmd() const {
  return cmd_.Get();
}
inline void CustomAnalysisInput::_internal_set_cmd(const std::string& value) {
  
  cmd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CustomAnalysisInput::set_cmd(std::string&& value) {
  
  cmd_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.CustomAnalysisInput.cmd)
}
inline void CustomAnalysisInput::set_cmd(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cmd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.CustomAnalysisInput.cmd)
}
inline void CustomAnalysisInput::set_cmd(const char* value,
    size_t size) {
  
  cmd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.CustomAnalysisInput.cmd)
}
inline std::string* CustomAnalysisInput::_internal_mutable_cmd() {
  
  return cmd_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CustomAnalysisInput::release_cmd() {
  // @@protoc_insertion_point(field_release:vlsir.spice.CustomAnalysisInput.cmd)
  return cmd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomAnalysisInput::set_allocated_cmd(std::string* cmd) {
  if (cmd != nullptr) {
    
  } else {
    
  }
  cmd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmd,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.CustomAnalysisInput.cmd)
}
inline std::string* CustomAnalysisInput::unsafe_arena_release_cmd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.CustomAnalysisInput.cmd)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return cmd_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CustomAnalysisInput::unsafe_arena_set_allocated_cmd(
    std::string* cmd) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (cmd != nullptr) {
    
  } else {
    
  }
  cmd_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      cmd, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.CustomAnalysisInput.cmd)
}

// repeated .vlsir.spice.Control ctrls = 5;
inline int CustomAnalysisInput::_internal_ctrls_size() const {
  return ctrls_.size();
}
inline int CustomAnalysisInput::ctrls_size() const {
  return _internal_ctrls_size();
}
inline void CustomAnalysisInput::clear_ctrls() {
  ctrls_.Clear();
}
inline ::vlsir::spice::Control* CustomAnalysisInput::mutable_ctrls(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >*
CustomAnalysisInput::mutable_ctrls() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.CustomAnalysisInput.ctrls)
  return &ctrls_;
}
inline const ::vlsir::spice::Control& CustomAnalysisInput::_internal_ctrls(int index) const {
  return ctrls_.Get(index);
}
inline const ::vlsir::spice::Control& CustomAnalysisInput::ctrls(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.CustomAnalysisInput.ctrls)
  return _internal_ctrls(index);
}
inline ::vlsir::spice::Control* CustomAnalysisInput::_internal_add_ctrls() {
  return ctrls_.Add();
}
inline ::vlsir::spice::Control* CustomAnalysisInput::add_ctrls() {
  // @@protoc_insertion_point(field_add:vlsir.spice.CustomAnalysisInput.ctrls)
  return _internal_add_ctrls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::spice::Control >&
CustomAnalysisInput::ctrls() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.CustomAnalysisInput.ctrls)
  return ctrls_;
}

// -------------------------------------------------------------------

// CustomAnalysisResult

// -------------------------------------------------------------------

// Sweep

// .vlsir.spice.LinearSweep linear = 1;
inline bool Sweep::_internal_has_linear() const {
  return tp_case() == kLinear;
}
inline bool Sweep::has_linear() const {
  return _internal_has_linear();
}
inline void Sweep::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void Sweep::clear_linear() {
  if (_internal_has_linear()) {
    if (GetArena() == nullptr) {
      delete tp_.linear_;
    }
    clear_has_tp();
  }
}
inline ::vlsir::spice::LinearSweep* Sweep::release_linear() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.linear)
  if (_internal_has_linear()) {
    clear_has_tp();
      ::vlsir::spice::LinearSweep* temp = tp_.linear_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tp_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::LinearSweep& Sweep::_internal_linear() const {
  return _internal_has_linear()
      ? *tp_.linear_
      : *reinterpret_cast< ::vlsir::spice::LinearSweep*>(&::vlsir::spice::_LinearSweep_default_instance_);
}
inline const ::vlsir::spice::LinearSweep& Sweep::linear() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.linear)
  return _internal_linear();
}
inline ::vlsir::spice::LinearSweep* Sweep::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Sweep.linear)
  if (_internal_has_linear()) {
    clear_has_tp();
    ::vlsir::spice::LinearSweep* temp = tp_.linear_;
    tp_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sweep::unsafe_arena_set_allocated_linear(::vlsir::spice::LinearSweep* linear) {
  clear_tp();
  if (linear) {
    set_has_linear();
    tp_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Sweep.linear)
}
inline ::vlsir::spice::LinearSweep* Sweep::_internal_mutable_linear() {
  if (!_internal_has_linear()) {
    clear_tp();
    set_has_linear();
    tp_.linear_ = CreateMaybeMessage< ::vlsir::spice::LinearSweep >(GetArena());
  }
  return tp_.linear_;
}
inline ::vlsir::spice::LinearSweep* Sweep::mutable_linear() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.linear)
  return _internal_mutable_linear();
}

// .vlsir.spice.LogSweep log = 2;
inline bool Sweep::_internal_has_log() const {
  return tp_case() == kLog;
}
inline bool Sweep::has_log() const {
  return _internal_has_log();
}
inline void Sweep::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void Sweep::clear_log() {
  if (_internal_has_log()) {
    if (GetArena() == nullptr) {
      delete tp_.log_;
    }
    clear_has_tp();
  }
}
inline ::vlsir::spice::LogSweep* Sweep::release_log() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.log)
  if (_internal_has_log()) {
    clear_has_tp();
      ::vlsir::spice::LogSweep* temp = tp_.log_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tp_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::LogSweep& Sweep::_internal_log() const {
  return _internal_has_log()
      ? *tp_.log_
      : *reinterpret_cast< ::vlsir::spice::LogSweep*>(&::vlsir::spice::_LogSweep_default_instance_);
}
inline const ::vlsir::spice::LogSweep& Sweep::log() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.log)
  return _internal_log();
}
inline ::vlsir::spice::LogSweep* Sweep::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Sweep.log)
  if (_internal_has_log()) {
    clear_has_tp();
    ::vlsir::spice::LogSweep* temp = tp_.log_;
    tp_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sweep::unsafe_arena_set_allocated_log(::vlsir::spice::LogSweep* log) {
  clear_tp();
  if (log) {
    set_has_log();
    tp_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Sweep.log)
}
inline ::vlsir::spice::LogSweep* Sweep::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_tp();
    set_has_log();
    tp_.log_ = CreateMaybeMessage< ::vlsir::spice::LogSweep >(GetArena());
  }
  return tp_.log_;
}
inline ::vlsir::spice::LogSweep* Sweep::mutable_log() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.log)
  return _internal_mutable_log();
}

// .vlsir.spice.PointSweep points = 3;
inline bool Sweep::_internal_has_points() const {
  return tp_case() == kPoints;
}
inline bool Sweep::has_points() const {
  return _internal_has_points();
}
inline void Sweep::set_has_points() {
  _oneof_case_[0] = kPoints;
}
inline void Sweep::clear_points() {
  if (_internal_has_points()) {
    if (GetArena() == nullptr) {
      delete tp_.points_;
    }
    clear_has_tp();
  }
}
inline ::vlsir::spice::PointSweep* Sweep::release_points() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Sweep.points)
  if (_internal_has_points()) {
    clear_has_tp();
      ::vlsir::spice::PointSweep* temp = tp_.points_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    tp_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::PointSweep& Sweep::_internal_points() const {
  return _internal_has_points()
      ? *tp_.points_
      : *reinterpret_cast< ::vlsir::spice::PointSweep*>(&::vlsir::spice::_PointSweep_default_instance_);
}
inline const ::vlsir::spice::PointSweep& Sweep::points() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Sweep.points)
  return _internal_points();
}
inline ::vlsir::spice::PointSweep* Sweep::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Sweep.points)
  if (_internal_has_points()) {
    clear_has_tp();
    ::vlsir::spice::PointSweep* temp = tp_.points_;
    tp_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sweep::unsafe_arena_set_allocated_points(::vlsir::spice::PointSweep* points) {
  clear_tp();
  if (points) {
    set_has_points();
    tp_.points_ = points;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Sweep.points)
}
inline ::vlsir::spice::PointSweep* Sweep::_internal_mutable_points() {
  if (!_internal_has_points()) {
    clear_tp();
    set_has_points();
    tp_.points_ = CreateMaybeMessage< ::vlsir::spice::PointSweep >(GetArena());
  }
  return tp_.points_;
}
inline ::vlsir::spice::PointSweep* Sweep::mutable_points() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Sweep.points)
  return _internal_mutable_points();
}

inline bool Sweep::has_tp() const {
  return tp_case() != TP_NOT_SET;
}
inline void Sweep::clear_has_tp() {
  _oneof_case_[0] = TP_NOT_SET;
}
inline Sweep::TpCase Sweep::tp_case() const {
  return Sweep::TpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinearSweep

// double start = 1;
inline void LinearSweep::clear_start() {
  start_ = 0;
}
inline double LinearSweep::_internal_start() const {
  return start_;
}
inline double LinearSweep::start() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.start)
  return _internal_start();
}
inline void LinearSweep::_internal_set_start(double value) {
  
  start_ = value;
}
inline void LinearSweep::set_start(double value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.start)
}

// double stop = 2;
inline void LinearSweep::clear_stop() {
  stop_ = 0;
}
inline double LinearSweep::_internal_stop() const {
  return stop_;
}
inline double LinearSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.stop)
  return _internal_stop();
}
inline void LinearSweep::_internal_set_stop(double value) {
  
  stop_ = value;
}
inline void LinearSweep::set_stop(double value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.stop)
}

// double step = 3;
inline void LinearSweep::clear_step() {
  step_ = 0;
}
inline double LinearSweep::_internal_step() const {
  return step_;
}
inline double LinearSweep::step() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LinearSweep.step)
  return _internal_step();
}
inline void LinearSweep::_internal_set_step(double value) {
  
  step_ = value;
}
inline void LinearSweep::set_step(double value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LinearSweep.step)
}

// -------------------------------------------------------------------

// LogSweep

// double start = 1;
inline void LogSweep::clear_start() {
  start_ = 0;
}
inline double LogSweep::_internal_start() const {
  return start_;
}
inline double LogSweep::start() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.start)
  return _internal_start();
}
inline void LogSweep::_internal_set_start(double value) {
  
  start_ = value;
}
inline void LogSweep::set_start(double value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.start)
}

// double stop = 2;
inline void LogSweep::clear_stop() {
  stop_ = 0;
}
inline double LogSweep::_internal_stop() const {
  return stop_;
}
inline double LogSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.stop)
  return _internal_stop();
}
inline void LogSweep::_internal_set_stop(double value) {
  
  stop_ = value;
}
inline void LogSweep::set_stop(double value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.stop)
}

// double npts = 3;
inline void LogSweep::clear_npts() {
  npts_ = 0;
}
inline double LogSweep::_internal_npts() const {
  return npts_;
}
inline double LogSweep::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LogSweep.npts)
  return _internal_npts();
}
inline void LogSweep::_internal_set_npts(double value) {
  
  npts_ = value;
}
inline void LogSweep::set_npts(double value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LogSweep.npts)
}

// -------------------------------------------------------------------

// PointSweep

// repeated double points = 1;
inline int PointSweep::_internal_points_size() const {
  return points_.size();
}
inline int PointSweep::points_size() const {
  return _internal_points_size();
}
inline void PointSweep::clear_points() {
  points_.Clear();
}
inline double PointSweep::_internal_points(int index) const {
  return points_.Get(index);
}
inline double PointSweep::points(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.points)
  return _internal_points(index);
}
inline void PointSweep::set_points(int index, double value) {
  points_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.points)
}
inline void PointSweep::_internal_add_points(double value) {
  points_.Add(value);
}
inline void PointSweep::add_points(double value) {
  _internal_add_points(value);
  // @@protoc_insertion_point(field_add:vlsir.spice.PointSweep.points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PointSweep::_internal_points() const {
  return points_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PointSweep::points() const {
  // @@protoc_insertion_point(field_list:vlsir.spice.PointSweep.points)
  return _internal_points();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PointSweep::_internal_mutable_points() {
  return &points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PointSweep::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.spice.PointSweep.points)
  return _internal_mutable_points();
}

// double stop = 2;
inline void PointSweep::clear_stop() {
  stop_ = 0;
}
inline double PointSweep::_internal_stop() const {
  return stop_;
}
inline double PointSweep::stop() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.stop)
  return _internal_stop();
}
inline void PointSweep::_internal_set_stop(double value) {
  
  stop_ = value;
}
inline void PointSweep::set_stop(double value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.stop)
}

// double npts = 3;
inline void PointSweep::clear_npts() {
  npts_ = 0;
}
inline double PointSweep::_internal_npts() const {
  return npts_;
}
inline double PointSweep::npts() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.PointSweep.npts)
  return _internal_npts();
}
inline void PointSweep::_internal_set_npts(double value) {
  
  npts_ = value;
}
inline void PointSweep::set_npts(double value) {
  _internal_set_npts(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.PointSweep.npts)
}

// -------------------------------------------------------------------

// Control

// .vlsir.spice.Include include = 1;
inline bool Control::_internal_has_include() const {
  return ctrl_case() == kInclude;
}
inline bool Control::has_include() const {
  return _internal_has_include();
}
inline void Control::set_has_include() {
  _oneof_case_[0] = kInclude;
}
inline void Control::clear_include() {
  if (_internal_has_include()) {
    if (GetArena() == nullptr) {
      delete ctrl_.include_;
    }
    clear_has_ctrl();
  }
}
inline ::vlsir::spice::Include* Control::release_include() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.include)
  if (_internal_has_include()) {
    clear_has_ctrl();
      ::vlsir::spice::Include* temp = ctrl_.include_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::Include& Control::_internal_include() const {
  return _internal_has_include()
      ? *ctrl_.include_
      : *reinterpret_cast< ::vlsir::spice::Include*>(&::vlsir::spice::_Include_default_instance_);
}
inline const ::vlsir::spice::Include& Control::include() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.include)
  return _internal_include();
}
inline ::vlsir::spice::Include* Control::unsafe_arena_release_include() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.include)
  if (_internal_has_include()) {
    clear_has_ctrl();
    ::vlsir::spice::Include* temp = ctrl_.include_;
    ctrl_.include_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_include(::vlsir::spice::Include* include) {
  clear_ctrl();
  if (include) {
    set_has_include();
    ctrl_.include_ = include;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.include)
}
inline ::vlsir::spice::Include* Control::_internal_mutable_include() {
  if (!_internal_has_include()) {
    clear_ctrl();
    set_has_include();
    ctrl_.include_ = CreateMaybeMessage< ::vlsir::spice::Include >(GetArena());
  }
  return ctrl_.include_;
}
inline ::vlsir::spice::Include* Control::mutable_include() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.include)
  return _internal_mutable_include();
}

// .vlsir.spice.LibInclude lib = 2;
inline bool Control::_internal_has_lib() const {
  return ctrl_case() == kLib;
}
inline bool Control::has_lib() const {
  return _internal_has_lib();
}
inline void Control::set_has_lib() {
  _oneof_case_[0] = kLib;
}
inline void Control::clear_lib() {
  if (_internal_has_lib()) {
    if (GetArena() == nullptr) {
      delete ctrl_.lib_;
    }
    clear_has_ctrl();
  }
}
inline ::vlsir::spice::LibInclude* Control::release_lib() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.lib)
  if (_internal_has_lib()) {
    clear_has_ctrl();
      ::vlsir::spice::LibInclude* temp = ctrl_.lib_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.lib_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::LibInclude& Control::_internal_lib() const {
  return _internal_has_lib()
      ? *ctrl_.lib_
      : *reinterpret_cast< ::vlsir::spice::LibInclude*>(&::vlsir::spice::_LibInclude_default_instance_);
}
inline const ::vlsir::spice::LibInclude& Control::lib() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.lib)
  return _internal_lib();
}
inline ::vlsir::spice::LibInclude* Control::unsafe_arena_release_lib() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.lib)
  if (_internal_has_lib()) {
    clear_has_ctrl();
    ::vlsir::spice::LibInclude* temp = ctrl_.lib_;
    ctrl_.lib_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_lib(::vlsir::spice::LibInclude* lib) {
  clear_ctrl();
  if (lib) {
    set_has_lib();
    ctrl_.lib_ = lib;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.lib)
}
inline ::vlsir::spice::LibInclude* Control::_internal_mutable_lib() {
  if (!_internal_has_lib()) {
    clear_ctrl();
    set_has_lib();
    ctrl_.lib_ = CreateMaybeMessage< ::vlsir::spice::LibInclude >(GetArena());
  }
  return ctrl_.lib_;
}
inline ::vlsir::spice::LibInclude* Control::mutable_lib() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.lib)
  return _internal_mutable_lib();
}

// .vlsir.spice.Save save = 5;
inline bool Control::_internal_has_save() const {
  return ctrl_case() == kSave;
}
inline bool Control::has_save() const {
  return _internal_has_save();
}
inline void Control::set_has_save() {
  _oneof_case_[0] = kSave;
}
inline void Control::clear_save() {
  if (_internal_has_save()) {
    if (GetArena() == nullptr) {
      delete ctrl_.save_;
    }
    clear_has_ctrl();
  }
}
inline ::vlsir::spice::Save* Control::release_save() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.save)
  if (_internal_has_save()) {
    clear_has_ctrl();
      ::vlsir::spice::Save* temp = ctrl_.save_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::Save& Control::_internal_save() const {
  return _internal_has_save()
      ? *ctrl_.save_
      : *reinterpret_cast< ::vlsir::spice::Save*>(&::vlsir::spice::_Save_default_instance_);
}
inline const ::vlsir::spice::Save& Control::save() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.save)
  return _internal_save();
}
inline ::vlsir::spice::Save* Control::unsafe_arena_release_save() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.save)
  if (_internal_has_save()) {
    clear_has_ctrl();
    ::vlsir::spice::Save* temp = ctrl_.save_;
    ctrl_.save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_save(::vlsir::spice::Save* save) {
  clear_ctrl();
  if (save) {
    set_has_save();
    ctrl_.save_ = save;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.save)
}
inline ::vlsir::spice::Save* Control::_internal_mutable_save() {
  if (!_internal_has_save()) {
    clear_ctrl();
    set_has_save();
    ctrl_.save_ = CreateMaybeMessage< ::vlsir::spice::Save >(GetArena());
  }
  return ctrl_.save_;
}
inline ::vlsir::spice::Save* Control::mutable_save() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.save)
  return _internal_mutable_save();
}

// .vlsir.spice.Meas meas = 6;
inline bool Control::_internal_has_meas() const {
  return ctrl_case() == kMeas;
}
inline bool Control::has_meas() const {
  return _internal_has_meas();
}
inline void Control::set_has_meas() {
  _oneof_case_[0] = kMeas;
}
inline void Control::clear_meas() {
  if (_internal_has_meas()) {
    if (GetArena() == nullptr) {
      delete ctrl_.meas_;
    }
    clear_has_ctrl();
  }
}
inline ::vlsir::spice::Meas* Control::release_meas() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.meas)
  if (_internal_has_meas()) {
    clear_has_ctrl();
      ::vlsir::spice::Meas* temp = ctrl_.meas_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.meas_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::spice::Meas& Control::_internal_meas() const {
  return _internal_has_meas()
      ? *ctrl_.meas_
      : *reinterpret_cast< ::vlsir::spice::Meas*>(&::vlsir::spice::_Meas_default_instance_);
}
inline const ::vlsir::spice::Meas& Control::meas() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.meas)
  return _internal_meas();
}
inline ::vlsir::spice::Meas* Control::unsafe_arena_release_meas() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.meas)
  if (_internal_has_meas()) {
    clear_has_ctrl();
    ::vlsir::spice::Meas* temp = ctrl_.meas_;
    ctrl_.meas_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_meas(::vlsir::spice::Meas* meas) {
  clear_ctrl();
  if (meas) {
    set_has_meas();
    ctrl_.meas_ = meas;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.meas)
}
inline ::vlsir::spice::Meas* Control::_internal_mutable_meas() {
  if (!_internal_has_meas()) {
    clear_ctrl();
    set_has_meas();
    ctrl_.meas_ = CreateMaybeMessage< ::vlsir::spice::Meas >(GetArena());
  }
  return ctrl_.meas_;
}
inline ::vlsir::spice::Meas* Control::mutable_meas() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.meas)
  return _internal_mutable_meas();
}

// .vlsir.utils.Param param = 7;
inline bool Control::_internal_has_param() const {
  return ctrl_case() == kParam;
}
inline bool Control::has_param() const {
  return _internal_has_param();
}
inline void Control::set_has_param() {
  _oneof_case_[0] = kParam;
}
inline ::vlsir::utils::Param* Control::release_param() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.param)
  if (_internal_has_param()) {
    clear_has_ctrl();
      ::vlsir::utils::Param* temp = ctrl_.param_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ctrl_.param_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::utils::Param& Control::_internal_param() const {
  return _internal_has_param()
      ? *ctrl_.param_
      : *reinterpret_cast< ::vlsir::utils::Param*>(&::vlsir::utils::_Param_default_instance_);
}
inline const ::vlsir::utils::Param& Control::param() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.param)
  return _internal_param();
}
inline ::vlsir::utils::Param* Control::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.param)
  if (_internal_has_param()) {
    clear_has_ctrl();
    ::vlsir::utils::Param* temp = ctrl_.param_;
    ctrl_.param_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_param(::vlsir::utils::Param* param) {
  clear_ctrl();
  if (param) {
    set_has_param();
    ctrl_.param_ = param;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.param)
}
inline ::vlsir::utils::Param* Control::_internal_mutable_param() {
  if (!_internal_has_param()) {
    clear_ctrl();
    set_has_param();
    ctrl_.param_ = CreateMaybeMessage< ::vlsir::utils::Param >(GetArena());
  }
  return ctrl_.param_;
}
inline ::vlsir::utils::Param* Control::mutable_param() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.param)
  return _internal_mutable_param();
}

// string literal = 10;
inline bool Control::_internal_has_literal() const {
  return ctrl_case() == kLiteral;
}
inline void Control::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Control::clear_literal() {
  if (_internal_has_literal()) {
    ctrl_.literal_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_ctrl();
  }
}
inline const std::string& Control::literal() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Control.literal)
  return _internal_literal();
}
inline void Control::set_literal(const std::string& value) {
  _internal_set_literal(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Control.literal)
}
inline std::string* Control::mutable_literal() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Control.literal)
  return _internal_mutable_literal();
}
inline const std::string& Control::_internal_literal() const {
  if (_internal_has_literal()) {
    return ctrl_.literal_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Control::_internal_set_literal(const std::string& value) {
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Control::set_literal(std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Control.literal)
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Control.literal)
}
inline void Control::set_literal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Control.literal)
}
inline void Control::set_literal(const char* value,
                             size_t size) {
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ctrl_.literal_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Control.literal)
}
inline std::string* Control::_internal_mutable_literal() {
  if (!_internal_has_literal()) {
    clear_ctrl();
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return ctrl_.literal_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Control::release_literal() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Control.literal)
  if (_internal_has_literal()) {
    clear_has_ctrl();
    return ctrl_.literal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Control::set_allocated_literal(std::string* literal) {
  if (has_ctrl()) {
    clear_ctrl();
  }
  if (literal != nullptr) {
    set_has_literal();
    ctrl_.literal_.UnsafeSetDefault(literal);
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.literal)
}
inline std::string* Control::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Control.literal)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_literal()) {
    clear_has_ctrl();
    return ctrl_.literal_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Control::unsafe_arena_set_allocated_literal(std::string* literal) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_literal()) {
    ctrl_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_ctrl();
  if (literal) {
    set_has_literal();
    ctrl_.literal_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), literal, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Control.literal)
}

inline bool Control::has_ctrl() const {
  return ctrl_case() != CTRL_NOT_SET;
}
inline void Control::clear_has_ctrl() {
  _oneof_case_[0] = CTRL_NOT_SET;
}
inline Control::CtrlCase Control::ctrl_case() const {
  return Control::CtrlCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Save

// .vlsir.spice.Save.SaveMode mode = 1;
inline bool Save::_internal_has_mode() const {
  return save_case() == kMode;
}
inline void Save::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void Save::clear_mode() {
  if (_internal_has_mode()) {
    save_.mode_ = 0;
    clear_has_save();
  }
}
inline ::vlsir::spice::Save_SaveMode Save::_internal_mode() const {
  if (_internal_has_mode()) {
    return static_cast< ::vlsir::spice::Save_SaveMode >(save_.mode_);
  }
  return static_cast< ::vlsir::spice::Save_SaveMode >(0);
}
inline ::vlsir::spice::Save_SaveMode Save::mode() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Save.mode)
  return _internal_mode();
}
inline void Save::_internal_set_mode(::vlsir::spice::Save_SaveMode value) {
  if (!_internal_has_mode()) {
    clear_save();
    set_has_mode();
  }
  save_.mode_ = value;
}
inline void Save::set_mode(::vlsir::spice::Save_SaveMode value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.mode)
  _internal_set_mode(value);
}

// string signal = 2;
inline bool Save::_internal_has_signal() const {
  return save_case() == kSignal;
}
inline void Save::set_has_signal() {
  _oneof_case_[0] = kSignal;
}
inline void Save::clear_signal() {
  if (_internal_has_signal()) {
    save_.signal_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_save();
  }
}
inline const std::string& Save::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Save.signal)
  return _internal_signal();
}
inline void Save::set_signal(const std::string& value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.signal)
}
inline std::string* Save::mutable_signal() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Save.signal)
  return _internal_mutable_signal();
}
inline const std::string& Save::_internal_signal() const {
  if (_internal_has_signal()) {
    return save_.signal_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Save::_internal_set_signal(const std::string& value) {
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Save::set_signal(std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.spice.Save.signal)
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Save.signal)
}
inline void Save::set_signal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Save.signal)
}
inline void Save::set_signal(const char* value,
                             size_t size) {
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  save_.signal_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Save.signal)
}
inline std::string* Save::_internal_mutable_signal() {
  if (!_internal_has_signal()) {
    clear_save();
    set_has_signal();
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return save_.signal_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Save::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Save.signal)
  if (_internal_has_signal()) {
    clear_has_save();
    return save_.signal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Save::set_allocated_signal(std::string* signal) {
  if (has_save()) {
    clear_save();
  }
  if (signal != nullptr) {
    set_has_signal();
    save_.signal_.UnsafeSetDefault(signal);
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Save.signal)
}
inline std::string* Save::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Save.signal)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_signal()) {
    clear_has_save();
    return save_.signal_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Save::unsafe_arena_set_allocated_signal(std::string* signal) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_signal()) {
    save_.signal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_save();
  if (signal) {
    set_has_signal();
    save_.signal_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signal, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Save.signal)
}

inline bool Save::has_save() const {
  return save_case() != SAVE_NOT_SET;
}
inline void Save::clear_has_save() {
  _oneof_case_[0] = SAVE_NOT_SET;
}
inline Save::SaveCase Save::save_case() const {
  return Save::SaveCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Include

// string path = 1;
inline void Include::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Include::path() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Include.path)
  return _internal_path();
}
inline void Include::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Include.path)
}
inline std::string* Include::mutable_path() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Include.path)
  return _internal_mutable_path();
}
inline const std::string& Include::_internal_path() const {
  return path_.Get();
}
inline void Include::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Include::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Include.path)
}
inline void Include::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Include.path)
}
inline void Include::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Include.path)
}
inline std::string* Include::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Include::release_path() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Include.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Include::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Include.path)
}
inline std::string* Include::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Include.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Include::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Include.path)
}

// -------------------------------------------------------------------

// LibInclude

// string path = 1;
inline void LibInclude::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LibInclude::path() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LibInclude.path)
  return _internal_path();
}
inline void LibInclude::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LibInclude.path)
}
inline std::string* LibInclude::mutable_path() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.LibInclude.path)
  return _internal_mutable_path();
}
inline const std::string& LibInclude::_internal_path() const {
  return path_.Get();
}
inline void LibInclude::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LibInclude::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.LibInclude.path)
}
inline void LibInclude::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.LibInclude.path)
}
inline void LibInclude::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.LibInclude.path)
}
inline std::string* LibInclude::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LibInclude::release_path() {
  // @@protoc_insertion_point(field_release:vlsir.spice.LibInclude.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LibInclude::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.LibInclude.path)
}
inline std::string* LibInclude::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.LibInclude.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LibInclude::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.LibInclude.path)
}

// string section = 2;
inline void LibInclude::clear_section() {
  section_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LibInclude::section() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.LibInclude.section)
  return _internal_section();
}
inline void LibInclude::set_section(const std::string& value) {
  _internal_set_section(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.LibInclude.section)
}
inline std::string* LibInclude::mutable_section() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.LibInclude.section)
  return _internal_mutable_section();
}
inline const std::string& LibInclude::_internal_section() const {
  return section_.Get();
}
inline void LibInclude::_internal_set_section(const std::string& value) {
  
  section_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LibInclude::set_section(std::string&& value) {
  
  section_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.LibInclude.section)
}
inline void LibInclude::set_section(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  section_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.LibInclude.section)
}
inline void LibInclude::set_section(const char* value,
    size_t size) {
  
  section_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.LibInclude.section)
}
inline std::string* LibInclude::_internal_mutable_section() {
  
  return section_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LibInclude::release_section() {
  // @@protoc_insertion_point(field_release:vlsir.spice.LibInclude.section)
  return section_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LibInclude::set_allocated_section(std::string* section) {
  if (section != nullptr) {
    
  } else {
    
  }
  section_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), section,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.LibInclude.section)
}
inline std::string* LibInclude::unsafe_arena_release_section() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.LibInclude.section)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return section_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LibInclude::unsafe_arena_set_allocated_section(
    std::string* section) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (section != nullptr) {
    
  } else {
    
  }
  section_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      section, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.LibInclude.section)
}

// -------------------------------------------------------------------

// Meas

// string analysis_type = 1;
inline void Meas::clear_analysis_type() {
  analysis_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Meas::analysis_type() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.analysis_type)
  return _internal_analysis_type();
}
inline void Meas::set_analysis_type(const std::string& value) {
  _internal_set_analysis_type(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.analysis_type)
}
inline std::string* Meas::mutable_analysis_type() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.analysis_type)
  return _internal_mutable_analysis_type();
}
inline const std::string& Meas::_internal_analysis_type() const {
  return analysis_type_.Get();
}
inline void Meas::_internal_set_analysis_type(const std::string& value) {
  
  analysis_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Meas::set_analysis_type(std::string&& value) {
  
  analysis_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Meas.analysis_type)
}
inline void Meas::set_analysis_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  analysis_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Meas.analysis_type)
}
inline void Meas::set_analysis_type(const char* value,
    size_t size) {
  
  analysis_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Meas.analysis_type)
}
inline std::string* Meas::_internal_mutable_analysis_type() {
  
  return analysis_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Meas::release_analysis_type() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.analysis_type)
  return analysis_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Meas::set_allocated_analysis_type(std::string* analysis_type) {
  if (analysis_type != nullptr) {
    
  } else {
    
  }
  analysis_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), analysis_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.analysis_type)
}
inline std::string* Meas::unsafe_arena_release_analysis_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Meas.analysis_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return analysis_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Meas::unsafe_arena_set_allocated_analysis_type(
    std::string* analysis_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (analysis_type != nullptr) {
    
  } else {
    
  }
  analysis_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      analysis_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Meas.analysis_type)
}

// string name = 2;
inline void Meas::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Meas::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.name)
  return _internal_name();
}
inline void Meas::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.name)
}
inline std::string* Meas::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.name)
  return _internal_mutable_name();
}
inline const std::string& Meas::_internal_name() const {
  return name_.Get();
}
inline void Meas::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Meas::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Meas.name)
}
inline void Meas::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Meas.name)
}
inline void Meas::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Meas.name)
}
inline std::string* Meas::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Meas::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Meas::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.name)
}
inline std::string* Meas::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Meas.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Meas::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Meas.name)
}

// string expr = 3;
inline void Meas::clear_expr() {
  expr_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Meas::expr() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Meas.expr)
  return _internal_expr();
}
inline void Meas::set_expr(const std::string& value) {
  _internal_set_expr(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Meas.expr)
}
inline std::string* Meas::mutable_expr() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Meas.expr)
  return _internal_mutable_expr();
}
inline const std::string& Meas::_internal_expr() const {
  return expr_.Get();
}
inline void Meas::_internal_set_expr(const std::string& value) {
  
  expr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Meas::set_expr(std::string&& value) {
  
  expr_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Meas.expr)
}
inline void Meas::set_expr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  expr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Meas.expr)
}
inline void Meas::set_expr(const char* value,
    size_t size) {
  
  expr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Meas.expr)
}
inline std::string* Meas::_internal_mutable_expr() {
  
  return expr_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Meas::release_expr() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Meas.expr)
  return expr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Meas::set_allocated_expr(std::string* expr) {
  if (expr != nullptr) {
    
  } else {
    
  }
  expr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Meas.expr)
}
inline std::string* Meas::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Meas.expr)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return expr_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Meas::unsafe_arena_set_allocated_expr(
    std::string* expr) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (expr != nullptr) {
    
  } else {
    
  }
  expr_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      expr, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Meas.expr)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Signal.name)
  return _internal_name();
}
inline void Signal::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Signal.name)
}
inline std::string* Signal::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.spice.Signal.name)
  return _internal_mutable_name();
}
inline const std::string& Signal::_internal_name() const {
  return name_.Get();
}
inline void Signal::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Signal::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.spice.Signal.name)
}
inline void Signal::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.spice.Signal.name)
}
inline void Signal::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.spice.Signal.name)
}
inline std::string* Signal::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.spice.Signal.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Signal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Signal.name)
}
inline std::string* Signal::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.spice.Signal.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Signal::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.spice.Signal.name)
}

// .vlsir.spice.Signal.Quantity quantity = 2;
inline void Signal::clear_quantity() {
  quantity_ = 0;
}
inline ::vlsir::spice::Signal_Quantity Signal::_internal_quantity() const {
  return static_cast< ::vlsir::spice::Signal_Quantity >(quantity_);
}
inline ::vlsir::spice::Signal_Quantity Signal::quantity() const {
  // @@protoc_insertion_point(field_get:vlsir.spice.Signal.quantity)
  return _internal_quantity();
}
inline void Signal::_internal_set_quantity(::vlsir::spice::Signal_Quantity value) {
  
  quantity_ = value;
}
inline void Signal::set_quantity(::vlsir::spice::Signal_Quantity value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:vlsir.spice.Signal.quantity)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spice
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::spice::Save_SaveMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::spice::Save_SaveMode>() {
  return ::vlsir::spice::Save_SaveMode_descriptor();
}
template <> struct is_proto_enum< ::vlsir::spice::Signal_Quantity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::spice::Signal_Quantity>() {
  return ::vlsir::spice::Signal_Quantity_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_spice_2eproto
