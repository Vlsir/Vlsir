// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layout/tetris.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_layout_2ftetris_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_layout_2ftetris_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
#include "layout/raw.pb.h"
#include "circuit.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_layout_2ftetris_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_layout_2ftetris_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_layout_2ftetris_2eproto;
namespace vlsir {
namespace tetris {
class Abstract;
struct AbstractDefaultTypeInternal;
extern AbstractDefaultTypeInternal _Abstract_default_instance_;
class AbstractPort;
struct AbstractPortDefaultTypeInternal;
extern AbstractPortDefaultTypeInternal _AbstractPort_default_instance_;
class AbstractPort_EdgePort;
struct AbstractPort_EdgePortDefaultTypeInternal;
extern AbstractPort_EdgePortDefaultTypeInternal _AbstractPort_EdgePort_default_instance_;
class AbstractPort_ZTopEdgePort;
struct AbstractPort_ZTopEdgePortDefaultTypeInternal;
extern AbstractPort_ZTopEdgePortDefaultTypeInternal _AbstractPort_ZTopEdgePort_default_instance_;
class AbstractPort_ZTopInner;
struct AbstractPort_ZTopInnerDefaultTypeInternal;
extern AbstractPort_ZTopInnerDefaultTypeInternal _AbstractPort_ZTopInner_default_instance_;
class Assign;
struct AssignDefaultTypeInternal;
extern AssignDefaultTypeInternal _Assign_default_instance_;
class Cell;
struct CellDefaultTypeInternal;
extern CellDefaultTypeInternal _Cell_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class LayerEnum;
struct LayerEnumDefaultTypeInternal;
extern LayerEnumDefaultTypeInternal _LayerEnum_default_instance_;
class Layout;
struct LayoutDefaultTypeInternal;
extern LayoutDefaultTypeInternal _Layout_default_instance_;
class Library;
struct LibraryDefaultTypeInternal;
extern LibraryDefaultTypeInternal _Library_default_instance_;
class MetalLayer;
struct MetalLayerDefaultTypeInternal;
extern MetalLayerDefaultTypeInternal _MetalLayer_default_instance_;
class Outline;
struct OutlineDefaultTypeInternal;
extern OutlineDefaultTypeInternal _Outline_default_instance_;
class Place;
struct PlaceDefaultTypeInternal;
extern PlaceDefaultTypeInternal _Place_default_instance_;
class PrimitiveLayer;
struct PrimitiveLayerDefaultTypeInternal;
extern PrimitiveLayerDefaultTypeInternal _PrimitiveLayer_default_instance_;
class RelPlace;
struct RelPlaceDefaultTypeInternal;
extern RelPlaceDefaultTypeInternal _RelPlace_default_instance_;
class Stack;
struct StackDefaultTypeInternal;
extern StackDefaultTypeInternal _Stack_default_instance_;
class TrackCross;
struct TrackCrossDefaultTypeInternal;
extern TrackCrossDefaultTypeInternal _TrackCross_default_instance_;
class TrackRef;
struct TrackRefDefaultTypeInternal;
extern TrackRefDefaultTypeInternal _TrackRef_default_instance_;
class TrackSpec;
struct TrackSpecDefaultTypeInternal;
extern TrackSpecDefaultTypeInternal _TrackSpec_default_instance_;
class TrackSpec_Repeat;
struct TrackSpec_RepeatDefaultTypeInternal;
extern TrackSpec_RepeatDefaultTypeInternal _TrackSpec_Repeat_default_instance_;
class TrackSpec_TrackEntry;
struct TrackSpec_TrackEntryDefaultTypeInternal;
extern TrackSpec_TrackEntryDefaultTypeInternal _TrackSpec_TrackEntry_default_instance_;
class ViaLayer;
struct ViaLayerDefaultTypeInternal;
extern ViaLayerDefaultTypeInternal _ViaLayer_default_instance_;
class Xy;
struct XyDefaultTypeInternal;
extern XyDefaultTypeInternal _Xy_default_instance_;
}  // namespace tetris
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::tetris::Abstract* Arena::CreateMaybeMessage<::vlsir::tetris::Abstract>(Arena*);
template<> ::vlsir::tetris::AbstractPort* Arena::CreateMaybeMessage<::vlsir::tetris::AbstractPort>(Arena*);
template<> ::vlsir::tetris::AbstractPort_EdgePort* Arena::CreateMaybeMessage<::vlsir::tetris::AbstractPort_EdgePort>(Arena*);
template<> ::vlsir::tetris::AbstractPort_ZTopEdgePort* Arena::CreateMaybeMessage<::vlsir::tetris::AbstractPort_ZTopEdgePort>(Arena*);
template<> ::vlsir::tetris::AbstractPort_ZTopInner* Arena::CreateMaybeMessage<::vlsir::tetris::AbstractPort_ZTopInner>(Arena*);
template<> ::vlsir::tetris::Assign* Arena::CreateMaybeMessage<::vlsir::tetris::Assign>(Arena*);
template<> ::vlsir::tetris::Cell* Arena::CreateMaybeMessage<::vlsir::tetris::Cell>(Arena*);
template<> ::vlsir::tetris::Instance* Arena::CreateMaybeMessage<::vlsir::tetris::Instance>(Arena*);
template<> ::vlsir::tetris::LayerEnum* Arena::CreateMaybeMessage<::vlsir::tetris::LayerEnum>(Arena*);
template<> ::vlsir::tetris::Layout* Arena::CreateMaybeMessage<::vlsir::tetris::Layout>(Arena*);
template<> ::vlsir::tetris::Library* Arena::CreateMaybeMessage<::vlsir::tetris::Library>(Arena*);
template<> ::vlsir::tetris::MetalLayer* Arena::CreateMaybeMessage<::vlsir::tetris::MetalLayer>(Arena*);
template<> ::vlsir::tetris::Outline* Arena::CreateMaybeMessage<::vlsir::tetris::Outline>(Arena*);
template<> ::vlsir::tetris::Place* Arena::CreateMaybeMessage<::vlsir::tetris::Place>(Arena*);
template<> ::vlsir::tetris::PrimitiveLayer* Arena::CreateMaybeMessage<::vlsir::tetris::PrimitiveLayer>(Arena*);
template<> ::vlsir::tetris::RelPlace* Arena::CreateMaybeMessage<::vlsir::tetris::RelPlace>(Arena*);
template<> ::vlsir::tetris::Stack* Arena::CreateMaybeMessage<::vlsir::tetris::Stack>(Arena*);
template<> ::vlsir::tetris::TrackCross* Arena::CreateMaybeMessage<::vlsir::tetris::TrackCross>(Arena*);
template<> ::vlsir::tetris::TrackRef* Arena::CreateMaybeMessage<::vlsir::tetris::TrackRef>(Arena*);
template<> ::vlsir::tetris::TrackSpec* Arena::CreateMaybeMessage<::vlsir::tetris::TrackSpec>(Arena*);
template<> ::vlsir::tetris::TrackSpec_Repeat* Arena::CreateMaybeMessage<::vlsir::tetris::TrackSpec_Repeat>(Arena*);
template<> ::vlsir::tetris::TrackSpec_TrackEntry* Arena::CreateMaybeMessage<::vlsir::tetris::TrackSpec_TrackEntry>(Arena*);
template<> ::vlsir::tetris::ViaLayer* Arena::CreateMaybeMessage<::vlsir::tetris::ViaLayer>(Arena*);
template<> ::vlsir::tetris::Xy* Arena::CreateMaybeMessage<::vlsir::tetris::Xy>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace tetris {

enum AbstractPort_PortSide : int {
  AbstractPort_PortSide_BOTTOM_OR_LEFT = 0,
  AbstractPort_PortSide_TOP_OR_RIGHT = 1,
  AbstractPort_PortSide_AbstractPort_PortSide_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AbstractPort_PortSide_AbstractPort_PortSide_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AbstractPort_PortSide_IsValid(int value);
constexpr AbstractPort_PortSide AbstractPort_PortSide_PortSide_MIN = AbstractPort_PortSide_BOTTOM_OR_LEFT;
constexpr AbstractPort_PortSide AbstractPort_PortSide_PortSide_MAX = AbstractPort_PortSide_TOP_OR_RIGHT;
constexpr int AbstractPort_PortSide_PortSide_ARRAYSIZE = AbstractPort_PortSide_PortSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbstractPort_PortSide_descriptor();
template<typename T>
inline const std::string& AbstractPort_PortSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AbstractPort_PortSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AbstractPort_PortSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AbstractPort_PortSide_descriptor(), enum_t_value);
}
inline bool AbstractPort_PortSide_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AbstractPort_PortSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AbstractPort_PortSide>(
    AbstractPort_PortSide_descriptor(), name, value);
}
enum LayerEnum_LayerType : int {
  LayerEnum_LayerType_PRIMITIVE = 0,
  LayerEnum_LayerType_METAL = 1,
  LayerEnum_LayerType_VIA = 2,
  LayerEnum_LayerType_LayerEnum_LayerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LayerEnum_LayerType_LayerEnum_LayerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LayerEnum_LayerType_IsValid(int value);
constexpr LayerEnum_LayerType LayerEnum_LayerType_LayerType_MIN = LayerEnum_LayerType_PRIMITIVE;
constexpr LayerEnum_LayerType LayerEnum_LayerType_LayerType_MAX = LayerEnum_LayerType_VIA;
constexpr int LayerEnum_LayerType_LayerType_ARRAYSIZE = LayerEnum_LayerType_LayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LayerEnum_LayerType_descriptor();
template<typename T>
inline const std::string& LayerEnum_LayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LayerEnum_LayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LayerEnum_LayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LayerEnum_LayerType_descriptor(), enum_t_value);
}
inline bool LayerEnum_LayerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LayerEnum_LayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LayerEnum_LayerType>(
    LayerEnum_LayerType_descriptor(), name, value);
}
enum MetalLayer_Dir : int {
  MetalLayer_Dir_HORIZ = 0,
  MetalLayer_Dir_VERT = 1,
  MetalLayer_Dir_MetalLayer_Dir_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MetalLayer_Dir_MetalLayer_Dir_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MetalLayer_Dir_IsValid(int value);
constexpr MetalLayer_Dir MetalLayer_Dir_Dir_MIN = MetalLayer_Dir_HORIZ;
constexpr MetalLayer_Dir MetalLayer_Dir_Dir_MAX = MetalLayer_Dir_VERT;
constexpr int MetalLayer_Dir_Dir_ARRAYSIZE = MetalLayer_Dir_Dir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_Dir_descriptor();
template<typename T>
inline const std::string& MetalLayer_Dir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetalLayer_Dir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetalLayer_Dir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetalLayer_Dir_descriptor(), enum_t_value);
}
inline bool MetalLayer_Dir_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetalLayer_Dir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetalLayer_Dir>(
    MetalLayer_Dir_descriptor(), name, value);
}
enum MetalLayer_PrimitiveMode : int {
  MetalLayer_PrimitiveMode_PRIM = 0,
  MetalLayer_PrimitiveMode_SPLIT = 1,
  MetalLayer_PrimitiveMode_STACK = 2,
  MetalLayer_PrimitiveMode_MetalLayer_PrimitiveMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MetalLayer_PrimitiveMode_MetalLayer_PrimitiveMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MetalLayer_PrimitiveMode_IsValid(int value);
constexpr MetalLayer_PrimitiveMode MetalLayer_PrimitiveMode_PrimitiveMode_MIN = MetalLayer_PrimitiveMode_PRIM;
constexpr MetalLayer_PrimitiveMode MetalLayer_PrimitiveMode_PrimitiveMode_MAX = MetalLayer_PrimitiveMode_STACK;
constexpr int MetalLayer_PrimitiveMode_PrimitiveMode_ARRAYSIZE = MetalLayer_PrimitiveMode_PrimitiveMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_PrimitiveMode_descriptor();
template<typename T>
inline const std::string& MetalLayer_PrimitiveMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetalLayer_PrimitiveMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetalLayer_PrimitiveMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetalLayer_PrimitiveMode_descriptor(), enum_t_value);
}
inline bool MetalLayer_PrimitiveMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetalLayer_PrimitiveMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetalLayer_PrimitiveMode>(
    MetalLayer_PrimitiveMode_descriptor(), name, value);
}
enum TrackSpec_TrackEntry_TrackType : int {
  TrackSpec_TrackEntry_TrackType_GAP = 0,
  TrackSpec_TrackEntry_TrackType_SIGNAL = 1,
  TrackSpec_TrackEntry_TrackType_RAIL = 2,
  TrackSpec_TrackEntry_TrackType_TrackSpec_TrackEntry_TrackType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackSpec_TrackEntry_TrackType_TrackSpec_TrackEntry_TrackType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackSpec_TrackEntry_TrackType_IsValid(int value);
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry_TrackType_TrackType_MIN = TrackSpec_TrackEntry_TrackType_GAP;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry_TrackType_TrackType_MAX = TrackSpec_TrackEntry_TrackType_RAIL;
constexpr int TrackSpec_TrackEntry_TrackType_TrackType_ARRAYSIZE = TrackSpec_TrackEntry_TrackType_TrackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSpec_TrackEntry_TrackType_descriptor();
template<typename T>
inline const std::string& TrackSpec_TrackEntry_TrackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackSpec_TrackEntry_TrackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackSpec_TrackEntry_TrackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackSpec_TrackEntry_TrackType_descriptor(), enum_t_value);
}
inline bool TrackSpec_TrackEntry_TrackType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackSpec_TrackEntry_TrackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackSpec_TrackEntry_TrackType>(
    TrackSpec_TrackEntry_TrackType_descriptor(), name, value);
}
// ===================================================================

class Library final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Library) */ {
 public:
  inline Library() : Library(nullptr) {}
  ~Library() override;
  explicit constexpr Library(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Library(const Library& from);
  Library(Library&& from) noexcept
    : Library() {
    *this = ::std::move(from);
  }

  inline Library& operator=(const Library& from) {
    CopyFrom(from);
    return *this;
  }
  inline Library& operator=(Library&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Library& default_instance() {
    return *internal_default_instance();
  }
  static inline const Library* internal_default_instance() {
    return reinterpret_cast<const Library*>(
               &_Library_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Library& a, Library& b) {
    a.Swap(&b);
  }
  inline void Swap(Library* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Library* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Library* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Library>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Library& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Library& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Library* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Library";
  }
  protected:
  explicit Library(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellsFieldNumber = 10,
    kDomainFieldNumber = 1,
    kAuthorFieldNumber = 20,
  };
  // repeated .vlsir.tetris.Cell cells = 10;
  int cells_size() const;
  private:
  int _internal_cells_size() const;
  public:
  void clear_cells();
  ::vlsir::tetris::Cell* mutable_cells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Cell >*
      mutable_cells();
  private:
  const ::vlsir::tetris::Cell& _internal_cells(int index) const;
  ::vlsir::tetris::Cell* _internal_add_cells();
  public:
  const ::vlsir::tetris::Cell& cells(int index) const;
  ::vlsir::tetris::Cell* add_cells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Cell >&
      cells() const;

  // string domain = 1;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // .vlsir.utils.AuthorMetadata author = 20;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const ::vlsir::utils::AuthorMetadata& author() const;
  PROTOBUF_NODISCARD ::vlsir::utils::AuthorMetadata* release_author();
  ::vlsir::utils::AuthorMetadata* mutable_author();
  void set_allocated_author(::vlsir::utils::AuthorMetadata* author);
  private:
  const ::vlsir::utils::AuthorMetadata& _internal_author() const;
  ::vlsir::utils::AuthorMetadata* _internal_mutable_author();
  public:
  void unsafe_arena_set_allocated_author(
      ::vlsir::utils::AuthorMetadata* author);
  ::vlsir::utils::AuthorMetadata* unsafe_arena_release_author();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Library)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Cell > cells_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::vlsir::utils::AuthorMetadata* author_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Cell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Cell) */ {
 public:
  inline Cell() : Cell(nullptr) {}
  ~Cell() override;
  explicit constexpr Cell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cell(const Cell& from);
  Cell(Cell&& from) noexcept
    : Cell() {
    *this = ::std::move(from);
  }

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cell& operator=(Cell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cell& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cell* internal_default_instance() {
    return reinterpret_cast<const Cell*>(
               &_Cell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Cell& a, Cell& b) {
    a.Swap(&b);
  }
  inline void Swap(Cell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Cell& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Cell";
  }
  protected:
  explicit Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kInterfaceFieldNumber = 10,
    kModuleFieldNumber = 11,
    kAbstractFieldNumber = 12,
    kLayoutFieldNumber = 13,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.circuit.Interface interface = 10;
  bool has_interface() const;
  private:
  bool _internal_has_interface() const;
  public:
  void clear_interface();
  const ::vlsir::circuit::Interface& interface() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::Interface* release_interface();
  ::vlsir::circuit::Interface* mutable_interface();
  void set_allocated_interface(::vlsir::circuit::Interface* interface);
  private:
  const ::vlsir::circuit::Interface& _internal_interface() const;
  ::vlsir::circuit::Interface* _internal_mutable_interface();
  public:
  void unsafe_arena_set_allocated_interface(
      ::vlsir::circuit::Interface* interface);
  ::vlsir::circuit::Interface* unsafe_arena_release_interface();

  // .vlsir.circuit.Module module = 11;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::vlsir::circuit::Module& module() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::Module* release_module();
  ::vlsir::circuit::Module* mutable_module();
  void set_allocated_module(::vlsir::circuit::Module* module);
  private:
  const ::vlsir::circuit::Module& _internal_module() const;
  ::vlsir::circuit::Module* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::vlsir::circuit::Module* module);
  ::vlsir::circuit::Module* unsafe_arena_release_module();

  // .vlsir.tetris.Abstract abstract = 12;
  bool has_abstract() const;
  private:
  bool _internal_has_abstract() const;
  public:
  void clear_abstract();
  const ::vlsir::tetris::Abstract& abstract() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Abstract* release_abstract();
  ::vlsir::tetris::Abstract* mutable_abstract();
  void set_allocated_abstract(::vlsir::tetris::Abstract* abstract);
  private:
  const ::vlsir::tetris::Abstract& _internal_abstract() const;
  ::vlsir::tetris::Abstract* _internal_mutable_abstract();
  public:
  void unsafe_arena_set_allocated_abstract(
      ::vlsir::tetris::Abstract* abstract);
  ::vlsir::tetris::Abstract* unsafe_arena_release_abstract();

  // .vlsir.tetris.Layout layout = 13;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const ::vlsir::tetris::Layout& layout() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Layout* release_layout();
  ::vlsir::tetris::Layout* mutable_layout();
  void set_allocated_layout(::vlsir::tetris::Layout* layout);
  private:
  const ::vlsir::tetris::Layout& _internal_layout() const;
  ::vlsir::tetris::Layout* _internal_mutable_layout();
  public:
  void unsafe_arena_set_allocated_layout(
      ::vlsir::tetris::Layout* layout);
  ::vlsir::tetris::Layout* unsafe_arena_release_layout();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Cell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::circuit::Interface* interface_;
  ::vlsir::circuit::Module* module_;
  ::vlsir::tetris::Abstract* abstract_;
  ::vlsir::tetris::Layout* layout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Layout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Layout) */ {
 public:
  inline Layout() : Layout(nullptr) {}
  ~Layout() override;
  explicit constexpr Layout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Layout(const Layout& from);
  Layout(Layout&& from) noexcept
    : Layout() {
    *this = ::std::move(from);
  }

  inline Layout& operator=(const Layout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layout& operator=(Layout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Layout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Layout* internal_default_instance() {
    return reinterpret_cast<const Layout*>(
               &_Layout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Layout& a, Layout& b) {
    a.Swap(&b);
  }
  inline void Swap(Layout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Layout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Layout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Layout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Layout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Layout";
  }
  protected:
  explicit Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstancesFieldNumber = 20,
    kAssignmentsFieldNumber = 21,
    kCutsFieldNumber = 22,
    kNameFieldNumber = 1,
    kOutlineFieldNumber = 10,
  };
  // repeated .vlsir.tetris.Instance instances = 20;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::tetris::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Instance >*
      mutable_instances();
  private:
  const ::vlsir::tetris::Instance& _internal_instances(int index) const;
  ::vlsir::tetris::Instance* _internal_add_instances();
  public:
  const ::vlsir::tetris::Instance& instances(int index) const;
  ::vlsir::tetris::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Instance >&
      instances() const;

  // repeated .vlsir.tetris.Assign assignments = 21;
  int assignments_size() const;
  private:
  int _internal_assignments_size() const;
  public:
  void clear_assignments();
  ::vlsir::tetris::Assign* mutable_assignments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Assign >*
      mutable_assignments();
  private:
  const ::vlsir::tetris::Assign& _internal_assignments(int index) const;
  ::vlsir::tetris::Assign* _internal_add_assignments();
  public:
  const ::vlsir::tetris::Assign& assignments(int index) const;
  ::vlsir::tetris::Assign* add_assignments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Assign >&
      assignments() const;

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  int cuts_size() const;
  private:
  int _internal_cuts_size() const;
  public:
  void clear_cuts();
  ::vlsir::tetris::TrackCross* mutable_cuts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >*
      mutable_cuts();
  private:
  const ::vlsir::tetris::TrackCross& _internal_cuts(int index) const;
  ::vlsir::tetris::TrackCross* _internal_add_cuts();
  public:
  const ::vlsir::tetris::TrackCross& cuts(int index) const;
  ::vlsir::tetris::TrackCross* add_cuts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >&
      cuts() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.tetris.Outline outline = 10;
  bool has_outline() const;
  private:
  bool _internal_has_outline() const;
  public:
  void clear_outline();
  const ::vlsir::tetris::Outline& outline() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Outline* release_outline();
  ::vlsir::tetris::Outline* mutable_outline();
  void set_allocated_outline(::vlsir::tetris::Outline* outline);
  private:
  const ::vlsir::tetris::Outline& _internal_outline() const;
  ::vlsir::tetris::Outline* _internal_mutable_outline();
  public:
  void unsafe_arena_set_allocated_outline(
      ::vlsir::tetris::Outline* outline);
  ::vlsir::tetris::Outline* unsafe_arena_release_outline();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Layout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Instance > instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Assign > assignments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross > cuts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::tetris::Outline* outline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Assign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Assign) */ {
 public:
  inline Assign() : Assign(nullptr) {}
  ~Assign() override;
  explicit constexpr Assign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Assign(const Assign& from);
  Assign(Assign&& from) noexcept
    : Assign() {
    *this = ::std::move(from);
  }

  inline Assign& operator=(const Assign& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assign& operator=(Assign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Assign& default_instance() {
    return *internal_default_instance();
  }
  static inline const Assign* internal_default_instance() {
    return reinterpret_cast<const Assign*>(
               &_Assign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Assign& a, Assign& b) {
    a.Swap(&b);
  }
  inline void Swap(Assign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Assign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Assign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Assign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Assign& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Assign";
  }
  protected:
  explicit Assign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kAtFieldNumber = 2,
  };
  // string net = 1;
  void clear_net();
  const std::string& net() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_net(ArgT0&& arg0, ArgT... args);
  std::string* mutable_net();
  PROTOBUF_NODISCARD std::string* release_net();
  void set_allocated_net(std::string* net);
  private:
  const std::string& _internal_net() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // .vlsir.tetris.TrackCross at = 2;
  bool has_at() const;
  private:
  bool _internal_has_at() const;
  public:
  void clear_at();
  const ::vlsir::tetris::TrackCross& at() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackCross* release_at();
  ::vlsir::tetris::TrackCross* mutable_at();
  void set_allocated_at(::vlsir::tetris::TrackCross* at);
  private:
  const ::vlsir::tetris::TrackCross& _internal_at() const;
  ::vlsir::tetris::TrackCross* _internal_mutable_at();
  public:
  void unsafe_arena_set_allocated_at(
      ::vlsir::tetris::TrackCross* at);
  ::vlsir::tetris::TrackCross* unsafe_arena_release_at();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Assign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
  ::vlsir::tetris::TrackCross* at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class TrackCross final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.TrackCross) */ {
 public:
  inline TrackCross() : TrackCross(nullptr) {}
  ~TrackCross() override;
  explicit constexpr TrackCross(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackCross(const TrackCross& from);
  TrackCross(TrackCross&& from) noexcept
    : TrackCross() {
    *this = ::std::move(from);
  }

  inline TrackCross& operator=(const TrackCross& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackCross& operator=(TrackCross&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackCross& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackCross* internal_default_instance() {
    return reinterpret_cast<const TrackCross*>(
               &_TrackCross_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrackCross& a, TrackCross& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackCross* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackCross* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackCross* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackCross>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackCross& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackCross& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackCross* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.TrackCross";
  }
  protected:
  explicit TrackCross(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackFieldNumber = 1,
    kCrossFieldNumber = 2,
  };
  // .vlsir.tetris.TrackRef track = 1;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::vlsir::tetris::TrackRef& track() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackRef* release_track();
  ::vlsir::tetris::TrackRef* mutable_track();
  void set_allocated_track(::vlsir::tetris::TrackRef* track);
  private:
  const ::vlsir::tetris::TrackRef& _internal_track() const;
  ::vlsir::tetris::TrackRef* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::vlsir::tetris::TrackRef* track);
  ::vlsir::tetris::TrackRef* unsafe_arena_release_track();

  // .vlsir.tetris.TrackRef cross = 2;
  bool has_cross() const;
  private:
  bool _internal_has_cross() const;
  public:
  void clear_cross();
  const ::vlsir::tetris::TrackRef& cross() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackRef* release_cross();
  ::vlsir::tetris::TrackRef* mutable_cross();
  void set_allocated_cross(::vlsir::tetris::TrackRef* cross);
  private:
  const ::vlsir::tetris::TrackRef& _internal_cross() const;
  ::vlsir::tetris::TrackRef* _internal_mutable_cross();
  public:
  void unsafe_arena_set_allocated_cross(
      ::vlsir::tetris::TrackRef* cross);
  ::vlsir::tetris::TrackRef* unsafe_arena_release_cross();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.TrackCross)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vlsir::tetris::TrackRef* track_;
  ::vlsir::tetris::TrackRef* cross_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class TrackRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.TrackRef) */ {
 public:
  inline TrackRef() : TrackRef(nullptr) {}
  ~TrackRef() override;
  explicit constexpr TrackRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackRef(const TrackRef& from);
  TrackRef(TrackRef&& from) noexcept
    : TrackRef() {
    *this = ::std::move(from);
  }

  inline TrackRef& operator=(const TrackRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackRef& operator=(TrackRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackRef* internal_default_instance() {
    return reinterpret_cast<const TrackRef*>(
               &_TrackRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TrackRef& a, TrackRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackRef& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.TrackRef";
  }
  protected:
  explicit TrackRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 1,
    kTrackFieldNumber = 2,
  };
  // int64 layer = 1;
  void clear_layer();
  int64_t layer() const;
  void set_layer(int64_t value);
  private:
  int64_t _internal_layer() const;
  void _internal_set_layer(int64_t value);
  public:

  // int64 track = 2;
  void clear_track();
  int64_t track() const;
  void set_track(int64_t value);
  private:
  int64_t _internal_track() const;
  void _internal_set_track(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.TrackRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t layer_;
  int64_t track_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Outline final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Outline) */ {
 public:
  inline Outline() : Outline(nullptr) {}
  ~Outline() override;
  explicit constexpr Outline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Outline(const Outline& from);
  Outline(Outline&& from) noexcept
    : Outline() {
    *this = ::std::move(from);
  }

  inline Outline& operator=(const Outline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Outline& operator=(Outline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Outline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Outline* internal_default_instance() {
    return reinterpret_cast<const Outline*>(
               &_Outline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Outline& a, Outline& b) {
    a.Swap(&b);
  }
  inline void Swap(Outline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Outline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Outline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Outline>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Outline& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Outline& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Outline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Outline";
  }
  protected:
  explicit Outline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kMetalsFieldNumber = 3,
  };
  // repeated int64 x = 1;
  int x_size() const;
  private:
  int _internal_x_size() const;
  public:
  void clear_x();
  private:
  int64_t _internal_x(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_x() const;
  void _internal_add_x(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_x();
  public:
  int64_t x(int index) const;
  void set_x(int index, int64_t value);
  void add_x(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      x() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_x();

  // repeated int64 y = 2;
  int y_size() const;
  private:
  int _internal_y_size() const;
  public:
  void clear_y();
  private:
  int64_t _internal_y(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_y() const;
  void _internal_add_y(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_y();
  public:
  int64_t y(int index) const;
  void set_y(int index, int64_t value);
  void add_y(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      y() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_y();

  // int64 metals = 3;
  void clear_metals();
  int64_t metals() const;
  void set_metals(int64_t value);
  private:
  int64_t _internal_metals() const;
  void _internal_set_metals(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Outline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > x_;
  mutable std::atomic<int> _x_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > y_;
  mutable std::atomic<int> _y_cached_byte_size_;
  int64_t metals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Abstract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Abstract) */ {
 public:
  inline Abstract() : Abstract(nullptr) {}
  ~Abstract() override;
  explicit constexpr Abstract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Abstract(const Abstract& from);
  Abstract(Abstract&& from) noexcept
    : Abstract() {
    *this = ::std::move(from);
  }

  inline Abstract& operator=(const Abstract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Abstract& operator=(Abstract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Abstract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Abstract* internal_default_instance() {
    return reinterpret_cast<const Abstract*>(
               &_Abstract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Abstract& a, Abstract& b) {
    a.Swap(&b);
  }
  inline void Swap(Abstract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Abstract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Abstract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Abstract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Abstract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Abstract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Abstract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Abstract";
  }
  protected:
  explicit Abstract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 20,
    kNameFieldNumber = 1,
    kOutlineFieldNumber = 10,
  };
  // repeated .vlsir.tetris.AbstractPort ports = 20;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::tetris::AbstractPort* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::AbstractPort >*
      mutable_ports();
  private:
  const ::vlsir::tetris::AbstractPort& _internal_ports(int index) const;
  ::vlsir::tetris::AbstractPort* _internal_add_ports();
  public:
  const ::vlsir::tetris::AbstractPort& ports(int index) const;
  ::vlsir::tetris::AbstractPort* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::AbstractPort >&
      ports() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.tetris.Outline outline = 10;
  bool has_outline() const;
  private:
  bool _internal_has_outline() const;
  public:
  void clear_outline();
  const ::vlsir::tetris::Outline& outline() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Outline* release_outline();
  ::vlsir::tetris::Outline* mutable_outline();
  void set_allocated_outline(::vlsir::tetris::Outline* outline);
  private:
  const ::vlsir::tetris::Outline& _internal_outline() const;
  ::vlsir::tetris::Outline* _internal_mutable_outline();
  public:
  void unsafe_arena_set_allocated_outline(
      ::vlsir::tetris::Outline* outline);
  ::vlsir::tetris::Outline* unsafe_arena_release_outline();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Abstract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::AbstractPort > ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::tetris::Outline* outline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class AbstractPort_EdgePort final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.AbstractPort.EdgePort) */ {
 public:
  inline AbstractPort_EdgePort() : AbstractPort_EdgePort(nullptr) {}
  ~AbstractPort_EdgePort() override;
  explicit constexpr AbstractPort_EdgePort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbstractPort_EdgePort(const AbstractPort_EdgePort& from);
  AbstractPort_EdgePort(AbstractPort_EdgePort&& from) noexcept
    : AbstractPort_EdgePort() {
    *this = ::std::move(from);
  }

  inline AbstractPort_EdgePort& operator=(const AbstractPort_EdgePort& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbstractPort_EdgePort& operator=(AbstractPort_EdgePort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbstractPort_EdgePort& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbstractPort_EdgePort* internal_default_instance() {
    return reinterpret_cast<const AbstractPort_EdgePort*>(
               &_AbstractPort_EdgePort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AbstractPort_EdgePort& a, AbstractPort_EdgePort& b) {
    a.Swap(&b);
  }
  inline void Swap(AbstractPort_EdgePort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbstractPort_EdgePort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbstractPort_EdgePort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbstractPort_EdgePort>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbstractPort_EdgePort& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AbstractPort_EdgePort& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbstractPort_EdgePort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.AbstractPort.EdgePort";
  }
  protected:
  explicit AbstractPort_EdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackFieldNumber = 1,
    kSideFieldNumber = 2,
  };
  // .vlsir.tetris.TrackRef track = 1;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::vlsir::tetris::TrackRef& track() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackRef* release_track();
  ::vlsir::tetris::TrackRef* mutable_track();
  void set_allocated_track(::vlsir::tetris::TrackRef* track);
  private:
  const ::vlsir::tetris::TrackRef& _internal_track() const;
  ::vlsir::tetris::TrackRef* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::vlsir::tetris::TrackRef* track);
  ::vlsir::tetris::TrackRef* unsafe_arena_release_track();

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  void clear_side();
  ::vlsir::tetris::AbstractPort_PortSide side() const;
  void set_side(::vlsir::tetris::AbstractPort_PortSide value);
  private:
  ::vlsir::tetris::AbstractPort_PortSide _internal_side() const;
  void _internal_set_side(::vlsir::tetris::AbstractPort_PortSide value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.AbstractPort.EdgePort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vlsir::tetris::TrackRef* track_;
  int side_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class AbstractPort_ZTopEdgePort final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.AbstractPort.ZTopEdgePort) */ {
 public:
  inline AbstractPort_ZTopEdgePort() : AbstractPort_ZTopEdgePort(nullptr) {}
  ~AbstractPort_ZTopEdgePort() override;
  explicit constexpr AbstractPort_ZTopEdgePort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbstractPort_ZTopEdgePort(const AbstractPort_ZTopEdgePort& from);
  AbstractPort_ZTopEdgePort(AbstractPort_ZTopEdgePort&& from) noexcept
    : AbstractPort_ZTopEdgePort() {
    *this = ::std::move(from);
  }

  inline AbstractPort_ZTopEdgePort& operator=(const AbstractPort_ZTopEdgePort& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbstractPort_ZTopEdgePort& operator=(AbstractPort_ZTopEdgePort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbstractPort_ZTopEdgePort& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbstractPort_ZTopEdgePort* internal_default_instance() {
    return reinterpret_cast<const AbstractPort_ZTopEdgePort*>(
               &_AbstractPort_ZTopEdgePort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AbstractPort_ZTopEdgePort& a, AbstractPort_ZTopEdgePort& b) {
    a.Swap(&b);
  }
  inline void Swap(AbstractPort_ZTopEdgePort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbstractPort_ZTopEdgePort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbstractPort_ZTopEdgePort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbstractPort_ZTopEdgePort>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbstractPort_ZTopEdgePort& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AbstractPort_ZTopEdgePort& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbstractPort_ZTopEdgePort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.AbstractPort.ZTopEdgePort";
  }
  protected:
  explicit AbstractPort_ZTopEdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntoFieldNumber = 3,
    kTrackFieldNumber = 1,
    kSideFieldNumber = 2,
  };
  // .vlsir.tetris.TrackRef into = 3;
  bool has_into() const;
  private:
  bool _internal_has_into() const;
  public:
  void clear_into();
  const ::vlsir::tetris::TrackRef& into() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackRef* release_into();
  ::vlsir::tetris::TrackRef* mutable_into();
  void set_allocated_into(::vlsir::tetris::TrackRef* into);
  private:
  const ::vlsir::tetris::TrackRef& _internal_into() const;
  ::vlsir::tetris::TrackRef* _internal_mutable_into();
  public:
  void unsafe_arena_set_allocated_into(
      ::vlsir::tetris::TrackRef* into);
  ::vlsir::tetris::TrackRef* unsafe_arena_release_into();

  // int64 track = 1;
  void clear_track();
  int64_t track() const;
  void set_track(int64_t value);
  private:
  int64_t _internal_track() const;
  void _internal_set_track(int64_t value);
  public:

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  void clear_side();
  ::vlsir::tetris::AbstractPort_PortSide side() const;
  void set_side(::vlsir::tetris::AbstractPort_PortSide value);
  private:
  ::vlsir::tetris::AbstractPort_PortSide _internal_side() const;
  void _internal_set_side(::vlsir::tetris::AbstractPort_PortSide value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.AbstractPort.ZTopEdgePort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vlsir::tetris::TrackRef* into_;
  int64_t track_;
  int side_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class AbstractPort_ZTopInner final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.AbstractPort.ZTopInner) */ {
 public:
  inline AbstractPort_ZTopInner() : AbstractPort_ZTopInner(nullptr) {}
  ~AbstractPort_ZTopInner() override;
  explicit constexpr AbstractPort_ZTopInner(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbstractPort_ZTopInner(const AbstractPort_ZTopInner& from);
  AbstractPort_ZTopInner(AbstractPort_ZTopInner&& from) noexcept
    : AbstractPort_ZTopInner() {
    *this = ::std::move(from);
  }

  inline AbstractPort_ZTopInner& operator=(const AbstractPort_ZTopInner& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbstractPort_ZTopInner& operator=(AbstractPort_ZTopInner&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbstractPort_ZTopInner& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbstractPort_ZTopInner* internal_default_instance() {
    return reinterpret_cast<const AbstractPort_ZTopInner*>(
               &_AbstractPort_ZTopInner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AbstractPort_ZTopInner& a, AbstractPort_ZTopInner& b) {
    a.Swap(&b);
  }
  inline void Swap(AbstractPort_ZTopInner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbstractPort_ZTopInner* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbstractPort_ZTopInner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbstractPort_ZTopInner>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbstractPort_ZTopInner& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AbstractPort_ZTopInner& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbstractPort_ZTopInner* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.AbstractPort.ZTopInner";
  }
  protected:
  explicit AbstractPort_ZTopInner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocsFieldNumber = 1,
  };
  // repeated .vlsir.tetris.TrackCross locs = 1;
  int locs_size() const;
  private:
  int _internal_locs_size() const;
  public:
  void clear_locs();
  ::vlsir::tetris::TrackCross* mutable_locs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >*
      mutable_locs();
  private:
  const ::vlsir::tetris::TrackCross& _internal_locs(int index) const;
  ::vlsir::tetris::TrackCross* _internal_add_locs();
  public:
  const ::vlsir::tetris::TrackCross& locs(int index) const;
  ::vlsir::tetris::TrackCross* add_locs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >&
      locs() const;

  // @@protoc_insertion_point(class_scope:vlsir.tetris.AbstractPort.ZTopInner)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross > locs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class AbstractPort final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.AbstractPort) */ {
 public:
  inline AbstractPort() : AbstractPort(nullptr) {}
  ~AbstractPort() override;
  explicit constexpr AbstractPort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbstractPort(const AbstractPort& from);
  AbstractPort(AbstractPort&& from) noexcept
    : AbstractPort() {
    *this = ::std::move(from);
  }

  inline AbstractPort& operator=(const AbstractPort& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbstractPort& operator=(AbstractPort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbstractPort& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kEdge = 10,
    kZtopEdge = 11,
    kZtopInner = 12,
    KIND_NOT_SET = 0,
  };

  static inline const AbstractPort* internal_default_instance() {
    return reinterpret_cast<const AbstractPort*>(
               &_AbstractPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AbstractPort& a, AbstractPort& b) {
    a.Swap(&b);
  }
  inline void Swap(AbstractPort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbstractPort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbstractPort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbstractPort>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbstractPort& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AbstractPort& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbstractPort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.AbstractPort";
  }
  protected:
  explicit AbstractPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AbstractPort_EdgePort EdgePort;
  typedef AbstractPort_ZTopEdgePort ZTopEdgePort;
  typedef AbstractPort_ZTopInner ZTopInner;

  typedef AbstractPort_PortSide PortSide;
  static constexpr PortSide BOTTOM_OR_LEFT =
    AbstractPort_PortSide_BOTTOM_OR_LEFT;
  static constexpr PortSide TOP_OR_RIGHT =
    AbstractPort_PortSide_TOP_OR_RIGHT;
  static inline bool PortSide_IsValid(int value) {
    return AbstractPort_PortSide_IsValid(value);
  }
  static constexpr PortSide PortSide_MIN =
    AbstractPort_PortSide_PortSide_MIN;
  static constexpr PortSide PortSide_MAX =
    AbstractPort_PortSide_PortSide_MAX;
  static constexpr int PortSide_ARRAYSIZE =
    AbstractPort_PortSide_PortSide_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PortSide_descriptor() {
    return AbstractPort_PortSide_descriptor();
  }
  template<typename T>
  static inline const std::string& PortSide_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PortSide>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PortSide_Name.");
    return AbstractPort_PortSide_Name(enum_t_value);
  }
  static inline bool PortSide_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PortSide* value) {
    return AbstractPort_PortSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kEdgeFieldNumber = 10,
    kZtopEdgeFieldNumber = 11,
    kZtopInnerFieldNumber = 12,
  };
  // string net = 1;
  void clear_net();
  const std::string& net() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_net(ArgT0&& arg0, ArgT... args);
  std::string* mutable_net();
  PROTOBUF_NODISCARD std::string* release_net();
  void set_allocated_net(std::string* net);
  private:
  const std::string& _internal_net() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
  bool has_edge() const;
  private:
  bool _internal_has_edge() const;
  public:
  void clear_edge();
  const ::vlsir::tetris::AbstractPort_EdgePort& edge() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::AbstractPort_EdgePort* release_edge();
  ::vlsir::tetris::AbstractPort_EdgePort* mutable_edge();
  void set_allocated_edge(::vlsir::tetris::AbstractPort_EdgePort* edge);
  private:
  const ::vlsir::tetris::AbstractPort_EdgePort& _internal_edge() const;
  ::vlsir::tetris::AbstractPort_EdgePort* _internal_mutable_edge();
  public:
  void unsafe_arena_set_allocated_edge(
      ::vlsir::tetris::AbstractPort_EdgePort* edge);
  ::vlsir::tetris::AbstractPort_EdgePort* unsafe_arena_release_edge();

  // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
  bool has_ztop_edge() const;
  private:
  bool _internal_has_ztop_edge() const;
  public:
  void clear_ztop_edge();
  const ::vlsir::tetris::AbstractPort_ZTopEdgePort& ztop_edge() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::AbstractPort_ZTopEdgePort* release_ztop_edge();
  ::vlsir::tetris::AbstractPort_ZTopEdgePort* mutable_ztop_edge();
  void set_allocated_ztop_edge(::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge);
  private:
  const ::vlsir::tetris::AbstractPort_ZTopEdgePort& _internal_ztop_edge() const;
  ::vlsir::tetris::AbstractPort_ZTopEdgePort* _internal_mutable_ztop_edge();
  public:
  void unsafe_arena_set_allocated_ztop_edge(
      ::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge);
  ::vlsir::tetris::AbstractPort_ZTopEdgePort* unsafe_arena_release_ztop_edge();

  // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
  bool has_ztop_inner() const;
  private:
  bool _internal_has_ztop_inner() const;
  public:
  void clear_ztop_inner();
  const ::vlsir::tetris::AbstractPort_ZTopInner& ztop_inner() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::AbstractPort_ZTopInner* release_ztop_inner();
  ::vlsir::tetris::AbstractPort_ZTopInner* mutable_ztop_inner();
  void set_allocated_ztop_inner(::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner);
  private:
  const ::vlsir::tetris::AbstractPort_ZTopInner& _internal_ztop_inner() const;
  ::vlsir::tetris::AbstractPort_ZTopInner* _internal_mutable_ztop_inner();
  public:
  void unsafe_arena_set_allocated_ztop_inner(
      ::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner);
  ::vlsir::tetris::AbstractPort_ZTopInner* unsafe_arena_release_ztop_inner();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.tetris.AbstractPort)
 private:
  class _Internal;
  void set_has_edge();
  void set_has_ztop_edge();
  void set_has_ztop_inner();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::tetris::AbstractPort_EdgePort* edge_;
    ::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge_;
    ::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit constexpr Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Instance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCellFieldNumber = 3,
    kLocFieldNumber = 4,
    kReflectHorizFieldNumber = 6,
    kReflectVertFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.utils.Reference cell = 3;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::vlsir::utils::Reference& cell() const;
  PROTOBUF_NODISCARD ::vlsir::utils::Reference* release_cell();
  ::vlsir::utils::Reference* mutable_cell();
  void set_allocated_cell(::vlsir::utils::Reference* cell);
  private:
  const ::vlsir::utils::Reference& _internal_cell() const;
  ::vlsir::utils::Reference* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::vlsir::utils::Reference* cell);
  ::vlsir::utils::Reference* unsafe_arena_release_cell();

  // .vlsir.tetris.Place loc = 4;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::vlsir::tetris::Place& loc() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Place* release_loc();
  ::vlsir::tetris::Place* mutable_loc();
  void set_allocated_loc(::vlsir::tetris::Place* loc);
  private:
  const ::vlsir::tetris::Place& _internal_loc() const;
  ::vlsir::tetris::Place* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::vlsir::tetris::Place* loc);
  ::vlsir::tetris::Place* unsafe_arena_release_loc();

  // bool reflect_horiz = 6;
  void clear_reflect_horiz();
  bool reflect_horiz() const;
  void set_reflect_horiz(bool value);
  private:
  bool _internal_reflect_horiz() const;
  void _internal_set_reflect_horiz(bool value);
  public:

  // bool reflect_vert = 7;
  void clear_reflect_vert();
  bool reflect_vert() const;
  void set_reflect_vert(bool value);
  private:
  bool _internal_reflect_vert() const;
  void _internal_set_reflect_vert(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::utils::Reference* cell_;
  ::vlsir::tetris::Place* loc_;
  bool reflect_horiz_;
  bool reflect_vert_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Place final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Place) */ {
 public:
  inline Place() : Place(nullptr) {}
  ~Place() override;
  explicit constexpr Place(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Place(const Place& from);
  Place(Place&& from) noexcept
    : Place() {
    *this = ::std::move(from);
  }

  inline Place& operator=(const Place& from) {
    CopyFrom(from);
    return *this;
  }
  inline Place& operator=(Place&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Place& default_instance() {
    return *internal_default_instance();
  }
  enum PlaceCase {
    kAbs = 1,
    kRel = 2,
    PLACE_NOT_SET = 0,
  };

  static inline const Place* internal_default_instance() {
    return reinterpret_cast<const Place*>(
               &_Place_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Place& a, Place& b) {
    a.Swap(&b);
  }
  inline void Swap(Place* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Place* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Place* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Place>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Place& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Place& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Place* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Place";
  }
  protected:
  explicit Place(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbsFieldNumber = 1,
    kRelFieldNumber = 2,
  };
  // .vlsir.raw.Point abs = 1;
  bool has_abs() const;
  private:
  bool _internal_has_abs() const;
  public:
  void clear_abs();
  const ::vlsir::raw::Point& abs() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Point* release_abs();
  ::vlsir::raw::Point* mutable_abs();
  void set_allocated_abs(::vlsir::raw::Point* abs);
  private:
  const ::vlsir::raw::Point& _internal_abs() const;
  ::vlsir::raw::Point* _internal_mutable_abs();
  public:
  void unsafe_arena_set_allocated_abs(
      ::vlsir::raw::Point* abs);
  ::vlsir::raw::Point* unsafe_arena_release_abs();

  // .vlsir.tetris.RelPlace rel = 2;
  bool has_rel() const;
  private:
  bool _internal_has_rel() const;
  public:
  void clear_rel();
  const ::vlsir::tetris::RelPlace& rel() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::RelPlace* release_rel();
  ::vlsir::tetris::RelPlace* mutable_rel();
  void set_allocated_rel(::vlsir::tetris::RelPlace* rel);
  private:
  const ::vlsir::tetris::RelPlace& _internal_rel() const;
  ::vlsir::tetris::RelPlace* _internal_mutable_rel();
  public:
  void unsafe_arena_set_allocated_rel(
      ::vlsir::tetris::RelPlace* rel);
  ::vlsir::tetris::RelPlace* unsafe_arena_release_rel();

  void clear_place();
  PlaceCase place_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.tetris.Place)
 private:
  class _Internal;
  void set_has_abs();
  void set_has_rel();

  inline bool has_place() const;
  inline void clear_has_place();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PlaceUnion {
    constexpr PlaceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::raw::Point* abs_;
    ::vlsir::tetris::RelPlace* rel_;
  } place_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class RelPlace final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vlsir.tetris.RelPlace) */ {
 public:
  inline RelPlace() : RelPlace(nullptr) {}
  explicit constexpr RelPlace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelPlace(const RelPlace& from);
  RelPlace(RelPlace&& from) noexcept
    : RelPlace() {
    *this = ::std::move(from);
  }

  inline RelPlace& operator=(const RelPlace& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelPlace& operator=(RelPlace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelPlace& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelPlace* internal_default_instance() {
    return reinterpret_cast<const RelPlace*>(
               &_RelPlace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RelPlace& a, RelPlace& b) {
    a.Swap(&b);
  }
  inline void Swap(RelPlace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelPlace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelPlace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelPlace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RelPlace& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RelPlace& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.RelPlace";
  }
  protected:
  explicit RelPlace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vlsir.tetris.RelPlace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Stack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Stack) */ {
 public:
  inline Stack() : Stack(nullptr) {}
  ~Stack() override;
  explicit constexpr Stack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stack(const Stack& from);
  Stack(Stack&& from) noexcept
    : Stack() {
    *this = ::std::move(from);
  }

  inline Stack& operator=(const Stack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stack& operator=(Stack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stack* internal_default_instance() {
    return reinterpret_cast<const Stack*>(
               &_Stack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Stack& a, Stack& b) {
    a.Swap(&b);
  }
  inline void Swap(Stack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Stack";
  }
  protected:
  explicit Stack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetalsFieldNumber = 3,
    kViasFieldNumber = 4,
    kPrimFieldNumber = 2,
    kBoundaryLayerFieldNumber = 11,
    kUnitsFieldNumber = 1,
  };
  // repeated .vlsir.tetris.MetalLayer metals = 3;
  int metals_size() const;
  private:
  int _internal_metals_size() const;
  public:
  void clear_metals();
  ::vlsir::tetris::MetalLayer* mutable_metals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::MetalLayer >*
      mutable_metals();
  private:
  const ::vlsir::tetris::MetalLayer& _internal_metals(int index) const;
  ::vlsir::tetris::MetalLayer* _internal_add_metals();
  public:
  const ::vlsir::tetris::MetalLayer& metals(int index) const;
  ::vlsir::tetris::MetalLayer* add_metals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::MetalLayer >&
      metals() const;

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  int vias_size() const;
  private:
  int _internal_vias_size() const;
  public:
  void clear_vias();
  ::vlsir::tetris::ViaLayer* mutable_vias(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::ViaLayer >*
      mutable_vias();
  private:
  const ::vlsir::tetris::ViaLayer& _internal_vias(int index) const;
  ::vlsir::tetris::ViaLayer* _internal_add_vias();
  public:
  const ::vlsir::tetris::ViaLayer& vias(int index) const;
  ::vlsir::tetris::ViaLayer* add_vias();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::ViaLayer >&
      vias() const;

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  bool has_prim() const;
  private:
  bool _internal_has_prim() const;
  public:
  void clear_prim();
  const ::vlsir::tetris::PrimitiveLayer& prim() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::PrimitiveLayer* release_prim();
  ::vlsir::tetris::PrimitiveLayer* mutable_prim();
  void set_allocated_prim(::vlsir::tetris::PrimitiveLayer* prim);
  private:
  const ::vlsir::tetris::PrimitiveLayer& _internal_prim() const;
  ::vlsir::tetris::PrimitiveLayer* _internal_mutable_prim();
  public:
  void unsafe_arena_set_allocated_prim(
      ::vlsir::tetris::PrimitiveLayer* prim);
  ::vlsir::tetris::PrimitiveLayer* unsafe_arena_release_prim();

  // .vlsir.raw.Layer boundary_layer = 11;
  bool has_boundary_layer() const;
  private:
  bool _internal_has_boundary_layer() const;
  public:
  void clear_boundary_layer();
  const ::vlsir::raw::Layer& boundary_layer() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Layer* release_boundary_layer();
  ::vlsir::raw::Layer* mutable_boundary_layer();
  void set_allocated_boundary_layer(::vlsir::raw::Layer* boundary_layer);
  private:
  const ::vlsir::raw::Layer& _internal_boundary_layer() const;
  ::vlsir::raw::Layer* _internal_mutable_boundary_layer();
  public:
  void unsafe_arena_set_allocated_boundary_layer(
      ::vlsir::raw::Layer* boundary_layer);
  ::vlsir::raw::Layer* unsafe_arena_release_boundary_layer();

  // .vlsir.raw.Units units = 1;
  void clear_units();
  ::vlsir::raw::Units units() const;
  void set_units(::vlsir::raw::Units value);
  private:
  ::vlsir::raw::Units _internal_units() const;
  void _internal_set_units(::vlsir::raw::Units value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Stack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::MetalLayer > metals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::ViaLayer > vias_;
  ::vlsir::tetris::PrimitiveLayer* prim_;
  ::vlsir::raw::Layer* boundary_layer_;
  int units_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class LayerEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.LayerEnum) */ {
 public:
  inline LayerEnum() : LayerEnum(nullptr) {}
  ~LayerEnum() override;
  explicit constexpr LayerEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayerEnum(const LayerEnum& from);
  LayerEnum(LayerEnum&& from) noexcept
    : LayerEnum() {
    *this = ::std::move(from);
  }

  inline LayerEnum& operator=(const LayerEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerEnum& operator=(LayerEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayerEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayerEnum* internal_default_instance() {
    return reinterpret_cast<const LayerEnum*>(
               &_LayerEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LayerEnum& a, LayerEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayerEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayerEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayerEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LayerEnum& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.LayerEnum";
  }
  protected:
  explicit LayerEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LayerEnum_LayerType LayerType;
  static constexpr LayerType PRIMITIVE =
    LayerEnum_LayerType_PRIMITIVE;
  static constexpr LayerType METAL =
    LayerEnum_LayerType_METAL;
  static constexpr LayerType VIA =
    LayerEnum_LayerType_VIA;
  static inline bool LayerType_IsValid(int value) {
    return LayerEnum_LayerType_IsValid(value);
  }
  static constexpr LayerType LayerType_MIN =
    LayerEnum_LayerType_LayerType_MIN;
  static constexpr LayerType LayerType_MAX =
    LayerEnum_LayerType_LayerType_MAX;
  static constexpr int LayerType_ARRAYSIZE =
    LayerEnum_LayerType_LayerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LayerType_descriptor() {
    return LayerEnum_LayerType_descriptor();
  }
  template<typename T>
  static inline const std::string& LayerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LayerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LayerType_Name.");
    return LayerEnum_LayerType_Name(enum_t_value);
  }
  static inline bool LayerType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LayerType* value) {
    return LayerEnum_LayerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // int64 index = 2;
  void clear_index();
  int64_t index() const;
  void set_index(int64_t value);
  private:
  int64_t _internal_index() const;
  void _internal_set_index(int64_t value);
  public:

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  void clear_type();
  ::vlsir::tetris::LayerEnum_LayerType type() const;
  void set_type(::vlsir::tetris::LayerEnum_LayerType value);
  private:
  ::vlsir::tetris::LayerEnum_LayerType _internal_type() const;
  void _internal_set_type(::vlsir::tetris::LayerEnum_LayerType value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.LayerEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t index_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class MetalLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.MetalLayer) */ {
 public:
  inline MetalLayer() : MetalLayer(nullptr) {}
  ~MetalLayer() override;
  explicit constexpr MetalLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetalLayer(const MetalLayer& from);
  MetalLayer(MetalLayer&& from) noexcept
    : MetalLayer() {
    *this = ::std::move(from);
  }

  inline MetalLayer& operator=(const MetalLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetalLayer& operator=(MetalLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetalLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetalLayer* internal_default_instance() {
    return reinterpret_cast<const MetalLayer*>(
               &_MetalLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MetalLayer& a, MetalLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(MetalLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetalLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetalLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetalLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetalLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetalLayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetalLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.MetalLayer";
  }
  protected:
  explicit MetalLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetalLayer_Dir Dir;
  static constexpr Dir HORIZ =
    MetalLayer_Dir_HORIZ;
  static constexpr Dir VERT =
    MetalLayer_Dir_VERT;
  static inline bool Dir_IsValid(int value) {
    return MetalLayer_Dir_IsValid(value);
  }
  static constexpr Dir Dir_MIN =
    MetalLayer_Dir_Dir_MIN;
  static constexpr Dir Dir_MAX =
    MetalLayer_Dir_Dir_MAX;
  static constexpr int Dir_ARRAYSIZE =
    MetalLayer_Dir_Dir_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Dir_descriptor() {
    return MetalLayer_Dir_descriptor();
  }
  template<typename T>
  static inline const std::string& Dir_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Dir>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Dir_Name.");
    return MetalLayer_Dir_Name(enum_t_value);
  }
  static inline bool Dir_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Dir* value) {
    return MetalLayer_Dir_Parse(name, value);
  }

  typedef MetalLayer_PrimitiveMode PrimitiveMode;
  static constexpr PrimitiveMode PRIM =
    MetalLayer_PrimitiveMode_PRIM;
  static constexpr PrimitiveMode SPLIT =
    MetalLayer_PrimitiveMode_SPLIT;
  static constexpr PrimitiveMode STACK =
    MetalLayer_PrimitiveMode_STACK;
  static inline bool PrimitiveMode_IsValid(int value) {
    return MetalLayer_PrimitiveMode_IsValid(value);
  }
  static constexpr PrimitiveMode PrimitiveMode_MIN =
    MetalLayer_PrimitiveMode_PrimitiveMode_MIN;
  static constexpr PrimitiveMode PrimitiveMode_MAX =
    MetalLayer_PrimitiveMode_PrimitiveMode_MAX;
  static constexpr int PrimitiveMode_ARRAYSIZE =
    MetalLayer_PrimitiveMode_PrimitiveMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PrimitiveMode_descriptor() {
    return MetalLayer_PrimitiveMode_descriptor();
  }
  template<typename T>
  static inline const std::string& PrimitiveMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PrimitiveMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PrimitiveMode_Name.");
    return MetalLayer_PrimitiveMode_Name(enum_t_value);
  }
  static inline bool PrimitiveMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PrimitiveMode* value) {
    return MetalLayer_PrimitiveMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 4,
    kNameFieldNumber = 1,
    kRawFieldNumber = 11,
    kCutsizeFieldNumber = 3,
    kDirFieldNumber = 2,
    kFlipFieldNumber = 7,
    kOffsetFieldNumber = 5,
    kOverlapFieldNumber = 6,
    kPrimFieldNumber = 8,
  };
  // repeated .vlsir.tetris.TrackSpec entries = 4;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::vlsir::tetris::TrackSpec* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec >*
      mutable_entries();
  private:
  const ::vlsir::tetris::TrackSpec& _internal_entries(int index) const;
  ::vlsir::tetris::TrackSpec* _internal_add_entries();
  public:
  const ::vlsir::tetris::TrackSpec& entries(int index) const;
  ::vlsir::tetris::TrackSpec* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec >&
      entries() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.raw.Layer raw = 11;
  bool has_raw() const;
  private:
  bool _internal_has_raw() const;
  public:
  void clear_raw();
  const ::vlsir::raw::Layer& raw() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Layer* release_raw();
  ::vlsir::raw::Layer* mutable_raw();
  void set_allocated_raw(::vlsir::raw::Layer* raw);
  private:
  const ::vlsir::raw::Layer& _internal_raw() const;
  ::vlsir::raw::Layer* _internal_mutable_raw();
  public:
  void unsafe_arena_set_allocated_raw(
      ::vlsir::raw::Layer* raw);
  ::vlsir::raw::Layer* unsafe_arena_release_raw();

  // int64 cutsize = 3;
  void clear_cutsize();
  int64_t cutsize() const;
  void set_cutsize(int64_t value);
  private:
  int64_t _internal_cutsize() const;
  void _internal_set_cutsize(int64_t value);
  public:

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  void clear_dir();
  ::vlsir::tetris::MetalLayer_Dir dir() const;
  void set_dir(::vlsir::tetris::MetalLayer_Dir value);
  private:
  ::vlsir::tetris::MetalLayer_Dir _internal_dir() const;
  void _internal_set_dir(::vlsir::tetris::MetalLayer_Dir value);
  public:

  // bool flip = 7;
  void clear_flip();
  bool flip() const;
  void set_flip(bool value);
  private:
  bool _internal_flip() const;
  void _internal_set_flip(bool value);
  public:

  // int64 offset = 5;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 overlap = 6;
  void clear_overlap();
  int64_t overlap() const;
  void set_overlap(int64_t value);
  private:
  int64_t _internal_overlap() const;
  void _internal_set_overlap(int64_t value);
  public:

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  void clear_prim();
  ::vlsir::tetris::MetalLayer_PrimitiveMode prim() const;
  void set_prim(::vlsir::tetris::MetalLayer_PrimitiveMode value);
  private:
  ::vlsir::tetris::MetalLayer_PrimitiveMode _internal_prim() const;
  void _internal_set_prim(::vlsir::tetris::MetalLayer_PrimitiveMode value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.MetalLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec > entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::raw::Layer* raw_;
  int64_t cutsize_;
  int dir_;
  bool flip_;
  int64_t offset_;
  int64_t overlap_;
  int prim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class ViaLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.ViaLayer) */ {
 public:
  inline ViaLayer() : ViaLayer(nullptr) {}
  ~ViaLayer() override;
  explicit constexpr ViaLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViaLayer(const ViaLayer& from);
  ViaLayer(ViaLayer&& from) noexcept
    : ViaLayer() {
    *this = ::std::move(from);
  }

  inline ViaLayer& operator=(const ViaLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViaLayer& operator=(ViaLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViaLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViaLayer* internal_default_instance() {
    return reinterpret_cast<const ViaLayer*>(
               &_ViaLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ViaLayer& a, ViaLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ViaLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViaLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViaLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViaLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViaLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViaLayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViaLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.ViaLayer";
  }
  protected:
  explicit ViaLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTopFieldNumber = 2,
    kBotFieldNumber = 3,
    kSizeFieldNumber = 4,
    kRawFieldNumber = 11,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.tetris.LayerEnum top = 2;
  bool has_top() const;
  private:
  bool _internal_has_top() const;
  public:
  void clear_top();
  const ::vlsir::tetris::LayerEnum& top() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::LayerEnum* release_top();
  ::vlsir::tetris::LayerEnum* mutable_top();
  void set_allocated_top(::vlsir::tetris::LayerEnum* top);
  private:
  const ::vlsir::tetris::LayerEnum& _internal_top() const;
  ::vlsir::tetris::LayerEnum* _internal_mutable_top();
  public:
  void unsafe_arena_set_allocated_top(
      ::vlsir::tetris::LayerEnum* top);
  ::vlsir::tetris::LayerEnum* unsafe_arena_release_top();

  // .vlsir.tetris.LayerEnum bot = 3;
  bool has_bot() const;
  private:
  bool _internal_has_bot() const;
  public:
  void clear_bot();
  const ::vlsir::tetris::LayerEnum& bot() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::LayerEnum* release_bot();
  ::vlsir::tetris::LayerEnum* mutable_bot();
  void set_allocated_bot(::vlsir::tetris::LayerEnum* bot);
  private:
  const ::vlsir::tetris::LayerEnum& _internal_bot() const;
  ::vlsir::tetris::LayerEnum* _internal_mutable_bot();
  public:
  void unsafe_arena_set_allocated_bot(
      ::vlsir::tetris::LayerEnum* bot);
  ::vlsir::tetris::LayerEnum* unsafe_arena_release_bot();

  // .vlsir.tetris.Xy size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::vlsir::tetris::Xy& size() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Xy* release_size();
  ::vlsir::tetris::Xy* mutable_size();
  void set_allocated_size(::vlsir::tetris::Xy* size);
  private:
  const ::vlsir::tetris::Xy& _internal_size() const;
  ::vlsir::tetris::Xy* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::vlsir::tetris::Xy* size);
  ::vlsir::tetris::Xy* unsafe_arena_release_size();

  // .vlsir.raw.Layer raw = 11;
  bool has_raw() const;
  private:
  bool _internal_has_raw() const;
  public:
  void clear_raw();
  const ::vlsir::raw::Layer& raw() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Layer* release_raw();
  ::vlsir::raw::Layer* mutable_raw();
  void set_allocated_raw(::vlsir::raw::Layer* raw);
  private:
  const ::vlsir::raw::Layer& _internal_raw() const;
  ::vlsir::raw::Layer* _internal_mutable_raw();
  public:
  void unsafe_arena_set_allocated_raw(
      ::vlsir::raw::Layer* raw);
  ::vlsir::raw::Layer* unsafe_arena_release_raw();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.ViaLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::tetris::LayerEnum* top_;
  ::vlsir::tetris::LayerEnum* bot_;
  ::vlsir::tetris::Xy* size_;
  ::vlsir::raw::Layer* raw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class PrimitiveLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.PrimitiveLayer) */ {
 public:
  inline PrimitiveLayer() : PrimitiveLayer(nullptr) {}
  ~PrimitiveLayer() override;
  explicit constexpr PrimitiveLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrimitiveLayer(const PrimitiveLayer& from);
  PrimitiveLayer(PrimitiveLayer&& from) noexcept
    : PrimitiveLayer() {
    *this = ::std::move(from);
  }

  inline PrimitiveLayer& operator=(const PrimitiveLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimitiveLayer& operator=(PrimitiveLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrimitiveLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrimitiveLayer* internal_default_instance() {
    return reinterpret_cast<const PrimitiveLayer*>(
               &_PrimitiveLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PrimitiveLayer& a, PrimitiveLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(PrimitiveLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimitiveLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrimitiveLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrimitiveLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrimitiveLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrimitiveLayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrimitiveLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.PrimitiveLayer";
  }
  protected:
  explicit PrimitiveLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchesFieldNumber = 1,
  };
  // .vlsir.tetris.Xy pitches = 1;
  bool has_pitches() const;
  private:
  bool _internal_has_pitches() const;
  public:
  void clear_pitches();
  const ::vlsir::tetris::Xy& pitches() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::Xy* release_pitches();
  ::vlsir::tetris::Xy* mutable_pitches();
  void set_allocated_pitches(::vlsir::tetris::Xy* pitches);
  private:
  const ::vlsir::tetris::Xy& _internal_pitches() const;
  ::vlsir::tetris::Xy* _internal_mutable_pitches();
  public:
  void unsafe_arena_set_allocated_pitches(
      ::vlsir::tetris::Xy* pitches);
  ::vlsir::tetris::Xy* unsafe_arena_release_pitches();

  // @@protoc_insertion_point(class_scope:vlsir.tetris.PrimitiveLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vlsir::tetris::Xy* pitches_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class TrackSpec_TrackEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.TrackSpec.TrackEntry) */ {
 public:
  inline TrackSpec_TrackEntry() : TrackSpec_TrackEntry(nullptr) {}
  ~TrackSpec_TrackEntry() override;
  explicit constexpr TrackSpec_TrackEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackSpec_TrackEntry(const TrackSpec_TrackEntry& from);
  TrackSpec_TrackEntry(TrackSpec_TrackEntry&& from) noexcept
    : TrackSpec_TrackEntry() {
    *this = ::std::move(from);
  }

  inline TrackSpec_TrackEntry& operator=(const TrackSpec_TrackEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSpec_TrackEntry& operator=(TrackSpec_TrackEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSpec_TrackEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackSpec_TrackEntry* internal_default_instance() {
    return reinterpret_cast<const TrackSpec_TrackEntry*>(
               &_TrackSpec_TrackEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TrackSpec_TrackEntry& a, TrackSpec_TrackEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackSpec_TrackEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSpec_TrackEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSpec_TrackEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackSpec_TrackEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackSpec_TrackEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackSpec_TrackEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackSpec_TrackEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.TrackSpec.TrackEntry";
  }
  protected:
  explicit TrackSpec_TrackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrackSpec_TrackEntry_TrackType TrackType;
  static constexpr TrackType GAP =
    TrackSpec_TrackEntry_TrackType_GAP;
  static constexpr TrackType SIGNAL =
    TrackSpec_TrackEntry_TrackType_SIGNAL;
  static constexpr TrackType RAIL =
    TrackSpec_TrackEntry_TrackType_RAIL;
  static inline bool TrackType_IsValid(int value) {
    return TrackSpec_TrackEntry_TrackType_IsValid(value);
  }
  static constexpr TrackType TrackType_MIN =
    TrackSpec_TrackEntry_TrackType_TrackType_MIN;
  static constexpr TrackType TrackType_MAX =
    TrackSpec_TrackEntry_TrackType_TrackType_MAX;
  static constexpr int TrackType_ARRAYSIZE =
    TrackSpec_TrackEntry_TrackType_TrackType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TrackType_descriptor() {
    return TrackSpec_TrackEntry_TrackType_descriptor();
  }
  template<typename T>
  static inline const std::string& TrackType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TrackType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TrackType_Name.");
    return TrackSpec_TrackEntry_TrackType_Name(enum_t_value);
  }
  static inline bool TrackType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TrackType* value) {
    return TrackSpec_TrackEntry_TrackType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 2,
    kTtypeFieldNumber = 1,
  };
  // int64 width = 2;
  void clear_width();
  int64_t width() const;
  void set_width(int64_t value);
  private:
  int64_t _internal_width() const;
  void _internal_set_width(int64_t value);
  public:

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  void clear_ttype();
  ::vlsir::tetris::TrackSpec_TrackEntry_TrackType ttype() const;
  void set_ttype(::vlsir::tetris::TrackSpec_TrackEntry_TrackType value);
  private:
  ::vlsir::tetris::TrackSpec_TrackEntry_TrackType _internal_ttype() const;
  void _internal_set_ttype(::vlsir::tetris::TrackSpec_TrackEntry_TrackType value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.TrackSpec.TrackEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t width_;
  int ttype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class TrackSpec_Repeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.TrackSpec.Repeat) */ {
 public:
  inline TrackSpec_Repeat() : TrackSpec_Repeat(nullptr) {}
  ~TrackSpec_Repeat() override;
  explicit constexpr TrackSpec_Repeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackSpec_Repeat(const TrackSpec_Repeat& from);
  TrackSpec_Repeat(TrackSpec_Repeat&& from) noexcept
    : TrackSpec_Repeat() {
    *this = ::std::move(from);
  }

  inline TrackSpec_Repeat& operator=(const TrackSpec_Repeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSpec_Repeat& operator=(TrackSpec_Repeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSpec_Repeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackSpec_Repeat* internal_default_instance() {
    return reinterpret_cast<const TrackSpec_Repeat*>(
               &_TrackSpec_Repeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TrackSpec_Repeat& a, TrackSpec_Repeat& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackSpec_Repeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSpec_Repeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSpec_Repeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackSpec_Repeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackSpec_Repeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackSpec_Repeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackSpec_Repeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.TrackSpec.Repeat";
  }
  protected:
  explicit TrackSpec_Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kNrepFieldNumber = 2,
  };
  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::vlsir::tetris::TrackSpec_TrackEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec_TrackEntry >*
      mutable_entries();
  private:
  const ::vlsir::tetris::TrackSpec_TrackEntry& _internal_entries(int index) const;
  ::vlsir::tetris::TrackSpec_TrackEntry* _internal_add_entries();
  public:
  const ::vlsir::tetris::TrackSpec_TrackEntry& entries(int index) const;
  ::vlsir::tetris::TrackSpec_TrackEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec_TrackEntry >&
      entries() const;

  // int64 nrep = 2;
  void clear_nrep();
  int64_t nrep() const;
  void set_nrep(int64_t value);
  private:
  int64_t _internal_nrep() const;
  void _internal_set_nrep(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.TrackSpec.Repeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec_TrackEntry > entries_;
  int64_t nrep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class TrackSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.TrackSpec) */ {
 public:
  inline TrackSpec() : TrackSpec(nullptr) {}
  ~TrackSpec() override;
  explicit constexpr TrackSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackSpec(const TrackSpec& from);
  TrackSpec(TrackSpec&& from) noexcept
    : TrackSpec() {
    *this = ::std::move(from);
  }

  inline TrackSpec& operator=(const TrackSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSpec& operator=(TrackSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSpec& default_instance() {
    return *internal_default_instance();
  }
  enum SpecCase {
    kEntry = 1,
    kRepeat = 2,
    SPEC_NOT_SET = 0,
  };

  static inline const TrackSpec* internal_default_instance() {
    return reinterpret_cast<const TrackSpec*>(
               &_TrackSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TrackSpec& a, TrackSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.TrackSpec";
  }
  protected:
  explicit TrackSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrackSpec_TrackEntry TrackEntry;
  typedef TrackSpec_Repeat Repeat;

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
    kRepeatFieldNumber = 2,
  };
  // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::vlsir::tetris::TrackSpec_TrackEntry& entry() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackSpec_TrackEntry* release_entry();
  ::vlsir::tetris::TrackSpec_TrackEntry* mutable_entry();
  void set_allocated_entry(::vlsir::tetris::TrackSpec_TrackEntry* entry);
  private:
  const ::vlsir::tetris::TrackSpec_TrackEntry& _internal_entry() const;
  ::vlsir::tetris::TrackSpec_TrackEntry* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::vlsir::tetris::TrackSpec_TrackEntry* entry);
  ::vlsir::tetris::TrackSpec_TrackEntry* unsafe_arena_release_entry();

  // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
  bool has_repeat() const;
  private:
  bool _internal_has_repeat() const;
  public:
  void clear_repeat();
  const ::vlsir::tetris::TrackSpec_Repeat& repeat() const;
  PROTOBUF_NODISCARD ::vlsir::tetris::TrackSpec_Repeat* release_repeat();
  ::vlsir::tetris::TrackSpec_Repeat* mutable_repeat();
  void set_allocated_repeat(::vlsir::tetris::TrackSpec_Repeat* repeat);
  private:
  const ::vlsir::tetris::TrackSpec_Repeat& _internal_repeat() const;
  ::vlsir::tetris::TrackSpec_Repeat* _internal_mutable_repeat();
  public:
  void unsafe_arena_set_allocated_repeat(
      ::vlsir::tetris::TrackSpec_Repeat* repeat);
  ::vlsir::tetris::TrackSpec_Repeat* unsafe_arena_release_repeat();

  void clear_spec();
  SpecCase spec_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.tetris.TrackSpec)
 private:
  class _Internal;
  void set_has_entry();
  void set_has_repeat();

  inline bool has_spec() const;
  inline void clear_has_spec();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SpecUnion {
    constexpr SpecUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::tetris::TrackSpec_TrackEntry* entry_;
    ::vlsir::tetris::TrackSpec_Repeat* repeat_;
  } spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// -------------------------------------------------------------------

class Xy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.tetris.Xy) */ {
 public:
  inline Xy() : Xy(nullptr) {}
  ~Xy() override;
  explicit constexpr Xy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Xy(const Xy& from);
  Xy(Xy&& from) noexcept
    : Xy() {
    *this = ::std::move(from);
  }

  inline Xy& operator=(const Xy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Xy& operator=(Xy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Xy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Xy* internal_default_instance() {
    return reinterpret_cast<const Xy*>(
               &_Xy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Xy& a, Xy& b) {
    a.Swap(&b);
  }
  inline void Swap(Xy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Xy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Xy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Xy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Xy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Xy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Xy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.tetris.Xy";
  }
  protected:
  explicit Xy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int64 x = 1;
  void clear_x();
  int64_t x() const;
  void set_x(int64_t value);
  private:
  int64_t _internal_x() const;
  void _internal_set_x(int64_t value);
  public:

  // int64 y = 2;
  void clear_y();
  int64_t y() const;
  void set_y(int64_t value);
  private:
  int64_t _internal_y() const;
  void _internal_set_y(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.tetris.Xy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t x_;
  int64_t y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_layout_2ftetris_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Library

// string domain = 1;
inline void Library::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& Library::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Library.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Library::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.Library.domain)
}
inline std::string* Library::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Library.domain)
  return _s;
}
inline const std::string& Library::_internal_domain() const {
  return domain_.Get();
}
inline void Library::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Library::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Library::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Library.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Library::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Library.domain)
}

// repeated .vlsir.tetris.Cell cells = 10;
inline int Library::_internal_cells_size() const {
  return cells_.size();
}
inline int Library::cells_size() const {
  return _internal_cells_size();
}
inline void Library::clear_cells() {
  cells_.Clear();
}
inline ::vlsir::tetris::Cell* Library::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Library.cells)
  return cells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Cell >*
Library::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Library.cells)
  return &cells_;
}
inline const ::vlsir::tetris::Cell& Library::_internal_cells(int index) const {
  return cells_.Get(index);
}
inline const ::vlsir::tetris::Cell& Library::cells(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Library.cells)
  return _internal_cells(index);
}
inline ::vlsir::tetris::Cell* Library::_internal_add_cells() {
  return cells_.Add();
}
inline ::vlsir::tetris::Cell* Library::add_cells() {
  ::vlsir::tetris::Cell* _add = _internal_add_cells();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Library.cells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Cell >&
Library::cells() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Library.cells)
  return cells_;
}

// .vlsir.utils.AuthorMetadata author = 20;
inline bool Library::_internal_has_author() const {
  return this != internal_default_instance() && author_ != nullptr;
}
inline bool Library::has_author() const {
  return _internal_has_author();
}
inline const ::vlsir::utils::AuthorMetadata& Library::_internal_author() const {
  const ::vlsir::utils::AuthorMetadata* p = author_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::AuthorMetadata&>(
      ::vlsir::utils::_AuthorMetadata_default_instance_);
}
inline const ::vlsir::utils::AuthorMetadata& Library::author() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Library.author)
  return _internal_author();
}
inline void Library::unsafe_arena_set_allocated_author(
    ::vlsir::utils::AuthorMetadata* author) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author_);
  }
  author_ = author;
  if (author) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Library.author)
}
inline ::vlsir::utils::AuthorMetadata* Library::release_author() {
  
  ::vlsir::utils::AuthorMetadata* temp = author_;
  author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::AuthorMetadata* Library::unsafe_arena_release_author() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Library.author)
  
  ::vlsir::utils::AuthorMetadata* temp = author_;
  author_ = nullptr;
  return temp;
}
inline ::vlsir::utils::AuthorMetadata* Library::_internal_mutable_author() {
  
  if (author_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::AuthorMetadata>(GetArenaForAllocation());
    author_ = p;
  }
  return author_;
}
inline ::vlsir::utils::AuthorMetadata* Library::mutable_author() {
  ::vlsir::utils::AuthorMetadata* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Library.author)
  return _msg;
}
inline void Library::set_allocated_author(::vlsir::utils::AuthorMetadata* author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(author_);
  }
  if (author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author));
    if (message_arena != submessage_arena) {
      author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, author, submessage_arena);
    }
    
  } else {
    
  }
  author_ = author;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Library.author)
}

// -------------------------------------------------------------------

// Cell

// string name = 1;
inline void Cell::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Cell::name() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Cell.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cell::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.Cell.name)
}
inline std::string* Cell::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Cell.name)
  return _s;
}
inline const std::string& Cell::_internal_name() const {
  return name_.Get();
}
inline void Cell::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Cell::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Cell::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Cell.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Cell::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Cell.name)
}

// .vlsir.circuit.Interface interface = 10;
inline bool Cell::_internal_has_interface() const {
  return this != internal_default_instance() && interface_ != nullptr;
}
inline bool Cell::has_interface() const {
  return _internal_has_interface();
}
inline const ::vlsir::circuit::Interface& Cell::_internal_interface() const {
  const ::vlsir::circuit::Interface* p = interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::Interface&>(
      ::vlsir::circuit::_Interface_default_instance_);
}
inline const ::vlsir::circuit::Interface& Cell::interface() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Cell.interface)
  return _internal_interface();
}
inline void Cell::unsafe_arena_set_allocated_interface(
    ::vlsir::circuit::Interface* interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  interface_ = interface;
  if (interface) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Cell.interface)
}
inline ::vlsir::circuit::Interface* Cell::release_interface() {
  
  ::vlsir::circuit::Interface* temp = interface_;
  interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::Interface* Cell::unsafe_arena_release_interface() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Cell.interface)
  
  ::vlsir::circuit::Interface* temp = interface_;
  interface_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Interface* Cell::_internal_mutable_interface() {
  
  if (interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Interface>(GetArenaForAllocation());
    interface_ = p;
  }
  return interface_;
}
inline ::vlsir::circuit::Interface* Cell::mutable_interface() {
  ::vlsir::circuit::Interface* _msg = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Cell.interface)
  return _msg;
}
inline void Cell::set_allocated_interface(::vlsir::circuit::Interface* interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  if (interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface));
    if (message_arena != submessage_arena) {
      interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Cell.interface)
}

// .vlsir.circuit.Module module = 11;
inline bool Cell::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool Cell::has_module() const {
  return _internal_has_module();
}
inline const ::vlsir::circuit::Module& Cell::_internal_module() const {
  const ::vlsir::circuit::Module* p = module_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::Module&>(
      ::vlsir::circuit::_Module_default_instance_);
}
inline const ::vlsir::circuit::Module& Cell::module() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Cell.module)
  return _internal_module();
}
inline void Cell::unsafe_arena_set_allocated_module(
    ::vlsir::circuit::Module* module) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Cell.module)
}
inline ::vlsir::circuit::Module* Cell::release_module() {
  
  ::vlsir::circuit::Module* temp = module_;
  module_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::Module* Cell::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Cell.module)
  
  ::vlsir::circuit::Module* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Module* Cell::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Module>(GetArenaForAllocation());
    module_ = p;
  }
  return module_;
}
inline ::vlsir::circuit::Module* Cell::mutable_module() {
  ::vlsir::circuit::Module* _msg = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Cell.module)
  return _msg;
}
inline void Cell::set_allocated_module(::vlsir::circuit::Module* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module));
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Cell.module)
}

// .vlsir.tetris.Abstract abstract = 12;
inline bool Cell::_internal_has_abstract() const {
  return this != internal_default_instance() && abstract_ != nullptr;
}
inline bool Cell::has_abstract() const {
  return _internal_has_abstract();
}
inline void Cell::clear_abstract() {
  if (GetArenaForAllocation() == nullptr && abstract_ != nullptr) {
    delete abstract_;
  }
  abstract_ = nullptr;
}
inline const ::vlsir::tetris::Abstract& Cell::_internal_abstract() const {
  const ::vlsir::tetris::Abstract* p = abstract_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Abstract&>(
      ::vlsir::tetris::_Abstract_default_instance_);
}
inline const ::vlsir::tetris::Abstract& Cell::abstract() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Cell.abstract)
  return _internal_abstract();
}
inline void Cell::unsafe_arena_set_allocated_abstract(
    ::vlsir::tetris::Abstract* abstract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abstract_);
  }
  abstract_ = abstract;
  if (abstract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Cell.abstract)
}
inline ::vlsir::tetris::Abstract* Cell::release_abstract() {
  
  ::vlsir::tetris::Abstract* temp = abstract_;
  abstract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Abstract* Cell::unsafe_arena_release_abstract() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Cell.abstract)
  
  ::vlsir::tetris::Abstract* temp = abstract_;
  abstract_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Abstract* Cell::_internal_mutable_abstract() {
  
  if (abstract_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Abstract>(GetArenaForAllocation());
    abstract_ = p;
  }
  return abstract_;
}
inline ::vlsir::tetris::Abstract* Cell::mutable_abstract() {
  ::vlsir::tetris::Abstract* _msg = _internal_mutable_abstract();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Cell.abstract)
  return _msg;
}
inline void Cell::set_allocated_abstract(::vlsir::tetris::Abstract* abstract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete abstract_;
  }
  if (abstract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Abstract>::GetOwningArena(abstract);
    if (message_arena != submessage_arena) {
      abstract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abstract, submessage_arena);
    }
    
  } else {
    
  }
  abstract_ = abstract;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Cell.abstract)
}

// .vlsir.tetris.Layout layout = 13;
inline bool Cell::_internal_has_layout() const {
  return this != internal_default_instance() && layout_ != nullptr;
}
inline bool Cell::has_layout() const {
  return _internal_has_layout();
}
inline void Cell::clear_layout() {
  if (GetArenaForAllocation() == nullptr && layout_ != nullptr) {
    delete layout_;
  }
  layout_ = nullptr;
}
inline const ::vlsir::tetris::Layout& Cell::_internal_layout() const {
  const ::vlsir::tetris::Layout* p = layout_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Layout&>(
      ::vlsir::tetris::_Layout_default_instance_);
}
inline const ::vlsir::tetris::Layout& Cell::layout() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Cell.layout)
  return _internal_layout();
}
inline void Cell::unsafe_arena_set_allocated_layout(
    ::vlsir::tetris::Layout* layout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(layout_);
  }
  layout_ = layout;
  if (layout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Cell.layout)
}
inline ::vlsir::tetris::Layout* Cell::release_layout() {
  
  ::vlsir::tetris::Layout* temp = layout_;
  layout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Layout* Cell::unsafe_arena_release_layout() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Cell.layout)
  
  ::vlsir::tetris::Layout* temp = layout_;
  layout_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Layout* Cell::_internal_mutable_layout() {
  
  if (layout_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Layout>(GetArenaForAllocation());
    layout_ = p;
  }
  return layout_;
}
inline ::vlsir::tetris::Layout* Cell::mutable_layout() {
  ::vlsir::tetris::Layout* _msg = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Cell.layout)
  return _msg;
}
inline void Cell::set_allocated_layout(::vlsir::tetris::Layout* layout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete layout_;
  }
  if (layout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Layout>::GetOwningArena(layout);
    if (message_arena != submessage_arena) {
      layout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layout, submessage_arena);
    }
    
  } else {
    
  }
  layout_ = layout;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Cell.layout)
}

// -------------------------------------------------------------------

// Layout

// string name = 1;
inline void Layout::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Layout::name() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Layout.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layout::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.Layout.name)
}
inline std::string* Layout::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Layout.name)
  return _s;
}
inline const std::string& Layout::_internal_name() const {
  return name_.Get();
}
inline void Layout::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Layout::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Layout::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Layout.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Layout::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Layout.name)
}

// .vlsir.tetris.Outline outline = 10;
inline bool Layout::_internal_has_outline() const {
  return this != internal_default_instance() && outline_ != nullptr;
}
inline bool Layout::has_outline() const {
  return _internal_has_outline();
}
inline void Layout::clear_outline() {
  if (GetArenaForAllocation() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
}
inline const ::vlsir::tetris::Outline& Layout::_internal_outline() const {
  const ::vlsir::tetris::Outline* p = outline_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Outline&>(
      ::vlsir::tetris::_Outline_default_instance_);
}
inline const ::vlsir::tetris::Outline& Layout::outline() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Layout.outline)
  return _internal_outline();
}
inline void Layout::unsafe_arena_set_allocated_outline(
    ::vlsir::tetris::Outline* outline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outline_);
  }
  outline_ = outline;
  if (outline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Layout.outline)
}
inline ::vlsir::tetris::Outline* Layout::release_outline() {
  
  ::vlsir::tetris::Outline* temp = outline_;
  outline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Outline* Layout::unsafe_arena_release_outline() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Layout.outline)
  
  ::vlsir::tetris::Outline* temp = outline_;
  outline_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Outline* Layout::_internal_mutable_outline() {
  
  if (outline_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Outline>(GetArenaForAllocation());
    outline_ = p;
  }
  return outline_;
}
inline ::vlsir::tetris::Outline* Layout::mutable_outline() {
  ::vlsir::tetris::Outline* _msg = _internal_mutable_outline();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Layout.outline)
  return _msg;
}
inline void Layout::set_allocated_outline(::vlsir::tetris::Outline* outline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outline_;
  }
  if (outline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Outline>::GetOwningArena(outline);
    if (message_arena != submessage_arena) {
      outline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outline, submessage_arena);
    }
    
  } else {
    
  }
  outline_ = outline;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Layout.outline)
}

// repeated .vlsir.tetris.Instance instances = 20;
inline int Layout::_internal_instances_size() const {
  return instances_.size();
}
inline int Layout::instances_size() const {
  return _internal_instances_size();
}
inline void Layout::clear_instances() {
  instances_.Clear();
}
inline ::vlsir::tetris::Instance* Layout::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Layout.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Instance >*
Layout::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Layout.instances)
  return &instances_;
}
inline const ::vlsir::tetris::Instance& Layout::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::vlsir::tetris::Instance& Layout::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Layout.instances)
  return _internal_instances(index);
}
inline ::vlsir::tetris::Instance* Layout::_internal_add_instances() {
  return instances_.Add();
}
inline ::vlsir::tetris::Instance* Layout::add_instances() {
  ::vlsir::tetris::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Layout.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Instance >&
Layout::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Layout.instances)
  return instances_;
}

// repeated .vlsir.tetris.Assign assignments = 21;
inline int Layout::_internal_assignments_size() const {
  return assignments_.size();
}
inline int Layout::assignments_size() const {
  return _internal_assignments_size();
}
inline void Layout::clear_assignments() {
  assignments_.Clear();
}
inline ::vlsir::tetris::Assign* Layout::mutable_assignments(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Layout.assignments)
  return assignments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Assign >*
Layout::mutable_assignments() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Layout.assignments)
  return &assignments_;
}
inline const ::vlsir::tetris::Assign& Layout::_internal_assignments(int index) const {
  return assignments_.Get(index);
}
inline const ::vlsir::tetris::Assign& Layout::assignments(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Layout.assignments)
  return _internal_assignments(index);
}
inline ::vlsir::tetris::Assign* Layout::_internal_add_assignments() {
  return assignments_.Add();
}
inline ::vlsir::tetris::Assign* Layout::add_assignments() {
  ::vlsir::tetris::Assign* _add = _internal_add_assignments();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Layout.assignments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::Assign >&
Layout::assignments() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Layout.assignments)
  return assignments_;
}

// repeated .vlsir.tetris.TrackCross cuts = 22;
inline int Layout::_internal_cuts_size() const {
  return cuts_.size();
}
inline int Layout::cuts_size() const {
  return _internal_cuts_size();
}
inline void Layout::clear_cuts() {
  cuts_.Clear();
}
inline ::vlsir::tetris::TrackCross* Layout::mutable_cuts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Layout.cuts)
  return cuts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >*
Layout::mutable_cuts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Layout.cuts)
  return &cuts_;
}
inline const ::vlsir::tetris::TrackCross& Layout::_internal_cuts(int index) const {
  return cuts_.Get(index);
}
inline const ::vlsir::tetris::TrackCross& Layout::cuts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Layout.cuts)
  return _internal_cuts(index);
}
inline ::vlsir::tetris::TrackCross* Layout::_internal_add_cuts() {
  return cuts_.Add();
}
inline ::vlsir::tetris::TrackCross* Layout::add_cuts() {
  ::vlsir::tetris::TrackCross* _add = _internal_add_cuts();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Layout.cuts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >&
Layout::cuts() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Layout.cuts)
  return cuts_;
}

// -------------------------------------------------------------------

// Assign

// string net = 1;
inline void Assign::clear_net() {
  net_.ClearToEmpty();
}
inline const std::string& Assign::net() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Assign.net)
  return _internal_net();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Assign::set_net(ArgT0&& arg0, ArgT... args) {
 
 net_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.Assign.net)
}
inline std::string* Assign::mutable_net() {
  std::string* _s = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Assign.net)
  return _s;
}
inline const std::string& Assign::_internal_net() const {
  return net_.Get();
}
inline void Assign::_internal_set_net(const std::string& value) {
  
  net_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Assign::_internal_mutable_net() {
  
  return net_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Assign::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Assign.net)
  return net_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Assign::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  net_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), net,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (net_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Assign.net)
}

// .vlsir.tetris.TrackCross at = 2;
inline bool Assign::_internal_has_at() const {
  return this != internal_default_instance() && at_ != nullptr;
}
inline bool Assign::has_at() const {
  return _internal_has_at();
}
inline void Assign::clear_at() {
  if (GetArenaForAllocation() == nullptr && at_ != nullptr) {
    delete at_;
  }
  at_ = nullptr;
}
inline const ::vlsir::tetris::TrackCross& Assign::_internal_at() const {
  const ::vlsir::tetris::TrackCross* p = at_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::TrackCross&>(
      ::vlsir::tetris::_TrackCross_default_instance_);
}
inline const ::vlsir::tetris::TrackCross& Assign::at() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Assign.at)
  return _internal_at();
}
inline void Assign::unsafe_arena_set_allocated_at(
    ::vlsir::tetris::TrackCross* at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(at_);
  }
  at_ = at;
  if (at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Assign.at)
}
inline ::vlsir::tetris::TrackCross* Assign::release_at() {
  
  ::vlsir::tetris::TrackCross* temp = at_;
  at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::TrackCross* Assign::unsafe_arena_release_at() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Assign.at)
  
  ::vlsir::tetris::TrackCross* temp = at_;
  at_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::TrackCross* Assign::_internal_mutable_at() {
  
  if (at_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::TrackCross>(GetArenaForAllocation());
    at_ = p;
  }
  return at_;
}
inline ::vlsir::tetris::TrackCross* Assign::mutable_at() {
  ::vlsir::tetris::TrackCross* _msg = _internal_mutable_at();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Assign.at)
  return _msg;
}
inline void Assign::set_allocated_at(::vlsir::tetris::TrackCross* at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete at_;
  }
  if (at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackCross>::GetOwningArena(at);
    if (message_arena != submessage_arena) {
      at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, at, submessage_arena);
    }
    
  } else {
    
  }
  at_ = at;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Assign.at)
}

// -------------------------------------------------------------------

// TrackCross

// .vlsir.tetris.TrackRef track = 1;
inline bool TrackCross::_internal_has_track() const {
  return this != internal_default_instance() && track_ != nullptr;
}
inline bool TrackCross::has_track() const {
  return _internal_has_track();
}
inline void TrackCross::clear_track() {
  if (GetArenaForAllocation() == nullptr && track_ != nullptr) {
    delete track_;
  }
  track_ = nullptr;
}
inline const ::vlsir::tetris::TrackRef& TrackCross::_internal_track() const {
  const ::vlsir::tetris::TrackRef* p = track_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::TrackRef&>(
      ::vlsir::tetris::_TrackRef_default_instance_);
}
inline const ::vlsir::tetris::TrackRef& TrackCross::track() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackCross.track)
  return _internal_track();
}
inline void TrackCross::unsafe_arena_set_allocated_track(
    ::vlsir::tetris::TrackRef* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_);
  }
  track_ = track;
  if (track) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.TrackCross.track)
}
inline ::vlsir::tetris::TrackRef* TrackCross::release_track() {
  
  ::vlsir::tetris::TrackRef* temp = track_;
  track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::TrackRef* TrackCross::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.TrackCross.track)
  
  ::vlsir::tetris::TrackRef* temp = track_;
  track_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::TrackRef* TrackCross::_internal_mutable_track() {
  
  if (track_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::TrackRef>(GetArenaForAllocation());
    track_ = p;
  }
  return track_;
}
inline ::vlsir::tetris::TrackRef* TrackCross::mutable_track() {
  ::vlsir::tetris::TrackRef* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.TrackCross.track)
  return _msg;
}
inline void TrackCross::set_allocated_track(::vlsir::tetris::TrackRef* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete track_;
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackRef>::GetOwningArena(track);
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    
  } else {
    
  }
  track_ = track;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackCross.track)
}

// .vlsir.tetris.TrackRef cross = 2;
inline bool TrackCross::_internal_has_cross() const {
  return this != internal_default_instance() && cross_ != nullptr;
}
inline bool TrackCross::has_cross() const {
  return _internal_has_cross();
}
inline void TrackCross::clear_cross() {
  if (GetArenaForAllocation() == nullptr && cross_ != nullptr) {
    delete cross_;
  }
  cross_ = nullptr;
}
inline const ::vlsir::tetris::TrackRef& TrackCross::_internal_cross() const {
  const ::vlsir::tetris::TrackRef* p = cross_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::TrackRef&>(
      ::vlsir::tetris::_TrackRef_default_instance_);
}
inline const ::vlsir::tetris::TrackRef& TrackCross::cross() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackCross.cross)
  return _internal_cross();
}
inline void TrackCross::unsafe_arena_set_allocated_cross(
    ::vlsir::tetris::TrackRef* cross) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cross_);
  }
  cross_ = cross;
  if (cross) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.TrackCross.cross)
}
inline ::vlsir::tetris::TrackRef* TrackCross::release_cross() {
  
  ::vlsir::tetris::TrackRef* temp = cross_;
  cross_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::TrackRef* TrackCross::unsafe_arena_release_cross() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.TrackCross.cross)
  
  ::vlsir::tetris::TrackRef* temp = cross_;
  cross_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::TrackRef* TrackCross::_internal_mutable_cross() {
  
  if (cross_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::TrackRef>(GetArenaForAllocation());
    cross_ = p;
  }
  return cross_;
}
inline ::vlsir::tetris::TrackRef* TrackCross::mutable_cross() {
  ::vlsir::tetris::TrackRef* _msg = _internal_mutable_cross();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.TrackCross.cross)
  return _msg;
}
inline void TrackCross::set_allocated_cross(::vlsir::tetris::TrackRef* cross) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cross_;
  }
  if (cross) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackRef>::GetOwningArena(cross);
    if (message_arena != submessage_arena) {
      cross = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cross, submessage_arena);
    }
    
  } else {
    
  }
  cross_ = cross;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackCross.cross)
}

// -------------------------------------------------------------------

// TrackRef

// int64 layer = 1;
inline void TrackRef::clear_layer() {
  layer_ = int64_t{0};
}
inline int64_t TrackRef::_internal_layer() const {
  return layer_;
}
inline int64_t TrackRef::layer() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackRef.layer)
  return _internal_layer();
}
inline void TrackRef::_internal_set_layer(int64_t value) {
  
  layer_ = value;
}
inline void TrackRef::set_layer(int64_t value) {
  _internal_set_layer(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.TrackRef.layer)
}

// int64 track = 2;
inline void TrackRef::clear_track() {
  track_ = int64_t{0};
}
inline int64_t TrackRef::_internal_track() const {
  return track_;
}
inline int64_t TrackRef::track() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackRef.track)
  return _internal_track();
}
inline void TrackRef::_internal_set_track(int64_t value) {
  
  track_ = value;
}
inline void TrackRef::set_track(int64_t value) {
  _internal_set_track(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.TrackRef.track)
}

// -------------------------------------------------------------------

// Outline

// repeated int64 x = 1;
inline int Outline::_internal_x_size() const {
  return x_.size();
}
inline int Outline::x_size() const {
  return _internal_x_size();
}
inline void Outline::clear_x() {
  x_.Clear();
}
inline int64_t Outline::_internal_x(int index) const {
  return x_.Get(index);
}
inline int64_t Outline::x(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Outline.x)
  return _internal_x(index);
}
inline void Outline::set_x(int index, int64_t value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Outline.x)
}
inline void Outline::_internal_add_x(int64_t value) {
  x_.Add(value);
}
inline void Outline::add_x(int64_t value) {
  _internal_add_x(value);
  // @@protoc_insertion_point(field_add:vlsir.tetris.Outline.x)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Outline::_internal_x() const {
  return x_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Outline::x() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Outline.x)
  return _internal_x();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Outline::_internal_mutable_x() {
  return &x_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Outline::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Outline.x)
  return _internal_mutable_x();
}

// repeated int64 y = 2;
inline int Outline::_internal_y_size() const {
  return y_.size();
}
inline int Outline::y_size() const {
  return _internal_y_size();
}
inline void Outline::clear_y() {
  y_.Clear();
}
inline int64_t Outline::_internal_y(int index) const {
  return y_.Get(index);
}
inline int64_t Outline::y(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Outline.y)
  return _internal_y(index);
}
inline void Outline::set_y(int index, int64_t value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Outline.y)
}
inline void Outline::_internal_add_y(int64_t value) {
  y_.Add(value);
}
inline void Outline::add_y(int64_t value) {
  _internal_add_y(value);
  // @@protoc_insertion_point(field_add:vlsir.tetris.Outline.y)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Outline::_internal_y() const {
  return y_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Outline::y() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Outline.y)
  return _internal_y();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Outline::_internal_mutable_y() {
  return &y_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Outline::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Outline.y)
  return _internal_mutable_y();
}

// int64 metals = 3;
inline void Outline::clear_metals() {
  metals_ = int64_t{0};
}
inline int64_t Outline::_internal_metals() const {
  return metals_;
}
inline int64_t Outline::metals() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Outline.metals)
  return _internal_metals();
}
inline void Outline::_internal_set_metals(int64_t value) {
  
  metals_ = value;
}
inline void Outline::set_metals(int64_t value) {
  _internal_set_metals(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Outline.metals)
}

// -------------------------------------------------------------------

// Abstract

// string name = 1;
inline void Abstract::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Abstract::name() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Abstract.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Abstract::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.Abstract.name)
}
inline std::string* Abstract::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Abstract.name)
  return _s;
}
inline const std::string& Abstract::_internal_name() const {
  return name_.Get();
}
inline void Abstract::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Abstract::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Abstract::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Abstract.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Abstract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Abstract.name)
}

// .vlsir.tetris.Outline outline = 10;
inline bool Abstract::_internal_has_outline() const {
  return this != internal_default_instance() && outline_ != nullptr;
}
inline bool Abstract::has_outline() const {
  return _internal_has_outline();
}
inline void Abstract::clear_outline() {
  if (GetArenaForAllocation() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
}
inline const ::vlsir::tetris::Outline& Abstract::_internal_outline() const {
  const ::vlsir::tetris::Outline* p = outline_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Outline&>(
      ::vlsir::tetris::_Outline_default_instance_);
}
inline const ::vlsir::tetris::Outline& Abstract::outline() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Abstract.outline)
  return _internal_outline();
}
inline void Abstract::unsafe_arena_set_allocated_outline(
    ::vlsir::tetris::Outline* outline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outline_);
  }
  outline_ = outline;
  if (outline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Abstract.outline)
}
inline ::vlsir::tetris::Outline* Abstract::release_outline() {
  
  ::vlsir::tetris::Outline* temp = outline_;
  outline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Outline* Abstract::unsafe_arena_release_outline() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Abstract.outline)
  
  ::vlsir::tetris::Outline* temp = outline_;
  outline_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Outline* Abstract::_internal_mutable_outline() {
  
  if (outline_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Outline>(GetArenaForAllocation());
    outline_ = p;
  }
  return outline_;
}
inline ::vlsir::tetris::Outline* Abstract::mutable_outline() {
  ::vlsir::tetris::Outline* _msg = _internal_mutable_outline();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Abstract.outline)
  return _msg;
}
inline void Abstract::set_allocated_outline(::vlsir::tetris::Outline* outline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outline_;
  }
  if (outline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Outline>::GetOwningArena(outline);
    if (message_arena != submessage_arena) {
      outline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outline, submessage_arena);
    }
    
  } else {
    
  }
  outline_ = outline;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Abstract.outline)
}

// repeated .vlsir.tetris.AbstractPort ports = 20;
inline int Abstract::_internal_ports_size() const {
  return ports_.size();
}
inline int Abstract::ports_size() const {
  return _internal_ports_size();
}
inline void Abstract::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::tetris::AbstractPort* Abstract::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Abstract.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::AbstractPort >*
Abstract::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Abstract.ports)
  return &ports_;
}
inline const ::vlsir::tetris::AbstractPort& Abstract::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::tetris::AbstractPort& Abstract::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Abstract.ports)
  return _internal_ports(index);
}
inline ::vlsir::tetris::AbstractPort* Abstract::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::tetris::AbstractPort* Abstract::add_ports() {
  ::vlsir::tetris::AbstractPort* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Abstract.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::AbstractPort >&
Abstract::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Abstract.ports)
  return ports_;
}

// -------------------------------------------------------------------

// AbstractPort_EdgePort

// .vlsir.tetris.TrackRef track = 1;
inline bool AbstractPort_EdgePort::_internal_has_track() const {
  return this != internal_default_instance() && track_ != nullptr;
}
inline bool AbstractPort_EdgePort::has_track() const {
  return _internal_has_track();
}
inline void AbstractPort_EdgePort::clear_track() {
  if (GetArenaForAllocation() == nullptr && track_ != nullptr) {
    delete track_;
  }
  track_ = nullptr;
}
inline const ::vlsir::tetris::TrackRef& AbstractPort_EdgePort::_internal_track() const {
  const ::vlsir::tetris::TrackRef* p = track_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::TrackRef&>(
      ::vlsir::tetris::_TrackRef_default_instance_);
}
inline const ::vlsir::tetris::TrackRef& AbstractPort_EdgePort::track() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.EdgePort.track)
  return _internal_track();
}
inline void AbstractPort_EdgePort::unsafe_arena_set_allocated_track(
    ::vlsir::tetris::TrackRef* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_);
  }
  track_ = track;
  if (track) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.AbstractPort.EdgePort.track)
}
inline ::vlsir::tetris::TrackRef* AbstractPort_EdgePort::release_track() {
  
  ::vlsir::tetris::TrackRef* temp = track_;
  track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::TrackRef* AbstractPort_EdgePort::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.AbstractPort.EdgePort.track)
  
  ::vlsir::tetris::TrackRef* temp = track_;
  track_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::TrackRef* AbstractPort_EdgePort::_internal_mutable_track() {
  
  if (track_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::TrackRef>(GetArenaForAllocation());
    track_ = p;
  }
  return track_;
}
inline ::vlsir::tetris::TrackRef* AbstractPort_EdgePort::mutable_track() {
  ::vlsir::tetris::TrackRef* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.EdgePort.track)
  return _msg;
}
inline void AbstractPort_EdgePort::set_allocated_track(::vlsir::tetris::TrackRef* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete track_;
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackRef>::GetOwningArena(track);
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    
  } else {
    
  }
  track_ = track;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.EdgePort.track)
}

// .vlsir.tetris.AbstractPort.PortSide side = 2;
inline void AbstractPort_EdgePort::clear_side() {
  side_ = 0;
}
inline ::vlsir::tetris::AbstractPort_PortSide AbstractPort_EdgePort::_internal_side() const {
  return static_cast< ::vlsir::tetris::AbstractPort_PortSide >(side_);
}
inline ::vlsir::tetris::AbstractPort_PortSide AbstractPort_EdgePort::side() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.EdgePort.side)
  return _internal_side();
}
inline void AbstractPort_EdgePort::_internal_set_side(::vlsir::tetris::AbstractPort_PortSide value) {
  
  side_ = value;
}
inline void AbstractPort_EdgePort::set_side(::vlsir::tetris::AbstractPort_PortSide value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.AbstractPort.EdgePort.side)
}

// -------------------------------------------------------------------

// AbstractPort_ZTopEdgePort

// int64 track = 1;
inline void AbstractPort_ZTopEdgePort::clear_track() {
  track_ = int64_t{0};
}
inline int64_t AbstractPort_ZTopEdgePort::_internal_track() const {
  return track_;
}
inline int64_t AbstractPort_ZTopEdgePort::track() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.ZTopEdgePort.track)
  return _internal_track();
}
inline void AbstractPort_ZTopEdgePort::_internal_set_track(int64_t value) {
  
  track_ = value;
}
inline void AbstractPort_ZTopEdgePort::set_track(int64_t value) {
  _internal_set_track(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.AbstractPort.ZTopEdgePort.track)
}

// .vlsir.tetris.AbstractPort.PortSide side = 2;
inline void AbstractPort_ZTopEdgePort::clear_side() {
  side_ = 0;
}
inline ::vlsir::tetris::AbstractPort_PortSide AbstractPort_ZTopEdgePort::_internal_side() const {
  return static_cast< ::vlsir::tetris::AbstractPort_PortSide >(side_);
}
inline ::vlsir::tetris::AbstractPort_PortSide AbstractPort_ZTopEdgePort::side() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.ZTopEdgePort.side)
  return _internal_side();
}
inline void AbstractPort_ZTopEdgePort::_internal_set_side(::vlsir::tetris::AbstractPort_PortSide value) {
  
  side_ = value;
}
inline void AbstractPort_ZTopEdgePort::set_side(::vlsir::tetris::AbstractPort_PortSide value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.AbstractPort.ZTopEdgePort.side)
}

// .vlsir.tetris.TrackRef into = 3;
inline bool AbstractPort_ZTopEdgePort::_internal_has_into() const {
  return this != internal_default_instance() && into_ != nullptr;
}
inline bool AbstractPort_ZTopEdgePort::has_into() const {
  return _internal_has_into();
}
inline void AbstractPort_ZTopEdgePort::clear_into() {
  if (GetArenaForAllocation() == nullptr && into_ != nullptr) {
    delete into_;
  }
  into_ = nullptr;
}
inline const ::vlsir::tetris::TrackRef& AbstractPort_ZTopEdgePort::_internal_into() const {
  const ::vlsir::tetris::TrackRef* p = into_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::TrackRef&>(
      ::vlsir::tetris::_TrackRef_default_instance_);
}
inline const ::vlsir::tetris::TrackRef& AbstractPort_ZTopEdgePort::into() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.ZTopEdgePort.into)
  return _internal_into();
}
inline void AbstractPort_ZTopEdgePort::unsafe_arena_set_allocated_into(
    ::vlsir::tetris::TrackRef* into) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(into_);
  }
  into_ = into;
  if (into) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.AbstractPort.ZTopEdgePort.into)
}
inline ::vlsir::tetris::TrackRef* AbstractPort_ZTopEdgePort::release_into() {
  
  ::vlsir::tetris::TrackRef* temp = into_;
  into_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::TrackRef* AbstractPort_ZTopEdgePort::unsafe_arena_release_into() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.AbstractPort.ZTopEdgePort.into)
  
  ::vlsir::tetris::TrackRef* temp = into_;
  into_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::TrackRef* AbstractPort_ZTopEdgePort::_internal_mutable_into() {
  
  if (into_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::TrackRef>(GetArenaForAllocation());
    into_ = p;
  }
  return into_;
}
inline ::vlsir::tetris::TrackRef* AbstractPort_ZTopEdgePort::mutable_into() {
  ::vlsir::tetris::TrackRef* _msg = _internal_mutable_into();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.ZTopEdgePort.into)
  return _msg;
}
inline void AbstractPort_ZTopEdgePort::set_allocated_into(::vlsir::tetris::TrackRef* into) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete into_;
  }
  if (into) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackRef>::GetOwningArena(into);
    if (message_arena != submessage_arena) {
      into = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, into, submessage_arena);
    }
    
  } else {
    
  }
  into_ = into;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ZTopEdgePort.into)
}

// -------------------------------------------------------------------

// AbstractPort_ZTopInner

// repeated .vlsir.tetris.TrackCross locs = 1;
inline int AbstractPort_ZTopInner::_internal_locs_size() const {
  return locs_.size();
}
inline int AbstractPort_ZTopInner::locs_size() const {
  return _internal_locs_size();
}
inline void AbstractPort_ZTopInner::clear_locs() {
  locs_.Clear();
}
inline ::vlsir::tetris::TrackCross* AbstractPort_ZTopInner::mutable_locs(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.ZTopInner.locs)
  return locs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >*
AbstractPort_ZTopInner::mutable_locs() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.AbstractPort.ZTopInner.locs)
  return &locs_;
}
inline const ::vlsir::tetris::TrackCross& AbstractPort_ZTopInner::_internal_locs(int index) const {
  return locs_.Get(index);
}
inline const ::vlsir::tetris::TrackCross& AbstractPort_ZTopInner::locs(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.ZTopInner.locs)
  return _internal_locs(index);
}
inline ::vlsir::tetris::TrackCross* AbstractPort_ZTopInner::_internal_add_locs() {
  return locs_.Add();
}
inline ::vlsir::tetris::TrackCross* AbstractPort_ZTopInner::add_locs() {
  ::vlsir::tetris::TrackCross* _add = _internal_add_locs();
  // @@protoc_insertion_point(field_add:vlsir.tetris.AbstractPort.ZTopInner.locs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackCross >&
AbstractPort_ZTopInner::locs() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.AbstractPort.ZTopInner.locs)
  return locs_;
}

// -------------------------------------------------------------------

// AbstractPort

// string net = 1;
inline void AbstractPort::clear_net() {
  net_.ClearToEmpty();
}
inline const std::string& AbstractPort::net() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.net)
  return _internal_net();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbstractPort::set_net(ArgT0&& arg0, ArgT... args) {
 
 net_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.AbstractPort.net)
}
inline std::string* AbstractPort::mutable_net() {
  std::string* _s = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.net)
  return _s;
}
inline const std::string& AbstractPort::_internal_net() const {
  return net_.Get();
}
inline void AbstractPort::_internal_set_net(const std::string& value) {
  
  net_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AbstractPort::_internal_mutable_net() {
  
  return net_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AbstractPort::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.AbstractPort.net)
  return net_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AbstractPort::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  net_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), net,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (net_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.net)
}

// .vlsir.tetris.AbstractPort.EdgePort edge = 10;
inline bool AbstractPort::_internal_has_edge() const {
  return kind_case() == kEdge;
}
inline bool AbstractPort::has_edge() const {
  return _internal_has_edge();
}
inline void AbstractPort::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void AbstractPort::clear_edge() {
  if (_internal_has_edge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.edge_;
    }
    clear_has_kind();
  }
}
inline ::vlsir::tetris::AbstractPort_EdgePort* AbstractPort::release_edge() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.AbstractPort.edge)
  if (_internal_has_edge()) {
    clear_has_kind();
      ::vlsir::tetris::AbstractPort_EdgePort* temp = kind_.edge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::tetris::AbstractPort_EdgePort& AbstractPort::_internal_edge() const {
  return _internal_has_edge()
      ? *kind_.edge_
      : reinterpret_cast< ::vlsir::tetris::AbstractPort_EdgePort&>(::vlsir::tetris::_AbstractPort_EdgePort_default_instance_);
}
inline const ::vlsir::tetris::AbstractPort_EdgePort& AbstractPort::edge() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.edge)
  return _internal_edge();
}
inline ::vlsir::tetris::AbstractPort_EdgePort* AbstractPort::unsafe_arena_release_edge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.AbstractPort.edge)
  if (_internal_has_edge()) {
    clear_has_kind();
    ::vlsir::tetris::AbstractPort_EdgePort* temp = kind_.edge_;
    kind_.edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AbstractPort::unsafe_arena_set_allocated_edge(::vlsir::tetris::AbstractPort_EdgePort* edge) {
  clear_kind();
  if (edge) {
    set_has_edge();
    kind_.edge_ = edge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.AbstractPort.edge)
}
inline ::vlsir::tetris::AbstractPort_EdgePort* AbstractPort::_internal_mutable_edge() {
  if (!_internal_has_edge()) {
    clear_kind();
    set_has_edge();
    kind_.edge_ = CreateMaybeMessage< ::vlsir::tetris::AbstractPort_EdgePort >(GetArenaForAllocation());
  }
  return kind_.edge_;
}
inline ::vlsir::tetris::AbstractPort_EdgePort* AbstractPort::mutable_edge() {
  ::vlsir::tetris::AbstractPort_EdgePort* _msg = _internal_mutable_edge();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.edge)
  return _msg;
}

// .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
inline bool AbstractPort::_internal_has_ztop_edge() const {
  return kind_case() == kZtopEdge;
}
inline bool AbstractPort::has_ztop_edge() const {
  return _internal_has_ztop_edge();
}
inline void AbstractPort::set_has_ztop_edge() {
  _oneof_case_[0] = kZtopEdge;
}
inline void AbstractPort::clear_ztop_edge() {
  if (_internal_has_ztop_edge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.ztop_edge_;
    }
    clear_has_kind();
  }
}
inline ::vlsir::tetris::AbstractPort_ZTopEdgePort* AbstractPort::release_ztop_edge() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.AbstractPort.ztop_edge)
  if (_internal_has_ztop_edge()) {
    clear_has_kind();
      ::vlsir::tetris::AbstractPort_ZTopEdgePort* temp = kind_.ztop_edge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.ztop_edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::tetris::AbstractPort_ZTopEdgePort& AbstractPort::_internal_ztop_edge() const {
  return _internal_has_ztop_edge()
      ? *kind_.ztop_edge_
      : reinterpret_cast< ::vlsir::tetris::AbstractPort_ZTopEdgePort&>(::vlsir::tetris::_AbstractPort_ZTopEdgePort_default_instance_);
}
inline const ::vlsir::tetris::AbstractPort_ZTopEdgePort& AbstractPort::ztop_edge() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.ztop_edge)
  return _internal_ztop_edge();
}
inline ::vlsir::tetris::AbstractPort_ZTopEdgePort* AbstractPort::unsafe_arena_release_ztop_edge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.AbstractPort.ztop_edge)
  if (_internal_has_ztop_edge()) {
    clear_has_kind();
    ::vlsir::tetris::AbstractPort_ZTopEdgePort* temp = kind_.ztop_edge_;
    kind_.ztop_edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AbstractPort::unsafe_arena_set_allocated_ztop_edge(::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge) {
  clear_kind();
  if (ztop_edge) {
    set_has_ztop_edge();
    kind_.ztop_edge_ = ztop_edge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.AbstractPort.ztop_edge)
}
inline ::vlsir::tetris::AbstractPort_ZTopEdgePort* AbstractPort::_internal_mutable_ztop_edge() {
  if (!_internal_has_ztop_edge()) {
    clear_kind();
    set_has_ztop_edge();
    kind_.ztop_edge_ = CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(GetArenaForAllocation());
  }
  return kind_.ztop_edge_;
}
inline ::vlsir::tetris::AbstractPort_ZTopEdgePort* AbstractPort::mutable_ztop_edge() {
  ::vlsir::tetris::AbstractPort_ZTopEdgePort* _msg = _internal_mutable_ztop_edge();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.ztop_edge)
  return _msg;
}

// .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
inline bool AbstractPort::_internal_has_ztop_inner() const {
  return kind_case() == kZtopInner;
}
inline bool AbstractPort::has_ztop_inner() const {
  return _internal_has_ztop_inner();
}
inline void AbstractPort::set_has_ztop_inner() {
  _oneof_case_[0] = kZtopInner;
}
inline void AbstractPort::clear_ztop_inner() {
  if (_internal_has_ztop_inner()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.ztop_inner_;
    }
    clear_has_kind();
  }
}
inline ::vlsir::tetris::AbstractPort_ZTopInner* AbstractPort::release_ztop_inner() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.AbstractPort.ztop_inner)
  if (_internal_has_ztop_inner()) {
    clear_has_kind();
      ::vlsir::tetris::AbstractPort_ZTopInner* temp = kind_.ztop_inner_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.ztop_inner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::tetris::AbstractPort_ZTopInner& AbstractPort::_internal_ztop_inner() const {
  return _internal_has_ztop_inner()
      ? *kind_.ztop_inner_
      : reinterpret_cast< ::vlsir::tetris::AbstractPort_ZTopInner&>(::vlsir::tetris::_AbstractPort_ZTopInner_default_instance_);
}
inline const ::vlsir::tetris::AbstractPort_ZTopInner& AbstractPort::ztop_inner() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.AbstractPort.ztop_inner)
  return _internal_ztop_inner();
}
inline ::vlsir::tetris::AbstractPort_ZTopInner* AbstractPort::unsafe_arena_release_ztop_inner() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.AbstractPort.ztop_inner)
  if (_internal_has_ztop_inner()) {
    clear_has_kind();
    ::vlsir::tetris::AbstractPort_ZTopInner* temp = kind_.ztop_inner_;
    kind_.ztop_inner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AbstractPort::unsafe_arena_set_allocated_ztop_inner(::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner) {
  clear_kind();
  if (ztop_inner) {
    set_has_ztop_inner();
    kind_.ztop_inner_ = ztop_inner;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.AbstractPort.ztop_inner)
}
inline ::vlsir::tetris::AbstractPort_ZTopInner* AbstractPort::_internal_mutable_ztop_inner() {
  if (!_internal_has_ztop_inner()) {
    clear_kind();
    set_has_ztop_inner();
    kind_.ztop_inner_ = CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopInner >(GetArenaForAllocation());
  }
  return kind_.ztop_inner_;
}
inline ::vlsir::tetris::AbstractPort_ZTopInner* AbstractPort::mutable_ztop_inner() {
  ::vlsir::tetris::AbstractPort_ZTopInner* _msg = _internal_mutable_ztop_inner();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.AbstractPort.ztop_inner)
  return _msg;
}

inline bool AbstractPort::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AbstractPort::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline AbstractPort::KindCase AbstractPort::kind_case() const {
  return AbstractPort::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Instance.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.Instance.name)
}
inline std::string* Instance::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Instance.name)
  return _s;
}
inline const std::string& Instance::_internal_name() const {
  return name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Instance.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Instance.name)
}

// .vlsir.utils.Reference cell = 3;
inline bool Instance::_internal_has_cell() const {
  return this != internal_default_instance() && cell_ != nullptr;
}
inline bool Instance::has_cell() const {
  return _internal_has_cell();
}
inline const ::vlsir::utils::Reference& Instance::_internal_cell() const {
  const ::vlsir::utils::Reference* p = cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::Reference&>(
      ::vlsir::utils::_Reference_default_instance_);
}
inline const ::vlsir::utils::Reference& Instance::cell() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Instance.cell)
  return _internal_cell();
}
inline void Instance::unsafe_arena_set_allocated_cell(
    ::vlsir::utils::Reference* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_);
  }
  cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Instance.cell)
}
inline ::vlsir::utils::Reference* Instance::release_cell() {
  
  ::vlsir::utils::Reference* temp = cell_;
  cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::Reference* Instance::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Instance.cell)
  
  ::vlsir::utils::Reference* temp = cell_;
  cell_ = nullptr;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::_internal_mutable_cell() {
  
  if (cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArenaForAllocation());
    cell_ = p;
  }
  return cell_;
}
inline ::vlsir::utils::Reference* Instance::mutable_cell() {
  ::vlsir::utils::Reference* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Instance.cell)
  return _msg;
}
inline void Instance::set_allocated_cell(::vlsir::utils::Reference* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Instance.cell)
}

// .vlsir.tetris.Place loc = 4;
inline bool Instance::_internal_has_loc() const {
  return this != internal_default_instance() && loc_ != nullptr;
}
inline bool Instance::has_loc() const {
  return _internal_has_loc();
}
inline void Instance::clear_loc() {
  if (GetArenaForAllocation() == nullptr && loc_ != nullptr) {
    delete loc_;
  }
  loc_ = nullptr;
}
inline const ::vlsir::tetris::Place& Instance::_internal_loc() const {
  const ::vlsir::tetris::Place* p = loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Place&>(
      ::vlsir::tetris::_Place_default_instance_);
}
inline const ::vlsir::tetris::Place& Instance::loc() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Instance.loc)
  return _internal_loc();
}
inline void Instance::unsafe_arena_set_allocated_loc(
    ::vlsir::tetris::Place* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(loc_);
  }
  loc_ = loc;
  if (loc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Instance.loc)
}
inline ::vlsir::tetris::Place* Instance::release_loc() {
  
  ::vlsir::tetris::Place* temp = loc_;
  loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Place* Instance::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Instance.loc)
  
  ::vlsir::tetris::Place* temp = loc_;
  loc_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Place* Instance::_internal_mutable_loc() {
  
  if (loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Place>(GetArenaForAllocation());
    loc_ = p;
  }
  return loc_;
}
inline ::vlsir::tetris::Place* Instance::mutable_loc() {
  ::vlsir::tetris::Place* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Instance.loc)
  return _msg;
}
inline void Instance::set_allocated_loc(::vlsir::tetris::Place* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Place>::GetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    
  } else {
    
  }
  loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Instance.loc)
}

// bool reflect_horiz = 6;
inline void Instance::clear_reflect_horiz() {
  reflect_horiz_ = false;
}
inline bool Instance::_internal_reflect_horiz() const {
  return reflect_horiz_;
}
inline bool Instance::reflect_horiz() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Instance.reflect_horiz)
  return _internal_reflect_horiz();
}
inline void Instance::_internal_set_reflect_horiz(bool value) {
  
  reflect_horiz_ = value;
}
inline void Instance::set_reflect_horiz(bool value) {
  _internal_set_reflect_horiz(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Instance.reflect_horiz)
}

// bool reflect_vert = 7;
inline void Instance::clear_reflect_vert() {
  reflect_vert_ = false;
}
inline bool Instance::_internal_reflect_vert() const {
  return reflect_vert_;
}
inline bool Instance::reflect_vert() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Instance.reflect_vert)
  return _internal_reflect_vert();
}
inline void Instance::_internal_set_reflect_vert(bool value) {
  
  reflect_vert_ = value;
}
inline void Instance::set_reflect_vert(bool value) {
  _internal_set_reflect_vert(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Instance.reflect_vert)
}

// -------------------------------------------------------------------

// Place

// .vlsir.raw.Point abs = 1;
inline bool Place::_internal_has_abs() const {
  return place_case() == kAbs;
}
inline bool Place::has_abs() const {
  return _internal_has_abs();
}
inline void Place::set_has_abs() {
  _oneof_case_[0] = kAbs;
}
inline ::vlsir::raw::Point* Place::release_abs() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Place.abs)
  if (_internal_has_abs()) {
    clear_has_place();
      ::vlsir::raw::Point* temp = place_.abs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    place_.abs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::raw::Point& Place::_internal_abs() const {
  return _internal_has_abs()
      ? *place_.abs_
      : reinterpret_cast< ::vlsir::raw::Point&>(::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& Place::abs() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Place.abs)
  return _internal_abs();
}
inline ::vlsir::raw::Point* Place::unsafe_arena_release_abs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.Place.abs)
  if (_internal_has_abs()) {
    clear_has_place();
    ::vlsir::raw::Point* temp = place_.abs_;
    place_.abs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Place::unsafe_arena_set_allocated_abs(::vlsir::raw::Point* abs) {
  clear_place();
  if (abs) {
    set_has_abs();
    place_.abs_ = abs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Place.abs)
}
inline ::vlsir::raw::Point* Place::_internal_mutable_abs() {
  if (!_internal_has_abs()) {
    clear_place();
    set_has_abs();
    place_.abs_ = CreateMaybeMessage< ::vlsir::raw::Point >(GetArenaForAllocation());
  }
  return place_.abs_;
}
inline ::vlsir::raw::Point* Place::mutable_abs() {
  ::vlsir::raw::Point* _msg = _internal_mutable_abs();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Place.abs)
  return _msg;
}

// .vlsir.tetris.RelPlace rel = 2;
inline bool Place::_internal_has_rel() const {
  return place_case() == kRel;
}
inline bool Place::has_rel() const {
  return _internal_has_rel();
}
inline void Place::set_has_rel() {
  _oneof_case_[0] = kRel;
}
inline void Place::clear_rel() {
  if (_internal_has_rel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete place_.rel_;
    }
    clear_has_place();
  }
}
inline ::vlsir::tetris::RelPlace* Place::release_rel() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Place.rel)
  if (_internal_has_rel()) {
    clear_has_place();
      ::vlsir::tetris::RelPlace* temp = place_.rel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    place_.rel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::tetris::RelPlace& Place::_internal_rel() const {
  return _internal_has_rel()
      ? *place_.rel_
      : reinterpret_cast< ::vlsir::tetris::RelPlace&>(::vlsir::tetris::_RelPlace_default_instance_);
}
inline const ::vlsir::tetris::RelPlace& Place::rel() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Place.rel)
  return _internal_rel();
}
inline ::vlsir::tetris::RelPlace* Place::unsafe_arena_release_rel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.Place.rel)
  if (_internal_has_rel()) {
    clear_has_place();
    ::vlsir::tetris::RelPlace* temp = place_.rel_;
    place_.rel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Place::unsafe_arena_set_allocated_rel(::vlsir::tetris::RelPlace* rel) {
  clear_place();
  if (rel) {
    set_has_rel();
    place_.rel_ = rel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Place.rel)
}
inline ::vlsir::tetris::RelPlace* Place::_internal_mutable_rel() {
  if (!_internal_has_rel()) {
    clear_place();
    set_has_rel();
    place_.rel_ = CreateMaybeMessage< ::vlsir::tetris::RelPlace >(GetArenaForAllocation());
  }
  return place_.rel_;
}
inline ::vlsir::tetris::RelPlace* Place::mutable_rel() {
  ::vlsir::tetris::RelPlace* _msg = _internal_mutable_rel();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Place.rel)
  return _msg;
}

inline bool Place::has_place() const {
  return place_case() != PLACE_NOT_SET;
}
inline void Place::clear_has_place() {
  _oneof_case_[0] = PLACE_NOT_SET;
}
inline Place::PlaceCase Place::place_case() const {
  return Place::PlaceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RelPlace

// -------------------------------------------------------------------

// Stack

// .vlsir.raw.Units units = 1;
inline void Stack::clear_units() {
  units_ = 0;
}
inline ::vlsir::raw::Units Stack::_internal_units() const {
  return static_cast< ::vlsir::raw::Units >(units_);
}
inline ::vlsir::raw::Units Stack::units() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Stack.units)
  return _internal_units();
}
inline void Stack::_internal_set_units(::vlsir::raw::Units value) {
  
  units_ = value;
}
inline void Stack::set_units(::vlsir::raw::Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Stack.units)
}

// .vlsir.tetris.PrimitiveLayer prim = 2;
inline bool Stack::_internal_has_prim() const {
  return this != internal_default_instance() && prim_ != nullptr;
}
inline bool Stack::has_prim() const {
  return _internal_has_prim();
}
inline void Stack::clear_prim() {
  if (GetArenaForAllocation() == nullptr && prim_ != nullptr) {
    delete prim_;
  }
  prim_ = nullptr;
}
inline const ::vlsir::tetris::PrimitiveLayer& Stack::_internal_prim() const {
  const ::vlsir::tetris::PrimitiveLayer* p = prim_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::PrimitiveLayer&>(
      ::vlsir::tetris::_PrimitiveLayer_default_instance_);
}
inline const ::vlsir::tetris::PrimitiveLayer& Stack::prim() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Stack.prim)
  return _internal_prim();
}
inline void Stack::unsafe_arena_set_allocated_prim(
    ::vlsir::tetris::PrimitiveLayer* prim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prim_);
  }
  prim_ = prim;
  if (prim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Stack.prim)
}
inline ::vlsir::tetris::PrimitiveLayer* Stack::release_prim() {
  
  ::vlsir::tetris::PrimitiveLayer* temp = prim_;
  prim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::PrimitiveLayer* Stack::unsafe_arena_release_prim() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Stack.prim)
  
  ::vlsir::tetris::PrimitiveLayer* temp = prim_;
  prim_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::PrimitiveLayer* Stack::_internal_mutable_prim() {
  
  if (prim_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::PrimitiveLayer>(GetArenaForAllocation());
    prim_ = p;
  }
  return prim_;
}
inline ::vlsir::tetris::PrimitiveLayer* Stack::mutable_prim() {
  ::vlsir::tetris::PrimitiveLayer* _msg = _internal_mutable_prim();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Stack.prim)
  return _msg;
}
inline void Stack::set_allocated_prim(::vlsir::tetris::PrimitiveLayer* prim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete prim_;
  }
  if (prim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::PrimitiveLayer>::GetOwningArena(prim);
    if (message_arena != submessage_arena) {
      prim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prim, submessage_arena);
    }
    
  } else {
    
  }
  prim_ = prim;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Stack.prim)
}

// repeated .vlsir.tetris.MetalLayer metals = 3;
inline int Stack::_internal_metals_size() const {
  return metals_.size();
}
inline int Stack::metals_size() const {
  return _internal_metals_size();
}
inline void Stack::clear_metals() {
  metals_.Clear();
}
inline ::vlsir::tetris::MetalLayer* Stack::mutable_metals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Stack.metals)
  return metals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::MetalLayer >*
Stack::mutable_metals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Stack.metals)
  return &metals_;
}
inline const ::vlsir::tetris::MetalLayer& Stack::_internal_metals(int index) const {
  return metals_.Get(index);
}
inline const ::vlsir::tetris::MetalLayer& Stack::metals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Stack.metals)
  return _internal_metals(index);
}
inline ::vlsir::tetris::MetalLayer* Stack::_internal_add_metals() {
  return metals_.Add();
}
inline ::vlsir::tetris::MetalLayer* Stack::add_metals() {
  ::vlsir::tetris::MetalLayer* _add = _internal_add_metals();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Stack.metals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::MetalLayer >&
Stack::metals() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Stack.metals)
  return metals_;
}

// repeated .vlsir.tetris.ViaLayer vias = 4;
inline int Stack::_internal_vias_size() const {
  return vias_.size();
}
inline int Stack::vias_size() const {
  return _internal_vias_size();
}
inline void Stack::clear_vias() {
  vias_.Clear();
}
inline ::vlsir::tetris::ViaLayer* Stack::mutable_vias(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Stack.vias)
  return vias_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::ViaLayer >*
Stack::mutable_vias() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.Stack.vias)
  return &vias_;
}
inline const ::vlsir::tetris::ViaLayer& Stack::_internal_vias(int index) const {
  return vias_.Get(index);
}
inline const ::vlsir::tetris::ViaLayer& Stack::vias(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Stack.vias)
  return _internal_vias(index);
}
inline ::vlsir::tetris::ViaLayer* Stack::_internal_add_vias() {
  return vias_.Add();
}
inline ::vlsir::tetris::ViaLayer* Stack::add_vias() {
  ::vlsir::tetris::ViaLayer* _add = _internal_add_vias();
  // @@protoc_insertion_point(field_add:vlsir.tetris.Stack.vias)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::ViaLayer >&
Stack::vias() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.Stack.vias)
  return vias_;
}

// .vlsir.raw.Layer boundary_layer = 11;
inline bool Stack::_internal_has_boundary_layer() const {
  return this != internal_default_instance() && boundary_layer_ != nullptr;
}
inline bool Stack::has_boundary_layer() const {
  return _internal_has_boundary_layer();
}
inline const ::vlsir::raw::Layer& Stack::_internal_boundary_layer() const {
  const ::vlsir::raw::Layer* p = boundary_layer_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Layer&>(
      ::vlsir::raw::_Layer_default_instance_);
}
inline const ::vlsir::raw::Layer& Stack::boundary_layer() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Stack.boundary_layer)
  return _internal_boundary_layer();
}
inline void Stack::unsafe_arena_set_allocated_boundary_layer(
    ::vlsir::raw::Layer* boundary_layer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(boundary_layer_);
  }
  boundary_layer_ = boundary_layer;
  if (boundary_layer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.Stack.boundary_layer)
}
inline ::vlsir::raw::Layer* Stack::release_boundary_layer() {
  
  ::vlsir::raw::Layer* temp = boundary_layer_;
  boundary_layer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Layer* Stack::unsafe_arena_release_boundary_layer() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.Stack.boundary_layer)
  
  ::vlsir::raw::Layer* temp = boundary_layer_;
  boundary_layer_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layer* Stack::_internal_mutable_boundary_layer() {
  
  if (boundary_layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layer>(GetArenaForAllocation());
    boundary_layer_ = p;
  }
  return boundary_layer_;
}
inline ::vlsir::raw::Layer* Stack::mutable_boundary_layer() {
  ::vlsir::raw::Layer* _msg = _internal_mutable_boundary_layer();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.Stack.boundary_layer)
  return _msg;
}
inline void Stack::set_allocated_boundary_layer(::vlsir::raw::Layer* boundary_layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(boundary_layer_);
  }
  if (boundary_layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(boundary_layer));
    if (message_arena != submessage_arena) {
      boundary_layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundary_layer, submessage_arena);
    }
    
  } else {
    
  }
  boundary_layer_ = boundary_layer;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Stack.boundary_layer)
}

// -------------------------------------------------------------------

// LayerEnum

// .vlsir.tetris.LayerEnum.LayerType type = 1;
inline void LayerEnum::clear_type() {
  type_ = 0;
}
inline ::vlsir::tetris::LayerEnum_LayerType LayerEnum::_internal_type() const {
  return static_cast< ::vlsir::tetris::LayerEnum_LayerType >(type_);
}
inline ::vlsir::tetris::LayerEnum_LayerType LayerEnum::type() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.LayerEnum.type)
  return _internal_type();
}
inline void LayerEnum::_internal_set_type(::vlsir::tetris::LayerEnum_LayerType value) {
  
  type_ = value;
}
inline void LayerEnum::set_type(::vlsir::tetris::LayerEnum_LayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.LayerEnum.type)
}

// int64 index = 2;
inline void LayerEnum::clear_index() {
  index_ = int64_t{0};
}
inline int64_t LayerEnum::_internal_index() const {
  return index_;
}
inline int64_t LayerEnum::index() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.LayerEnum.index)
  return _internal_index();
}
inline void LayerEnum::_internal_set_index(int64_t value) {
  
  index_ = value;
}
inline void LayerEnum::set_index(int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.LayerEnum.index)
}

// -------------------------------------------------------------------

// MetalLayer

// string name = 1;
inline void MetalLayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MetalLayer::name() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetalLayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.name)
}
inline std::string* MetalLayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.MetalLayer.name)
  return _s;
}
inline const std::string& MetalLayer::_internal_name() const {
  return name_.Get();
}
inline void MetalLayer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetalLayer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetalLayer::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.MetalLayer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetalLayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.MetalLayer.name)
}

// .vlsir.tetris.MetalLayer.Dir dir = 2;
inline void MetalLayer::clear_dir() {
  dir_ = 0;
}
inline ::vlsir::tetris::MetalLayer_Dir MetalLayer::_internal_dir() const {
  return static_cast< ::vlsir::tetris::MetalLayer_Dir >(dir_);
}
inline ::vlsir::tetris::MetalLayer_Dir MetalLayer::dir() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.dir)
  return _internal_dir();
}
inline void MetalLayer::_internal_set_dir(::vlsir::tetris::MetalLayer_Dir value) {
  
  dir_ = value;
}
inline void MetalLayer::set_dir(::vlsir::tetris::MetalLayer_Dir value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.dir)
}

// int64 cutsize = 3;
inline void MetalLayer::clear_cutsize() {
  cutsize_ = int64_t{0};
}
inline int64_t MetalLayer::_internal_cutsize() const {
  return cutsize_;
}
inline int64_t MetalLayer::cutsize() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.cutsize)
  return _internal_cutsize();
}
inline void MetalLayer::_internal_set_cutsize(int64_t value) {
  
  cutsize_ = value;
}
inline void MetalLayer::set_cutsize(int64_t value) {
  _internal_set_cutsize(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.cutsize)
}

// repeated .vlsir.tetris.TrackSpec entries = 4;
inline int MetalLayer::_internal_entries_size() const {
  return entries_.size();
}
inline int MetalLayer::entries_size() const {
  return _internal_entries_size();
}
inline void MetalLayer::clear_entries() {
  entries_.Clear();
}
inline ::vlsir::tetris::TrackSpec* MetalLayer::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.MetalLayer.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec >*
MetalLayer::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.MetalLayer.entries)
  return &entries_;
}
inline const ::vlsir::tetris::TrackSpec& MetalLayer::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::vlsir::tetris::TrackSpec& MetalLayer::entries(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.entries)
  return _internal_entries(index);
}
inline ::vlsir::tetris::TrackSpec* MetalLayer::_internal_add_entries() {
  return entries_.Add();
}
inline ::vlsir::tetris::TrackSpec* MetalLayer::add_entries() {
  ::vlsir::tetris::TrackSpec* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:vlsir.tetris.MetalLayer.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec >&
MetalLayer::entries() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.MetalLayer.entries)
  return entries_;
}

// int64 offset = 5;
inline void MetalLayer::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t MetalLayer::_internal_offset() const {
  return offset_;
}
inline int64_t MetalLayer::offset() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.offset)
  return _internal_offset();
}
inline void MetalLayer::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void MetalLayer::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.offset)
}

// int64 overlap = 6;
inline void MetalLayer::clear_overlap() {
  overlap_ = int64_t{0};
}
inline int64_t MetalLayer::_internal_overlap() const {
  return overlap_;
}
inline int64_t MetalLayer::overlap() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.overlap)
  return _internal_overlap();
}
inline void MetalLayer::_internal_set_overlap(int64_t value) {
  
  overlap_ = value;
}
inline void MetalLayer::set_overlap(int64_t value) {
  _internal_set_overlap(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.overlap)
}

// bool flip = 7;
inline void MetalLayer::clear_flip() {
  flip_ = false;
}
inline bool MetalLayer::_internal_flip() const {
  return flip_;
}
inline bool MetalLayer::flip() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.flip)
  return _internal_flip();
}
inline void MetalLayer::_internal_set_flip(bool value) {
  
  flip_ = value;
}
inline void MetalLayer::set_flip(bool value) {
  _internal_set_flip(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.flip)
}

// .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
inline void MetalLayer::clear_prim() {
  prim_ = 0;
}
inline ::vlsir::tetris::MetalLayer_PrimitiveMode MetalLayer::_internal_prim() const {
  return static_cast< ::vlsir::tetris::MetalLayer_PrimitiveMode >(prim_);
}
inline ::vlsir::tetris::MetalLayer_PrimitiveMode MetalLayer::prim() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.prim)
  return _internal_prim();
}
inline void MetalLayer::_internal_set_prim(::vlsir::tetris::MetalLayer_PrimitiveMode value) {
  
  prim_ = value;
}
inline void MetalLayer::set_prim(::vlsir::tetris::MetalLayer_PrimitiveMode value) {
  _internal_set_prim(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.MetalLayer.prim)
}

// .vlsir.raw.Layer raw = 11;
inline bool MetalLayer::_internal_has_raw() const {
  return this != internal_default_instance() && raw_ != nullptr;
}
inline bool MetalLayer::has_raw() const {
  return _internal_has_raw();
}
inline const ::vlsir::raw::Layer& MetalLayer::_internal_raw() const {
  const ::vlsir::raw::Layer* p = raw_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Layer&>(
      ::vlsir::raw::_Layer_default_instance_);
}
inline const ::vlsir::raw::Layer& MetalLayer::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.MetalLayer.raw)
  return _internal_raw();
}
inline void MetalLayer::unsafe_arena_set_allocated_raw(
    ::vlsir::raw::Layer* raw) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_);
  }
  raw_ = raw;
  if (raw) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.MetalLayer.raw)
}
inline ::vlsir::raw::Layer* MetalLayer::release_raw() {
  
  ::vlsir::raw::Layer* temp = raw_;
  raw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Layer* MetalLayer::unsafe_arena_release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.MetalLayer.raw)
  
  ::vlsir::raw::Layer* temp = raw_;
  raw_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layer* MetalLayer::_internal_mutable_raw() {
  
  if (raw_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layer>(GetArenaForAllocation());
    raw_ = p;
  }
  return raw_;
}
inline ::vlsir::raw::Layer* MetalLayer::mutable_raw() {
  ::vlsir::raw::Layer* _msg = _internal_mutable_raw();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.MetalLayer.raw)
  return _msg;
}
inline void MetalLayer::set_allocated_raw(::vlsir::raw::Layer* raw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_);
  }
  if (raw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw));
    if (message_arena != submessage_arena) {
      raw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw, submessage_arena);
    }
    
  } else {
    
  }
  raw_ = raw;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.MetalLayer.raw)
}

// -------------------------------------------------------------------

// ViaLayer

// string name = 1;
inline void ViaLayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ViaLayer::name() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.ViaLayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViaLayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.tetris.ViaLayer.name)
}
inline std::string* ViaLayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.ViaLayer.name)
  return _s;
}
inline const std::string& ViaLayer::_internal_name() const {
  return name_.Get();
}
inline void ViaLayer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ViaLayer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ViaLayer::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.ViaLayer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ViaLayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.ViaLayer.name)
}

// .vlsir.tetris.LayerEnum top = 2;
inline bool ViaLayer::_internal_has_top() const {
  return this != internal_default_instance() && top_ != nullptr;
}
inline bool ViaLayer::has_top() const {
  return _internal_has_top();
}
inline void ViaLayer::clear_top() {
  if (GetArenaForAllocation() == nullptr && top_ != nullptr) {
    delete top_;
  }
  top_ = nullptr;
}
inline const ::vlsir::tetris::LayerEnum& ViaLayer::_internal_top() const {
  const ::vlsir::tetris::LayerEnum* p = top_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::LayerEnum&>(
      ::vlsir::tetris::_LayerEnum_default_instance_);
}
inline const ::vlsir::tetris::LayerEnum& ViaLayer::top() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.ViaLayer.top)
  return _internal_top();
}
inline void ViaLayer::unsafe_arena_set_allocated_top(
    ::vlsir::tetris::LayerEnum* top) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_);
  }
  top_ = top;
  if (top) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.ViaLayer.top)
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::release_top() {
  
  ::vlsir::tetris::LayerEnum* temp = top_;
  top_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::unsafe_arena_release_top() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.ViaLayer.top)
  
  ::vlsir::tetris::LayerEnum* temp = top_;
  top_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::_internal_mutable_top() {
  
  if (top_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::LayerEnum>(GetArenaForAllocation());
    top_ = p;
  }
  return top_;
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::mutable_top() {
  ::vlsir::tetris::LayerEnum* _msg = _internal_mutable_top();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.ViaLayer.top)
  return _msg;
}
inline void ViaLayer::set_allocated_top(::vlsir::tetris::LayerEnum* top) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete top_;
  }
  if (top) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::LayerEnum>::GetOwningArena(top);
    if (message_arena != submessage_arena) {
      top = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top, submessage_arena);
    }
    
  } else {
    
  }
  top_ = top;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.ViaLayer.top)
}

// .vlsir.tetris.LayerEnum bot = 3;
inline bool ViaLayer::_internal_has_bot() const {
  return this != internal_default_instance() && bot_ != nullptr;
}
inline bool ViaLayer::has_bot() const {
  return _internal_has_bot();
}
inline void ViaLayer::clear_bot() {
  if (GetArenaForAllocation() == nullptr && bot_ != nullptr) {
    delete bot_;
  }
  bot_ = nullptr;
}
inline const ::vlsir::tetris::LayerEnum& ViaLayer::_internal_bot() const {
  const ::vlsir::tetris::LayerEnum* p = bot_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::LayerEnum&>(
      ::vlsir::tetris::_LayerEnum_default_instance_);
}
inline const ::vlsir::tetris::LayerEnum& ViaLayer::bot() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.ViaLayer.bot)
  return _internal_bot();
}
inline void ViaLayer::unsafe_arena_set_allocated_bot(
    ::vlsir::tetris::LayerEnum* bot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bot_);
  }
  bot_ = bot;
  if (bot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.ViaLayer.bot)
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::release_bot() {
  
  ::vlsir::tetris::LayerEnum* temp = bot_;
  bot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::unsafe_arena_release_bot() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.ViaLayer.bot)
  
  ::vlsir::tetris::LayerEnum* temp = bot_;
  bot_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::_internal_mutable_bot() {
  
  if (bot_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::LayerEnum>(GetArenaForAllocation());
    bot_ = p;
  }
  return bot_;
}
inline ::vlsir::tetris::LayerEnum* ViaLayer::mutable_bot() {
  ::vlsir::tetris::LayerEnum* _msg = _internal_mutable_bot();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.ViaLayer.bot)
  return _msg;
}
inline void ViaLayer::set_allocated_bot(::vlsir::tetris::LayerEnum* bot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bot_;
  }
  if (bot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::LayerEnum>::GetOwningArena(bot);
    if (message_arena != submessage_arena) {
      bot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bot, submessage_arena);
    }
    
  } else {
    
  }
  bot_ = bot;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.ViaLayer.bot)
}

// .vlsir.tetris.Xy size = 4;
inline bool ViaLayer::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool ViaLayer::has_size() const {
  return _internal_has_size();
}
inline void ViaLayer::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::vlsir::tetris::Xy& ViaLayer::_internal_size() const {
  const ::vlsir::tetris::Xy* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Xy&>(
      ::vlsir::tetris::_Xy_default_instance_);
}
inline const ::vlsir::tetris::Xy& ViaLayer::size() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.ViaLayer.size)
  return _internal_size();
}
inline void ViaLayer::unsafe_arena_set_allocated_size(
    ::vlsir::tetris::Xy* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.ViaLayer.size)
}
inline ::vlsir::tetris::Xy* ViaLayer::release_size() {
  
  ::vlsir::tetris::Xy* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Xy* ViaLayer::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.ViaLayer.size)
  
  ::vlsir::tetris::Xy* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Xy* ViaLayer::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Xy>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::vlsir::tetris::Xy* ViaLayer::mutable_size() {
  ::vlsir::tetris::Xy* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.ViaLayer.size)
  return _msg;
}
inline void ViaLayer::set_allocated_size(::vlsir::tetris::Xy* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Xy>::GetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.ViaLayer.size)
}

// .vlsir.raw.Layer raw = 11;
inline bool ViaLayer::_internal_has_raw() const {
  return this != internal_default_instance() && raw_ != nullptr;
}
inline bool ViaLayer::has_raw() const {
  return _internal_has_raw();
}
inline const ::vlsir::raw::Layer& ViaLayer::_internal_raw() const {
  const ::vlsir::raw::Layer* p = raw_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Layer&>(
      ::vlsir::raw::_Layer_default_instance_);
}
inline const ::vlsir::raw::Layer& ViaLayer::raw() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.ViaLayer.raw)
  return _internal_raw();
}
inline void ViaLayer::unsafe_arena_set_allocated_raw(
    ::vlsir::raw::Layer* raw) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_);
  }
  raw_ = raw;
  if (raw) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.ViaLayer.raw)
}
inline ::vlsir::raw::Layer* ViaLayer::release_raw() {
  
  ::vlsir::raw::Layer* temp = raw_;
  raw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Layer* ViaLayer::unsafe_arena_release_raw() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.ViaLayer.raw)
  
  ::vlsir::raw::Layer* temp = raw_;
  raw_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layer* ViaLayer::_internal_mutable_raw() {
  
  if (raw_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layer>(GetArenaForAllocation());
    raw_ = p;
  }
  return raw_;
}
inline ::vlsir::raw::Layer* ViaLayer::mutable_raw() {
  ::vlsir::raw::Layer* _msg = _internal_mutable_raw();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.ViaLayer.raw)
  return _msg;
}
inline void ViaLayer::set_allocated_raw(::vlsir::raw::Layer* raw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_);
  }
  if (raw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw));
    if (message_arena != submessage_arena) {
      raw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw, submessage_arena);
    }
    
  } else {
    
  }
  raw_ = raw;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.ViaLayer.raw)
}

// -------------------------------------------------------------------

// PrimitiveLayer

// .vlsir.tetris.Xy pitches = 1;
inline bool PrimitiveLayer::_internal_has_pitches() const {
  return this != internal_default_instance() && pitches_ != nullptr;
}
inline bool PrimitiveLayer::has_pitches() const {
  return _internal_has_pitches();
}
inline void PrimitiveLayer::clear_pitches() {
  if (GetArenaForAllocation() == nullptr && pitches_ != nullptr) {
    delete pitches_;
  }
  pitches_ = nullptr;
}
inline const ::vlsir::tetris::Xy& PrimitiveLayer::_internal_pitches() const {
  const ::vlsir::tetris::Xy* p = pitches_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::tetris::Xy&>(
      ::vlsir::tetris::_Xy_default_instance_);
}
inline const ::vlsir::tetris::Xy& PrimitiveLayer::pitches() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.PrimitiveLayer.pitches)
  return _internal_pitches();
}
inline void PrimitiveLayer::unsafe_arena_set_allocated_pitches(
    ::vlsir::tetris::Xy* pitches) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pitches_);
  }
  pitches_ = pitches;
  if (pitches) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.PrimitiveLayer.pitches)
}
inline ::vlsir::tetris::Xy* PrimitiveLayer::release_pitches() {
  
  ::vlsir::tetris::Xy* temp = pitches_;
  pitches_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::tetris::Xy* PrimitiveLayer::unsafe_arena_release_pitches() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.PrimitiveLayer.pitches)
  
  ::vlsir::tetris::Xy* temp = pitches_;
  pitches_ = nullptr;
  return temp;
}
inline ::vlsir::tetris::Xy* PrimitiveLayer::_internal_mutable_pitches() {
  
  if (pitches_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::tetris::Xy>(GetArenaForAllocation());
    pitches_ = p;
  }
  return pitches_;
}
inline ::vlsir::tetris::Xy* PrimitiveLayer::mutable_pitches() {
  ::vlsir::tetris::Xy* _msg = _internal_mutable_pitches();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.PrimitiveLayer.pitches)
  return _msg;
}
inline void PrimitiveLayer::set_allocated_pitches(::vlsir::tetris::Xy* pitches) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pitches_;
  }
  if (pitches) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::Xy>::GetOwningArena(pitches);
    if (message_arena != submessage_arena) {
      pitches = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pitches, submessage_arena);
    }
    
  } else {
    
  }
  pitches_ = pitches;
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.PrimitiveLayer.pitches)
}

// -------------------------------------------------------------------

// TrackSpec_TrackEntry

// .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
inline void TrackSpec_TrackEntry::clear_ttype() {
  ttype_ = 0;
}
inline ::vlsir::tetris::TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::_internal_ttype() const {
  return static_cast< ::vlsir::tetris::TrackSpec_TrackEntry_TrackType >(ttype_);
}
inline ::vlsir::tetris::TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::ttype() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackSpec.TrackEntry.ttype)
  return _internal_ttype();
}
inline void TrackSpec_TrackEntry::_internal_set_ttype(::vlsir::tetris::TrackSpec_TrackEntry_TrackType value) {
  
  ttype_ = value;
}
inline void TrackSpec_TrackEntry::set_ttype(::vlsir::tetris::TrackSpec_TrackEntry_TrackType value) {
  _internal_set_ttype(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.TrackSpec.TrackEntry.ttype)
}

// int64 width = 2;
inline void TrackSpec_TrackEntry::clear_width() {
  width_ = int64_t{0};
}
inline int64_t TrackSpec_TrackEntry::_internal_width() const {
  return width_;
}
inline int64_t TrackSpec_TrackEntry::width() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackSpec.TrackEntry.width)
  return _internal_width();
}
inline void TrackSpec_TrackEntry::_internal_set_width(int64_t value) {
  
  width_ = value;
}
inline void TrackSpec_TrackEntry::set_width(int64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.TrackSpec.TrackEntry.width)
}

// -------------------------------------------------------------------

// TrackSpec_Repeat

// repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
inline int TrackSpec_Repeat::_internal_entries_size() const {
  return entries_.size();
}
inline int TrackSpec_Repeat::entries_size() const {
  return _internal_entries_size();
}
inline void TrackSpec_Repeat::clear_entries() {
  entries_.Clear();
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec_Repeat::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.TrackSpec.Repeat.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec_TrackEntry >*
TrackSpec_Repeat::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.tetris.TrackSpec.Repeat.entries)
  return &entries_;
}
inline const ::vlsir::tetris::TrackSpec_TrackEntry& TrackSpec_Repeat::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::vlsir::tetris::TrackSpec_TrackEntry& TrackSpec_Repeat::entries(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackSpec.Repeat.entries)
  return _internal_entries(index);
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec_Repeat::_internal_add_entries() {
  return entries_.Add();
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec_Repeat::add_entries() {
  ::vlsir::tetris::TrackSpec_TrackEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:vlsir.tetris.TrackSpec.Repeat.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::tetris::TrackSpec_TrackEntry >&
TrackSpec_Repeat::entries() const {
  // @@protoc_insertion_point(field_list:vlsir.tetris.TrackSpec.Repeat.entries)
  return entries_;
}

// int64 nrep = 2;
inline void TrackSpec_Repeat::clear_nrep() {
  nrep_ = int64_t{0};
}
inline int64_t TrackSpec_Repeat::_internal_nrep() const {
  return nrep_;
}
inline int64_t TrackSpec_Repeat::nrep() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackSpec.Repeat.nrep)
  return _internal_nrep();
}
inline void TrackSpec_Repeat::_internal_set_nrep(int64_t value) {
  
  nrep_ = value;
}
inline void TrackSpec_Repeat::set_nrep(int64_t value) {
  _internal_set_nrep(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.TrackSpec.Repeat.nrep)
}

// -------------------------------------------------------------------

// TrackSpec

// .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
inline bool TrackSpec::_internal_has_entry() const {
  return spec_case() == kEntry;
}
inline bool TrackSpec::has_entry() const {
  return _internal_has_entry();
}
inline void TrackSpec::set_has_entry() {
  _oneof_case_[0] = kEntry;
}
inline void TrackSpec::clear_entry() {
  if (_internal_has_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete spec_.entry_;
    }
    clear_has_spec();
  }
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec::release_entry() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.TrackSpec.entry)
  if (_internal_has_entry()) {
    clear_has_spec();
      ::vlsir::tetris::TrackSpec_TrackEntry* temp = spec_.entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    spec_.entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::tetris::TrackSpec_TrackEntry& TrackSpec::_internal_entry() const {
  return _internal_has_entry()
      ? *spec_.entry_
      : reinterpret_cast< ::vlsir::tetris::TrackSpec_TrackEntry&>(::vlsir::tetris::_TrackSpec_TrackEntry_default_instance_);
}
inline const ::vlsir::tetris::TrackSpec_TrackEntry& TrackSpec::entry() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackSpec.entry)
  return _internal_entry();
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.TrackSpec.entry)
  if (_internal_has_entry()) {
    clear_has_spec();
    ::vlsir::tetris::TrackSpec_TrackEntry* temp = spec_.entry_;
    spec_.entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackSpec::unsafe_arena_set_allocated_entry(::vlsir::tetris::TrackSpec_TrackEntry* entry) {
  clear_spec();
  if (entry) {
    set_has_entry();
    spec_.entry_ = entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.TrackSpec.entry)
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec::_internal_mutable_entry() {
  if (!_internal_has_entry()) {
    clear_spec();
    set_has_entry();
    spec_.entry_ = CreateMaybeMessage< ::vlsir::tetris::TrackSpec_TrackEntry >(GetArenaForAllocation());
  }
  return spec_.entry_;
}
inline ::vlsir::tetris::TrackSpec_TrackEntry* TrackSpec::mutable_entry() {
  ::vlsir::tetris::TrackSpec_TrackEntry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.TrackSpec.entry)
  return _msg;
}

// .vlsir.tetris.TrackSpec.Repeat repeat = 2;
inline bool TrackSpec::_internal_has_repeat() const {
  return spec_case() == kRepeat;
}
inline bool TrackSpec::has_repeat() const {
  return _internal_has_repeat();
}
inline void TrackSpec::set_has_repeat() {
  _oneof_case_[0] = kRepeat;
}
inline void TrackSpec::clear_repeat() {
  if (_internal_has_repeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete spec_.repeat_;
    }
    clear_has_spec();
  }
}
inline ::vlsir::tetris::TrackSpec_Repeat* TrackSpec::release_repeat() {
  // @@protoc_insertion_point(field_release:vlsir.tetris.TrackSpec.repeat)
  if (_internal_has_repeat()) {
    clear_has_spec();
      ::vlsir::tetris::TrackSpec_Repeat* temp = spec_.repeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    spec_.repeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::tetris::TrackSpec_Repeat& TrackSpec::_internal_repeat() const {
  return _internal_has_repeat()
      ? *spec_.repeat_
      : reinterpret_cast< ::vlsir::tetris::TrackSpec_Repeat&>(::vlsir::tetris::_TrackSpec_Repeat_default_instance_);
}
inline const ::vlsir::tetris::TrackSpec_Repeat& TrackSpec::repeat() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.TrackSpec.repeat)
  return _internal_repeat();
}
inline ::vlsir::tetris::TrackSpec_Repeat* TrackSpec::unsafe_arena_release_repeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.tetris.TrackSpec.repeat)
  if (_internal_has_repeat()) {
    clear_has_spec();
    ::vlsir::tetris::TrackSpec_Repeat* temp = spec_.repeat_;
    spec_.repeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackSpec::unsafe_arena_set_allocated_repeat(::vlsir::tetris::TrackSpec_Repeat* repeat) {
  clear_spec();
  if (repeat) {
    set_has_repeat();
    spec_.repeat_ = repeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.tetris.TrackSpec.repeat)
}
inline ::vlsir::tetris::TrackSpec_Repeat* TrackSpec::_internal_mutable_repeat() {
  if (!_internal_has_repeat()) {
    clear_spec();
    set_has_repeat();
    spec_.repeat_ = CreateMaybeMessage< ::vlsir::tetris::TrackSpec_Repeat >(GetArenaForAllocation());
  }
  return spec_.repeat_;
}
inline ::vlsir::tetris::TrackSpec_Repeat* TrackSpec::mutable_repeat() {
  ::vlsir::tetris::TrackSpec_Repeat* _msg = _internal_mutable_repeat();
  // @@protoc_insertion_point(field_mutable:vlsir.tetris.TrackSpec.repeat)
  return _msg;
}

inline bool TrackSpec::has_spec() const {
  return spec_case() != SPEC_NOT_SET;
}
inline void TrackSpec::clear_has_spec() {
  _oneof_case_[0] = SPEC_NOT_SET;
}
inline TrackSpec::SpecCase TrackSpec::spec_case() const {
  return TrackSpec::SpecCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Xy

// int64 x = 1;
inline void Xy::clear_x() {
  x_ = int64_t{0};
}
inline int64_t Xy::_internal_x() const {
  return x_;
}
inline int64_t Xy::x() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Xy.x)
  return _internal_x();
}
inline void Xy::_internal_set_x(int64_t value) {
  
  x_ = value;
}
inline void Xy::set_x(int64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Xy.x)
}

// int64 y = 2;
inline void Xy::clear_y() {
  y_ = int64_t{0};
}
inline int64_t Xy::_internal_y() const {
  return y_;
}
inline int64_t Xy::y() const {
  // @@protoc_insertion_point(field_get:vlsir.tetris.Xy.y)
  return _internal_y();
}
inline void Xy::_internal_set_y(int64_t value) {
  
  y_ = value;
}
inline void Xy::set_y(int64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vlsir.tetris.Xy.y)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tetris
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::tetris::AbstractPort_PortSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::tetris::AbstractPort_PortSide>() {
  return ::vlsir::tetris::AbstractPort_PortSide_descriptor();
}
template <> struct is_proto_enum< ::vlsir::tetris::LayerEnum_LayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::tetris::LayerEnum_LayerType>() {
  return ::vlsir::tetris::LayerEnum_LayerType_descriptor();
}
template <> struct is_proto_enum< ::vlsir::tetris::MetalLayer_Dir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::tetris::MetalLayer_Dir>() {
  return ::vlsir::tetris::MetalLayer_Dir_descriptor();
}
template <> struct is_proto_enum< ::vlsir::tetris::MetalLayer_PrimitiveMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::tetris::MetalLayer_PrimitiveMode>() {
  return ::vlsir::tetris::MetalLayer_PrimitiveMode_descriptor();
}
template <> struct is_proto_enum< ::vlsir::tetris::TrackSpec_TrackEntry_TrackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::tetris::TrackSpec_TrackEntry_TrackType>() {
  return ::vlsir::tetris::TrackSpec_TrackEntry_TrackType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_layout_2ftetris_2eproto
