// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layout/tetris.proto

#include "layout/tetris.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace vlsir {
namespace tetris {
constexpr Library::Library(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cells_()
  , domain_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , author_(nullptr){}
struct LibraryDefaultTypeInternal {
  constexpr LibraryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LibraryDefaultTypeInternal() {}
  union {
    Library _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LibraryDefaultTypeInternal _Library_default_instance_;
constexpr Cell::Cell(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , interface_(nullptr)
  , module_(nullptr)
  , abstract_(nullptr)
  , layout_(nullptr){}
struct CellDefaultTypeInternal {
  constexpr CellDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CellDefaultTypeInternal() {}
  union {
    Cell _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CellDefaultTypeInternal _Cell_default_instance_;
constexpr Layout::Layout(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : instances_()
  , assignments_()
  , cuts_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , outline_(nullptr){}
struct LayoutDefaultTypeInternal {
  constexpr LayoutDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LayoutDefaultTypeInternal() {}
  union {
    Layout _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LayoutDefaultTypeInternal _Layout_default_instance_;
constexpr Assign::Assign(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : net_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , at_(nullptr){}
struct AssignDefaultTypeInternal {
  constexpr AssignDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AssignDefaultTypeInternal() {}
  union {
    Assign _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AssignDefaultTypeInternal _Assign_default_instance_;
constexpr TrackCross::TrackCross(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : track_(nullptr)
  , cross_(nullptr){}
struct TrackCrossDefaultTypeInternal {
  constexpr TrackCrossDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TrackCrossDefaultTypeInternal() {}
  union {
    TrackCross _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TrackCrossDefaultTypeInternal _TrackCross_default_instance_;
constexpr TrackRef::TrackRef(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : layer_(int64_t{0})
  , track_(int64_t{0}){}
struct TrackRefDefaultTypeInternal {
  constexpr TrackRefDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TrackRefDefaultTypeInternal() {}
  union {
    TrackRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TrackRefDefaultTypeInternal _TrackRef_default_instance_;
constexpr Outline::Outline(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_()
  , _x_cached_byte_size_(0)
  , y_()
  , _y_cached_byte_size_(0)
  , metals_(int64_t{0}){}
struct OutlineDefaultTypeInternal {
  constexpr OutlineDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OutlineDefaultTypeInternal() {}
  union {
    Outline _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OutlineDefaultTypeInternal _Outline_default_instance_;
constexpr Abstract::Abstract(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ports_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , outline_(nullptr){}
struct AbstractDefaultTypeInternal {
  constexpr AbstractDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AbstractDefaultTypeInternal() {}
  union {
    Abstract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AbstractDefaultTypeInternal _Abstract_default_instance_;
constexpr AbstractPort_EdgePort::AbstractPort_EdgePort(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : track_(nullptr)
  , side_(0)
{}
struct AbstractPort_EdgePortDefaultTypeInternal {
  constexpr AbstractPort_EdgePortDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AbstractPort_EdgePortDefaultTypeInternal() {}
  union {
    AbstractPort_EdgePort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AbstractPort_EdgePortDefaultTypeInternal _AbstractPort_EdgePort_default_instance_;
constexpr AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : into_(nullptr)
  , track_(int64_t{0})
  , side_(0)
{}
struct AbstractPort_ZTopEdgePortDefaultTypeInternal {
  constexpr AbstractPort_ZTopEdgePortDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AbstractPort_ZTopEdgePortDefaultTypeInternal() {}
  union {
    AbstractPort_ZTopEdgePort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AbstractPort_ZTopEdgePortDefaultTypeInternal _AbstractPort_ZTopEdgePort_default_instance_;
constexpr AbstractPort_ZTopInner::AbstractPort_ZTopInner(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : locs_(){}
struct AbstractPort_ZTopInnerDefaultTypeInternal {
  constexpr AbstractPort_ZTopInnerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AbstractPort_ZTopInnerDefaultTypeInternal() {}
  union {
    AbstractPort_ZTopInner _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AbstractPort_ZTopInnerDefaultTypeInternal _AbstractPort_ZTopInner_default_instance_;
constexpr AbstractPort::AbstractPort(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : net_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , _oneof_case_{}{}
struct AbstractPortDefaultTypeInternal {
  constexpr AbstractPortDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AbstractPortDefaultTypeInternal() {}
  union {
    AbstractPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AbstractPortDefaultTypeInternal _AbstractPort_default_instance_;
constexpr Instance::Instance(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cell_(nullptr)
  , loc_(nullptr)
  , reflect_horiz_(false)
  , reflect_vert_(false){}
struct InstanceDefaultTypeInternal {
  constexpr InstanceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InstanceDefaultTypeInternal() {}
  union {
    Instance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InstanceDefaultTypeInternal _Instance_default_instance_;
constexpr Place::Place(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct PlaceDefaultTypeInternal {
  constexpr PlaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlaceDefaultTypeInternal() {}
  union {
    Place _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlaceDefaultTypeInternal _Place_default_instance_;
constexpr RelPlace::RelPlace(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct RelPlaceDefaultTypeInternal {
  constexpr RelPlaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RelPlaceDefaultTypeInternal() {}
  union {
    RelPlace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RelPlaceDefaultTypeInternal _RelPlace_default_instance_;
constexpr Stack::Stack(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : metals_()
  , vias_()
  , prim_(nullptr)
  , boundary_layer_(nullptr)
  , units_(0)
{}
struct StackDefaultTypeInternal {
  constexpr StackDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StackDefaultTypeInternal() {}
  union {
    Stack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StackDefaultTypeInternal _Stack_default_instance_;
constexpr LayerEnum::LayerEnum(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : index_(int64_t{0})
  , type_(0)
{}
struct LayerEnumDefaultTypeInternal {
  constexpr LayerEnumDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LayerEnumDefaultTypeInternal() {}
  union {
    LayerEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LayerEnumDefaultTypeInternal _LayerEnum_default_instance_;
constexpr MetalLayer::MetalLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , raw_(nullptr)
  , cutsize_(int64_t{0})
  , dir_(0)

  , flip_(false)
  , offset_(int64_t{0})
  , overlap_(int64_t{0})
  , prim_(0)
{}
struct MetalLayerDefaultTypeInternal {
  constexpr MetalLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MetalLayerDefaultTypeInternal() {}
  union {
    MetalLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MetalLayerDefaultTypeInternal _MetalLayer_default_instance_;
constexpr ViaLayer::ViaLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , top_(nullptr)
  , bot_(nullptr)
  , size_(nullptr)
  , raw_(nullptr){}
struct ViaLayerDefaultTypeInternal {
  constexpr ViaLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ViaLayerDefaultTypeInternal() {}
  union {
    ViaLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ViaLayerDefaultTypeInternal _ViaLayer_default_instance_;
constexpr PrimitiveLayer::PrimitiveLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pitches_(nullptr){}
struct PrimitiveLayerDefaultTypeInternal {
  constexpr PrimitiveLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PrimitiveLayerDefaultTypeInternal() {}
  union {
    PrimitiveLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PrimitiveLayerDefaultTypeInternal _PrimitiveLayer_default_instance_;
constexpr TrackSpec_TrackEntry::TrackSpec_TrackEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(int64_t{0})
  , ttype_(0)
{}
struct TrackSpec_TrackEntryDefaultTypeInternal {
  constexpr TrackSpec_TrackEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TrackSpec_TrackEntryDefaultTypeInternal() {}
  union {
    TrackSpec_TrackEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TrackSpec_TrackEntryDefaultTypeInternal _TrackSpec_TrackEntry_default_instance_;
constexpr TrackSpec_Repeat::TrackSpec_Repeat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_()
  , nrep_(int64_t{0}){}
struct TrackSpec_RepeatDefaultTypeInternal {
  constexpr TrackSpec_RepeatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TrackSpec_RepeatDefaultTypeInternal() {}
  union {
    TrackSpec_Repeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TrackSpec_RepeatDefaultTypeInternal _TrackSpec_Repeat_default_instance_;
constexpr TrackSpec::TrackSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct TrackSpecDefaultTypeInternal {
  constexpr TrackSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TrackSpecDefaultTypeInternal() {}
  union {
    TrackSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TrackSpecDefaultTypeInternal _TrackSpec_default_instance_;
constexpr Xy::Xy(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(int64_t{0})
  , y_(int64_t{0}){}
struct XyDefaultTypeInternal {
  constexpr XyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~XyDefaultTypeInternal() {}
  union {
    Xy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT XyDefaultTypeInternal _Xy_default_instance_;
}  // namespace tetris
}  // namespace vlsir
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_layout_2ftetris_2eproto[24];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_layout_2ftetris_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_layout_2ftetris_2eproto = nullptr;

const uint32_t TableStruct_layout_2ftetris_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, domain_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, cells_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, author_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, interface_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, module_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, abstract_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, layout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, outline_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, instances_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, assignments_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, cuts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, net_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, cross_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, layer_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, track_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, x_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, y_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, metals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, outline_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, ports_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, side_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, side_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, into_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopInner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopInner, locs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, net_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, kind_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, cell_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, loc_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, reflect_horiz_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, reflect_vert_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, place_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::RelPlace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, units_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, prim_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, metals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, vias_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, boundary_layer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, type_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, dir_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, cutsize_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, entries_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, offset_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, overlap_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, flip_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, prim_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, raw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, top_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, bot_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, size_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, raw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::PrimitiveLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::PrimitiveLayer, pitches_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, ttype_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, entries_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, nrep_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, spec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, x_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, y_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vlsir::tetris::Library)},
  { 9, -1, -1, sizeof(::vlsir::tetris::Cell)},
  { 20, -1, -1, sizeof(::vlsir::tetris::Layout)},
  { 31, -1, -1, sizeof(::vlsir::tetris::Assign)},
  { 39, -1, -1, sizeof(::vlsir::tetris::TrackCross)},
  { 47, -1, -1, sizeof(::vlsir::tetris::TrackRef)},
  { 55, -1, -1, sizeof(::vlsir::tetris::Outline)},
  { 64, -1, -1, sizeof(::vlsir::tetris::Abstract)},
  { 73, -1, -1, sizeof(::vlsir::tetris::AbstractPort_EdgePort)},
  { 81, -1, -1, sizeof(::vlsir::tetris::AbstractPort_ZTopEdgePort)},
  { 90, -1, -1, sizeof(::vlsir::tetris::AbstractPort_ZTopInner)},
  { 97, -1, -1, sizeof(::vlsir::tetris::AbstractPort)},
  { 108, -1, -1, sizeof(::vlsir::tetris::Instance)},
  { 119, -1, -1, sizeof(::vlsir::tetris::Place)},
  { 128, -1, -1, sizeof(::vlsir::tetris::RelPlace)},
  { 134, -1, -1, sizeof(::vlsir::tetris::Stack)},
  { 145, -1, -1, sizeof(::vlsir::tetris::LayerEnum)},
  { 153, -1, -1, sizeof(::vlsir::tetris::MetalLayer)},
  { 168, -1, -1, sizeof(::vlsir::tetris::ViaLayer)},
  { 179, -1, -1, sizeof(::vlsir::tetris::PrimitiveLayer)},
  { 186, -1, -1, sizeof(::vlsir::tetris::TrackSpec_TrackEntry)},
  { 194, -1, -1, sizeof(::vlsir::tetris::TrackSpec_Repeat)},
  { 202, -1, -1, sizeof(::vlsir::tetris::TrackSpec)},
  { 211, -1, -1, sizeof(::vlsir::tetris::Xy)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Library_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Cell_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Layout_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Assign_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackCross_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackRef_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Outline_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Abstract_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_EdgePort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_ZTopEdgePort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_ZTopInner_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Instance_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Place_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_RelPlace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Stack_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_LayerEnum_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_MetalLayer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_ViaLayer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_PrimitiveLayer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackSpec_TrackEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackSpec_Repeat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Xy_default_instance_),
};

const char descriptor_table_protodef_layout_2ftetris_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023layout/tetris.proto\022\014vlsir.tetris\032\013uti"
  "ls.proto\032\020layout/raw.proto\032\rcircuit.prot"
  "o\"i\n\007Library\022\016\n\006domain\030\001 \001(\t\022!\n\005cells\030\n "
  "\003(\0132\022.vlsir.tetris.Cell\022+\n\006author\030\024 \001(\0132"
  "\033.vlsir.utils.AuthorMetadata\"\270\001\n\004Cell\022\014\n"
  "\004name\030\001 \001(\t\022+\n\tinterface\030\n \001(\0132\030.vlsir.c"
  "ircuit.Interface\022%\n\006module\030\013 \001(\0132\025.vlsir"
  ".circuit.Module\022(\n\010abstract\030\014 \001(\0132\026.vlsi"
  "r.tetris.Abstract\022$\n\006layout\030\r \001(\0132\024.vlsi"
  "r.tetris.Layout\"\274\001\n\006Layout\022\014\n\004name\030\001 \001(\t"
  "\022&\n\007outline\030\n \001(\0132\025.vlsir.tetris.Outline"
  "\022)\n\tinstances\030\024 \003(\0132\026.vlsir.tetris.Insta"
  "nce\022)\n\013assignments\030\025 \003(\0132\024.vlsir.tetris."
  "Assign\022&\n\004cuts\030\026 \003(\0132\030.vlsir.tetris.Trac"
  "kCross\";\n\006Assign\022\013\n\003net\030\001 \001(\t\022$\n\002at\030\002 \001("
  "\0132\030.vlsir.tetris.TrackCross\"Z\n\nTrackCros"
  "s\022%\n\005track\030\001 \001(\0132\026.vlsir.tetris.TrackRef"
  "\022%\n\005cross\030\002 \001(\0132\026.vlsir.tetris.TrackRef\""
  "(\n\010TrackRef\022\r\n\005layer\030\001 \001(\003\022\r\n\005track\030\002 \001("
  "\003\"/\n\007Outline\022\t\n\001x\030\001 \003(\003\022\t\n\001y\030\002 \003(\003\022\016\n\006me"
  "tals\030\003 \001(\003\"k\n\010Abstract\022\014\n\004name\030\001 \001(\t\022&\n\007"
  "outline\030\n \001(\0132\025.vlsir.tetris.Outline\022)\n\005"
  "ports\030\024 \003(\0132\032.vlsir.tetris.AbstractPort\""
  "\227\004\n\014AbstractPort\022\013\n\003net\030\001 \001(\t\0223\n\004edge\030\n "
  "\001(\0132#.vlsir.tetris.AbstractPort.EdgePort"
  "H\000\022<\n\tztop_edge\030\013 \001(\0132\'.vlsir.tetris.Abs"
  "tractPort.ZTopEdgePortH\000\022:\n\nztop_inner\030\014"
  " \001(\0132$.vlsir.tetris.AbstractPort.ZTopInn"
  "erH\000\032d\n\010EdgePort\022%\n\005track\030\001 \001(\0132\026.vlsir."
  "tetris.TrackRef\0221\n\004side\030\002 \001(\0162#.vlsir.te"
  "tris.AbstractPort.PortSide\032v\n\014ZTopEdgePo"
  "rt\022\r\n\005track\030\001 \001(\003\0221\n\004side\030\002 \001(\0162#.vlsir."
  "tetris.AbstractPort.PortSide\022$\n\004into\030\003 \001"
  "(\0132\026.vlsir.tetris.TrackRef\0323\n\tZTopInner\022"
  "&\n\004locs\030\001 \003(\0132\030.vlsir.tetris.TrackCross\""
  "0\n\010PortSide\022\022\n\016BOTTOM_OR_LEFT\020\000\022\020\n\014TOP_O"
  "R_RIGHT\020\001B\006\n\004kind\"\215\001\n\010Instance\022\014\n\004name\030\001"
  " \001(\t\022$\n\004cell\030\003 \001(\0132\026.vlsir.utils.Referen"
  "ce\022 \n\003loc\030\004 \001(\0132\023.vlsir.tetris.Place\022\025\n\r"
  "reflect_horiz\030\006 \001(\010\022\024\n\014reflect_vert\030\007 \001("
  "\010\"X\n\005Place\022\037\n\003abs\030\001 \001(\0132\020.vlsir.raw.Poin"
  "tH\000\022%\n\003rel\030\002 \001(\0132\026.vlsir.tetris.RelPlace"
  "H\000B\007\n\005place\"\n\n\010RelPlace\"\316\001\n\005Stack\022\037\n\005uni"
  "ts\030\001 \001(\0162\020.vlsir.raw.Units\022*\n\004prim\030\002 \001(\013"
  "2\034.vlsir.tetris.PrimitiveLayer\022(\n\006metals"
  "\030\003 \003(\0132\030.vlsir.tetris.MetalLayer\022$\n\004vias"
  "\030\004 \003(\0132\026.vlsir.tetris.ViaLayer\022(\n\016bounda"
  "ry_layer\030\013 \001(\0132\020.vlsir.raw.Layer\"{\n\tLaye"
  "rEnum\022/\n\004type\030\001 \001(\0162!.vlsir.tetris.Layer"
  "Enum.LayerType\022\r\n\005index\030\002 \001(\003\".\n\tLayerTy"
  "pe\022\r\n\tPRIMITIVE\020\000\022\t\n\005METAL\020\001\022\007\n\003VIA\020\002\"\321\002"
  "\n\nMetalLayer\022\014\n\004name\030\001 \001(\t\022)\n\003dir\030\002 \001(\0162"
  "\034.vlsir.tetris.MetalLayer.Dir\022\017\n\007cutsize"
  "\030\003 \001(\003\022(\n\007entries\030\004 \003(\0132\027.vlsir.tetris.T"
  "rackSpec\022\016\n\006offset\030\005 \001(\003\022\017\n\007overlap\030\006 \001("
  "\003\022\014\n\004flip\030\007 \001(\010\0224\n\004prim\030\010 \001(\0162&.vlsir.te"
  "tris.MetalLayer.PrimitiveMode\022\035\n\003raw\030\013 \001"
  "(\0132\020.vlsir.raw.Layer\"\032\n\003Dir\022\t\n\005HORIZ\020\000\022\010"
  "\n\004VERT\020\001\"/\n\rPrimitiveMode\022\010\n\004PRIM\020\000\022\t\n\005S"
  "PLIT\020\001\022\t\n\005STACK\020\002\"\243\001\n\010ViaLayer\022\014\n\004name\030\001"
  " \001(\t\022$\n\003top\030\002 \001(\0132\027.vlsir.tetris.LayerEn"
  "um\022$\n\003bot\030\003 \001(\0132\027.vlsir.tetris.LayerEnum"
  "\022\036\n\004size\030\004 \001(\0132\020.vlsir.tetris.Xy\022\035\n\003raw\030"
  "\013 \001(\0132\020.vlsir.raw.Layer\"3\n\016PrimitiveLaye"
  "r\022!\n\007pitches\030\001 \001(\0132\020.vlsir.tetris.Xy\"\316\002\n"
  "\tTrackSpec\0223\n\005entry\030\001 \001(\0132\".vlsir.tetris"
  ".TrackSpec.TrackEntryH\000\0220\n\006repeat\030\002 \001(\0132"
  "\036.vlsir.tetris.TrackSpec.RepeatH\000\032\204\001\n\nTr"
  "ackEntry\022;\n\005ttype\030\001 \001(\0162,.vlsir.tetris.T"
  "rackSpec.TrackEntry.TrackType\022\r\n\005width\030\002"
  " \001(\003\"*\n\tTrackType\022\007\n\003GAP\020\000\022\n\n\006SIGNAL\020\001\022\010"
  "\n\004RAIL\020\002\032K\n\006Repeat\0223\n\007entries\030\001 \003(\0132\".vl"
  "sir.tetris.TrackSpec.TrackEntry\022\014\n\004nrep\030"
  "\002 \001(\003B\006\n\004spec\"\032\n\002Xy\022\t\n\001x\030\001 \001(\003\022\t\n\001y\030\002 \001("
  "\003b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_layout_2ftetris_2eproto_deps[3] = {
  &::descriptor_table_circuit_2eproto,
  &::descriptor_table_layout_2fraw_2eproto,
  &::descriptor_table_utils_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_layout_2ftetris_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_layout_2ftetris_2eproto = {
  false, false, 2969, descriptor_table_protodef_layout_2ftetris_2eproto, "layout/tetris.proto", 
  &descriptor_table_layout_2ftetris_2eproto_once, descriptor_table_layout_2ftetris_2eproto_deps, 3, 24,
  schemas, file_default_instances, TableStruct_layout_2ftetris_2eproto::offsets,
  file_level_metadata_layout_2ftetris_2eproto, file_level_enum_descriptors_layout_2ftetris_2eproto, file_level_service_descriptors_layout_2ftetris_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_layout_2ftetris_2eproto_getter() {
  return &descriptor_table_layout_2ftetris_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_layout_2ftetris_2eproto(&descriptor_table_layout_2ftetris_2eproto);
namespace vlsir {
namespace tetris {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbstractPort_PortSide_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[0];
}
bool AbstractPort_PortSide_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AbstractPort_PortSide AbstractPort::BOTTOM_OR_LEFT;
constexpr AbstractPort_PortSide AbstractPort::TOP_OR_RIGHT;
constexpr AbstractPort_PortSide AbstractPort::PortSide_MIN;
constexpr AbstractPort_PortSide AbstractPort::PortSide_MAX;
constexpr int AbstractPort::PortSide_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LayerEnum_LayerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[1];
}
bool LayerEnum_LayerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LayerEnum_LayerType LayerEnum::PRIMITIVE;
constexpr LayerEnum_LayerType LayerEnum::METAL;
constexpr LayerEnum_LayerType LayerEnum::VIA;
constexpr LayerEnum_LayerType LayerEnum::LayerType_MIN;
constexpr LayerEnum_LayerType LayerEnum::LayerType_MAX;
constexpr int LayerEnum::LayerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_Dir_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[2];
}
bool MetalLayer_Dir_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MetalLayer_Dir MetalLayer::HORIZ;
constexpr MetalLayer_Dir MetalLayer::VERT;
constexpr MetalLayer_Dir MetalLayer::Dir_MIN;
constexpr MetalLayer_Dir MetalLayer::Dir_MAX;
constexpr int MetalLayer::Dir_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_PrimitiveMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[3];
}
bool MetalLayer_PrimitiveMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MetalLayer_PrimitiveMode MetalLayer::PRIM;
constexpr MetalLayer_PrimitiveMode MetalLayer::SPLIT;
constexpr MetalLayer_PrimitiveMode MetalLayer::STACK;
constexpr MetalLayer_PrimitiveMode MetalLayer::PrimitiveMode_MIN;
constexpr MetalLayer_PrimitiveMode MetalLayer::PrimitiveMode_MAX;
constexpr int MetalLayer::PrimitiveMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSpec_TrackEntry_TrackType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[4];
}
bool TrackSpec_TrackEntry_TrackType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::GAP;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::SIGNAL;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::RAIL;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::TrackType_MIN;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::TrackType_MAX;
constexpr int TrackSpec_TrackEntry::TrackType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Library::_Internal {
 public:
  static const ::vlsir::utils::AuthorMetadata& author(const Library* msg);
};

const ::vlsir::utils::AuthorMetadata&
Library::_Internal::author(const Library* msg) {
  return *msg->author_;
}
void Library::clear_author() {
  if (GetArenaForAllocation() == nullptr && author_ != nullptr) {
    delete author_;
  }
  author_ = nullptr;
}
Library::Library(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cells_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Library)
}
Library::Library(const Library& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      cells_(from.cells_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_domain().empty()) {
    domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_domain(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_author()) {
    author_ = new ::vlsir::utils::AuthorMetadata(*from.author_);
  } else {
    author_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Library)
}

inline void Library::SharedCtor() {
domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
author_ = nullptr;
}

Library::~Library() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Library)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Library::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete author_;
}

void Library::ArenaDtor(void* object) {
  Library* _this = reinterpret_cast< Library* >(object);
  (void)_this;
}
void Library::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Library::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Library::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Library)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cells_.Clear();
  domain_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && author_ != nullptr) {
    delete author_;
  }
  author_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Library::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string domain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_domain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Library.domain"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Cell cells = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.AuthorMetadata author = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Library::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Library)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string domain = 1;
  if (!this->_internal_domain().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain().data(), static_cast<int>(this->_internal_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Library.domain");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_domain(), target);
  }

  // repeated .vlsir.tetris.Cell cells = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cells_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_cells(i), target, stream);
  }

  // .vlsir.utils.AuthorMetadata author = 20;
  if (this->_internal_has_author()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::author(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Library)
  return target;
}

size_t Library::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Library)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.Cell cells = 10;
  total_size += 1UL * this->_internal_cells_size();
  for (const auto& msg : this->cells_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string domain = 1;
  if (!this->_internal_domain().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain());
  }

  // .vlsir.utils.AuthorMetadata author = 20;
  if (this->_internal_has_author()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *author_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Library::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Library::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Library::GetClassData() const { return &_class_data_; }

void Library::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Library *>(to)->MergeFrom(
      static_cast<const Library &>(from));
}


void Library::MergeFrom(const Library& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Library)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cells_.MergeFrom(from.cells_);
  if (!from._internal_domain().empty()) {
    _internal_set_domain(from._internal_domain());
  }
  if (from._internal_has_author()) {
    _internal_mutable_author()->::vlsir::utils::AuthorMetadata::MergeFrom(from._internal_author());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Library::CopyFrom(const Library& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Library)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Library::IsInitialized() const {
  return true;
}

void Library::InternalSwap(Library* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  cells_.InternalSwap(&other->cells_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &domain_, lhs_arena,
      &other->domain_, rhs_arena
  );
  swap(author_, other->author_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Library::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[0]);
}

// ===================================================================

class Cell::_Internal {
 public:
  static const ::vlsir::circuit::Interface& interface(const Cell* msg);
  static const ::vlsir::circuit::Module& module(const Cell* msg);
  static const ::vlsir::tetris::Abstract& abstract(const Cell* msg);
  static const ::vlsir::tetris::Layout& layout(const Cell* msg);
};

const ::vlsir::circuit::Interface&
Cell::_Internal::interface(const Cell* msg) {
  return *msg->interface_;
}
const ::vlsir::circuit::Module&
Cell::_Internal::module(const Cell* msg) {
  return *msg->module_;
}
const ::vlsir::tetris::Abstract&
Cell::_Internal::abstract(const Cell* msg) {
  return *msg->abstract_;
}
const ::vlsir::tetris::Layout&
Cell::_Internal::layout(const Cell* msg) {
  return *msg->layout_;
}
void Cell::clear_interface() {
  if (GetArenaForAllocation() == nullptr && interface_ != nullptr) {
    delete interface_;
  }
  interface_ = nullptr;
}
void Cell::clear_module() {
  if (GetArenaForAllocation() == nullptr && module_ != nullptr) {
    delete module_;
  }
  module_ = nullptr;
}
Cell::Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Cell)
}
Cell::Cell(const Cell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_interface()) {
    interface_ = new ::vlsir::circuit::Interface(*from.interface_);
  } else {
    interface_ = nullptr;
  }
  if (from._internal_has_module()) {
    module_ = new ::vlsir::circuit::Module(*from.module_);
  } else {
    module_ = nullptr;
  }
  if (from._internal_has_abstract()) {
    abstract_ = new ::vlsir::tetris::Abstract(*from.abstract_);
  } else {
    abstract_ = nullptr;
  }
  if (from._internal_has_layout()) {
    layout_ = new ::vlsir::tetris::Layout(*from.layout_);
  } else {
    layout_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Cell)
}

inline void Cell::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&interface_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&layout_) -
    reinterpret_cast<char*>(&interface_)) + sizeof(layout_));
}

Cell::~Cell() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Cell)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Cell::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete interface_;
  if (this != internal_default_instance()) delete module_;
  if (this != internal_default_instance()) delete abstract_;
  if (this != internal_default_instance()) delete layout_;
}

void Cell::ArenaDtor(void* object) {
  Cell* _this = reinterpret_cast< Cell* >(object);
  (void)_this;
}
void Cell::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Cell::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Cell::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Cell)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && interface_ != nullptr) {
    delete interface_;
  }
  interface_ = nullptr;
  if (GetArenaForAllocation() == nullptr && module_ != nullptr) {
    delete module_;
  }
  module_ = nullptr;
  if (GetArenaForAllocation() == nullptr && abstract_ != nullptr) {
    delete abstract_;
  }
  abstract_ = nullptr;
  if (GetArenaForAllocation() == nullptr && layout_ != nullptr) {
    delete layout_;
  }
  layout_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cell::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Cell.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.circuit.Interface interface = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_interface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.circuit.Module module = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_module(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Abstract abstract = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_abstract(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Layout layout = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_layout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Cell::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Cell)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Cell.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.circuit.Interface interface = 10;
  if (this->_internal_has_interface()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::interface(this), target, stream);
  }

  // .vlsir.circuit.Module module = 11;
  if (this->_internal_has_module()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::module(this), target, stream);
  }

  // .vlsir.tetris.Abstract abstract = 12;
  if (this->_internal_has_abstract()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::abstract(this), target, stream);
  }

  // .vlsir.tetris.Layout layout = 13;
  if (this->_internal_has_layout()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::layout(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Cell)
  return target;
}

size_t Cell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Cell)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.circuit.Interface interface = 10;
  if (this->_internal_has_interface()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *interface_);
  }

  // .vlsir.circuit.Module module = 11;
  if (this->_internal_has_module()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *module_);
  }

  // .vlsir.tetris.Abstract abstract = 12;
  if (this->_internal_has_abstract()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *abstract_);
  }

  // .vlsir.tetris.Layout layout = 13;
  if (this->_internal_has_layout()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *layout_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cell::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Cell::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cell::GetClassData() const { return &_class_data_; }

void Cell::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Cell *>(to)->MergeFrom(
      static_cast<const Cell &>(from));
}


void Cell::MergeFrom(const Cell& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Cell)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_interface()) {
    _internal_mutable_interface()->::vlsir::circuit::Interface::MergeFrom(from._internal_interface());
  }
  if (from._internal_has_module()) {
    _internal_mutable_module()->::vlsir::circuit::Module::MergeFrom(from._internal_module());
  }
  if (from._internal_has_abstract()) {
    _internal_mutable_abstract()->::vlsir::tetris::Abstract::MergeFrom(from._internal_abstract());
  }
  if (from._internal_has_layout()) {
    _internal_mutable_layout()->::vlsir::tetris::Layout::MergeFrom(from._internal_layout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Cell::CopyFrom(const Cell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Cell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cell::IsInitialized() const {
  return true;
}

void Cell::InternalSwap(Cell* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cell, layout_)
      + sizeof(Cell::layout_)
      - PROTOBUF_FIELD_OFFSET(Cell, interface_)>(
          reinterpret_cast<char*>(&interface_),
          reinterpret_cast<char*>(&other->interface_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cell::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[1]);
}

// ===================================================================

class Layout::_Internal {
 public:
  static const ::vlsir::tetris::Outline& outline(const Layout* msg);
};

const ::vlsir::tetris::Outline&
Layout::_Internal::outline(const Layout* msg) {
  return *msg->outline_;
}
Layout::Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  instances_(arena),
  assignments_(arena),
  cuts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Layout)
}
Layout::Layout(const Layout& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      instances_(from.instances_),
      assignments_(from.assignments_),
      cuts_(from.cuts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_outline()) {
    outline_ = new ::vlsir::tetris::Outline(*from.outline_);
  } else {
    outline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Layout)
}

inline void Layout::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
outline_ = nullptr;
}

Layout::~Layout() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Layout)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Layout::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete outline_;
}

void Layout::ArenaDtor(void* object) {
  Layout* _this = reinterpret_cast< Layout* >(object);
  (void)_this;
}
void Layout::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Layout::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Layout::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Layout)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  instances_.Clear();
  assignments_.Clear();
  cuts_.Clear();
  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Layout::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Layout.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Outline outline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_outline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Instance instances = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_instances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Assign assignments = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_assignments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.TrackCross cuts = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cuts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Layout::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Layout)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Layout.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::outline(this), target, stream);
  }

  // repeated .vlsir.tetris.Instance instances = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_instances_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_instances(i), target, stream);
  }

  // repeated .vlsir.tetris.Assign assignments = 21;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_assignments_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, this->_internal_assignments(i), target, stream);
  }

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cuts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, this->_internal_cuts(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Layout)
  return target;
}

size_t Layout::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Layout)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.Instance instances = 20;
  total_size += 2UL * this->_internal_instances_size();
  for (const auto& msg : this->instances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.Assign assignments = 21;
  total_size += 2UL * this->_internal_assignments_size();
  for (const auto& msg : this->assignments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  total_size += 2UL * this->_internal_cuts_size();
  for (const auto& msg : this->cuts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outline_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Layout::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Layout::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Layout::GetClassData() const { return &_class_data_; }

void Layout::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Layout *>(to)->MergeFrom(
      static_cast<const Layout &>(from));
}


void Layout::MergeFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Layout)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  instances_.MergeFrom(from.instances_);
  assignments_.MergeFrom(from.assignments_);
  cuts_.MergeFrom(from.cuts_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_outline()) {
    _internal_mutable_outline()->::vlsir::tetris::Outline::MergeFrom(from._internal_outline());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Layout::CopyFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Layout)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layout::IsInitialized() const {
  return true;
}

void Layout::InternalSwap(Layout* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  instances_.InternalSwap(&other->instances_);
  assignments_.InternalSwap(&other->assignments_);
  cuts_.InternalSwap(&other->cuts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(outline_, other->outline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Layout::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[2]);
}

// ===================================================================

class Assign::_Internal {
 public:
  static const ::vlsir::tetris::TrackCross& at(const Assign* msg);
};

const ::vlsir::tetris::TrackCross&
Assign::_Internal::at(const Assign* msg) {
  return *msg->at_;
}
Assign::Assign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Assign)
}
Assign::Assign(const Assign& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_net().empty()) {
    net_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_net(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_at()) {
    at_ = new ::vlsir::tetris::TrackCross(*from.at_);
  } else {
    at_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Assign)
}

inline void Assign::SharedCtor() {
net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
at_ = nullptr;
}

Assign::~Assign() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Assign)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Assign::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  net_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete at_;
}

void Assign::ArenaDtor(void* object) {
  Assign* _this = reinterpret_cast< Assign* >(object);
  (void)_this;
}
void Assign::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Assign::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Assign::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Assign)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  net_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && at_ != nullptr) {
    delete at_;
  }
  at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Assign::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_net();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Assign.net"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackCross at = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Assign::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Assign)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_net().data(), static_cast<int>(this->_internal_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Assign.net");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_net(), target);
  }

  // .vlsir.tetris.TrackCross at = 2;
  if (this->_internal_has_at()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::at(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Assign)
  return target;
}

size_t Assign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Assign)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_net());
  }

  // .vlsir.tetris.TrackCross at = 2;
  if (this->_internal_has_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Assign::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Assign::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Assign::GetClassData() const { return &_class_data_; }

void Assign::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Assign *>(to)->MergeFrom(
      static_cast<const Assign &>(from));
}


void Assign::MergeFrom(const Assign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Assign)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_net().empty()) {
    _internal_set_net(from._internal_net());
  }
  if (from._internal_has_at()) {
    _internal_mutable_at()->::vlsir::tetris::TrackCross::MergeFrom(from._internal_at());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Assign::CopyFrom(const Assign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Assign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Assign::IsInitialized() const {
  return true;
}

void Assign::InternalSwap(Assign* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &net_, lhs_arena,
      &other->net_, rhs_arena
  );
  swap(at_, other->at_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Assign::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[3]);
}

// ===================================================================

class TrackCross::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& track(const TrackCross* msg);
  static const ::vlsir::tetris::TrackRef& cross(const TrackCross* msg);
};

const ::vlsir::tetris::TrackRef&
TrackCross::_Internal::track(const TrackCross* msg) {
  return *msg->track_;
}
const ::vlsir::tetris::TrackRef&
TrackCross::_Internal::cross(const TrackCross* msg) {
  return *msg->cross_;
}
TrackCross::TrackCross(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackCross)
}
TrackCross::TrackCross(const TrackCross& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_track()) {
    track_ = new ::vlsir::tetris::TrackRef(*from.track_);
  } else {
    track_ = nullptr;
  }
  if (from._internal_has_cross()) {
    cross_ = new ::vlsir::tetris::TrackRef(*from.cross_);
  } else {
    cross_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackCross)
}

inline void TrackCross::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&track_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cross_) -
    reinterpret_cast<char*>(&track_)) + sizeof(cross_));
}

TrackCross::~TrackCross() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackCross)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TrackCross::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete track_;
  if (this != internal_default_instance()) delete cross_;
}

void TrackCross::ArenaDtor(void* object) {
  TrackCross* _this = reinterpret_cast< TrackCross* >(object);
  (void)_this;
}
void TrackCross::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackCross::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrackCross::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackCross)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && track_ != nullptr) {
    delete track_;
  }
  track_ = nullptr;
  if (GetArenaForAllocation() == nullptr && cross_ != nullptr) {
    delete cross_;
  }
  cross_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackCross::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackRef track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackRef cross = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cross(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackCross::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackCross)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::track(this), target, stream);
  }

  // .vlsir.tetris.TrackRef cross = 2;
  if (this->_internal_has_cross()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::cross(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackCross)
  return target;
}

size_t TrackCross::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackCross)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *track_);
  }

  // .vlsir.tetris.TrackRef cross = 2;
  if (this->_internal_has_cross()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cross_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackCross::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrackCross::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackCross::GetClassData() const { return &_class_data_; }

void TrackCross::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrackCross *>(to)->MergeFrom(
      static_cast<const TrackCross &>(from));
}


void TrackCross::MergeFrom(const TrackCross& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackCross)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_track()) {
    _internal_mutable_track()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_track());
  }
  if (from._internal_has_cross()) {
    _internal_mutable_cross()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_cross());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackCross::CopyFrom(const TrackCross& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackCross)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackCross::IsInitialized() const {
  return true;
}

void TrackCross::InternalSwap(TrackCross* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackCross, cross_)
      + sizeof(TrackCross::cross_)
      - PROTOBUF_FIELD_OFFSET(TrackCross, track_)>(
          reinterpret_cast<char*>(&track_),
          reinterpret_cast<char*>(&other->track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackCross::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[4]);
}

// ===================================================================

class TrackRef::_Internal {
 public:
};

TrackRef::TrackRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackRef)
}
TrackRef::TrackRef(const TrackRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&layer_, &from.layer_,
    static_cast<size_t>(reinterpret_cast<char*>(&track_) -
    reinterpret_cast<char*>(&layer_)) + sizeof(track_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackRef)
}

inline void TrackRef::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&layer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&track_) -
    reinterpret_cast<char*>(&layer_)) + sizeof(track_));
}

TrackRef::~TrackRef() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackRef)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TrackRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TrackRef::ArenaDtor(void* object) {
  TrackRef* _this = reinterpret_cast< TrackRef* >(object);
  (void)_this;
}
void TrackRef::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackRef::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrackRef::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&layer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&track_) -
      reinterpret_cast<char*>(&layer_)) + sizeof(track_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackRef::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 layer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          layer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 track = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 layer = 1;
  if (this->_internal_layer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_layer(), target);
  }

  // int64 track = 2;
  if (this->_internal_track() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_track(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackRef)
  return target;
}

size_t TrackRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 layer = 1;
  if (this->_internal_layer() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_layer());
  }

  // int64 track = 2;
  if (this->_internal_track() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_track());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrackRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackRef::GetClassData() const { return &_class_data_; }

void TrackRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrackRef *>(to)->MergeFrom(
      static_cast<const TrackRef &>(from));
}


void TrackRef::MergeFrom(const TrackRef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackRef)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_layer() != 0) {
    _internal_set_layer(from._internal_layer());
  }
  if (from._internal_track() != 0) {
    _internal_set_track(from._internal_track());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackRef::CopyFrom(const TrackRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackRef::IsInitialized() const {
  return true;
}

void TrackRef::InternalSwap(TrackRef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackRef, track_)
      + sizeof(TrackRef::track_)
      - PROTOBUF_FIELD_OFFSET(TrackRef, layer_)>(
          reinterpret_cast<char*>(&layer_),
          reinterpret_cast<char*>(&other->layer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackRef::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[5]);
}

// ===================================================================

class Outline::_Internal {
 public:
};

Outline::Outline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  x_(arena),
  y_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Outline)
}
Outline::Outline(const Outline& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      x_(from.x_),
      y_(from.y_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  metals_ = from.metals_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Outline)
}

inline void Outline::SharedCtor() {
metals_ = int64_t{0};
}

Outline::~Outline() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Outline)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Outline::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Outline::ArenaDtor(void* object) {
  Outline* _this = reinterpret_cast< Outline* >(object);
  (void)_this;
}
void Outline::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Outline::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Outline::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Outline)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  x_.Clear();
  y_.Clear();
  metals_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Outline::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_x(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_x(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_y(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_y(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 metals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          metals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Outline::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Outline)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 x = 1;
  {
    int byte_size = _x_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_x(), byte_size, target);
    }
  }

  // repeated int64 y = 2;
  {
    int byte_size = _y_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_y(), byte_size, target);
    }
  }

  // int64 metals = 3;
  if (this->_internal_metals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_metals(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Outline)
  return target;
}

size_t Outline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Outline)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 x = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->x_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _x_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 y = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->y_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _y_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 metals = 3;
  if (this->_internal_metals() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_metals());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Outline::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Outline::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Outline::GetClassData() const { return &_class_data_; }

void Outline::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Outline *>(to)->MergeFrom(
      static_cast<const Outline &>(from));
}


void Outline::MergeFrom(const Outline& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Outline)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  x_.MergeFrom(from.x_);
  y_.MergeFrom(from.y_);
  if (from._internal_metals() != 0) {
    _internal_set_metals(from._internal_metals());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Outline::CopyFrom(const Outline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Outline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Outline::IsInitialized() const {
  return true;
}

void Outline::InternalSwap(Outline* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  x_.InternalSwap(&other->x_);
  y_.InternalSwap(&other->y_);
  swap(metals_, other->metals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Outline::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[6]);
}

// ===================================================================

class Abstract::_Internal {
 public:
  static const ::vlsir::tetris::Outline& outline(const Abstract* msg);
};

const ::vlsir::tetris::Outline&
Abstract::_Internal::outline(const Abstract* msg) {
  return *msg->outline_;
}
Abstract::Abstract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ports_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Abstract)
}
Abstract::Abstract(const Abstract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ports_(from.ports_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_outline()) {
    outline_ = new ::vlsir::tetris::Outline(*from.outline_);
  } else {
    outline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Abstract)
}

inline void Abstract::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
outline_ = nullptr;
}

Abstract::~Abstract() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Abstract)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Abstract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete outline_;
}

void Abstract::ArenaDtor(void* object) {
  Abstract* _this = reinterpret_cast< Abstract* >(object);
  (void)_this;
}
void Abstract::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Abstract::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Abstract::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Abstract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ports_.Clear();
  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Abstract::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Abstract.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Outline outline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_outline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.AbstractPort ports = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Abstract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Abstract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Abstract.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::outline(this), target, stream);
  }

  // repeated .vlsir.tetris.AbstractPort ports = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ports_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_ports(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Abstract)
  return target;
}

size_t Abstract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Abstract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.AbstractPort ports = 20;
  total_size += 2UL * this->_internal_ports_size();
  for (const auto& msg : this->ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outline_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Abstract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Abstract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Abstract::GetClassData() const { return &_class_data_; }

void Abstract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Abstract *>(to)->MergeFrom(
      static_cast<const Abstract &>(from));
}


void Abstract::MergeFrom(const Abstract& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Abstract)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ports_.MergeFrom(from.ports_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_outline()) {
    _internal_mutable_outline()->::vlsir::tetris::Outline::MergeFrom(from._internal_outline());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Abstract::CopyFrom(const Abstract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Abstract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Abstract::IsInitialized() const {
  return true;
}

void Abstract::InternalSwap(Abstract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ports_.InternalSwap(&other->ports_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(outline_, other->outline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Abstract::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[7]);
}

// ===================================================================

class AbstractPort_EdgePort::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& track(const AbstractPort_EdgePort* msg);
};

const ::vlsir::tetris::TrackRef&
AbstractPort_EdgePort::_Internal::track(const AbstractPort_EdgePort* msg) {
  return *msg->track_;
}
AbstractPort_EdgePort::AbstractPort_EdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.EdgePort)
}
AbstractPort_EdgePort::AbstractPort_EdgePort(const AbstractPort_EdgePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_track()) {
    track_ = new ::vlsir::tetris::TrackRef(*from.track_);
  } else {
    track_ = nullptr;
  }
  side_ = from.side_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.EdgePort)
}

inline void AbstractPort_EdgePort::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&track_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&side_) -
    reinterpret_cast<char*>(&track_)) + sizeof(side_));
}

AbstractPort_EdgePort::~AbstractPort_EdgePort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.EdgePort)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AbstractPort_EdgePort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete track_;
}

void AbstractPort_EdgePort::ArenaDtor(void* object) {
  AbstractPort_EdgePort* _this = reinterpret_cast< AbstractPort_EdgePort* >(object);
  (void)_this;
}
void AbstractPort_EdgePort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort_EdgePort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AbstractPort_EdgePort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.EdgePort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && track_ != nullptr) {
    delete track_;
  }
  track_ = nullptr;
  side_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_EdgePort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackRef track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.PortSide side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::vlsir::tetris::AbstractPort_PortSide>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort_EdgePort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.EdgePort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::track(this), target, stream);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.EdgePort)
  return target;
}

size_t AbstractPort_EdgePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.EdgePort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *track_);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_side());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort_EdgePort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AbstractPort_EdgePort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort_EdgePort::GetClassData() const { return &_class_data_; }

void AbstractPort_EdgePort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AbstractPort_EdgePort *>(to)->MergeFrom(
      static_cast<const AbstractPort_EdgePort &>(from));
}


void AbstractPort_EdgePort::MergeFrom(const AbstractPort_EdgePort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.EdgePort)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_track()) {
    _internal_mutable_track()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_track());
  }
  if (from._internal_side() != 0) {
    _internal_set_side(from._internal_side());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort_EdgePort::CopyFrom(const AbstractPort_EdgePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.EdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_EdgePort::IsInitialized() const {
  return true;
}

void AbstractPort_EdgePort::InternalSwap(AbstractPort_EdgePort* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbstractPort_EdgePort, side_)
      + sizeof(AbstractPort_EdgePort::side_)
      - PROTOBUF_FIELD_OFFSET(AbstractPort_EdgePort, track_)>(
          reinterpret_cast<char*>(&track_),
          reinterpret_cast<char*>(&other->track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_EdgePort::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[8]);
}

// ===================================================================

class AbstractPort_ZTopEdgePort::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& into(const AbstractPort_ZTopEdgePort* msg);
};

const ::vlsir::tetris::TrackRef&
AbstractPort_ZTopEdgePort::_Internal::into(const AbstractPort_ZTopEdgePort* msg) {
  return *msg->into_;
}
AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
}
AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(const AbstractPort_ZTopEdgePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_into()) {
    into_ = new ::vlsir::tetris::TrackRef(*from.into_);
  } else {
    into_ = nullptr;
  }
  ::memcpy(&track_, &from.track_,
    static_cast<size_t>(reinterpret_cast<char*>(&side_) -
    reinterpret_cast<char*>(&track_)) + sizeof(side_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
}

inline void AbstractPort_ZTopEdgePort::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&into_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&side_) -
    reinterpret_cast<char*>(&into_)) + sizeof(side_));
}

AbstractPort_ZTopEdgePort::~AbstractPort_ZTopEdgePort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AbstractPort_ZTopEdgePort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete into_;
}

void AbstractPort_ZTopEdgePort::ArenaDtor(void* object) {
  AbstractPort_ZTopEdgePort* _this = reinterpret_cast< AbstractPort_ZTopEdgePort* >(object);
  (void)_this;
}
void AbstractPort_ZTopEdgePort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort_ZTopEdgePort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AbstractPort_ZTopEdgePort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && into_ != nullptr) {
    delete into_;
  }
  into_ = nullptr;
  ::memset(&track_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&side_) -
      reinterpret_cast<char*>(&track_)) + sizeof(side_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_ZTopEdgePort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.PortSide side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::vlsir::tetris::AbstractPort_PortSide>(val));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackRef into = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_into(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort_ZTopEdgePort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 track = 1;
  if (this->_internal_track() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_track(), target);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_side(), target);
  }

  // .vlsir.tetris.TrackRef into = 3;
  if (this->_internal_has_into()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::into(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.ZTopEdgePort)
  return target;
}

size_t AbstractPort_ZTopEdgePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef into = 3;
  if (this->_internal_has_into()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *into_);
  }

  // int64 track = 1;
  if (this->_internal_track() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_track());
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_side());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort_ZTopEdgePort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AbstractPort_ZTopEdgePort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort_ZTopEdgePort::GetClassData() const { return &_class_data_; }

void AbstractPort_ZTopEdgePort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AbstractPort_ZTopEdgePort *>(to)->MergeFrom(
      static_cast<const AbstractPort_ZTopEdgePort &>(from));
}


void AbstractPort_ZTopEdgePort::MergeFrom(const AbstractPort_ZTopEdgePort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_into()) {
    _internal_mutable_into()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_into());
  }
  if (from._internal_track() != 0) {
    _internal_set_track(from._internal_track());
  }
  if (from._internal_side() != 0) {
    _internal_set_side(from._internal_side());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort_ZTopEdgePort::CopyFrom(const AbstractPort_ZTopEdgePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_ZTopEdgePort::IsInitialized() const {
  return true;
}

void AbstractPort_ZTopEdgePort::InternalSwap(AbstractPort_ZTopEdgePort* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbstractPort_ZTopEdgePort, side_)
      + sizeof(AbstractPort_ZTopEdgePort::side_)
      - PROTOBUF_FIELD_OFFSET(AbstractPort_ZTopEdgePort, into_)>(
          reinterpret_cast<char*>(&into_),
          reinterpret_cast<char*>(&other->into_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_ZTopEdgePort::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[9]);
}

// ===================================================================

class AbstractPort_ZTopInner::_Internal {
 public:
};

AbstractPort_ZTopInner::AbstractPort_ZTopInner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  locs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.ZTopInner)
}
AbstractPort_ZTopInner::AbstractPort_ZTopInner(const AbstractPort_ZTopInner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      locs_(from.locs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.ZTopInner)
}

inline void AbstractPort_ZTopInner::SharedCtor() {
}

AbstractPort_ZTopInner::~AbstractPort_ZTopInner() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.ZTopInner)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AbstractPort_ZTopInner::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AbstractPort_ZTopInner::ArenaDtor(void* object) {
  AbstractPort_ZTopInner* _this = reinterpret_cast< AbstractPort_ZTopInner* >(object);
  (void)_this;
}
void AbstractPort_ZTopInner::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort_ZTopInner::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AbstractPort_ZTopInner::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.ZTopInner)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  locs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_ZTopInner::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vlsir.tetris.TrackCross locs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort_ZTopInner::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.ZTopInner)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackCross locs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_locs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_locs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.ZTopInner)
  return target;
}

size_t AbstractPort_ZTopInner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.ZTopInner)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackCross locs = 1;
  total_size += 1UL * this->_internal_locs_size();
  for (const auto& msg : this->locs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort_ZTopInner::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AbstractPort_ZTopInner::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort_ZTopInner::GetClassData() const { return &_class_data_; }

void AbstractPort_ZTopInner::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AbstractPort_ZTopInner *>(to)->MergeFrom(
      static_cast<const AbstractPort_ZTopInner &>(from));
}


void AbstractPort_ZTopInner::MergeFrom(const AbstractPort_ZTopInner& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  locs_.MergeFrom(from.locs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort_ZTopInner::CopyFrom(const AbstractPort_ZTopInner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_ZTopInner::IsInitialized() const {
  return true;
}

void AbstractPort_ZTopInner::InternalSwap(AbstractPort_ZTopInner* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  locs_.InternalSwap(&other->locs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_ZTopInner::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[10]);
}

// ===================================================================

class AbstractPort::_Internal {
 public:
  static const ::vlsir::tetris::AbstractPort_EdgePort& edge(const AbstractPort* msg);
  static const ::vlsir::tetris::AbstractPort_ZTopEdgePort& ztop_edge(const AbstractPort* msg);
  static const ::vlsir::tetris::AbstractPort_ZTopInner& ztop_inner(const AbstractPort* msg);
};

const ::vlsir::tetris::AbstractPort_EdgePort&
AbstractPort::_Internal::edge(const AbstractPort* msg) {
  return *msg->kind_.edge_;
}
const ::vlsir::tetris::AbstractPort_ZTopEdgePort&
AbstractPort::_Internal::ztop_edge(const AbstractPort* msg) {
  return *msg->kind_.ztop_edge_;
}
const ::vlsir::tetris::AbstractPort_ZTopInner&
AbstractPort::_Internal::ztop_inner(const AbstractPort* msg) {
  return *msg->kind_.ztop_inner_;
}
void AbstractPort::set_allocated_edge(::vlsir::tetris::AbstractPort_EdgePort* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::AbstractPort_EdgePort>::GetOwningArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    set_has_edge();
    kind_.edge_ = edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.edge)
}
void AbstractPort::set_allocated_ztop_edge(::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (ztop_edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::AbstractPort_ZTopEdgePort>::GetOwningArena(ztop_edge);
    if (message_arena != submessage_arena) {
      ztop_edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ztop_edge, submessage_arena);
    }
    set_has_ztop_edge();
    kind_.ztop_edge_ = ztop_edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ztop_edge)
}
void AbstractPort::set_allocated_ztop_inner(::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (ztop_inner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::AbstractPort_ZTopInner>::GetOwningArena(ztop_inner);
    if (message_arena != submessage_arena) {
      ztop_inner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ztop_inner, submessage_arena);
    }
    set_has_ztop_inner();
    kind_.ztop_inner_ = ztop_inner;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ztop_inner)
}
AbstractPort::AbstractPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort)
}
AbstractPort::AbstractPort(const AbstractPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_net().empty()) {
    net_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_net(), 
      GetArenaForAllocation());
  }
  clear_has_kind();
  switch (from.kind_case()) {
    case kEdge: {
      _internal_mutable_edge()->::vlsir::tetris::AbstractPort_EdgePort::MergeFrom(from._internal_edge());
      break;
    }
    case kZtopEdge: {
      _internal_mutable_ztop_edge()->::vlsir::tetris::AbstractPort_ZTopEdgePort::MergeFrom(from._internal_ztop_edge());
      break;
    }
    case kZtopInner: {
      _internal_mutable_ztop_inner()->::vlsir::tetris::AbstractPort_ZTopInner::MergeFrom(from._internal_ztop_inner());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort)
}

inline void AbstractPort::SharedCtor() {
net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_kind();
}

AbstractPort::~AbstractPort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AbstractPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  net_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_kind()) {
    clear_kind();
  }
}

void AbstractPort::ArenaDtor(void* object) {
  AbstractPort* _this = reinterpret_cast< AbstractPort* >(object);
  (void)_this;
}
void AbstractPort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AbstractPort::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.AbstractPort)
  switch (kind_case()) {
    case kEdge: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.edge_;
      }
      break;
    }
    case kZtopEdge: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.ztop_edge_;
      }
      break;
    }
    case kZtopInner: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.ztop_inner_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void AbstractPort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  net_.ClearToEmpty();
  clear_kind();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_net();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.AbstractPort.net"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ztop_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_ztop_inner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_net().data(), static_cast<int>(this->_internal_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.AbstractPort.net");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_net(), target);
  }

  // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
  if (_internal_has_edge()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::edge(this), target, stream);
  }

  // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
  if (_internal_has_ztop_edge()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::ztop_edge(this), target, stream);
  }

  // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
  if (_internal_has_ztop_inner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::ztop_inner(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort)
  return target;
}

size_t AbstractPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_net());
  }

  switch (kind_case()) {
    // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
    case kEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.edge_);
      break;
    }
    // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
    case kZtopEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.ztop_edge_);
      break;
    }
    // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
    case kZtopInner: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.ztop_inner_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AbstractPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort::GetClassData() const { return &_class_data_; }

void AbstractPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AbstractPort *>(to)->MergeFrom(
      static_cast<const AbstractPort &>(from));
}


void AbstractPort::MergeFrom(const AbstractPort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_net().empty()) {
    _internal_set_net(from._internal_net());
  }
  switch (from.kind_case()) {
    case kEdge: {
      _internal_mutable_edge()->::vlsir::tetris::AbstractPort_EdgePort::MergeFrom(from._internal_edge());
      break;
    }
    case kZtopEdge: {
      _internal_mutable_ztop_edge()->::vlsir::tetris::AbstractPort_ZTopEdgePort::MergeFrom(from._internal_ztop_edge());
      break;
    }
    case kZtopInner: {
      _internal_mutable_ztop_inner()->::vlsir::tetris::AbstractPort_ZTopInner::MergeFrom(from._internal_ztop_inner());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort::CopyFrom(const AbstractPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort::IsInitialized() const {
  return true;
}

void AbstractPort::InternalSwap(AbstractPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &net_, lhs_arena,
      &other->net_, rhs_arena
  );
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[11]);
}

// ===================================================================

class Instance::_Internal {
 public:
  static const ::vlsir::utils::Reference& cell(const Instance* msg);
  static const ::vlsir::tetris::Place& loc(const Instance* msg);
};

const ::vlsir::utils::Reference&
Instance::_Internal::cell(const Instance* msg) {
  return *msg->cell_;
}
const ::vlsir::tetris::Place&
Instance::_Internal::loc(const Instance* msg) {
  return *msg->loc_;
}
void Instance::clear_cell() {
  if (GetArenaForAllocation() == nullptr && cell_ != nullptr) {
    delete cell_;
  }
  cell_ = nullptr;
}
Instance::Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Instance)
}
Instance::Instance(const Instance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_cell()) {
    cell_ = new ::vlsir::utils::Reference(*from.cell_);
  } else {
    cell_ = nullptr;
  }
  if (from._internal_has_loc()) {
    loc_ = new ::vlsir::tetris::Place(*from.loc_);
  } else {
    loc_ = nullptr;
  }
  ::memcpy(&reflect_horiz_, &from.reflect_horiz_,
    static_cast<size_t>(reinterpret_cast<char*>(&reflect_vert_) -
    reinterpret_cast<char*>(&reflect_horiz_)) + sizeof(reflect_vert_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Instance)
}

inline void Instance::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cell_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reflect_vert_) -
    reinterpret_cast<char*>(&cell_)) + sizeof(reflect_vert_));
}

Instance::~Instance() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Instance)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Instance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete cell_;
  if (this != internal_default_instance()) delete loc_;
}

void Instance::ArenaDtor(void* object) {
  Instance* _this = reinterpret_cast< Instance* >(object);
  (void)_this;
}
void Instance::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Instance::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Instance::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Instance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && cell_ != nullptr) {
    delete cell_;
  }
  cell_ = nullptr;
  if (GetArenaForAllocation() == nullptr && loc_ != nullptr) {
    delete loc_;
  }
  loc_ = nullptr;
  ::memset(&reflect_horiz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reflect_vert_) -
      reinterpret_cast<char*>(&reflect_horiz_)) + sizeof(reflect_vert_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Instance::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Instance.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.Reference cell = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Place loc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_loc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reflect_horiz = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          reflect_horiz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reflect_vert = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          reflect_vert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Instance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Instance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Instance.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.utils.Reference cell = 3;
  if (this->_internal_has_cell()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cell(this), target, stream);
  }

  // .vlsir.tetris.Place loc = 4;
  if (this->_internal_has_loc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::loc(this), target, stream);
  }

  // bool reflect_horiz = 6;
  if (this->_internal_reflect_horiz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_reflect_horiz(), target);
  }

  // bool reflect_vert = 7;
  if (this->_internal_reflect_vert() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_reflect_vert(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Instance)
  return target;
}

size_t Instance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Instance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.utils.Reference cell = 3;
  if (this->_internal_has_cell()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cell_);
  }

  // .vlsir.tetris.Place loc = 4;
  if (this->_internal_has_loc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *loc_);
  }

  // bool reflect_horiz = 6;
  if (this->_internal_reflect_horiz() != 0) {
    total_size += 1 + 1;
  }

  // bool reflect_vert = 7;
  if (this->_internal_reflect_vert() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Instance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Instance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Instance::GetClassData() const { return &_class_data_; }

void Instance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Instance *>(to)->MergeFrom(
      static_cast<const Instance &>(from));
}


void Instance::MergeFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Instance)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_cell()) {
    _internal_mutable_cell()->::vlsir::utils::Reference::MergeFrom(from._internal_cell());
  }
  if (from._internal_has_loc()) {
    _internal_mutable_loc()->::vlsir::tetris::Place::MergeFrom(from._internal_loc());
  }
  if (from._internal_reflect_horiz() != 0) {
    _internal_set_reflect_horiz(from._internal_reflect_horiz());
  }
  if (from._internal_reflect_vert() != 0) {
    _internal_set_reflect_vert(from._internal_reflect_vert());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Instance::CopyFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Instance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instance::IsInitialized() const {
  return true;
}

void Instance::InternalSwap(Instance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Instance, reflect_vert_)
      + sizeof(Instance::reflect_vert_)
      - PROTOBUF_FIELD_OFFSET(Instance, cell_)>(
          reinterpret_cast<char*>(&cell_),
          reinterpret_cast<char*>(&other->cell_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Instance::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[12]);
}

// ===================================================================

class Place::_Internal {
 public:
  static const ::vlsir::raw::Point& abs(const Place* msg);
  static const ::vlsir::tetris::RelPlace& rel(const Place* msg);
};

const ::vlsir::raw::Point&
Place::_Internal::abs(const Place* msg) {
  return *msg->place_.abs_;
}
const ::vlsir::tetris::RelPlace&
Place::_Internal::rel(const Place* msg) {
  return *msg->place_.rel_;
}
void Place::set_allocated_abs(::vlsir::raw::Point* abs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_place();
  if (abs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abs));
    if (message_arena != submessage_arena) {
      abs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abs, submessage_arena);
    }
    set_has_abs();
    place_.abs_ = abs;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Place.abs)
}
void Place::clear_abs() {
  if (_internal_has_abs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete place_.abs_;
    }
    clear_has_place();
  }
}
void Place::set_allocated_rel(::vlsir::tetris::RelPlace* rel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_place();
  if (rel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::RelPlace>::GetOwningArena(rel);
    if (message_arena != submessage_arena) {
      rel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rel, submessage_arena);
    }
    set_has_rel();
    place_.rel_ = rel;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Place.rel)
}
Place::Place(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Place)
}
Place::Place(const Place& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_place();
  switch (from.place_case()) {
    case kAbs: {
      _internal_mutable_abs()->::vlsir::raw::Point::MergeFrom(from._internal_abs());
      break;
    }
    case kRel: {
      _internal_mutable_rel()->::vlsir::tetris::RelPlace::MergeFrom(from._internal_rel());
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Place)
}

inline void Place::SharedCtor() {
clear_has_place();
}

Place::~Place() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Place)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Place::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_place()) {
    clear_place();
  }
}

void Place::ArenaDtor(void* object) {
  Place* _this = reinterpret_cast< Place* >(object);
  (void)_this;
}
void Place::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Place::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Place::clear_place() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.Place)
  switch (place_case()) {
    case kAbs: {
      if (GetArenaForAllocation() == nullptr) {
        delete place_.abs_;
      }
      break;
    }
    case kRel: {
      if (GetArenaForAllocation() == nullptr) {
        delete place_.rel_;
      }
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PLACE_NOT_SET;
}


void Place::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Place)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_place();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Place::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.raw.Point abs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_abs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.RelPlace rel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Place::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Place)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.raw.Point abs = 1;
  if (_internal_has_abs()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::abs(this), target, stream);
  }

  // .vlsir.tetris.RelPlace rel = 2;
  if (_internal_has_rel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::rel(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Place)
  return target;
}

size_t Place::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Place)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (place_case()) {
    // .vlsir.raw.Point abs = 1;
    case kAbs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *place_.abs_);
      break;
    }
    // .vlsir.tetris.RelPlace rel = 2;
    case kRel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *place_.rel_);
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Place::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Place::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Place::GetClassData() const { return &_class_data_; }

void Place::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Place *>(to)->MergeFrom(
      static_cast<const Place &>(from));
}


void Place::MergeFrom(const Place& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Place)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.place_case()) {
    case kAbs: {
      _internal_mutable_abs()->::vlsir::raw::Point::MergeFrom(from._internal_abs());
      break;
    }
    case kRel: {
      _internal_mutable_rel()->::vlsir::tetris::RelPlace::MergeFrom(from._internal_rel());
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Place::CopyFrom(const Place& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Place)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Place::IsInitialized() const {
  return true;
}

void Place::InternalSwap(Place* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(place_, other->place_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Place::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[13]);
}

// ===================================================================

class RelPlace::_Internal {
 public:
};

RelPlace::RelPlace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.RelPlace)
}
RelPlace::RelPlace(const RelPlace& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.RelPlace)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RelPlace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RelPlace::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RelPlace::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[14]);
}

// ===================================================================

class Stack::_Internal {
 public:
  static const ::vlsir::tetris::PrimitiveLayer& prim(const Stack* msg);
  static const ::vlsir::raw::Layer& boundary_layer(const Stack* msg);
};

const ::vlsir::tetris::PrimitiveLayer&
Stack::_Internal::prim(const Stack* msg) {
  return *msg->prim_;
}
const ::vlsir::raw::Layer&
Stack::_Internal::boundary_layer(const Stack* msg) {
  return *msg->boundary_layer_;
}
void Stack::clear_boundary_layer() {
  if (GetArenaForAllocation() == nullptr && boundary_layer_ != nullptr) {
    delete boundary_layer_;
  }
  boundary_layer_ = nullptr;
}
Stack::Stack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  metals_(arena),
  vias_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Stack)
}
Stack::Stack(const Stack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      metals_(from.metals_),
      vias_(from.vias_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_prim()) {
    prim_ = new ::vlsir::tetris::PrimitiveLayer(*from.prim_);
  } else {
    prim_ = nullptr;
  }
  if (from._internal_has_boundary_layer()) {
    boundary_layer_ = new ::vlsir::raw::Layer(*from.boundary_layer_);
  } else {
    boundary_layer_ = nullptr;
  }
  units_ = from.units_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Stack)
}

inline void Stack::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&prim_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&units_) -
    reinterpret_cast<char*>(&prim_)) + sizeof(units_));
}

Stack::~Stack() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Stack)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Stack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete prim_;
  if (this != internal_default_instance()) delete boundary_layer_;
}

void Stack::ArenaDtor(void* object) {
  Stack* _this = reinterpret_cast< Stack* >(object);
  (void)_this;
}
void Stack::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Stack::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Stack::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Stack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metals_.Clear();
  vias_.Clear();
  if (GetArenaForAllocation() == nullptr && prim_ != nullptr) {
    delete prim_;
  }
  prim_ = nullptr;
  if (GetArenaForAllocation() == nullptr && boundary_layer_ != nullptr) {
    delete boundary_layer_;
  }
  boundary_layer_ = nullptr;
  units_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stack::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.raw.Units units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_units(static_cast<::vlsir::raw::Units>(val));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.PrimitiveLayer prim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.MetalLayer metals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.ViaLayer vias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vias(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.raw.Layer boundary_layer = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundary_layer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Stack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.raw.Units units = 1;
  if (this->_internal_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_units(), target);
  }

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  if (this->_internal_has_prim()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::prim(this), target, stream);
  }

  // repeated .vlsir.tetris.MetalLayer metals = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_metals_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_metals(i), target, stream);
  }

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_vias_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_vias(i), target, stream);
  }

  // .vlsir.raw.Layer boundary_layer = 11;
  if (this->_internal_has_boundary_layer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::boundary_layer(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Stack)
  return target;
}

size_t Stack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Stack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.MetalLayer metals = 3;
  total_size += 1UL * this->_internal_metals_size();
  for (const auto& msg : this->metals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  total_size += 1UL * this->_internal_vias_size();
  for (const auto& msg : this->vias_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  if (this->_internal_has_prim()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *prim_);
  }

  // .vlsir.raw.Layer boundary_layer = 11;
  if (this->_internal_has_boundary_layer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *boundary_layer_);
  }

  // .vlsir.raw.Units units = 1;
  if (this->_internal_units() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_units());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Stack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stack::GetClassData() const { return &_class_data_; }

void Stack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Stack *>(to)->MergeFrom(
      static_cast<const Stack &>(from));
}


void Stack::MergeFrom(const Stack& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Stack)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  metals_.MergeFrom(from.metals_);
  vias_.MergeFrom(from.vias_);
  if (from._internal_has_prim()) {
    _internal_mutable_prim()->::vlsir::tetris::PrimitiveLayer::MergeFrom(from._internal_prim());
  }
  if (from._internal_has_boundary_layer()) {
    _internal_mutable_boundary_layer()->::vlsir::raw::Layer::MergeFrom(from._internal_boundary_layer());
  }
  if (from._internal_units() != 0) {
    _internal_set_units(from._internal_units());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stack::CopyFrom(const Stack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Stack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stack::IsInitialized() const {
  return true;
}

void Stack::InternalSwap(Stack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  metals_.InternalSwap(&other->metals_);
  vias_.InternalSwap(&other->vias_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stack, units_)
      + sizeof(Stack::units_)
      - PROTOBUF_FIELD_OFFSET(Stack, prim_)>(
          reinterpret_cast<char*>(&prim_),
          reinterpret_cast<char*>(&other->prim_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stack::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[15]);
}

// ===================================================================

class LayerEnum::_Internal {
 public:
};

LayerEnum::LayerEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.LayerEnum)
}
LayerEnum::LayerEnum(const LayerEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&index_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.LayerEnum)
}

inline void LayerEnum::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&index_)) + sizeof(type_));
}

LayerEnum::~LayerEnum() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.LayerEnum)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LayerEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LayerEnum::ArenaDtor(void* object) {
  LayerEnum* _this = reinterpret_cast< LayerEnum* >(object);
  (void)_this;
}
void LayerEnum::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LayerEnum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LayerEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.LayerEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&index_)) + sizeof(type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LayerEnum::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.LayerEnum.LayerType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::vlsir::tetris::LayerEnum_LayerType>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LayerEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.LayerEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // int64 index = 2;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.LayerEnum)
  return target;
}

size_t LayerEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.LayerEnum)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 index = 2;
  if (this->_internal_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_index());
  }

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LayerEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LayerEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LayerEnum::GetClassData() const { return &_class_data_; }

void LayerEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LayerEnum *>(to)->MergeFrom(
      static_cast<const LayerEnum &>(from));
}


void LayerEnum::MergeFrom(const LayerEnum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.LayerEnum)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_index() != 0) {
    _internal_set_index(from._internal_index());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LayerEnum::CopyFrom(const LayerEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.LayerEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerEnum::IsInitialized() const {
  return true;
}

void LayerEnum::InternalSwap(LayerEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LayerEnum, type_)
      + sizeof(LayerEnum::type_)
      - PROTOBUF_FIELD_OFFSET(LayerEnum, index_)>(
          reinterpret_cast<char*>(&index_),
          reinterpret_cast<char*>(&other->index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LayerEnum::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[16]);
}

// ===================================================================

class MetalLayer::_Internal {
 public:
  static const ::vlsir::raw::Layer& raw(const MetalLayer* msg);
};

const ::vlsir::raw::Layer&
MetalLayer::_Internal::raw(const MetalLayer* msg) {
  return *msg->raw_;
}
void MetalLayer::clear_raw() {
  if (GetArenaForAllocation() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
}
MetalLayer::MetalLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.MetalLayer)
}
MetalLayer::MetalLayer(const MetalLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_raw()) {
    raw_ = new ::vlsir::raw::Layer(*from.raw_);
  } else {
    raw_ = nullptr;
  }
  ::memcpy(&cutsize_, &from.cutsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&prim_) -
    reinterpret_cast<char*>(&cutsize_)) + sizeof(prim_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.MetalLayer)
}

inline void MetalLayer::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&raw_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prim_) -
    reinterpret_cast<char*>(&raw_)) + sizeof(prim_));
}

MetalLayer::~MetalLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.MetalLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MetalLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete raw_;
}

void MetalLayer::ArenaDtor(void* object) {
  MetalLayer* _this = reinterpret_cast< MetalLayer* >(object);
  (void)_this;
}
void MetalLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MetalLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MetalLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.MetalLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
  ::memset(&cutsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prim_) -
      reinterpret_cast<char*>(&cutsize_)) + sizeof(prim_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MetalLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.MetalLayer.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.MetalLayer.Dir dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::vlsir::tetris::MetalLayer_Dir>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 cutsize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          cutsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.TrackSpec entries = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 overlap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool flip = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          flip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_prim(static_cast<::vlsir::tetris::MetalLayer_PrimitiveMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.raw.Layer raw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MetalLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.MetalLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.MetalLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_dir(), target);
  }

  // int64 cutsize = 3;
  if (this->_internal_cutsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_cutsize(), target);
  }

  // repeated .vlsir.tetris.TrackSpec entries = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_entries(i), target, stream);
  }

  // int64 offset = 5;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_offset(), target);
  }

  // int64 overlap = 6;
  if (this->_internal_overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_overlap(), target);
  }

  // bool flip = 7;
  if (this->_internal_flip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_flip(), target);
  }

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  if (this->_internal_prim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_prim(), target);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::raw(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.MetalLayer)
  return target;
}

size_t MetalLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.MetalLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec entries = 4;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *raw_);
  }

  // int64 cutsize = 3;
  if (this->_internal_cutsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_cutsize());
  }

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dir());
  }

  // bool flip = 7;
  if (this->_internal_flip() != 0) {
    total_size += 1 + 1;
  }

  // int64 offset = 5;
  if (this->_internal_offset() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  // int64 overlap = 6;
  if (this->_internal_overlap() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_overlap());
  }

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  if (this->_internal_prim() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_prim());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MetalLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MetalLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MetalLayer::GetClassData() const { return &_class_data_; }

void MetalLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MetalLayer *>(to)->MergeFrom(
      static_cast<const MetalLayer &>(from));
}


void MetalLayer::MergeFrom(const MetalLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.MetalLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_raw()) {
    _internal_mutable_raw()->::vlsir::raw::Layer::MergeFrom(from._internal_raw());
  }
  if (from._internal_cutsize() != 0) {
    _internal_set_cutsize(from._internal_cutsize());
  }
  if (from._internal_dir() != 0) {
    _internal_set_dir(from._internal_dir());
  }
  if (from._internal_flip() != 0) {
    _internal_set_flip(from._internal_flip());
  }
  if (from._internal_offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  if (from._internal_overlap() != 0) {
    _internal_set_overlap(from._internal_overlap());
  }
  if (from._internal_prim() != 0) {
    _internal_set_prim(from._internal_prim());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MetalLayer::CopyFrom(const MetalLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.MetalLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetalLayer::IsInitialized() const {
  return true;
}

void MetalLayer::InternalSwap(MetalLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MetalLayer, prim_)
      + sizeof(MetalLayer::prim_)
      - PROTOBUF_FIELD_OFFSET(MetalLayer, raw_)>(
          reinterpret_cast<char*>(&raw_),
          reinterpret_cast<char*>(&other->raw_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MetalLayer::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[17]);
}

// ===================================================================

class ViaLayer::_Internal {
 public:
  static const ::vlsir::tetris::LayerEnum& top(const ViaLayer* msg);
  static const ::vlsir::tetris::LayerEnum& bot(const ViaLayer* msg);
  static const ::vlsir::tetris::Xy& size(const ViaLayer* msg);
  static const ::vlsir::raw::Layer& raw(const ViaLayer* msg);
};

const ::vlsir::tetris::LayerEnum&
ViaLayer::_Internal::top(const ViaLayer* msg) {
  return *msg->top_;
}
const ::vlsir::tetris::LayerEnum&
ViaLayer::_Internal::bot(const ViaLayer* msg) {
  return *msg->bot_;
}
const ::vlsir::tetris::Xy&
ViaLayer::_Internal::size(const ViaLayer* msg) {
  return *msg->size_;
}
const ::vlsir::raw::Layer&
ViaLayer::_Internal::raw(const ViaLayer* msg) {
  return *msg->raw_;
}
void ViaLayer::clear_raw() {
  if (GetArenaForAllocation() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
}
ViaLayer::ViaLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.ViaLayer)
}
ViaLayer::ViaLayer(const ViaLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_top()) {
    top_ = new ::vlsir::tetris::LayerEnum(*from.top_);
  } else {
    top_ = nullptr;
  }
  if (from._internal_has_bot()) {
    bot_ = new ::vlsir::tetris::LayerEnum(*from.bot_);
  } else {
    bot_ = nullptr;
  }
  if (from._internal_has_size()) {
    size_ = new ::vlsir::tetris::Xy(*from.size_);
  } else {
    size_ = nullptr;
  }
  if (from._internal_has_raw()) {
    raw_ = new ::vlsir::raw::Layer(*from.raw_);
  } else {
    raw_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.ViaLayer)
}

inline void ViaLayer::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&top_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&raw_) -
    reinterpret_cast<char*>(&top_)) + sizeof(raw_));
}

ViaLayer::~ViaLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.ViaLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ViaLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete top_;
  if (this != internal_default_instance()) delete bot_;
  if (this != internal_default_instance()) delete size_;
  if (this != internal_default_instance()) delete raw_;
}

void ViaLayer::ArenaDtor(void* object) {
  ViaLayer* _this = reinterpret_cast< ViaLayer* >(object);
  (void)_this;
}
void ViaLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ViaLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ViaLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.ViaLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && top_ != nullptr) {
    delete top_;
  }
  top_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bot_ != nullptr) {
    delete bot_;
  }
  bot_ = nullptr;
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
  if (GetArenaForAllocation() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ViaLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.ViaLayer.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.LayerEnum top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_top(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.LayerEnum bot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Xy size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.raw.Layer raw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViaLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.ViaLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.ViaLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.LayerEnum top = 2;
  if (this->_internal_has_top()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::top(this), target, stream);
  }

  // .vlsir.tetris.LayerEnum bot = 3;
  if (this->_internal_has_bot()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::bot(this), target, stream);
  }

  // .vlsir.tetris.Xy size = 4;
  if (this->_internal_has_size()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::size(this), target, stream);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::raw(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.ViaLayer)
  return target;
}

size_t ViaLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.ViaLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.LayerEnum top = 2;
  if (this->_internal_has_top()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *top_);
  }

  // .vlsir.tetris.LayerEnum bot = 3;
  if (this->_internal_has_bot()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bot_);
  }

  // .vlsir.tetris.Xy size = 4;
  if (this->_internal_has_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *size_);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *raw_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ViaLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ViaLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ViaLayer::GetClassData() const { return &_class_data_; }

void ViaLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ViaLayer *>(to)->MergeFrom(
      static_cast<const ViaLayer &>(from));
}


void ViaLayer::MergeFrom(const ViaLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.ViaLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_top()) {
    _internal_mutable_top()->::vlsir::tetris::LayerEnum::MergeFrom(from._internal_top());
  }
  if (from._internal_has_bot()) {
    _internal_mutable_bot()->::vlsir::tetris::LayerEnum::MergeFrom(from._internal_bot());
  }
  if (from._internal_has_size()) {
    _internal_mutable_size()->::vlsir::tetris::Xy::MergeFrom(from._internal_size());
  }
  if (from._internal_has_raw()) {
    _internal_mutable_raw()->::vlsir::raw::Layer::MergeFrom(from._internal_raw());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ViaLayer::CopyFrom(const ViaLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.ViaLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViaLayer::IsInitialized() const {
  return true;
}

void ViaLayer::InternalSwap(ViaLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ViaLayer, raw_)
      + sizeof(ViaLayer::raw_)
      - PROTOBUF_FIELD_OFFSET(ViaLayer, top_)>(
          reinterpret_cast<char*>(&top_),
          reinterpret_cast<char*>(&other->top_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ViaLayer::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[18]);
}

// ===================================================================

class PrimitiveLayer::_Internal {
 public:
  static const ::vlsir::tetris::Xy& pitches(const PrimitiveLayer* msg);
};

const ::vlsir::tetris::Xy&
PrimitiveLayer::_Internal::pitches(const PrimitiveLayer* msg) {
  return *msg->pitches_;
}
PrimitiveLayer::PrimitiveLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.PrimitiveLayer)
}
PrimitiveLayer::PrimitiveLayer(const PrimitiveLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pitches()) {
    pitches_ = new ::vlsir::tetris::Xy(*from.pitches_);
  } else {
    pitches_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.PrimitiveLayer)
}

inline void PrimitiveLayer::SharedCtor() {
pitches_ = nullptr;
}

PrimitiveLayer::~PrimitiveLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.PrimitiveLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PrimitiveLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete pitches_;
}

void PrimitiveLayer::ArenaDtor(void* object) {
  PrimitiveLayer* _this = reinterpret_cast< PrimitiveLayer* >(object);
  (void)_this;
}
void PrimitiveLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrimitiveLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PrimitiveLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.PrimitiveLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && pitches_ != nullptr) {
    delete pitches_;
  }
  pitches_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrimitiveLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.Xy pitches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pitches(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrimitiveLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.PrimitiveLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.Xy pitches = 1;
  if (this->_internal_has_pitches()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pitches(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.PrimitiveLayer)
  return target;
}

size_t PrimitiveLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.PrimitiveLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.Xy pitches = 1;
  if (this->_internal_has_pitches()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pitches_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrimitiveLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PrimitiveLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrimitiveLayer::GetClassData() const { return &_class_data_; }

void PrimitiveLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PrimitiveLayer *>(to)->MergeFrom(
      static_cast<const PrimitiveLayer &>(from));
}


void PrimitiveLayer::MergeFrom(const PrimitiveLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.PrimitiveLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pitches()) {
    _internal_mutable_pitches()->::vlsir::tetris::Xy::MergeFrom(from._internal_pitches());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrimitiveLayer::CopyFrom(const PrimitiveLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.PrimitiveLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimitiveLayer::IsInitialized() const {
  return true;
}

void PrimitiveLayer::InternalSwap(PrimitiveLayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(pitches_, other->pitches_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrimitiveLayer::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[19]);
}

// ===================================================================

class TrackSpec_TrackEntry::_Internal {
 public:
};

TrackSpec_TrackEntry::TrackSpec_TrackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec.TrackEntry)
}
TrackSpec_TrackEntry::TrackSpec_TrackEntry(const TrackSpec_TrackEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&ttype_) -
    reinterpret_cast<char*>(&width_)) + sizeof(ttype_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec.TrackEntry)
}

inline void TrackSpec_TrackEntry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ttype_) -
    reinterpret_cast<char*>(&width_)) + sizeof(ttype_));
}

TrackSpec_TrackEntry::~TrackSpec_TrackEntry() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec.TrackEntry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TrackSpec_TrackEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TrackSpec_TrackEntry::ArenaDtor(void* object) {
  TrackSpec_TrackEntry* _this = reinterpret_cast< TrackSpec_TrackEntry* >(object);
  (void)_this;
}
void TrackSpec_TrackEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackSpec_TrackEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrackSpec_TrackEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec.TrackEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ttype_) -
      reinterpret_cast<char*>(&width_)) + sizeof(ttype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec_TrackEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ttype(static_cast<::vlsir::tetris::TrackSpec_TrackEntry_TrackType>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackSpec_TrackEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec.TrackEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  if (this->_internal_ttype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ttype(), target);
  }

  // int64 width = 2;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec.TrackEntry)
  return target;
}

size_t TrackSpec_TrackEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec.TrackEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 width = 2;
  if (this->_internal_width() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_width());
  }

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  if (this->_internal_ttype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ttype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackSpec_TrackEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrackSpec_TrackEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackSpec_TrackEntry::GetClassData() const { return &_class_data_; }

void TrackSpec_TrackEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrackSpec_TrackEntry *>(to)->MergeFrom(
      static_cast<const TrackSpec_TrackEntry &>(from));
}


void TrackSpec_TrackEntry::MergeFrom(const TrackSpec_TrackEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from._internal_ttype() != 0) {
    _internal_set_ttype(from._internal_ttype());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackSpec_TrackEntry::CopyFrom(const TrackSpec_TrackEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec_TrackEntry::IsInitialized() const {
  return true;
}

void TrackSpec_TrackEntry::InternalSwap(TrackSpec_TrackEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackSpec_TrackEntry, ttype_)
      + sizeof(TrackSpec_TrackEntry::ttype_)
      - PROTOBUF_FIELD_OFFSET(TrackSpec_TrackEntry, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec_TrackEntry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[20]);
}

// ===================================================================

class TrackSpec_Repeat::_Internal {
 public:
};

TrackSpec_Repeat::TrackSpec_Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec.Repeat)
}
TrackSpec_Repeat::TrackSpec_Repeat(const TrackSpec_Repeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nrep_ = from.nrep_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec.Repeat)
}

inline void TrackSpec_Repeat::SharedCtor() {
nrep_ = int64_t{0};
}

TrackSpec_Repeat::~TrackSpec_Repeat() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec.Repeat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TrackSpec_Repeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TrackSpec_Repeat::ArenaDtor(void* object) {
  TrackSpec_Repeat* _this = reinterpret_cast< TrackSpec_Repeat* >(object);
  (void)_this;
}
void TrackSpec_Repeat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackSpec_Repeat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrackSpec_Repeat::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec.Repeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  nrep_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec_Repeat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 nrep = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          nrep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackSpec_Repeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec.Repeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  // int64 nrep = 2;
  if (this->_internal_nrep() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_nrep(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec.Repeat)
  return target;
}

size_t TrackSpec_Repeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec.Repeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 nrep = 2;
  if (this->_internal_nrep() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_nrep());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackSpec_Repeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrackSpec_Repeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackSpec_Repeat::GetClassData() const { return &_class_data_; }

void TrackSpec_Repeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrackSpec_Repeat *>(to)->MergeFrom(
      static_cast<const TrackSpec_Repeat &>(from));
}


void TrackSpec_Repeat::MergeFrom(const TrackSpec_Repeat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec.Repeat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  if (from._internal_nrep() != 0) {
    _internal_set_nrep(from._internal_nrep());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackSpec_Repeat::CopyFrom(const TrackSpec_Repeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec.Repeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec_Repeat::IsInitialized() const {
  return true;
}

void TrackSpec_Repeat::InternalSwap(TrackSpec_Repeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
  swap(nrep_, other->nrep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec_Repeat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[21]);
}

// ===================================================================

class TrackSpec::_Internal {
 public:
  static const ::vlsir::tetris::TrackSpec_TrackEntry& entry(const TrackSpec* msg);
  static const ::vlsir::tetris::TrackSpec_Repeat& repeat(const TrackSpec* msg);
};

const ::vlsir::tetris::TrackSpec_TrackEntry&
TrackSpec::_Internal::entry(const TrackSpec* msg) {
  return *msg->spec_.entry_;
}
const ::vlsir::tetris::TrackSpec_Repeat&
TrackSpec::_Internal::repeat(const TrackSpec* msg) {
  return *msg->spec_.repeat_;
}
void TrackSpec::set_allocated_entry(::vlsir::tetris::TrackSpec_TrackEntry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_spec();
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackSpec_TrackEntry>::GetOwningArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    set_has_entry();
    spec_.entry_ = entry;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackSpec.entry)
}
void TrackSpec::set_allocated_repeat(::vlsir::tetris::TrackSpec_Repeat* repeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_spec();
  if (repeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::tetris::TrackSpec_Repeat>::GetOwningArena(repeat);
    if (message_arena != submessage_arena) {
      repeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeat, submessage_arena);
    }
    set_has_repeat();
    spec_.repeat_ = repeat;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackSpec.repeat)
}
TrackSpec::TrackSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec)
}
TrackSpec::TrackSpec(const TrackSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_spec();
  switch (from.spec_case()) {
    case kEntry: {
      _internal_mutable_entry()->::vlsir::tetris::TrackSpec_TrackEntry::MergeFrom(from._internal_entry());
      break;
    }
    case kRepeat: {
      _internal_mutable_repeat()->::vlsir::tetris::TrackSpec_Repeat::MergeFrom(from._internal_repeat());
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec)
}

inline void TrackSpec::SharedCtor() {
clear_has_spec();
}

TrackSpec::~TrackSpec() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TrackSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_spec()) {
    clear_spec();
  }
}

void TrackSpec::ArenaDtor(void* object) {
  TrackSpec* _this = reinterpret_cast< TrackSpec* >(object);
  (void)_this;
}
void TrackSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrackSpec::clear_spec() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.TrackSpec)
  switch (spec_case()) {
    case kEntry: {
      if (GetArenaForAllocation() == nullptr) {
        delete spec_.entry_;
      }
      break;
    }
    case kRepeat: {
      if (GetArenaForAllocation() == nullptr) {
        delete spec_.repeat_;
      }
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SPEC_NOT_SET;
}


void TrackSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_spec();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_entry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
  if (_internal_has_entry()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::entry(this), target, stream);
  }

  // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
  if (_internal_has_repeat()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::repeat(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec)
  return target;
}

size_t TrackSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (spec_case()) {
    // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
    case kEntry: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_.entry_);
      break;
    }
    // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
    case kRepeat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_.repeat_);
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrackSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackSpec::GetClassData() const { return &_class_data_; }

void TrackSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrackSpec *>(to)->MergeFrom(
      static_cast<const TrackSpec &>(from));
}


void TrackSpec::MergeFrom(const TrackSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.spec_case()) {
    case kEntry: {
      _internal_mutable_entry()->::vlsir::tetris::TrackSpec_TrackEntry::MergeFrom(from._internal_entry());
      break;
    }
    case kRepeat: {
      _internal_mutable_repeat()->::vlsir::tetris::TrackSpec_Repeat::MergeFrom(from._internal_repeat());
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackSpec::CopyFrom(const TrackSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec::IsInitialized() const {
  return true;
}

void TrackSpec::InternalSwap(TrackSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(spec_, other->spec_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[22]);
}

// ===================================================================

class Xy::_Internal {
 public:
};

Xy::Xy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Xy)
}
Xy::Xy(const Xy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Xy)
}

inline void Xy::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Xy::~Xy() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Xy)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Xy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Xy::ArenaDtor(void* object) {
  Xy* _this = reinterpret_cast< Xy* >(object);
  (void)_this;
}
void Xy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Xy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Xy::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Xy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Xy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Xy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Xy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_x(), target);
  }

  // int64 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Xy)
  return target;
}

size_t Xy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Xy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_x());
  }

  // int64 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_y());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Xy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Xy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Xy::GetClassData() const { return &_class_data_; }

void Xy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Xy *>(to)->MergeFrom(
      static_cast<const Xy &>(from));
}


void Xy::MergeFrom(const Xy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Xy)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _internal_set_y(from._internal_y());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Xy::CopyFrom(const Xy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Xy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Xy::IsInitialized() const {
  return true;
}

void Xy::InternalSwap(Xy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Xy, y_)
      + sizeof(Xy::y_)
      - PROTOBUF_FIELD_OFFSET(Xy, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Xy::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace tetris
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Library* Arena::CreateMaybeMessage< ::vlsir::tetris::Library >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Library >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Cell* Arena::CreateMaybeMessage< ::vlsir::tetris::Cell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Cell >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Layout* Arena::CreateMaybeMessage< ::vlsir::tetris::Layout >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Layout >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Assign* Arena::CreateMaybeMessage< ::vlsir::tetris::Assign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Assign >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackCross* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackCross >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackCross >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackRef* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackRef >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Outline* Arena::CreateMaybeMessage< ::vlsir::tetris::Outline >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Outline >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Abstract* Arena::CreateMaybeMessage< ::vlsir::tetris::Abstract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Abstract >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_EdgePort* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_EdgePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_EdgePort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_ZTopEdgePort* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_ZTopInner* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopInner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_ZTopInner >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Instance* Arena::CreateMaybeMessage< ::vlsir::tetris::Instance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Instance >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Place* Arena::CreateMaybeMessage< ::vlsir::tetris::Place >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Place >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::RelPlace* Arena::CreateMaybeMessage< ::vlsir::tetris::RelPlace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::RelPlace >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Stack* Arena::CreateMaybeMessage< ::vlsir::tetris::Stack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Stack >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::LayerEnum* Arena::CreateMaybeMessage< ::vlsir::tetris::LayerEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::LayerEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::MetalLayer* Arena::CreateMaybeMessage< ::vlsir::tetris::MetalLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::MetalLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::ViaLayer* Arena::CreateMaybeMessage< ::vlsir::tetris::ViaLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::ViaLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::PrimitiveLayer* Arena::CreateMaybeMessage< ::vlsir::tetris::PrimitiveLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::PrimitiveLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec_TrackEntry* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec_TrackEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec_TrackEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec_Repeat* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec_Repeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec_Repeat >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Xy* Arena::CreateMaybeMessage< ::vlsir::tetris::Xy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Xy >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
