// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: circuit.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_circuit_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_circuit_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_circuit_2eproto;
namespace vlsir {
namespace circuit {
class Concat;
struct ConcatDefaultTypeInternal;
extern ConcatDefaultTypeInternal _Concat_default_instance_;
class Connection;
struct ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class ConnectionTarget;
struct ConnectionTargetDefaultTypeInternal;
extern ConnectionTargetDefaultTypeInternal _ConnectionTarget_default_instance_;
class ExternalModule;
struct ExternalModuleDefaultTypeInternal;
extern ExternalModuleDefaultTypeInternal _ExternalModule_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Interface;
struct InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class Module;
struct ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class Port;
struct PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class Signal;
struct SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Slice;
struct SliceDefaultTypeInternal;
extern SliceDefaultTypeInternal _Slice_default_instance_;
}  // namespace circuit
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::circuit::Concat* Arena::CreateMaybeMessage<::vlsir::circuit::Concat>(Arena*);
template<> ::vlsir::circuit::Connection* Arena::CreateMaybeMessage<::vlsir::circuit::Connection>(Arena*);
template<> ::vlsir::circuit::ConnectionTarget* Arena::CreateMaybeMessage<::vlsir::circuit::ConnectionTarget>(Arena*);
template<> ::vlsir::circuit::ExternalModule* Arena::CreateMaybeMessage<::vlsir::circuit::ExternalModule>(Arena*);
template<> ::vlsir::circuit::Instance* Arena::CreateMaybeMessage<::vlsir::circuit::Instance>(Arena*);
template<> ::vlsir::circuit::Interface* Arena::CreateMaybeMessage<::vlsir::circuit::Interface>(Arena*);
template<> ::vlsir::circuit::Module* Arena::CreateMaybeMessage<::vlsir::circuit::Module>(Arena*);
template<> ::vlsir::circuit::Package* Arena::CreateMaybeMessage<::vlsir::circuit::Package>(Arena*);
template<> ::vlsir::circuit::Port* Arena::CreateMaybeMessage<::vlsir::circuit::Port>(Arena*);
template<> ::vlsir::circuit::Signal* Arena::CreateMaybeMessage<::vlsir::circuit::Signal>(Arena*);
template<> ::vlsir::circuit::Slice* Arena::CreateMaybeMessage<::vlsir::circuit::Slice>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace circuit {

enum Port_Direction : int {
  Port_Direction_INPUT = 0,
  Port_Direction_OUTPUT = 1,
  Port_Direction_INOUT = 2,
  Port_Direction_NONE = 3,
  Port_Direction_Port_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Port_Direction_Port_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Port_Direction_IsValid(int value);
constexpr Port_Direction Port_Direction_Direction_MIN = Port_Direction_INPUT;
constexpr Port_Direction Port_Direction_Direction_MAX = Port_Direction_NONE;
constexpr int Port_Direction_Direction_ARRAYSIZE = Port_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Port_Direction_descriptor();
template<typename T>
inline const std::string& Port_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Port_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Port_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Port_Direction_descriptor(), enum_t_value);
}
inline bool Port_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Port_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Port_Direction>(
    Port_Direction_descriptor(), name, value);
}
// ===================================================================

class Package final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() override;
  explicit constexpr Package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Package(const Package& from);
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Package& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Package";
  }
  protected:
  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 2,
    kExtModulesFieldNumber = 3,
    kDomainFieldNumber = 1,
    kDescFieldNumber = 10,
  };
  // repeated .vlsir.circuit.Module modules = 2;
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::vlsir::circuit::Module* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >*
      mutable_modules();
  private:
  const ::vlsir::circuit::Module& _internal_modules(int index) const;
  ::vlsir::circuit::Module* _internal_add_modules();
  public:
  const ::vlsir::circuit::Module& modules(int index) const;
  ::vlsir::circuit::Module* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >&
      modules() const;

  // repeated .vlsir.circuit.ExternalModule ext_modules = 3;
  int ext_modules_size() const;
  private:
  int _internal_ext_modules_size() const;
  public:
  void clear_ext_modules();
  ::vlsir::circuit::ExternalModule* mutable_ext_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
      mutable_ext_modules();
  private:
  const ::vlsir::circuit::ExternalModule& _internal_ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* _internal_add_ext_modules();
  public:
  const ::vlsir::circuit::ExternalModule& ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* add_ext_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
      ext_modules() const;

  // string domain = 1;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string desc = 10;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module > modules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule > ext_modules_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Port final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Port) */ {
 public:
  inline Port() : Port(nullptr) {}
  ~Port() override;
  explicit constexpr Port(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Port(const Port& from);
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline Port& operator=(Port&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Port& default_instance() {
    return *internal_default_instance();
  }
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }
  inline void Swap(Port* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Port& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Port& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Port";
  }
  protected:
  explicit Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Port_Direction Direction;
  static constexpr Direction INPUT =
    Port_Direction_INPUT;
  static constexpr Direction OUTPUT =
    Port_Direction_OUTPUT;
  static constexpr Direction INOUT =
    Port_Direction_INOUT;
  static constexpr Direction NONE =
    Port_Direction_NONE;
  static inline bool Direction_IsValid(int value) {
    return Port_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    Port_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    Port_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    Port_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return Port_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return Port_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return Port_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSignalFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // string signal = 1;
  void clear_signal();
  const std::string& signal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signal();
  PROTOBUF_NODISCARD std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  private:
  const std::string& _internal_signal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  // .vlsir.circuit.Port.Direction direction = 2;
  void clear_direction();
  ::vlsir::circuit::Port_Direction direction() const;
  void set_direction(::vlsir::circuit::Port_Direction value);
  private:
  ::vlsir::circuit::Port_Direction _internal_direction() const;
  void _internal_set_direction(::vlsir::circuit::Port_Direction value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Signal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {}
  ~Signal() override;
  explicit constexpr Signal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Signal";
  }
  protected:
  explicit Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kWidthFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 width = 2;
  void clear_width();
  int64_t width() const;
  void set_width(int64_t value);
  private:
  int64_t _internal_width() const;
  void _internal_set_width(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Signal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int64_t width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Slice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Slice) */ {
 public:
  inline Slice() : Slice(nullptr) {}
  ~Slice() override;
  explicit constexpr Slice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Slice(const Slice& from);
  Slice(Slice&& from) noexcept
    : Slice() {
    *this = ::std::move(from);
  }

  inline Slice& operator=(const Slice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Slice& operator=(Slice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Slice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Slice* internal_default_instance() {
    return reinterpret_cast<const Slice*>(
               &_Slice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Slice& a, Slice& b) {
    a.Swap(&b);
  }
  inline void Swap(Slice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Slice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Slice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Slice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Slice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Slice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Slice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Slice";
  }
  protected:
  explicit Slice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalFieldNumber = 1,
    kTopFieldNumber = 2,
    kBotFieldNumber = 3,
  };
  // string signal = 1;
  void clear_signal();
  const std::string& signal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signal();
  PROTOBUF_NODISCARD std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  private:
  const std::string& _internal_signal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  // int64 top = 2;
  void clear_top();
  int64_t top() const;
  void set_top(int64_t value);
  private:
  int64_t _internal_top() const;
  void _internal_set_top(int64_t value);
  public:

  // int64 bot = 3;
  void clear_bot();
  int64_t bot() const;
  void set_bot(int64_t value);
  private:
  int64_t _internal_bot() const;
  void _internal_set_bot(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Slice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  int64_t top_;
  int64_t bot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Concat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Concat) */ {
 public:
  inline Concat() : Concat(nullptr) {}
  ~Concat() override;
  explicit constexpr Concat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Concat(const Concat& from);
  Concat(Concat&& from) noexcept
    : Concat() {
    *this = ::std::move(from);
  }

  inline Concat& operator=(const Concat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Concat& operator=(Concat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Concat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Concat* internal_default_instance() {
    return reinterpret_cast<const Concat*>(
               &_Concat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Concat& a, Concat& b) {
    a.Swap(&b);
  }
  inline void Swap(Concat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Concat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Concat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Concat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Concat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Concat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Concat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Concat";
  }
  protected:
  explicit Concat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
  };
  // repeated .vlsir.circuit.ConnectionTarget parts = 1;
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::vlsir::circuit::ConnectionTarget* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >*
      mutable_parts();
  private:
  const ::vlsir::circuit::ConnectionTarget& _internal_parts(int index) const;
  ::vlsir::circuit::ConnectionTarget* _internal_add_parts();
  public:
  const ::vlsir::circuit::ConnectionTarget& parts(int index) const;
  ::vlsir::circuit::ConnectionTarget* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >&
      parts() const;

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Concat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget > parts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class ConnectionTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ConnectionTarget) */ {
 public:
  inline ConnectionTarget() : ConnectionTarget(nullptr) {}
  ~ConnectionTarget() override;
  explicit constexpr ConnectionTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionTarget(const ConnectionTarget& from);
  ConnectionTarget(ConnectionTarget&& from) noexcept
    : ConnectionTarget() {
    *this = ::std::move(from);
  }

  inline ConnectionTarget& operator=(const ConnectionTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionTarget& operator=(ConnectionTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionTarget& default_instance() {
    return *internal_default_instance();
  }
  enum StypeCase {
    kSig = 1,
    kSlice = 2,
    kConcat = 3,
    STYPE_NOT_SET = 0,
  };

  static inline const ConnectionTarget* internal_default_instance() {
    return reinterpret_cast<const ConnectionTarget*>(
               &_ConnectionTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConnectionTarget& a, ConnectionTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectionTarget& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.ConnectionTarget";
  }
  protected:
  explicit ConnectionTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigFieldNumber = 1,
    kSliceFieldNumber = 2,
    kConcatFieldNumber = 3,
  };
  // string sig = 1;
  bool has_sig() const;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const std::string& sig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sig();
  PROTOBUF_NODISCARD std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // .vlsir.circuit.Slice slice = 2;
  bool has_slice() const;
  private:
  bool _internal_has_slice() const;
  public:
  void clear_slice();
  const ::vlsir::circuit::Slice& slice() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::Slice* release_slice();
  ::vlsir::circuit::Slice* mutable_slice();
  void set_allocated_slice(::vlsir::circuit::Slice* slice);
  private:
  const ::vlsir::circuit::Slice& _internal_slice() const;
  ::vlsir::circuit::Slice* _internal_mutable_slice();
  public:
  void unsafe_arena_set_allocated_slice(
      ::vlsir::circuit::Slice* slice);
  ::vlsir::circuit::Slice* unsafe_arena_release_slice();

  // .vlsir.circuit.Concat concat = 3;
  bool has_concat() const;
  private:
  bool _internal_has_concat() const;
  public:
  void clear_concat();
  const ::vlsir::circuit::Concat& concat() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::Concat* release_concat();
  ::vlsir::circuit::Concat* mutable_concat();
  void set_allocated_concat(::vlsir::circuit::Concat* concat);
  private:
  const ::vlsir::circuit::Concat& _internal_concat() const;
  ::vlsir::circuit::Concat* _internal_mutable_concat();
  public:
  void unsafe_arena_set_allocated_concat(
      ::vlsir::circuit::Concat* concat);
  ::vlsir::circuit::Concat* unsafe_arena_release_concat();

  void clear_stype();
  StypeCase stype_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.circuit.ConnectionTarget)
 private:
  class _Internal;
  void set_has_sig();
  void set_has_slice();
  void set_has_concat();

  inline bool has_stype() const;
  inline void clear_has_stype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StypeUnion {
    constexpr StypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
    ::vlsir::circuit::Slice* slice_;
    ::vlsir::circuit::Concat* concat_;
  } stype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Connection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  ~Connection() override;
  explicit constexpr Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortnameFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // string portname = 1;
  void clear_portname();
  const std::string& portname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_portname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_portname();
  PROTOBUF_NODISCARD std::string* release_portname();
  void set_allocated_portname(std::string* portname);
  private:
  const std::string& _internal_portname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_portname(const std::string& value);
  std::string* _internal_mutable_portname();
  public:

  // .vlsir.circuit.ConnectionTarget target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::vlsir::circuit::ConnectionTarget& target() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::ConnectionTarget* release_target();
  ::vlsir::circuit::ConnectionTarget* mutable_target();
  void set_allocated_target(::vlsir::circuit::ConnectionTarget* target);
  private:
  const ::vlsir::circuit::ConnectionTarget& _internal_target() const;
  ::vlsir::circuit::ConnectionTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::vlsir::circuit::ConnectionTarget* target);
  ::vlsir::circuit::ConnectionTarget* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr portname_;
  ::vlsir::circuit::ConnectionTarget* target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit constexpr Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Instance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kConnectionsFieldNumber = 4,
    kNameFieldNumber = 1,
    kModuleFieldNumber = 2,
  };
  // repeated .vlsir.utils.Param parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  private:
  const ::vlsir::utils::Param& _internal_parameters(int index) const;
  ::vlsir::utils::Param* _internal_add_parameters();
  public:
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // repeated .vlsir.circuit.Connection connections = 4;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  ::vlsir::circuit::Connection* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >*
      mutable_connections();
  private:
  const ::vlsir::circuit::Connection& _internal_connections(int index) const;
  ::vlsir::circuit::Connection* _internal_add_connections();
  public:
  const ::vlsir::circuit::Connection& connections(int index) const;
  ::vlsir::circuit::Connection* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >&
      connections() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.utils.Reference module = 2;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::vlsir::utils::Reference& module() const;
  PROTOBUF_NODISCARD ::vlsir::utils::Reference* release_module();
  ::vlsir::utils::Reference* mutable_module();
  void set_allocated_module(::vlsir::utils::Reference* module);
  private:
  const ::vlsir::utils::Reference& _internal_module() const;
  ::vlsir::utils::Reference* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::vlsir::utils::Reference* module);
  ::vlsir::utils::Reference* unsafe_arena_release_module();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection > connections_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::utils::Reference* module_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Module final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Module) */ {
 public:
  inline Module() : Module(nullptr) {}
  ~Module() override;
  explicit constexpr Module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Module(const Module& from);
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Module& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Module& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Module";
  }
  protected:
  explicit Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 2,
    kSignalsFieldNumber = 3,
    kInstancesFieldNumber = 4,
    kParametersFieldNumber = 5,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 2;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Signal signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  private:
  const ::vlsir::circuit::Signal& _internal_signals(int index) const;
  ::vlsir::circuit::Signal* _internal_add_signals();
  public:
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.circuit.Instance instances = 4;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::circuit::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
      mutable_instances();
  private:
  const ::vlsir::circuit::Instance& _internal_instances(int index) const;
  ::vlsir::circuit::Instance* _internal_add_instances();
  public:
  const ::vlsir::circuit::Instance& instances(int index) const;
  ::vlsir::circuit::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
      instances() const;

  // repeated .vlsir.utils.Param parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  private:
  const ::vlsir::utils::Param& _internal_parameters(int index) const;
  ::vlsir::utils::Param* _internal_add_parameters();
  public:
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance > instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class ExternalModule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ExternalModule) */ {
 public:
  inline ExternalModule() : ExternalModule(nullptr) {}
  ~ExternalModule() override;
  explicit constexpr ExternalModule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalModule(const ExternalModule& from);
  ExternalModule(ExternalModule&& from) noexcept
    : ExternalModule() {
    *this = ::std::move(from);
  }

  inline ExternalModule& operator=(const ExternalModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalModule& operator=(ExternalModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalModule* internal_default_instance() {
    return reinterpret_cast<const ExternalModule*>(
               &_ExternalModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExternalModule& a, ExternalModule& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalModule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalModule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternalModule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExternalModule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalModule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.ExternalModule";
  }
  protected:
  explicit ExternalModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 3,
    kParametersFieldNumber = 5,
    kDescFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 3;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.utils.Param parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  private:
  const ::vlsir::utils::Param& _internal_parameters(int index) const;
  ::vlsir::utils::Param* _internal_add_parameters();
  public:
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // string desc = 2;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // .vlsir.utils.QualifiedName name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::vlsir::utils::QualifiedName& name() const;
  PROTOBUF_NODISCARD ::vlsir::utils::QualifiedName* release_name();
  ::vlsir::utils::QualifiedName* mutable_name();
  void set_allocated_name(::vlsir::utils::QualifiedName* name);
  private:
  const ::vlsir::utils::QualifiedName& _internal_name() const;
  ::vlsir::utils::QualifiedName* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::vlsir::utils::QualifiedName* name);
  ::vlsir::utils::QualifiedName* unsafe_arena_release_name();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.ExternalModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::vlsir::utils::QualifiedName* name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Interface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Interface) */ {
 public:
  inline Interface() : Interface(nullptr) {}
  ~Interface() override;
  explicit constexpr Interface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Interface(const Interface& from);
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interface& operator=(Interface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Interface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }
  inline void Swap(Interface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Interface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Interface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Interface& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Interface";
  }
  protected:
  explicit Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 10,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 10;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Interface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Package

// string domain = 1;
inline void Package::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& Package::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.domain)
}
inline std::string* Package::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.domain)
  return _s;
}
inline const std::string& Package::_internal_domain() const {
  return domain_.Get();
}
inline void Package::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Package::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Package::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.domain)
}

// repeated .vlsir.circuit.Module modules = 2;
inline int Package::_internal_modules_size() const {
  return modules_.size();
}
inline int Package::modules_size() const {
  return _internal_modules_size();
}
inline void Package::clear_modules() {
  modules_.Clear();
}
inline ::vlsir::circuit::Module* Package::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.modules)
  return modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >*
Package::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.modules)
  return &modules_;
}
inline const ::vlsir::circuit::Module& Package::_internal_modules(int index) const {
  return modules_.Get(index);
}
inline const ::vlsir::circuit::Module& Package::modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.modules)
  return _internal_modules(index);
}
inline ::vlsir::circuit::Module* Package::_internal_add_modules() {
  return modules_.Add();
}
inline ::vlsir::circuit::Module* Package::add_modules() {
  ::vlsir::circuit::Module* _add = _internal_add_modules();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >&
Package::modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.modules)
  return modules_;
}

// repeated .vlsir.circuit.ExternalModule ext_modules = 3;
inline int Package::_internal_ext_modules_size() const {
  return ext_modules_.size();
}
inline int Package::ext_modules_size() const {
  return _internal_ext_modules_size();
}
inline void Package::clear_ext_modules() {
  ext_modules_.Clear();
}
inline ::vlsir::circuit::ExternalModule* Package::mutable_ext_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.ext_modules)
  return ext_modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
Package::mutable_ext_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.ext_modules)
  return &ext_modules_;
}
inline const ::vlsir::circuit::ExternalModule& Package::_internal_ext_modules(int index) const {
  return ext_modules_.Get(index);
}
inline const ::vlsir::circuit::ExternalModule& Package::ext_modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.ext_modules)
  return _internal_ext_modules(index);
}
inline ::vlsir::circuit::ExternalModule* Package::_internal_add_ext_modules() {
  return ext_modules_.Add();
}
inline ::vlsir::circuit::ExternalModule* Package::add_ext_modules() {
  ::vlsir::circuit::ExternalModule* _add = _internal_add_ext_modules();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.ext_modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
Package::ext_modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.ext_modules)
  return ext_modules_;
}

// string desc = 10;
inline void Package::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& Package::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.desc)
}
inline std::string* Package::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.desc)
  return _s;
}
inline const std::string& Package::_internal_desc() const {
  return desc_.Get();
}
inline void Package::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Package::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Package::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.desc)
}

// -------------------------------------------------------------------

// Port

// string signal = 1;
inline void Port::clear_signal() {
  signal_.ClearToEmpty();
}
inline const std::string& Port::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.signal)
  return _internal_signal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Port::set_signal(ArgT0&& arg0, ArgT... args) {
 
 signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.signal)
}
inline std::string* Port::mutable_signal() {
  std::string* _s = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Port.signal)
  return _s;
}
inline const std::string& Port::_internal_signal() const {
  return signal_.Get();
}
inline void Port::_internal_set_signal(const std::string& value) {
  
  signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Port::_internal_mutable_signal() {
  
  return signal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Port::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Port.signal)
  return signal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Port::set_allocated_signal(std::string* signal) {
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signal,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signal_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Port.signal)
}

// .vlsir.circuit.Port.Direction direction = 2;
inline void Port::clear_direction() {
  direction_ = 0;
}
inline ::vlsir::circuit::Port_Direction Port::_internal_direction() const {
  return static_cast< ::vlsir::circuit::Port_Direction >(direction_);
}
inline ::vlsir::circuit::Port_Direction Port::direction() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.direction)
  return _internal_direction();
}
inline void Port::_internal_set_direction(::vlsir::circuit::Port_Direction value) {
  
  direction_ = value;
}
inline void Port::set_direction(::vlsir::circuit::Port_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.direction)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Signal::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.name)
}
inline std::string* Signal::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Signal.name)
  return _s;
}
inline const std::string& Signal::_internal_name() const {
  return name_.Get();
}
inline void Signal::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Signal::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Signal.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Signal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Signal.name)
}

// int64 width = 2;
inline void Signal::clear_width() {
  width_ = int64_t{0};
}
inline int64_t Signal::_internal_width() const {
  return width_;
}
inline int64_t Signal::width() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.width)
  return _internal_width();
}
inline void Signal::_internal_set_width(int64_t value) {
  
  width_ = value;
}
inline void Signal::set_width(int64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.width)
}

// -------------------------------------------------------------------

// Slice

// string signal = 1;
inline void Slice::clear_signal() {
  signal_.ClearToEmpty();
}
inline const std::string& Slice::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.signal)
  return _internal_signal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Slice::set_signal(ArgT0&& arg0, ArgT... args) {
 
 signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.signal)
}
inline std::string* Slice::mutable_signal() {
  std::string* _s = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Slice.signal)
  return _s;
}
inline const std::string& Slice::_internal_signal() const {
  return signal_.Get();
}
inline void Slice::_internal_set_signal(const std::string& value) {
  
  signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Slice::_internal_mutable_signal() {
  
  return signal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Slice::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Slice.signal)
  return signal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Slice::set_allocated_signal(std::string* signal) {
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signal,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signal_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Slice.signal)
}

// int64 top = 2;
inline void Slice::clear_top() {
  top_ = int64_t{0};
}
inline int64_t Slice::_internal_top() const {
  return top_;
}
inline int64_t Slice::top() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.top)
  return _internal_top();
}
inline void Slice::_internal_set_top(int64_t value) {
  
  top_ = value;
}
inline void Slice::set_top(int64_t value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.top)
}

// int64 bot = 3;
inline void Slice::clear_bot() {
  bot_ = int64_t{0};
}
inline int64_t Slice::_internal_bot() const {
  return bot_;
}
inline int64_t Slice::bot() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.bot)
  return _internal_bot();
}
inline void Slice::_internal_set_bot(int64_t value) {
  
  bot_ = value;
}
inline void Slice::set_bot(int64_t value) {
  _internal_set_bot(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.bot)
}

// -------------------------------------------------------------------

// Concat

// repeated .vlsir.circuit.ConnectionTarget parts = 1;
inline int Concat::_internal_parts_size() const {
  return parts_.size();
}
inline int Concat::parts_size() const {
  return _internal_parts_size();
}
inline void Concat::clear_parts() {
  parts_.Clear();
}
inline ::vlsir::circuit::ConnectionTarget* Concat::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Concat.parts)
  return parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >*
Concat::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Concat.parts)
  return &parts_;
}
inline const ::vlsir::circuit::ConnectionTarget& Concat::_internal_parts(int index) const {
  return parts_.Get(index);
}
inline const ::vlsir::circuit::ConnectionTarget& Concat::parts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Concat.parts)
  return _internal_parts(index);
}
inline ::vlsir::circuit::ConnectionTarget* Concat::_internal_add_parts() {
  return parts_.Add();
}
inline ::vlsir::circuit::ConnectionTarget* Concat::add_parts() {
  ::vlsir::circuit::ConnectionTarget* _add = _internal_add_parts();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Concat.parts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >&
Concat::parts() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Concat.parts)
  return parts_;
}

// -------------------------------------------------------------------

// ConnectionTarget

// string sig = 1;
inline bool ConnectionTarget::_internal_has_sig() const {
  return stype_case() == kSig;
}
inline bool ConnectionTarget::has_sig() const {
  return _internal_has_sig();
}
inline void ConnectionTarget::set_has_sig() {
  _oneof_case_[0] = kSig;
}
inline void ConnectionTarget::clear_sig() {
  if (_internal_has_sig()) {
    stype_.sig_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_stype();
  }
}
inline const std::string& ConnectionTarget::sig() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.sig)
  return _internal_sig();
}
template <typename ArgT0, typename... ArgT>
inline void ConnectionTarget::set_sig(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.ConnectionTarget.sig)
}
inline std::string* ConnectionTarget::mutable_sig() {
  std::string* _s = _internal_mutable_sig();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.sig)
  return _s;
}
inline const std::string& ConnectionTarget::_internal_sig() const {
  if (_internal_has_sig()) {
    return stype_.sig_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ConnectionTarget::_internal_set_sig(const std::string& value) {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionTarget::_internal_mutable_sig() {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return stype_.sig_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionTarget::release_sig() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.sig)
  if (_internal_has_sig()) {
    clear_has_stype();
    return stype_.sig_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::set_allocated_sig(std::string* sig) {
  if (has_stype()) {
    clear_stype();
  }
  if (sig != nullptr) {
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(sig);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(sig);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ConnectionTarget.sig)
}

// .vlsir.circuit.Slice slice = 2;
inline bool ConnectionTarget::_internal_has_slice() const {
  return stype_case() == kSlice;
}
inline bool ConnectionTarget::has_slice() const {
  return _internal_has_slice();
}
inline void ConnectionTarget::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void ConnectionTarget::clear_slice() {
  if (_internal_has_slice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stype_.slice_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Slice* ConnectionTarget::release_slice() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.slice)
  if (_internal_has_slice()) {
    clear_has_stype();
      ::vlsir::circuit::Slice* temp = stype_.slice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Slice& ConnectionTarget::_internal_slice() const {
  return _internal_has_slice()
      ? *stype_.slice_
      : reinterpret_cast< ::vlsir::circuit::Slice&>(::vlsir::circuit::_Slice_default_instance_);
}
inline const ::vlsir::circuit::Slice& ConnectionTarget::slice() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.slice)
  return _internal_slice();
}
inline ::vlsir::circuit::Slice* ConnectionTarget::unsafe_arena_release_slice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.ConnectionTarget.slice)
  if (_internal_has_slice()) {
    clear_has_stype();
    ::vlsir::circuit::Slice* temp = stype_.slice_;
    stype_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::unsafe_arena_set_allocated_slice(::vlsir::circuit::Slice* slice) {
  clear_stype();
  if (slice) {
    set_has_slice();
    stype_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ConnectionTarget.slice)
}
inline ::vlsir::circuit::Slice* ConnectionTarget::_internal_mutable_slice() {
  if (!_internal_has_slice()) {
    clear_stype();
    set_has_slice();
    stype_.slice_ = CreateMaybeMessage< ::vlsir::circuit::Slice >(GetArenaForAllocation());
  }
  return stype_.slice_;
}
inline ::vlsir::circuit::Slice* ConnectionTarget::mutable_slice() {
  ::vlsir::circuit::Slice* _msg = _internal_mutable_slice();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.slice)
  return _msg;
}

// .vlsir.circuit.Concat concat = 3;
inline bool ConnectionTarget::_internal_has_concat() const {
  return stype_case() == kConcat;
}
inline bool ConnectionTarget::has_concat() const {
  return _internal_has_concat();
}
inline void ConnectionTarget::set_has_concat() {
  _oneof_case_[0] = kConcat;
}
inline void ConnectionTarget::clear_concat() {
  if (_internal_has_concat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stype_.concat_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Concat* ConnectionTarget::release_concat() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.concat)
  if (_internal_has_concat()) {
    clear_has_stype();
      ::vlsir::circuit::Concat* temp = stype_.concat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Concat& ConnectionTarget::_internal_concat() const {
  return _internal_has_concat()
      ? *stype_.concat_
      : reinterpret_cast< ::vlsir::circuit::Concat&>(::vlsir::circuit::_Concat_default_instance_);
}
inline const ::vlsir::circuit::Concat& ConnectionTarget::concat() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.concat)
  return _internal_concat();
}
inline ::vlsir::circuit::Concat* ConnectionTarget::unsafe_arena_release_concat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.ConnectionTarget.concat)
  if (_internal_has_concat()) {
    clear_has_stype();
    ::vlsir::circuit::Concat* temp = stype_.concat_;
    stype_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::unsafe_arena_set_allocated_concat(::vlsir::circuit::Concat* concat) {
  clear_stype();
  if (concat) {
    set_has_concat();
    stype_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ConnectionTarget.concat)
}
inline ::vlsir::circuit::Concat* ConnectionTarget::_internal_mutable_concat() {
  if (!_internal_has_concat()) {
    clear_stype();
    set_has_concat();
    stype_.concat_ = CreateMaybeMessage< ::vlsir::circuit::Concat >(GetArenaForAllocation());
  }
  return stype_.concat_;
}
inline ::vlsir::circuit::Concat* ConnectionTarget::mutable_concat() {
  ::vlsir::circuit::Concat* _msg = _internal_mutable_concat();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.concat)
  return _msg;
}

inline bool ConnectionTarget::has_stype() const {
  return stype_case() != STYPE_NOT_SET;
}
inline void ConnectionTarget::clear_has_stype() {
  _oneof_case_[0] = STYPE_NOT_SET;
}
inline ConnectionTarget::StypeCase ConnectionTarget::stype_case() const {
  return ConnectionTarget::StypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Connection

// string portname = 1;
inline void Connection::clear_portname() {
  portname_.ClearToEmpty();
}
inline const std::string& Connection::portname() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.portname)
  return _internal_portname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_portname(ArgT0&& arg0, ArgT... args) {
 
 portname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Connection.portname)
}
inline std::string* Connection::mutable_portname() {
  std::string* _s = _internal_mutable_portname();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.portname)
  return _s;
}
inline const std::string& Connection::_internal_portname() const {
  return portname_.Get();
}
inline void Connection::_internal_set_portname(const std::string& value) {
  
  portname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_portname() {
  
  return portname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connection::release_portname() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.portname)
  return portname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connection::set_allocated_portname(std::string* portname) {
  if (portname != nullptr) {
    
  } else {
    
  }
  portname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), portname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (portname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    portname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Connection.portname)
}

// .vlsir.circuit.ConnectionTarget target = 2;
inline bool Connection::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool Connection::has_target() const {
  return _internal_has_target();
}
inline void Connection::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::vlsir::circuit::ConnectionTarget& Connection::_internal_target() const {
  const ::vlsir::circuit::ConnectionTarget* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::ConnectionTarget&>(
      ::vlsir::circuit::_ConnectionTarget_default_instance_);
}
inline const ::vlsir::circuit::ConnectionTarget& Connection::target() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.target)
  return _internal_target();
}
inline void Connection::unsafe_arena_set_allocated_target(
    ::vlsir::circuit::ConnectionTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Connection.target)
}
inline ::vlsir::circuit::ConnectionTarget* Connection::release_target() {
  
  ::vlsir::circuit::ConnectionTarget* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.target)
  
  ::vlsir::circuit::ConnectionTarget* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::ConnectionTarget>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::mutable_target() {
  ::vlsir::circuit::ConnectionTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.target)
  return _msg;
}
inline void Connection::set_allocated_target(::vlsir::circuit::ConnectionTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::circuit::ConnectionTarget>::GetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Connection.target)
}

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Instance.name)
}
inline std::string* Instance::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.name)
  return _s;
}
inline const std::string& Instance::_internal_name() const {
  return name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.name)
}

// .vlsir.utils.Reference module = 2;
inline bool Instance::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool Instance::has_module() const {
  return _internal_has_module();
}
inline const ::vlsir::utils::Reference& Instance::_internal_module() const {
  const ::vlsir::utils::Reference* p = module_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::Reference&>(
      ::vlsir::utils::_Reference_default_instance_);
}
inline const ::vlsir::utils::Reference& Instance::module() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.module)
  return _internal_module();
}
inline void Instance::unsafe_arena_set_allocated_module(
    ::vlsir::utils::Reference* module) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Instance.module)
}
inline ::vlsir::utils::Reference* Instance::release_module() {
  
  ::vlsir::utils::Reference* temp = module_;
  module_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::Reference* Instance::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.module)
  
  ::vlsir::utils::Reference* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArenaForAllocation());
    module_ = p;
  }
  return module_;
}
inline ::vlsir::utils::Reference* Instance::mutable_module() {
  ::vlsir::utils::Reference* _msg = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.module)
  return _msg;
}
inline void Instance::set_allocated_module(::vlsir::utils::Reference* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module));
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.module)
}

// repeated .vlsir.utils.Param parameters = 3;
inline int Instance::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Instance::parameters_size() const {
  return _internal_parameters_size();
}
inline ::vlsir::utils::Param* Instance::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
Instance::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Instance.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& Instance::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::utils::Param& Instance::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::utils::Param* Instance::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::utils::Param* Instance::add_parameters() {
  ::vlsir::utils::Param* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Instance.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
Instance::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Instance.parameters)
  return parameters_;
}

// repeated .vlsir.circuit.Connection connections = 4;
inline int Instance::_internal_connections_size() const {
  return connections_.size();
}
inline int Instance::connections_size() const {
  return _internal_connections_size();
}
inline void Instance::clear_connections() {
  connections_.Clear();
}
inline ::vlsir::circuit::Connection* Instance::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.connections)
  return connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >*
Instance::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Instance.connections)
  return &connections_;
}
inline const ::vlsir::circuit::Connection& Instance::_internal_connections(int index) const {
  return connections_.Get(index);
}
inline const ::vlsir::circuit::Connection& Instance::connections(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.connections)
  return _internal_connections(index);
}
inline ::vlsir::circuit::Connection* Instance::_internal_add_connections() {
  return connections_.Add();
}
inline ::vlsir::circuit::Connection* Instance::add_connections() {
  ::vlsir::circuit::Connection* _add = _internal_add_connections();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Instance.connections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >&
Instance::connections() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Instance.connections)
  return connections_;
}

// -------------------------------------------------------------------

// Module

// string name = 1;
inline void Module::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Module.name)
}
inline std::string* Module::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.name)
  return _s;
}
inline const std::string& Module::_internal_name() const {
  return name_.Get();
}
inline void Module::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Module.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Module::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Module.name)
}

// repeated .vlsir.circuit.Port ports = 2;
inline int Module::_internal_ports_size() const {
  return ports_.size();
}
inline int Module::ports_size() const {
  return _internal_ports_size();
}
inline void Module::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Module::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
Module::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Module::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& Module::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* Module::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* Module::add_ports() {
  ::vlsir::circuit::Port* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
Module::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.ports)
  return ports_;
}

// repeated .vlsir.circuit.Signal signals = 3;
inline int Module::_internal_signals_size() const {
  return signals_.size();
}
inline int Module::signals_size() const {
  return _internal_signals_size();
}
inline void Module::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::circuit::Signal* Module::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
Module::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& Module::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const ::vlsir::circuit::Signal& Module::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.signals)
  return _internal_signals(index);
}
inline ::vlsir::circuit::Signal* Module::_internal_add_signals() {
  return signals_.Add();
}
inline ::vlsir::circuit::Signal* Module::add_signals() {
  ::vlsir::circuit::Signal* _add = _internal_add_signals();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.signals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
Module::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.signals)
  return signals_;
}

// repeated .vlsir.circuit.Instance instances = 4;
inline int Module::_internal_instances_size() const {
  return instances_.size();
}
inline int Module::instances_size() const {
  return _internal_instances_size();
}
inline void Module::clear_instances() {
  instances_.Clear();
}
inline ::vlsir::circuit::Instance* Module::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
Module::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.instances)
  return &instances_;
}
inline const ::vlsir::circuit::Instance& Module::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::vlsir::circuit::Instance& Module::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.instances)
  return _internal_instances(index);
}
inline ::vlsir::circuit::Instance* Module::_internal_add_instances() {
  return instances_.Add();
}
inline ::vlsir::circuit::Instance* Module::add_instances() {
  ::vlsir::circuit::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
Module::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.instances)
  return instances_;
}

// repeated .vlsir.utils.Param parameters = 5;
inline int Module::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Module::parameters_size() const {
  return _internal_parameters_size();
}
inline ::vlsir::utils::Param* Module::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
Module::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& Module::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::utils::Param& Module::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::utils::Param* Module::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::utils::Param* Module::add_parameters() {
  ::vlsir::utils::Param* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
Module::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// ExternalModule

// .vlsir.utils.QualifiedName name = 1;
inline bool ExternalModule::_internal_has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline bool ExternalModule::has_name() const {
  return _internal_has_name();
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::_internal_name() const {
  const ::vlsir::utils::QualifiedName* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::QualifiedName&>(
      ::vlsir::utils::_QualifiedName_default_instance_);
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.name)
  return _internal_name();
}
inline void ExternalModule::unsafe_arena_set_allocated_name(
    ::vlsir::utils::QualifiedName* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ExternalModule.name)
}
inline ::vlsir::utils::QualifiedName* ExternalModule::release_name() {
  
  ::vlsir::utils::QualifiedName* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.name)
  
  ::vlsir::utils::QualifiedName* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::_internal_mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::QualifiedName>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::mutable_name() {
  ::vlsir::utils::QualifiedName* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.name)
  return _msg;
}
inline void ExternalModule::set_allocated_name(::vlsir::utils::QualifiedName* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.name)
}

// string desc = 2;
inline void ExternalModule::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& ExternalModule::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalModule::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.ExternalModule.desc)
}
inline std::string* ExternalModule::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.desc)
  return _s;
}
inline const std::string& ExternalModule::_internal_desc() const {
  return desc_.Get();
}
inline void ExternalModule::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExternalModule::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExternalModule::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExternalModule::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.desc)
}

// repeated .vlsir.circuit.Port ports = 3;
inline int ExternalModule::_internal_ports_size() const {
  return ports_.size();
}
inline int ExternalModule::ports_size() const {
  return _internal_ports_size();
}
inline void ExternalModule::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* ExternalModule::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
ExternalModule::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& ExternalModule::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& ExternalModule::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* ExternalModule::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* ExternalModule::add_ports() {
  ::vlsir::circuit::Port* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
ExternalModule::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.ports)
  return ports_;
}

// repeated .vlsir.utils.Param parameters = 5;
inline int ExternalModule::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ExternalModule::parameters_size() const {
  return _internal_parameters_size();
}
inline ::vlsir::utils::Param* ExternalModule::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
ExternalModule::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& ExternalModule::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::utils::Param& ExternalModule::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::utils::Param* ExternalModule::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::utils::Param* ExternalModule::add_parameters() {
  ::vlsir::utils::Param* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
ExternalModule::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// Interface

// string name = 1;
inline void Interface::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Interface::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Interface::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Interface.name)
}
inline std::string* Interface::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.name)
  return _s;
}
inline const std::string& Interface::_internal_name() const {
  return name_.Get();
}
inline void Interface::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Interface::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Interface::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Interface.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Interface::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Interface.name)
}

// repeated .vlsir.circuit.Port ports = 10;
inline int Interface::_internal_ports_size() const {
  return ports_.size();
}
inline int Interface::ports_size() const {
  return _internal_ports_size();
}
inline void Interface::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Interface::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
Interface::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Interface.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Interface::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& Interface::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* Interface::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* Interface::add_ports() {
  ::vlsir::circuit::Port* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Interface.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
Interface::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Interface.ports)
  return ports_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace circuit
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::circuit::Port_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::circuit::Port_Direction>() {
  return ::vlsir::circuit::Port_Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto
