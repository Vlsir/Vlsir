// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: circuit.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_circuit_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_circuit_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_circuit_2eproto;
namespace vlsir {
namespace circuit {
class Concat;
struct ConcatDefaultTypeInternal;
extern ConcatDefaultTypeInternal _Concat_default_instance_;
class Connection;
struct ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class ExternalModule;
struct ExternalModuleDefaultTypeInternal;
extern ExternalModuleDefaultTypeInternal _ExternalModule_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Instance_ConnectionsEntry_DoNotUse;
struct Instance_ConnectionsEntry_DoNotUseDefaultTypeInternal;
extern Instance_ConnectionsEntry_DoNotUseDefaultTypeInternal _Instance_ConnectionsEntry_DoNotUse_default_instance_;
class Instance_ParametersEntry_DoNotUse;
struct Instance_ParametersEntry_DoNotUseDefaultTypeInternal;
extern Instance_ParametersEntry_DoNotUseDefaultTypeInternal _Instance_ParametersEntry_DoNotUse_default_instance_;
class Interface;
struct InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class Module;
struct ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class Parameter;
struct ParameterDefaultTypeInternal;
extern ParameterDefaultTypeInternal _Parameter_default_instance_;
class ParameterValue;
struct ParameterValueDefaultTypeInternal;
extern ParameterValueDefaultTypeInternal _ParameterValue_default_instance_;
class Port;
struct PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class Signal;
struct SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Slice;
struct SliceDefaultTypeInternal;
extern SliceDefaultTypeInternal _Slice_default_instance_;
}  // namespace circuit
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::circuit::Concat* Arena::CreateMaybeMessage<::vlsir::circuit::Concat>(Arena*);
template<> ::vlsir::circuit::Connection* Arena::CreateMaybeMessage<::vlsir::circuit::Connection>(Arena*);
template<> ::vlsir::circuit::ExternalModule* Arena::CreateMaybeMessage<::vlsir::circuit::ExternalModule>(Arena*);
template<> ::vlsir::circuit::Instance* Arena::CreateMaybeMessage<::vlsir::circuit::Instance>(Arena*);
template<> ::vlsir::circuit::Instance_ConnectionsEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::circuit::Instance_ConnectionsEntry_DoNotUse>(Arena*);
template<> ::vlsir::circuit::Instance_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::vlsir::circuit::Instance_ParametersEntry_DoNotUse>(Arena*);
template<> ::vlsir::circuit::Interface* Arena::CreateMaybeMessage<::vlsir::circuit::Interface>(Arena*);
template<> ::vlsir::circuit::Module* Arena::CreateMaybeMessage<::vlsir::circuit::Module>(Arena*);
template<> ::vlsir::circuit::Package* Arena::CreateMaybeMessage<::vlsir::circuit::Package>(Arena*);
template<> ::vlsir::circuit::Parameter* Arena::CreateMaybeMessage<::vlsir::circuit::Parameter>(Arena*);
template<> ::vlsir::circuit::ParameterValue* Arena::CreateMaybeMessage<::vlsir::circuit::ParameterValue>(Arena*);
template<> ::vlsir::circuit::Port* Arena::CreateMaybeMessage<::vlsir::circuit::Port>(Arena*);
template<> ::vlsir::circuit::Signal* Arena::CreateMaybeMessage<::vlsir::circuit::Signal>(Arena*);
template<> ::vlsir::circuit::Slice* Arena::CreateMaybeMessage<::vlsir::circuit::Slice>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace circuit {

enum Port_Direction : int {
  Port_Direction_INPUT = 0,
  Port_Direction_OUTPUT = 1,
  Port_Direction_INOUT = 2,
  Port_Direction_NONE = 3,
  Port_Direction_Port_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Port_Direction_Port_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Port_Direction_IsValid(int value);
constexpr Port_Direction Port_Direction_Direction_MIN = Port_Direction_INPUT;
constexpr Port_Direction Port_Direction_Direction_MAX = Port_Direction_NONE;
constexpr int Port_Direction_Direction_ARRAYSIZE = Port_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Port_Direction_descriptor();
template<typename T>
inline const std::string& Port_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Port_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Port_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Port_Direction_descriptor(), enum_t_value);
}
inline bool Port_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Port_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Port_Direction>(
    Port_Direction_descriptor(), name, value);
}
// ===================================================================

class Package final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() override;
  explicit constexpr Package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Package(const Package& from);
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Package* New() const final {
    return new Package();
  }

  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Package& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Package";
  }
  protected:
  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 2,
    kExtModulesFieldNumber = 3,
    kDomainFieldNumber = 1,
    kDescFieldNumber = 10,
  };
  // repeated .vlsir.circuit.Module modules = 2;
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::vlsir::circuit::Module* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >*
      mutable_modules();
  private:
  const ::vlsir::circuit::Module& _internal_modules(int index) const;
  ::vlsir::circuit::Module* _internal_add_modules();
  public:
  const ::vlsir::circuit::Module& modules(int index) const;
  ::vlsir::circuit::Module* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >&
      modules() const;

  // repeated .vlsir.circuit.ExternalModule ext_modules = 3;
  int ext_modules_size() const;
  private:
  int _internal_ext_modules_size() const;
  public:
  void clear_ext_modules();
  ::vlsir::circuit::ExternalModule* mutable_ext_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
      mutable_ext_modules();
  private:
  const ::vlsir::circuit::ExternalModule& _internal_ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* _internal_add_ext_modules();
  public:
  const ::vlsir::circuit::ExternalModule& ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* add_ext_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
      ext_modules() const;

  // string domain = 1;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_MUST_USE_RESULT std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string desc = 10;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_MUST_USE_RESULT std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module > modules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule > ext_modules_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class ParameterValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ParameterValue) */ {
 public:
  inline ParameterValue() : ParameterValue(nullptr) {}
  ~ParameterValue() override;
  explicit constexpr ParameterValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParameterValue(const ParameterValue& from);
  ParameterValue(ParameterValue&& from) noexcept
    : ParameterValue() {
    *this = ::std::move(from);
  }

  inline ParameterValue& operator=(const ParameterValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterValue& operator=(ParameterValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParameterValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kInteger = 2,
    kDouble = 3,
    kString = 4,
    kLiteral = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const ParameterValue* internal_default_instance() {
    return reinterpret_cast<const ParameterValue*>(
               &_ParameterValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ParameterValue& a, ParameterValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParameterValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParameterValue* New() const final {
    return new ParameterValue();
  }

  ParameterValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParameterValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParameterValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParameterValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.ParameterValue";
  }
  protected:
  explicit ParameterValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegerFieldNumber = 2,
    kDoubleFieldNumber = 3,
    kStringFieldNumber = 4,
    kLiteralFieldNumber = 5,
  };
  // int64 integer = 2;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  ::PROTOBUF_NAMESPACE_ID::int64 integer() const;
  void set_integer(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_integer() const;
  void _internal_set_integer(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double double = 3;
  bool has_double_() const;
  private:
  bool _internal_has_double_() const;
  public:
  void clear_double_();
  double double_() const;
  void set_double_(double value);
  private:
  double _internal_double_() const;
  void _internal_set_double_(double value);
  public:

  // string string = 4;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_MUST_USE_RESULT std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  // string literal = 5;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const std::string& literal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_literal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_literal();
  PROTOBUF_MUST_USE_RESULT std::string* release_literal();
  void set_allocated_literal(std::string* literal);
  private:
  const std::string& _internal_literal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_literal(const std::string& value);
  std::string* _internal_mutable_literal();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.circuit.ParameterValue)
 private:
  class _Internal;
  void set_has_integer();
  void set_has_double_();
  void set_has_string();
  void set_has_literal();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::int64 integer_;
    double double__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr literal_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Parameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Parameter) */ {
 public:
  inline Parameter() : Parameter(nullptr) {}
  ~Parameter() override;
  explicit constexpr Parameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Parameter(const Parameter& from);
  Parameter(Parameter&& from) noexcept
    : Parameter() {
    *this = ::std::move(from);
  }

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parameter& operator=(Parameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Parameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Parameter* internal_default_instance() {
    return reinterpret_cast<const Parameter*>(
               &_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Parameter& a, Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(Parameter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Parameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Parameter* New() const final {
    return new Parameter();
  }

  Parameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Parameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Parameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Parameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Parameter";
  }
  protected:
  explicit Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescFieldNumber = 3,
    kDefaultFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string desc = 3;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_MUST_USE_RESULT std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // .vlsir.circuit.ParameterValue default = 2;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  const ::vlsir::circuit::ParameterValue& default_() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::circuit::ParameterValue* release_default_();
  ::vlsir::circuit::ParameterValue* mutable_default_();
  void set_allocated_default_(::vlsir::circuit::ParameterValue* default_);
  private:
  const ::vlsir::circuit::ParameterValue& _internal_default_() const;
  ::vlsir::circuit::ParameterValue* _internal_mutable_default_();
  public:
  void unsafe_arena_set_allocated_default_(
      ::vlsir::circuit::ParameterValue* default_);
  ::vlsir::circuit::ParameterValue* unsafe_arena_release_default_();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Parameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::vlsir::circuit::ParameterValue* default__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Port final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Port) */ {
 public:
  inline Port() : Port(nullptr) {}
  ~Port() override;
  explicit constexpr Port(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Port(const Port& from);
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline Port& operator=(Port&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Port& default_instance() {
    return *internal_default_instance();
  }
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }
  inline void Swap(Port* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Port* New() const final {
    return new Port();
  }

  Port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Port& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Port& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Port";
  }
  protected:
  explicit Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Port_Direction Direction;
  static constexpr Direction INPUT =
    Port_Direction_INPUT;
  static constexpr Direction OUTPUT =
    Port_Direction_OUTPUT;
  static constexpr Direction INOUT =
    Port_Direction_INOUT;
  static constexpr Direction NONE =
    Port_Direction_NONE;
  static inline bool Direction_IsValid(int value) {
    return Port_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    Port_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    Port_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    Port_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return Port_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return Port_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return Port_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSignalFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // .vlsir.circuit.Signal signal = 1;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  const ::vlsir::circuit::Signal& signal() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::circuit::Signal* release_signal();
  ::vlsir::circuit::Signal* mutable_signal();
  void set_allocated_signal(::vlsir::circuit::Signal* signal);
  private:
  const ::vlsir::circuit::Signal& _internal_signal() const;
  ::vlsir::circuit::Signal* _internal_mutable_signal();
  public:
  void unsafe_arena_set_allocated_signal(
      ::vlsir::circuit::Signal* signal);
  ::vlsir::circuit::Signal* unsafe_arena_release_signal();

  // .vlsir.circuit.Port.Direction direction = 2;
  void clear_direction();
  ::vlsir::circuit::Port_Direction direction() const;
  void set_direction(::vlsir::circuit::Port_Direction value);
  private:
  ::vlsir::circuit::Port_Direction _internal_direction() const;
  void _internal_set_direction(::vlsir::circuit::Port_Direction value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vlsir::circuit::Signal* signal_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Signal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {}
  ~Signal() override;
  explicit constexpr Signal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return new Signal();
  }

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Signal";
  }
  protected:
  explicit Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kWidthFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int64 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Signal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Slice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Slice) */ {
 public:
  inline Slice() : Slice(nullptr) {}
  ~Slice() override;
  explicit constexpr Slice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Slice(const Slice& from);
  Slice(Slice&& from) noexcept
    : Slice() {
    *this = ::std::move(from);
  }

  inline Slice& operator=(const Slice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Slice& operator=(Slice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Slice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Slice* internal_default_instance() {
    return reinterpret_cast<const Slice*>(
               &_Slice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Slice& a, Slice& b) {
    a.Swap(&b);
  }
  inline void Swap(Slice* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Slice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Slice* New() const final {
    return new Slice();
  }

  Slice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Slice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Slice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Slice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Slice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Slice";
  }
  protected:
  explicit Slice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalFieldNumber = 1,
    kTopFieldNumber = 2,
    kBotFieldNumber = 3,
  };
  // string signal = 1;
  void clear_signal();
  const std::string& signal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signal();
  PROTOBUF_MUST_USE_RESULT std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  private:
  const std::string& _internal_signal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  // int64 top = 2;
  void clear_top();
  ::PROTOBUF_NAMESPACE_ID::int64 top() const;
  void set_top(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_top() const;
  void _internal_set_top(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 bot = 3;
  void clear_bot();
  ::PROTOBUF_NAMESPACE_ID::int64 bot() const;
  void set_bot(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_bot() const;
  void _internal_set_bot(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Slice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  ::PROTOBUF_NAMESPACE_ID::int64 top_;
  ::PROTOBUF_NAMESPACE_ID::int64 bot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Concat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Concat) */ {
 public:
  inline Concat() : Concat(nullptr) {}
  ~Concat() override;
  explicit constexpr Concat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Concat(const Concat& from);
  Concat(Concat&& from) noexcept
    : Concat() {
    *this = ::std::move(from);
  }

  inline Concat& operator=(const Concat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Concat& operator=(Concat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Concat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Concat* internal_default_instance() {
    return reinterpret_cast<const Concat*>(
               &_Concat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Concat& a, Concat& b) {
    a.Swap(&b);
  }
  inline void Swap(Concat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Concat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Concat* New() const final {
    return new Concat();
  }

  Concat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Concat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Concat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Concat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Concat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Concat";
  }
  protected:
  explicit Concat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Connection parts = 1;
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::vlsir::circuit::Connection* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >*
      mutable_parts();
  private:
  const ::vlsir::circuit::Connection& _internal_parts(int index) const;
  ::vlsir::circuit::Connection* _internal_add_parts();
  public:
  const ::vlsir::circuit::Connection& parts(int index) const;
  ::vlsir::circuit::Connection* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >&
      parts() const;

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Concat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection > parts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Connection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  ~Connection() override;
  explicit constexpr Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  enum StypeCase {
    kSig = 1,
    kSlice = 2,
    kConcat = 3,
    STYPE_NOT_SET = 0,
  };

  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Connection* New() const final {
    return new Connection();
  }

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigFieldNumber = 1,
    kSliceFieldNumber = 2,
    kConcatFieldNumber = 3,
  };
  // .vlsir.circuit.Signal sig = 1;
  bool has_sig() const;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const ::vlsir::circuit::Signal& sig() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::circuit::Signal* release_sig();
  ::vlsir::circuit::Signal* mutable_sig();
  void set_allocated_sig(::vlsir::circuit::Signal* sig);
  private:
  const ::vlsir::circuit::Signal& _internal_sig() const;
  ::vlsir::circuit::Signal* _internal_mutable_sig();
  public:
  void unsafe_arena_set_allocated_sig(
      ::vlsir::circuit::Signal* sig);
  ::vlsir::circuit::Signal* unsafe_arena_release_sig();

  // .vlsir.circuit.Slice slice = 2;
  bool has_slice() const;
  private:
  bool _internal_has_slice() const;
  public:
  void clear_slice();
  const ::vlsir::circuit::Slice& slice() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::circuit::Slice* release_slice();
  ::vlsir::circuit::Slice* mutable_slice();
  void set_allocated_slice(::vlsir::circuit::Slice* slice);
  private:
  const ::vlsir::circuit::Slice& _internal_slice() const;
  ::vlsir::circuit::Slice* _internal_mutable_slice();
  public:
  void unsafe_arena_set_allocated_slice(
      ::vlsir::circuit::Slice* slice);
  ::vlsir::circuit::Slice* unsafe_arena_release_slice();

  // .vlsir.circuit.Concat concat = 3;
  bool has_concat() const;
  private:
  bool _internal_has_concat() const;
  public:
  void clear_concat();
  const ::vlsir::circuit::Concat& concat() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::circuit::Concat* release_concat();
  ::vlsir::circuit::Concat* mutable_concat();
  void set_allocated_concat(::vlsir::circuit::Concat* concat);
  private:
  const ::vlsir::circuit::Concat& _internal_concat() const;
  ::vlsir::circuit::Concat* _internal_mutable_concat();
  public:
  void unsafe_arena_set_allocated_concat(
      ::vlsir::circuit::Concat* concat);
  ::vlsir::circuit::Concat* unsafe_arena_release_concat();

  void clear_stype();
  StypeCase stype_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.circuit.Connection)
 private:
  class _Internal;
  void set_has_sig();
  void set_has_slice();
  void set_has_concat();

  inline bool has_stype() const;
  inline void clear_has_stype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StypeUnion {
    constexpr StypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vlsir::circuit::Signal* sig_;
    ::vlsir::circuit::Slice* slice_;
    ::vlsir::circuit::Concat* concat_;
  } stype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Instance_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_ParametersEntry_DoNotUse, 
    std::string, ::vlsir::circuit::ParameterValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_ParametersEntry_DoNotUse, 
    std::string, ::vlsir::circuit::ParameterValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Instance_ParametersEntry_DoNotUse();
  explicit constexpr Instance_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Instance_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Instance_ParametersEntry_DoNotUse& other);
  static const Instance_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Instance_ParametersEntry_DoNotUse*>(&_Instance_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.circuit.Instance.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Instance_ConnectionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_ConnectionsEntry_DoNotUse, 
    std::string, ::vlsir::circuit::Connection,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_ConnectionsEntry_DoNotUse, 
    std::string, ::vlsir::circuit::Connection,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Instance_ConnectionsEntry_DoNotUse();
  explicit constexpr Instance_ConnectionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Instance_ConnectionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Instance_ConnectionsEntry_DoNotUse& other);
  static const Instance_ConnectionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Instance_ConnectionsEntry_DoNotUse*>(&_Instance_ConnectionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vlsir.circuit.Instance.ConnectionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit constexpr Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const final {
    return new Instance();
  }

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Instance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kConnectionsFieldNumber = 4,
    kNameFieldNumber = 1,
    kModuleFieldNumber = 2,
  };
  // map<string, .vlsir.circuit.ParameterValue> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >*
      mutable_parameters();

  // map<string, .vlsir.circuit.Connection> connections = 4;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >&
      _internal_connections() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >*
      _internal_mutable_connections();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >&
      connections() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >*
      mutable_connections();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.utils.Reference module = 2;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::vlsir::utils::Reference& module() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::utils::Reference* release_module();
  ::vlsir::utils::Reference* mutable_module();
  void set_allocated_module(::vlsir::utils::Reference* module);
  private:
  const ::vlsir::utils::Reference& _internal_module() const;
  ::vlsir::utils::Reference* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::vlsir::utils::Reference* module);
  ::vlsir::utils::Reference* unsafe_arena_release_module();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Instance_ParametersEntry_DoNotUse,
      std::string, ::vlsir::circuit::ParameterValue,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Instance_ConnectionsEntry_DoNotUse,
      std::string, ::vlsir::circuit::Connection,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> connections_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::utils::Reference* module_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Module final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Module) */ {
 public:
  inline Module() : Module(nullptr) {}
  ~Module() override;
  explicit constexpr Module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Module(const Module& from);
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Module* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Module* New() const final {
    return new Module();
  }

  Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Module& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Module& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Module";
  }
  protected:
  explicit Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 2,
    kSignalsFieldNumber = 3,
    kInstancesFieldNumber = 4,
    kParametersFieldNumber = 5,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 2;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Signal signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  private:
  const ::vlsir::circuit::Signal& _internal_signals(int index) const;
  ::vlsir::circuit::Signal* _internal_add_signals();
  public:
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.circuit.Instance instances = 4;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::circuit::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
      mutable_instances();
  private:
  const ::vlsir::circuit::Instance& _internal_instances(int index) const;
  ::vlsir::circuit::Instance* _internal_add_instances();
  public:
  const ::vlsir::circuit::Instance& instances(int index) const;
  ::vlsir::circuit::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
      instances() const;

  // repeated .vlsir.circuit.Parameter parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::circuit::Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >*
      mutable_parameters();
  private:
  const ::vlsir::circuit::Parameter& _internal_parameters(int index) const;
  ::vlsir::circuit::Parameter* _internal_add_parameters();
  public:
  const ::vlsir::circuit::Parameter& parameters(int index) const;
  ::vlsir::circuit::Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance > instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class ExternalModule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ExternalModule) */ {
 public:
  inline ExternalModule() : ExternalModule(nullptr) {}
  ~ExternalModule() override;
  explicit constexpr ExternalModule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalModule(const ExternalModule& from);
  ExternalModule(ExternalModule&& from) noexcept
    : ExternalModule() {
    *this = ::std::move(from);
  }

  inline ExternalModule& operator=(const ExternalModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalModule& operator=(ExternalModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalModule* internal_default_instance() {
    return reinterpret_cast<const ExternalModule*>(
               &_ExternalModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ExternalModule& a, ExternalModule& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalModule* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExternalModule* New() const final {
    return new ExternalModule();
  }

  ExternalModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExternalModule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternalModule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExternalModule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalModule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.ExternalModule";
  }
  protected:
  explicit ExternalModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 3,
    kParametersFieldNumber = 5,
    kDescFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 3;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Parameter parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::circuit::Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >*
      mutable_parameters();
  private:
  const ::vlsir::circuit::Parameter& _internal_parameters(int index) const;
  ::vlsir::circuit::Parameter* _internal_add_parameters();
  public:
  const ::vlsir::circuit::Parameter& parameters(int index) const;
  ::vlsir::circuit::Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >&
      parameters() const;

  // string desc = 2;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_MUST_USE_RESULT std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // .vlsir.utils.QualifiedName name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::vlsir::utils::QualifiedName& name() const;
  PROTOBUF_MUST_USE_RESULT ::vlsir::utils::QualifiedName* release_name();
  ::vlsir::utils::QualifiedName* mutable_name();
  void set_allocated_name(::vlsir::utils::QualifiedName* name);
  private:
  const ::vlsir::utils::QualifiedName& _internal_name() const;
  ::vlsir::utils::QualifiedName* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::vlsir::utils::QualifiedName* name);
  ::vlsir::utils::QualifiedName* unsafe_arena_release_name();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.ExternalModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::vlsir::utils::QualifiedName* name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Interface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Interface) */ {
 public:
  inline Interface() : Interface(nullptr) {}
  ~Interface() override;
  explicit constexpr Interface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Interface(const Interface& from);
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interface& operator=(Interface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Interface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }
  inline void Swap(Interface* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Interface* New() const final {
    return new Interface();
  }

  Interface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Interface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Interface& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Interface";
  }
  protected:
  explicit Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 10,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 10;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Interface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Package

// string domain = 1;
inline void Package::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& Package::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.domain)
}
inline std::string* Package::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.domain)
  return _s;
}
inline const std::string& Package::_internal_domain() const {
  return domain_.Get();
}
inline void Package::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Package::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Package::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.domain)
}

// repeated .vlsir.circuit.Module modules = 2;
inline int Package::_internal_modules_size() const {
  return modules_.size();
}
inline int Package::modules_size() const {
  return _internal_modules_size();
}
inline void Package::clear_modules() {
  modules_.Clear();
}
inline ::vlsir::circuit::Module* Package::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.modules)
  return modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >*
Package::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.modules)
  return &modules_;
}
inline const ::vlsir::circuit::Module& Package::_internal_modules(int index) const {
  return modules_.Get(index);
}
inline const ::vlsir::circuit::Module& Package::modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.modules)
  return _internal_modules(index);
}
inline ::vlsir::circuit::Module* Package::_internal_add_modules() {
  return modules_.Add();
}
inline ::vlsir::circuit::Module* Package::add_modules() {
  ::vlsir::circuit::Module* _add = _internal_add_modules();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >&
Package::modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.modules)
  return modules_;
}

// repeated .vlsir.circuit.ExternalModule ext_modules = 3;
inline int Package::_internal_ext_modules_size() const {
  return ext_modules_.size();
}
inline int Package::ext_modules_size() const {
  return _internal_ext_modules_size();
}
inline void Package::clear_ext_modules() {
  ext_modules_.Clear();
}
inline ::vlsir::circuit::ExternalModule* Package::mutable_ext_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.ext_modules)
  return ext_modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
Package::mutable_ext_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.ext_modules)
  return &ext_modules_;
}
inline const ::vlsir::circuit::ExternalModule& Package::_internal_ext_modules(int index) const {
  return ext_modules_.Get(index);
}
inline const ::vlsir::circuit::ExternalModule& Package::ext_modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.ext_modules)
  return _internal_ext_modules(index);
}
inline ::vlsir::circuit::ExternalModule* Package::_internal_add_ext_modules() {
  return ext_modules_.Add();
}
inline ::vlsir::circuit::ExternalModule* Package::add_ext_modules() {
  ::vlsir::circuit::ExternalModule* _add = _internal_add_ext_modules();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.ext_modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
Package::ext_modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.ext_modules)
  return ext_modules_;
}

// string desc = 10;
inline void Package::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& Package::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.desc)
}
inline std::string* Package::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.desc)
  return _s;
}
inline const std::string& Package::_internal_desc() const {
  return desc_.Get();
}
inline void Package::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Package::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Package::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.desc)
}

// -------------------------------------------------------------------

// ParameterValue

// int64 integer = 2;
inline bool ParameterValue::_internal_has_integer() const {
  return value_case() == kInteger;
}
inline bool ParameterValue::has_integer() const {
  return _internal_has_integer();
}
inline void ParameterValue::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void ParameterValue::clear_integer() {
  if (_internal_has_integer()) {
    value_.integer_ = int64_t{0};
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ParameterValue::_internal_integer() const {
  if (_internal_has_integer()) {
    return value_.integer_;
  }
  return int64_t{0};
}
inline void ParameterValue::_internal_set_integer(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_integer()) {
    clear_value();
    set_has_integer();
  }
  value_.integer_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ParameterValue::integer() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ParameterValue.integer)
  return _internal_integer();
}
inline void ParameterValue::set_integer(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_integer(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.ParameterValue.integer)
}

// double double = 3;
inline bool ParameterValue::_internal_has_double_() const {
  return value_case() == kDouble;
}
inline bool ParameterValue::has_double_() const {
  return _internal_has_double_();
}
inline void ParameterValue::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void ParameterValue::clear_double_() {
  if (_internal_has_double_()) {
    value_.double__ = 0;
    clear_has_value();
  }
}
inline double ParameterValue::_internal_double_() const {
  if (_internal_has_double_()) {
    return value_.double__;
  }
  return 0;
}
inline void ParameterValue::_internal_set_double_(double value) {
  if (!_internal_has_double_()) {
    clear_value();
    set_has_double_();
  }
  value_.double__ = value;
}
inline double ParameterValue::double_() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ParameterValue.double)
  return _internal_double_();
}
inline void ParameterValue::set_double_(double value) {
  _internal_set_double_(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.ParameterValue.double)
}

// string string = 4;
inline bool ParameterValue::_internal_has_string() const {
  return value_case() == kString;
}
inline bool ParameterValue::has_string() const {
  return _internal_has_string();
}
inline void ParameterValue::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void ParameterValue::clear_string() {
  if (_internal_has_string()) {
    value_.string_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_value();
  }
}
inline const std::string& ParameterValue::string() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ParameterValue.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline void ParameterValue::set_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.ParameterValue.string)
}
inline std::string* ParameterValue::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ParameterValue.string)
  return _s;
}
inline const std::string& ParameterValue::_internal_string() const {
  if (_internal_has_string()) {
    return value_.string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ParameterValue::_internal_set_string(const std::string& value) {
  if (!_internal_has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParameterValue::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.string_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParameterValue::release_string() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ParameterValue.string)
  if (_internal_has_string()) {
    clear_has_value();
    return value_.string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ParameterValue::set_allocated_string(std::string* string) {
  if (has_value()) {
    clear_value();
  }
  if (string != nullptr) {
    set_has_string();
    value_.string_.UnsafeSetDefault(string);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(string);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ParameterValue.string)
}

// string literal = 5;
inline bool ParameterValue::_internal_has_literal() const {
  return value_case() == kLiteral;
}
inline bool ParameterValue::has_literal() const {
  return _internal_has_literal();
}
inline void ParameterValue::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void ParameterValue::clear_literal() {
  if (_internal_has_literal()) {
    value_.literal_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_value();
  }
}
inline const std::string& ParameterValue::literal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ParameterValue.literal)
  return _internal_literal();
}
template <typename ArgT0, typename... ArgT>
inline void ParameterValue::set_literal(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_literal()) {
    clear_value();
    set_has_literal();
    value_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.literal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.ParameterValue.literal)
}
inline std::string* ParameterValue::mutable_literal() {
  std::string* _s = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ParameterValue.literal)
  return _s;
}
inline const std::string& ParameterValue::_internal_literal() const {
  if (_internal_has_literal()) {
    return value_.literal_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ParameterValue::_internal_set_literal(const std::string& value) {
  if (!_internal_has_literal()) {
    clear_value();
    set_has_literal();
    value_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.literal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParameterValue::_internal_mutable_literal() {
  if (!_internal_has_literal()) {
    clear_value();
    set_has_literal();
    value_.literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.literal_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParameterValue::release_literal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ParameterValue.literal)
  if (_internal_has_literal()) {
    clear_has_value();
    return value_.literal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ParameterValue::set_allocated_literal(std::string* literal) {
  if (has_value()) {
    clear_value();
  }
  if (literal != nullptr) {
    set_has_literal();
    value_.literal_.UnsafeSetDefault(literal);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(literal);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ParameterValue.literal)
}

inline bool ParameterValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ParameterValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ParameterValue::ValueCase ParameterValue::value_case() const {
  return ParameterValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Parameter

// string name = 1;
inline void Parameter::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Parameter::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Parameter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameter::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Parameter.name)
}
inline std::string* Parameter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Parameter.name)
  return _s;
}
inline const std::string& Parameter::_internal_name() const {
  return name_.Get();
}
inline void Parameter::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Parameter::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Parameter::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Parameter.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Parameter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Parameter.name)
}

// .vlsir.circuit.ParameterValue default = 2;
inline bool Parameter::_internal_has_default_() const {
  return this != internal_default_instance() && default__ != nullptr;
}
inline bool Parameter::has_default_() const {
  return _internal_has_default_();
}
inline void Parameter::clear_default_() {
  if (GetArenaForAllocation() == nullptr && default__ != nullptr) {
    delete default__;
  }
  default__ = nullptr;
}
inline const ::vlsir::circuit::ParameterValue& Parameter::_internal_default_() const {
  const ::vlsir::circuit::ParameterValue* p = default__;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::ParameterValue&>(
      ::vlsir::circuit::_ParameterValue_default_instance_);
}
inline const ::vlsir::circuit::ParameterValue& Parameter::default_() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Parameter.default)
  return _internal_default_();
}
inline void Parameter::unsafe_arena_set_allocated_default_(
    ::vlsir::circuit::ParameterValue* default_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default__);
  }
  default__ = default_;
  if (default_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Parameter.default)
}
inline ::vlsir::circuit::ParameterValue* Parameter::release_default_() {
  
  ::vlsir::circuit::ParameterValue* temp = default__;
  default__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::ParameterValue* Parameter::unsafe_arena_release_default_() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Parameter.default)
  
  ::vlsir::circuit::ParameterValue* temp = default__;
  default__ = nullptr;
  return temp;
}
inline ::vlsir::circuit::ParameterValue* Parameter::_internal_mutable_default_() {
  
  if (default__ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::ParameterValue>(GetArenaForAllocation());
    default__ = p;
  }
  return default__;
}
inline ::vlsir::circuit::ParameterValue* Parameter::mutable_default_() {
  ::vlsir::circuit::ParameterValue* _msg = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Parameter.default)
  return _msg;
}
inline void Parameter::set_allocated_default_(::vlsir::circuit::ParameterValue* default_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete default__;
  }
  if (default_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::circuit::ParameterValue>::GetOwningArena(default_);
    if (message_arena != submessage_arena) {
      default_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_, submessage_arena);
    }
    
  } else {
    
  }
  default__ = default_;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Parameter.default)
}

// string desc = 3;
inline void Parameter::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& Parameter::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Parameter.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameter::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Parameter.desc)
}
inline std::string* Parameter::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Parameter.desc)
  return _s;
}
inline const std::string& Parameter::_internal_desc() const {
  return desc_.Get();
}
inline void Parameter::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Parameter::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Parameter::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Parameter.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Parameter::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Parameter.desc)
}

// -------------------------------------------------------------------

// Port

// .vlsir.circuit.Signal signal = 1;
inline bool Port::_internal_has_signal() const {
  return this != internal_default_instance() && signal_ != nullptr;
}
inline bool Port::has_signal() const {
  return _internal_has_signal();
}
inline void Port::clear_signal() {
  if (GetArenaForAllocation() == nullptr && signal_ != nullptr) {
    delete signal_;
  }
  signal_ = nullptr;
}
inline const ::vlsir::circuit::Signal& Port::_internal_signal() const {
  const ::vlsir::circuit::Signal* p = signal_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::Signal&>(
      ::vlsir::circuit::_Signal_default_instance_);
}
inline const ::vlsir::circuit::Signal& Port::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.signal)
  return _internal_signal();
}
inline void Port::unsafe_arena_set_allocated_signal(
    ::vlsir::circuit::Signal* signal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_);
  }
  signal_ = signal;
  if (signal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Port.signal)
}
inline ::vlsir::circuit::Signal* Port::release_signal() {
  
  ::vlsir::circuit::Signal* temp = signal_;
  signal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::Signal* Port::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Port.signal)
  
  ::vlsir::circuit::Signal* temp = signal_;
  signal_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Signal* Port::_internal_mutable_signal() {
  
  if (signal_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Signal>(GetArenaForAllocation());
    signal_ = p;
  }
  return signal_;
}
inline ::vlsir::circuit::Signal* Port::mutable_signal() {
  ::vlsir::circuit::Signal* _msg = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Port.signal)
  return _msg;
}
inline void Port::set_allocated_signal(::vlsir::circuit::Signal* signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signal_;
  }
  if (signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::circuit::Signal>::GetOwningArena(signal);
    if (message_arena != submessage_arena) {
      signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal, submessage_arena);
    }
    
  } else {
    
  }
  signal_ = signal;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Port.signal)
}

// .vlsir.circuit.Port.Direction direction = 2;
inline void Port::clear_direction() {
  direction_ = 0;
}
inline ::vlsir::circuit::Port_Direction Port::_internal_direction() const {
  return static_cast< ::vlsir::circuit::Port_Direction >(direction_);
}
inline ::vlsir::circuit::Port_Direction Port::direction() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.direction)
  return _internal_direction();
}
inline void Port::_internal_set_direction(::vlsir::circuit::Port_Direction value) {
  
  direction_ = value;
}
inline void Port::set_direction(::vlsir::circuit::Port_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.direction)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Signal::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.name)
}
inline std::string* Signal::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Signal.name)
  return _s;
}
inline const std::string& Signal::_internal_name() const {
  return name_.Get();
}
inline void Signal::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Signal::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Signal.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Signal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Signal.name)
}

// int64 width = 2;
inline void Signal::clear_width() {
  width_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Signal::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Signal::width() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.width)
  return _internal_width();
}
inline void Signal::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  width_ = value;
}
inline void Signal::set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.width)
}

// -------------------------------------------------------------------

// Slice

// string signal = 1;
inline void Slice::clear_signal() {
  signal_.ClearToEmpty();
}
inline const std::string& Slice::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.signal)
  return _internal_signal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Slice::set_signal(ArgT0&& arg0, ArgT... args) {
 
 signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.signal)
}
inline std::string* Slice::mutable_signal() {
  std::string* _s = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Slice.signal)
  return _s;
}
inline const std::string& Slice::_internal_signal() const {
  return signal_.Get();
}
inline void Slice::_internal_set_signal(const std::string& value) {
  
  signal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Slice::_internal_mutable_signal() {
  
  return signal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Slice::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Slice.signal)
  return signal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Slice::set_allocated_signal(std::string* signal) {
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signal,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Slice.signal)
}

// int64 top = 2;
inline void Slice::clear_top() {
  top_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::_internal_top() const {
  return top_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::top() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.top)
  return _internal_top();
}
inline void Slice::_internal_set_top(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  top_ = value;
}
inline void Slice::set_top(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.top)
}

// int64 bot = 3;
inline void Slice::clear_bot() {
  bot_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::_internal_bot() const {
  return bot_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::bot() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.bot)
  return _internal_bot();
}
inline void Slice::_internal_set_bot(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  bot_ = value;
}
inline void Slice::set_bot(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_bot(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.bot)
}

// -------------------------------------------------------------------

// Concat

// repeated .vlsir.circuit.Connection parts = 1;
inline int Concat::_internal_parts_size() const {
  return parts_.size();
}
inline int Concat::parts_size() const {
  return _internal_parts_size();
}
inline void Concat::clear_parts() {
  parts_.Clear();
}
inline ::vlsir::circuit::Connection* Concat::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Concat.parts)
  return parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >*
Concat::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Concat.parts)
  return &parts_;
}
inline const ::vlsir::circuit::Connection& Concat::_internal_parts(int index) const {
  return parts_.Get(index);
}
inline const ::vlsir::circuit::Connection& Concat::parts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Concat.parts)
  return _internal_parts(index);
}
inline ::vlsir::circuit::Connection* Concat::_internal_add_parts() {
  return parts_.Add();
}
inline ::vlsir::circuit::Connection* Concat::add_parts() {
  ::vlsir::circuit::Connection* _add = _internal_add_parts();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Concat.parts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >&
Concat::parts() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Concat.parts)
  return parts_;
}

// -------------------------------------------------------------------

// Connection

// .vlsir.circuit.Signal sig = 1;
inline bool Connection::_internal_has_sig() const {
  return stype_case() == kSig;
}
inline bool Connection::has_sig() const {
  return _internal_has_sig();
}
inline void Connection::set_has_sig() {
  _oneof_case_[0] = kSig;
}
inline void Connection::clear_sig() {
  if (_internal_has_sig()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stype_.sig_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Signal* Connection::release_sig() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.sig)
  if (_internal_has_sig()) {
    clear_has_stype();
      ::vlsir::circuit::Signal* temp = stype_.sig_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.sig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Signal& Connection::_internal_sig() const {
  return _internal_has_sig()
      ? *stype_.sig_
      : reinterpret_cast< ::vlsir::circuit::Signal&>(::vlsir::circuit::_Signal_default_instance_);
}
inline const ::vlsir::circuit::Signal& Connection::sig() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.sig)
  return _internal_sig();
}
inline ::vlsir::circuit::Signal* Connection::unsafe_arena_release_sig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Connection.sig)
  if (_internal_has_sig()) {
    clear_has_stype();
    ::vlsir::circuit::Signal* temp = stype_.sig_;
    stype_.sig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Connection::unsafe_arena_set_allocated_sig(::vlsir::circuit::Signal* sig) {
  clear_stype();
  if (sig) {
    set_has_sig();
    stype_.sig_ = sig;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Connection.sig)
}
inline ::vlsir::circuit::Signal* Connection::_internal_mutable_sig() {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_ = CreateMaybeMessage< ::vlsir::circuit::Signal >(GetArenaForAllocation());
  }
  return stype_.sig_;
}
inline ::vlsir::circuit::Signal* Connection::mutable_sig() {
  ::vlsir::circuit::Signal* _msg = _internal_mutable_sig();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.sig)
  return _msg;
}

// .vlsir.circuit.Slice slice = 2;
inline bool Connection::_internal_has_slice() const {
  return stype_case() == kSlice;
}
inline bool Connection::has_slice() const {
  return _internal_has_slice();
}
inline void Connection::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void Connection::clear_slice() {
  if (_internal_has_slice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stype_.slice_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Slice* Connection::release_slice() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.slice)
  if (_internal_has_slice()) {
    clear_has_stype();
      ::vlsir::circuit::Slice* temp = stype_.slice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Slice& Connection::_internal_slice() const {
  return _internal_has_slice()
      ? *stype_.slice_
      : reinterpret_cast< ::vlsir::circuit::Slice&>(::vlsir::circuit::_Slice_default_instance_);
}
inline const ::vlsir::circuit::Slice& Connection::slice() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.slice)
  return _internal_slice();
}
inline ::vlsir::circuit::Slice* Connection::unsafe_arena_release_slice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Connection.slice)
  if (_internal_has_slice()) {
    clear_has_stype();
    ::vlsir::circuit::Slice* temp = stype_.slice_;
    stype_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Connection::unsafe_arena_set_allocated_slice(::vlsir::circuit::Slice* slice) {
  clear_stype();
  if (slice) {
    set_has_slice();
    stype_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Connection.slice)
}
inline ::vlsir::circuit::Slice* Connection::_internal_mutable_slice() {
  if (!_internal_has_slice()) {
    clear_stype();
    set_has_slice();
    stype_.slice_ = CreateMaybeMessage< ::vlsir::circuit::Slice >(GetArenaForAllocation());
  }
  return stype_.slice_;
}
inline ::vlsir::circuit::Slice* Connection::mutable_slice() {
  ::vlsir::circuit::Slice* _msg = _internal_mutable_slice();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.slice)
  return _msg;
}

// .vlsir.circuit.Concat concat = 3;
inline bool Connection::_internal_has_concat() const {
  return stype_case() == kConcat;
}
inline bool Connection::has_concat() const {
  return _internal_has_concat();
}
inline void Connection::set_has_concat() {
  _oneof_case_[0] = kConcat;
}
inline void Connection::clear_concat() {
  if (_internal_has_concat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stype_.concat_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Concat* Connection::release_concat() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.concat)
  if (_internal_has_concat()) {
    clear_has_stype();
      ::vlsir::circuit::Concat* temp = stype_.concat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Concat& Connection::_internal_concat() const {
  return _internal_has_concat()
      ? *stype_.concat_
      : reinterpret_cast< ::vlsir::circuit::Concat&>(::vlsir::circuit::_Concat_default_instance_);
}
inline const ::vlsir::circuit::Concat& Connection::concat() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.concat)
  return _internal_concat();
}
inline ::vlsir::circuit::Concat* Connection::unsafe_arena_release_concat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Connection.concat)
  if (_internal_has_concat()) {
    clear_has_stype();
    ::vlsir::circuit::Concat* temp = stype_.concat_;
    stype_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Connection::unsafe_arena_set_allocated_concat(::vlsir::circuit::Concat* concat) {
  clear_stype();
  if (concat) {
    set_has_concat();
    stype_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Connection.concat)
}
inline ::vlsir::circuit::Concat* Connection::_internal_mutable_concat() {
  if (!_internal_has_concat()) {
    clear_stype();
    set_has_concat();
    stype_.concat_ = CreateMaybeMessage< ::vlsir::circuit::Concat >(GetArenaForAllocation());
  }
  return stype_.concat_;
}
inline ::vlsir::circuit::Concat* Connection::mutable_concat() {
  ::vlsir::circuit::Concat* _msg = _internal_mutable_concat();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.concat)
  return _msg;
}

inline bool Connection::has_stype() const {
  return stype_case() != STYPE_NOT_SET;
}
inline void Connection::clear_has_stype() {
  _oneof_case_[0] = STYPE_NOT_SET;
}
inline Connection::StypeCase Connection::stype_case() const {
  return Connection::StypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Instance.name)
}
inline std::string* Instance::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.name)
  return _s;
}
inline const std::string& Instance::_internal_name() const {
  return name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.name)
}

// .vlsir.utils.Reference module = 2;
inline bool Instance::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool Instance::has_module() const {
  return _internal_has_module();
}
inline const ::vlsir::utils::Reference& Instance::_internal_module() const {
  const ::vlsir::utils::Reference* p = module_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::Reference&>(
      ::vlsir::utils::_Reference_default_instance_);
}
inline const ::vlsir::utils::Reference& Instance::module() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.module)
  return _internal_module();
}
inline void Instance::unsafe_arena_set_allocated_module(
    ::vlsir::utils::Reference* module) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Instance.module)
}
inline ::vlsir::utils::Reference* Instance::release_module() {
  
  ::vlsir::utils::Reference* temp = module_;
  module_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::Reference* Instance::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.module)
  
  ::vlsir::utils::Reference* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArenaForAllocation());
    module_ = p;
  }
  return module_;
}
inline ::vlsir::utils::Reference* Instance::mutable_module() {
  ::vlsir::utils::Reference* _msg = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.module)
  return _msg;
}
inline void Instance::set_allocated_module(::vlsir::utils::Reference* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module));
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.module)
}

// map<string, .vlsir.circuit.ParameterValue> parameters = 3;
inline int Instance::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Instance::parameters_size() const {
  return _internal_parameters_size();
}
inline void Instance::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >&
Instance::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >&
Instance::parameters() const {
  // @@protoc_insertion_point(field_map:vlsir.circuit.Instance.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >*
Instance::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::ParameterValue >*
Instance::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.circuit.Instance.parameters)
  return _internal_mutable_parameters();
}

// map<string, .vlsir.circuit.Connection> connections = 4;
inline int Instance::_internal_connections_size() const {
  return connections_.size();
}
inline int Instance::connections_size() const {
  return _internal_connections_size();
}
inline void Instance::clear_connections() {
  connections_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >&
Instance::_internal_connections() const {
  return connections_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >&
Instance::connections() const {
  // @@protoc_insertion_point(field_map:vlsir.circuit.Instance.connections)
  return _internal_connections();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >*
Instance::_internal_mutable_connections() {
  return connections_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vlsir::circuit::Connection >*
Instance::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_map:vlsir.circuit.Instance.connections)
  return _internal_mutable_connections();
}

// -------------------------------------------------------------------

// Module

// string name = 1;
inline void Module::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Module.name)
}
inline std::string* Module::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.name)
  return _s;
}
inline const std::string& Module::_internal_name() const {
  return name_.Get();
}
inline void Module::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Module.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Module::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Module.name)
}

// repeated .vlsir.circuit.Port ports = 2;
inline int Module::_internal_ports_size() const {
  return ports_.size();
}
inline int Module::ports_size() const {
  return _internal_ports_size();
}
inline void Module::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Module::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
Module::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Module::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& Module::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* Module::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* Module::add_ports() {
  ::vlsir::circuit::Port* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
Module::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.ports)
  return ports_;
}

// repeated .vlsir.circuit.Signal signals = 3;
inline int Module::_internal_signals_size() const {
  return signals_.size();
}
inline int Module::signals_size() const {
  return _internal_signals_size();
}
inline void Module::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::circuit::Signal* Module::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
Module::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& Module::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const ::vlsir::circuit::Signal& Module::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.signals)
  return _internal_signals(index);
}
inline ::vlsir::circuit::Signal* Module::_internal_add_signals() {
  return signals_.Add();
}
inline ::vlsir::circuit::Signal* Module::add_signals() {
  ::vlsir::circuit::Signal* _add = _internal_add_signals();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.signals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
Module::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.signals)
  return signals_;
}

// repeated .vlsir.circuit.Instance instances = 4;
inline int Module::_internal_instances_size() const {
  return instances_.size();
}
inline int Module::instances_size() const {
  return _internal_instances_size();
}
inline void Module::clear_instances() {
  instances_.Clear();
}
inline ::vlsir::circuit::Instance* Module::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
Module::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.instances)
  return &instances_;
}
inline const ::vlsir::circuit::Instance& Module::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::vlsir::circuit::Instance& Module::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.instances)
  return _internal_instances(index);
}
inline ::vlsir::circuit::Instance* Module::_internal_add_instances() {
  return instances_.Add();
}
inline ::vlsir::circuit::Instance* Module::add_instances() {
  ::vlsir::circuit::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
Module::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.instances)
  return instances_;
}

// repeated .vlsir.circuit.Parameter parameters = 5;
inline int Module::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Module::parameters_size() const {
  return _internal_parameters_size();
}
inline void Module::clear_parameters() {
  parameters_.Clear();
}
inline ::vlsir::circuit::Parameter* Module::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >*
Module::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.parameters)
  return &parameters_;
}
inline const ::vlsir::circuit::Parameter& Module::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::circuit::Parameter& Module::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::circuit::Parameter* Module::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::circuit::Parameter* Module::add_parameters() {
  ::vlsir::circuit::Parameter* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >&
Module::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// ExternalModule

// .vlsir.utils.QualifiedName name = 1;
inline bool ExternalModule::_internal_has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline bool ExternalModule::has_name() const {
  return _internal_has_name();
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::_internal_name() const {
  const ::vlsir::utils::QualifiedName* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::QualifiedName&>(
      ::vlsir::utils::_QualifiedName_default_instance_);
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.name)
  return _internal_name();
}
inline void ExternalModule::unsafe_arena_set_allocated_name(
    ::vlsir::utils::QualifiedName* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ExternalModule.name)
}
inline ::vlsir::utils::QualifiedName* ExternalModule::release_name() {
  
  ::vlsir::utils::QualifiedName* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.name)
  
  ::vlsir::utils::QualifiedName* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::_internal_mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::QualifiedName>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::mutable_name() {
  ::vlsir::utils::QualifiedName* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.name)
  return _msg;
}
inline void ExternalModule::set_allocated_name(::vlsir::utils::QualifiedName* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.name)
}

// string desc = 2;
inline void ExternalModule::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& ExternalModule::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalModule::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.ExternalModule.desc)
}
inline std::string* ExternalModule::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.desc)
  return _s;
}
inline const std::string& ExternalModule::_internal_desc() const {
  return desc_.Get();
}
inline void ExternalModule::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExternalModule::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExternalModule::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExternalModule::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.desc)
}

// repeated .vlsir.circuit.Port ports = 3;
inline int ExternalModule::_internal_ports_size() const {
  return ports_.size();
}
inline int ExternalModule::ports_size() const {
  return _internal_ports_size();
}
inline void ExternalModule::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* ExternalModule::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
ExternalModule::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& ExternalModule::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& ExternalModule::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* ExternalModule::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* ExternalModule::add_ports() {
  ::vlsir::circuit::Port* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
ExternalModule::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.ports)
  return ports_;
}

// repeated .vlsir.circuit.Parameter parameters = 5;
inline int ExternalModule::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ExternalModule::parameters_size() const {
  return _internal_parameters_size();
}
inline void ExternalModule::clear_parameters() {
  parameters_.Clear();
}
inline ::vlsir::circuit::Parameter* ExternalModule::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >*
ExternalModule::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.parameters)
  return &parameters_;
}
inline const ::vlsir::circuit::Parameter& ExternalModule::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::circuit::Parameter& ExternalModule::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::circuit::Parameter* ExternalModule::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::circuit::Parameter* ExternalModule::add_parameters() {
  ::vlsir::circuit::Parameter* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Parameter >&
ExternalModule::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// Interface

// string name = 1;
inline void Interface::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Interface::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Interface::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.circuit.Interface.name)
}
inline std::string* Interface::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.name)
  return _s;
}
inline const std::string& Interface::_internal_name() const {
  return name_.Get();
}
inline void Interface::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Interface::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Interface::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Interface.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Interface::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Interface.name)
}

// repeated .vlsir.circuit.Port ports = 10;
inline int Interface::_internal_ports_size() const {
  return ports_.size();
}
inline int Interface::ports_size() const {
  return _internal_ports_size();
}
inline void Interface::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Interface::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
Interface::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Interface.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Interface::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& Interface::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* Interface::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* Interface::add_ports() {
  ::vlsir::circuit::Port* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.circuit.Interface.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
Interface::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Interface.ports)
  return ports_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace circuit
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::circuit::Port_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::circuit::Port_Direction>() {
  return ::vlsir::circuit::Port_Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto
