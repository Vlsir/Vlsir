// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: circuit.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_circuit_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_circuit_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_circuit_2eproto;
namespace vlsir {
namespace circuit {
class Concat;
class ConcatDefaultTypeInternal;
extern ConcatDefaultTypeInternal _Concat_default_instance_;
class Connection;
class ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class ConnectionTarget;
class ConnectionTargetDefaultTypeInternal;
extern ConnectionTargetDefaultTypeInternal _ConnectionTarget_default_instance_;
class ExternalModule;
class ExternalModuleDefaultTypeInternal;
extern ExternalModuleDefaultTypeInternal _ExternalModule_default_instance_;
class Instance;
class InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Interface;
class InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class Module;
class ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class Package;
class PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class Port;
class PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Slice;
class SliceDefaultTypeInternal;
extern SliceDefaultTypeInternal _Slice_default_instance_;
}  // namespace circuit
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::circuit::Concat* Arena::CreateMaybeMessage<::vlsir::circuit::Concat>(Arena*);
template<> ::vlsir::circuit::Connection* Arena::CreateMaybeMessage<::vlsir::circuit::Connection>(Arena*);
template<> ::vlsir::circuit::ConnectionTarget* Arena::CreateMaybeMessage<::vlsir::circuit::ConnectionTarget>(Arena*);
template<> ::vlsir::circuit::ExternalModule* Arena::CreateMaybeMessage<::vlsir::circuit::ExternalModule>(Arena*);
template<> ::vlsir::circuit::Instance* Arena::CreateMaybeMessage<::vlsir::circuit::Instance>(Arena*);
template<> ::vlsir::circuit::Interface* Arena::CreateMaybeMessage<::vlsir::circuit::Interface>(Arena*);
template<> ::vlsir::circuit::Module* Arena::CreateMaybeMessage<::vlsir::circuit::Module>(Arena*);
template<> ::vlsir::circuit::Package* Arena::CreateMaybeMessage<::vlsir::circuit::Package>(Arena*);
template<> ::vlsir::circuit::Port* Arena::CreateMaybeMessage<::vlsir::circuit::Port>(Arena*);
template<> ::vlsir::circuit::Signal* Arena::CreateMaybeMessage<::vlsir::circuit::Signal>(Arena*);
template<> ::vlsir::circuit::Slice* Arena::CreateMaybeMessage<::vlsir::circuit::Slice>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace circuit {

enum Port_Direction : int {
  Port_Direction_INPUT = 0,
  Port_Direction_OUTPUT = 1,
  Port_Direction_INOUT = 2,
  Port_Direction_NONE = 3,
  Port_Direction_Port_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Port_Direction_Port_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Port_Direction_IsValid(int value);
constexpr Port_Direction Port_Direction_Direction_MIN = Port_Direction_INPUT;
constexpr Port_Direction Port_Direction_Direction_MAX = Port_Direction_NONE;
constexpr int Port_Direction_Direction_ARRAYSIZE = Port_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Port_Direction_descriptor();
template<typename T>
inline const std::string& Port_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Port_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Port_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Port_Direction_descriptor(), enum_t_value);
}
inline bool Port_Direction_Parse(
    const std::string& name, Port_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Port_Direction>(
    Port_Direction_descriptor(), name, value);
}
// ===================================================================

class Package PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Package) */ {
 public:
  inline Package() : Package(nullptr) {};
  virtual ~Package();

  Package(const Package& from);
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Package& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Package* New() const final {
    return CreateMaybeMessage<Package>(nullptr);
  }

  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Package& from);
  void MergeFrom(const Package& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Package";
  }
  protected:
  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 2,
    kExtModulesFieldNumber = 3,
    kDomainFieldNumber = 1,
    kDescFieldNumber = 10,
  };
  // repeated .vlsir.circuit.Module modules = 2;
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::vlsir::circuit::Module* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >*
      mutable_modules();
  private:
  const ::vlsir::circuit::Module& _internal_modules(int index) const;
  ::vlsir::circuit::Module* _internal_add_modules();
  public:
  const ::vlsir::circuit::Module& modules(int index) const;
  ::vlsir::circuit::Module* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >&
      modules() const;

  // repeated .vlsir.circuit.ExternalModule ext_modules = 3;
  int ext_modules_size() const;
  private:
  int _internal_ext_modules_size() const;
  public:
  void clear_ext_modules();
  ::vlsir::circuit::ExternalModule* mutable_ext_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
      mutable_ext_modules();
  private:
  const ::vlsir::circuit::ExternalModule& _internal_ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* _internal_add_ext_modules();
  public:
  const ::vlsir::circuit::ExternalModule& ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* add_ext_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
      ext_modules() const;

  // string domain = 1;
  void clear_domain();
  const std::string& domain() const;
  void set_domain(const std::string& value);
  void set_domain(std::string&& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  std::string* mutable_domain();
  std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_domain();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_domain(
      std::string* domain);
  private:
  const std::string& _internal_domain() const;
  void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string desc = 10;
  void clear_desc();
  const std::string& desc() const;
  void set_desc(const std::string& value);
  void set_desc(std::string&& value);
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  std::string* mutable_desc();
  std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_desc();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_desc(
      std::string* desc);
  private:
  const std::string& _internal_desc() const;
  void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module > modules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule > ext_modules_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Port PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Port) */ {
 public:
  inline Port() : Port(nullptr) {};
  virtual ~Port();

  Port(const Port& from);
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline Port& operator=(Port&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Port& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }
  inline void Swap(Port* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Port* New() const final {
    return CreateMaybeMessage<Port>(nullptr);
  }

  Port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Port";
  }
  protected:
  explicit Port(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Port_Direction Direction;
  static constexpr Direction INPUT =
    Port_Direction_INPUT;
  static constexpr Direction OUTPUT =
    Port_Direction_OUTPUT;
  static constexpr Direction INOUT =
    Port_Direction_INOUT;
  static constexpr Direction NONE =
    Port_Direction_NONE;
  static inline bool Direction_IsValid(int value) {
    return Port_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    Port_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    Port_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    Port_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return Port_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return Port_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(const std::string& name,
      Direction* value) {
    return Port_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSignalFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // string signal = 1;
  void clear_signal();
  const std::string& signal() const;
  void set_signal(const std::string& value);
  void set_signal(std::string&& value);
  void set_signal(const char* value);
  void set_signal(const char* value, size_t size);
  std::string* mutable_signal();
  std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signal();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signal(
      std::string* signal);
  private:
  const std::string& _internal_signal() const;
  void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  // .vlsir.circuit.Port.Direction direction = 2;
  void clear_direction();
  ::vlsir::circuit::Port_Direction direction() const;
  void set_direction(::vlsir::circuit::Port_Direction value);
  private:
  ::vlsir::circuit::Port_Direction _internal_direction() const;
  void _internal_set_direction(::vlsir::circuit::Port_Direction value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Signal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {};
  virtual ~Signal();

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(nullptr);
  }

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Signal";
  }
  protected:
  explicit Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kWidthFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int64 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Signal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Slice PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Slice) */ {
 public:
  inline Slice() : Slice(nullptr) {};
  virtual ~Slice();

  Slice(const Slice& from);
  Slice(Slice&& from) noexcept
    : Slice() {
    *this = ::std::move(from);
  }

  inline Slice& operator=(const Slice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Slice& operator=(Slice&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Slice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Slice* internal_default_instance() {
    return reinterpret_cast<const Slice*>(
               &_Slice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Slice& a, Slice& b) {
    a.Swap(&b);
  }
  inline void Swap(Slice* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Slice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Slice* New() const final {
    return CreateMaybeMessage<Slice>(nullptr);
  }

  Slice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Slice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Slice& from);
  void MergeFrom(const Slice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Slice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Slice";
  }
  protected:
  explicit Slice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalFieldNumber = 1,
    kTopFieldNumber = 2,
    kBotFieldNumber = 3,
  };
  // string signal = 1;
  void clear_signal();
  const std::string& signal() const;
  void set_signal(const std::string& value);
  void set_signal(std::string&& value);
  void set_signal(const char* value);
  void set_signal(const char* value, size_t size);
  std::string* mutable_signal();
  std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signal();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signal(
      std::string* signal);
  private:
  const std::string& _internal_signal() const;
  void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  // int64 top = 2;
  void clear_top();
  ::PROTOBUF_NAMESPACE_ID::int64 top() const;
  void set_top(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_top() const;
  void _internal_set_top(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 bot = 3;
  void clear_bot();
  ::PROTOBUF_NAMESPACE_ID::int64 bot() const;
  void set_bot(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_bot() const;
  void _internal_set_bot(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Slice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
  ::PROTOBUF_NAMESPACE_ID::int64 top_;
  ::PROTOBUF_NAMESPACE_ID::int64 bot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Concat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Concat) */ {
 public:
  inline Concat() : Concat(nullptr) {};
  virtual ~Concat();

  Concat(const Concat& from);
  Concat(Concat&& from) noexcept
    : Concat() {
    *this = ::std::move(from);
  }

  inline Concat& operator=(const Concat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Concat& operator=(Concat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Concat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Concat* internal_default_instance() {
    return reinterpret_cast<const Concat*>(
               &_Concat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Concat& a, Concat& b) {
    a.Swap(&b);
  }
  inline void Swap(Concat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Concat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Concat* New() const final {
    return CreateMaybeMessage<Concat>(nullptr);
  }

  Concat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Concat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Concat& from);
  void MergeFrom(const Concat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Concat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Concat";
  }
  protected:
  explicit Concat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
  };
  // repeated .vlsir.circuit.ConnectionTarget parts = 1;
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::vlsir::circuit::ConnectionTarget* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >*
      mutable_parts();
  private:
  const ::vlsir::circuit::ConnectionTarget& _internal_parts(int index) const;
  ::vlsir::circuit::ConnectionTarget* _internal_add_parts();
  public:
  const ::vlsir::circuit::ConnectionTarget& parts(int index) const;
  ::vlsir::circuit::ConnectionTarget* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >&
      parts() const;

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Concat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget > parts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class ConnectionTarget PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ConnectionTarget) */ {
 public:
  inline ConnectionTarget() : ConnectionTarget(nullptr) {};
  virtual ~ConnectionTarget();

  ConnectionTarget(const ConnectionTarget& from);
  ConnectionTarget(ConnectionTarget&& from) noexcept
    : ConnectionTarget() {
    *this = ::std::move(from);
  }

  inline ConnectionTarget& operator=(const ConnectionTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionTarget& operator=(ConnectionTarget&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectionTarget& default_instance();

  enum StypeCase {
    kSig = 1,
    kSlice = 2,
    kConcat = 3,
    STYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionTarget* internal_default_instance() {
    return reinterpret_cast<const ConnectionTarget*>(
               &_ConnectionTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConnectionTarget& a, ConnectionTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionTarget* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionTarget* New() const final {
    return CreateMaybeMessage<ConnectionTarget>(nullptr);
  }

  ConnectionTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionTarget>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionTarget& from);
  void MergeFrom(const ConnectionTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.ConnectionTarget";
  }
  protected:
  explicit ConnectionTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigFieldNumber = 1,
    kSliceFieldNumber = 2,
    kConcatFieldNumber = 3,
  };
  // string sig = 1;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const std::string& sig() const;
  void set_sig(const std::string& value);
  void set_sig(std::string&& value);
  void set_sig(const char* value);
  void set_sig(const char* value, size_t size);
  std::string* mutable_sig();
  std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sig();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sig(
      std::string* sig);
  private:
  const std::string& _internal_sig() const;
  void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // .vlsir.circuit.Slice slice = 2;
  bool has_slice() const;
  private:
  bool _internal_has_slice() const;
  public:
  void clear_slice();
  const ::vlsir::circuit::Slice& slice() const;
  ::vlsir::circuit::Slice* release_slice();
  ::vlsir::circuit::Slice* mutable_slice();
  void set_allocated_slice(::vlsir::circuit::Slice* slice);
  private:
  const ::vlsir::circuit::Slice& _internal_slice() const;
  ::vlsir::circuit::Slice* _internal_mutable_slice();
  public:
  void unsafe_arena_set_allocated_slice(
      ::vlsir::circuit::Slice* slice);
  ::vlsir::circuit::Slice* unsafe_arena_release_slice();

  // .vlsir.circuit.Concat concat = 3;
  bool has_concat() const;
  private:
  bool _internal_has_concat() const;
  public:
  void clear_concat();
  const ::vlsir::circuit::Concat& concat() const;
  ::vlsir::circuit::Concat* release_concat();
  ::vlsir::circuit::Concat* mutable_concat();
  void set_allocated_concat(::vlsir::circuit::Concat* concat);
  private:
  const ::vlsir::circuit::Concat& _internal_concat() const;
  ::vlsir::circuit::Concat* _internal_mutable_concat();
  public:
  void unsafe_arena_set_allocated_concat(
      ::vlsir::circuit::Concat* concat);
  ::vlsir::circuit::Concat* unsafe_arena_release_concat();

  void clear_stype();
  StypeCase stype_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.circuit.ConnectionTarget)
 private:
  class _Internal;
  void set_has_sig();
  void set_has_slice();
  void set_has_concat();

  inline bool has_stype() const;
  inline void clear_has_stype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StypeUnion {
    StypeUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
    ::vlsir::circuit::Slice* slice_;
    ::vlsir::circuit::Concat* concat_;
  } stype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Connection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {};
  virtual ~Connection();

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Connection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Connection* New() const final {
    return CreateMaybeMessage<Connection>(nullptr);
  }

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortnameFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // string portname = 1;
  void clear_portname();
  const std::string& portname() const;
  void set_portname(const std::string& value);
  void set_portname(std::string&& value);
  void set_portname(const char* value);
  void set_portname(const char* value, size_t size);
  std::string* mutable_portname();
  std::string* release_portname();
  void set_allocated_portname(std::string* portname);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_portname();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_portname(
      std::string* portname);
  private:
  const std::string& _internal_portname() const;
  void _internal_set_portname(const std::string& value);
  std::string* _internal_mutable_portname();
  public:

  // .vlsir.circuit.ConnectionTarget target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::vlsir::circuit::ConnectionTarget& target() const;
  ::vlsir::circuit::ConnectionTarget* release_target();
  ::vlsir::circuit::ConnectionTarget* mutable_target();
  void set_allocated_target(::vlsir::circuit::ConnectionTarget* target);
  private:
  const ::vlsir::circuit::ConnectionTarget& _internal_target() const;
  ::vlsir::circuit::ConnectionTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::vlsir::circuit::ConnectionTarget* target);
  ::vlsir::circuit::ConnectionTarget* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr portname_;
  ::vlsir::circuit::ConnectionTarget* target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Instance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {};
  virtual ~Instance();

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Instance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const final {
    return CreateMaybeMessage<Instance>(nullptr);
  }

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kConnectionsFieldNumber = 4,
    kNameFieldNumber = 1,
    kModuleFieldNumber = 2,
  };
  // repeated .vlsir.utils.Param parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  private:
  const ::vlsir::utils::Param& _internal_parameters(int index) const;
  ::vlsir::utils::Param* _internal_add_parameters();
  public:
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // repeated .vlsir.circuit.Connection connections = 4;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  ::vlsir::circuit::Connection* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >*
      mutable_connections();
  private:
  const ::vlsir::circuit::Connection& _internal_connections(int index) const;
  ::vlsir::circuit::Connection* _internal_add_connections();
  public:
  const ::vlsir::circuit::Connection& connections(int index) const;
  ::vlsir::circuit::Connection* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >&
      connections() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.utils.Reference module = 2;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::vlsir::utils::Reference& module() const;
  ::vlsir::utils::Reference* release_module();
  ::vlsir::utils::Reference* mutable_module();
  void set_allocated_module(::vlsir::utils::Reference* module);
  private:
  const ::vlsir::utils::Reference& _internal_module() const;
  ::vlsir::utils::Reference* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::vlsir::utils::Reference* module);
  ::vlsir::utils::Reference* unsafe_arena_release_module();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection > connections_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::utils::Reference* module_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Module PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Module) */ {
 public:
  inline Module() : Module(nullptr) {};
  virtual ~Module();

  Module(const Module& from);
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Module& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Module* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Module* New() const final {
    return CreateMaybeMessage<Module>(nullptr);
  }

  Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Module";
  }
  protected:
  explicit Module(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 2,
    kSignalsFieldNumber = 3,
    kInstancesFieldNumber = 4,
    kParametersFieldNumber = 5,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 2;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Signal signals = 3;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  private:
  const ::vlsir::circuit::Signal& _internal_signals(int index) const;
  ::vlsir::circuit::Signal* _internal_add_signals();
  public:
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.circuit.Instance instances = 4;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::circuit::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
      mutable_instances();
  private:
  const ::vlsir::circuit::Instance& _internal_instances(int index) const;
  ::vlsir::circuit::Instance* _internal_add_instances();
  public:
  const ::vlsir::circuit::Instance& instances(int index) const;
  ::vlsir::circuit::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
      instances() const;

  // repeated .vlsir.utils.Param parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  private:
  const ::vlsir::utils::Param& _internal_parameters(int index) const;
  ::vlsir::utils::Param* _internal_add_parameters();
  public:
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance > instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class ExternalModule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ExternalModule) */ {
 public:
  inline ExternalModule() : ExternalModule(nullptr) {};
  virtual ~ExternalModule();

  ExternalModule(const ExternalModule& from);
  ExternalModule(ExternalModule&& from) noexcept
    : ExternalModule() {
    *this = ::std::move(from);
  }

  inline ExternalModule& operator=(const ExternalModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalModule& operator=(ExternalModule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExternalModule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternalModule* internal_default_instance() {
    return reinterpret_cast<const ExternalModule*>(
               &_ExternalModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExternalModule& a, ExternalModule& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalModule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExternalModule* New() const final {
    return CreateMaybeMessage<ExternalModule>(nullptr);
  }

  ExternalModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExternalModule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExternalModule& from);
  void MergeFrom(const ExternalModule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalModule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.ExternalModule";
  }
  protected:
  explicit ExternalModule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 3,
    kSignalsFieldNumber = 4,
    kParametersFieldNumber = 5,
    kDescFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 3;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Signal signals = 4;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  private:
  const ::vlsir::circuit::Signal& _internal_signals(int index) const;
  ::vlsir::circuit::Signal* _internal_add_signals();
  public:
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.utils.Param parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  private:
  const ::vlsir::utils::Param& _internal_parameters(int index) const;
  ::vlsir::utils::Param* _internal_add_parameters();
  public:
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // string desc = 2;
  void clear_desc();
  const std::string& desc() const;
  void set_desc(const std::string& value);
  void set_desc(std::string&& value);
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  std::string* mutable_desc();
  std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_desc();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_desc(
      std::string* desc);
  private:
  const std::string& _internal_desc() const;
  void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // .vlsir.utils.QualifiedName name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::vlsir::utils::QualifiedName& name() const;
  ::vlsir::utils::QualifiedName* release_name();
  ::vlsir::utils::QualifiedName* mutable_name();
  void set_allocated_name(::vlsir::utils::QualifiedName* name);
  private:
  const ::vlsir::utils::QualifiedName& _internal_name() const;
  ::vlsir::utils::QualifiedName* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::vlsir::utils::QualifiedName* name);
  ::vlsir::utils::QualifiedName* unsafe_arena_release_name();

  // @@protoc_insertion_point(class_scope:vlsir.circuit.ExternalModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::vlsir::utils::QualifiedName* name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// -------------------------------------------------------------------

class Interface PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Interface) */ {
 public:
  inline Interface() : Interface(nullptr) {};
  virtual ~Interface();

  Interface(const Interface& from);
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interface& operator=(Interface&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Interface& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }
  inline void Swap(Interface* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Interface* New() const final {
    return CreateMaybeMessage<Interface>(nullptr);
  }

  Interface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Interface& from);
  void MergeFrom(const Interface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.circuit.Interface";
  }
  protected:
  explicit Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_circuit_2eproto);
    return ::descriptor_table_circuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 10,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.circuit.Port ports = 10;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  private:
  const ::vlsir::circuit::Port& _internal_ports(int index) const;
  ::vlsir::circuit::Port* _internal_add_ports();
  public:
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Interface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuit_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Package

// string domain = 1;
inline void Package::clear_domain() {
  domain_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Package::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.domain)
  return _internal_domain();
}
inline void Package::set_domain(const std::string& value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.domain)
}
inline std::string* Package::mutable_domain() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.domain)
  return _internal_mutable_domain();
}
inline const std::string& Package::_internal_domain() const {
  return domain_.Get();
}
inline void Package::_internal_set_domain(const std::string& value) {
  
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Package::set_domain(std::string&& value) {
  
  domain_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Package.domain)
}
inline void Package::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Package.domain)
}
inline void Package::set_domain(const char* value,
    size_t size) {
  
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Package.domain)
}
inline std::string* Package::_internal_mutable_domain() {
  
  return domain_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Package::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Package::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.domain)
}
inline std::string* Package::unsafe_arena_release_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Package.domain)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return domain_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Package::unsafe_arena_set_allocated_domain(
    std::string* domain) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      domain, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Package.domain)
}

// repeated .vlsir.circuit.Module modules = 2;
inline int Package::_internal_modules_size() const {
  return modules_.size();
}
inline int Package::modules_size() const {
  return _internal_modules_size();
}
inline void Package::clear_modules() {
  modules_.Clear();
}
inline ::vlsir::circuit::Module* Package::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.modules)
  return modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >*
Package::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.modules)
  return &modules_;
}
inline const ::vlsir::circuit::Module& Package::_internal_modules(int index) const {
  return modules_.Get(index);
}
inline const ::vlsir::circuit::Module& Package::modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.modules)
  return _internal_modules(index);
}
inline ::vlsir::circuit::Module* Package::_internal_add_modules() {
  return modules_.Add();
}
inline ::vlsir::circuit::Module* Package::add_modules() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.modules)
  return _internal_add_modules();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Module >&
Package::modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.modules)
  return modules_;
}

// repeated .vlsir.circuit.ExternalModule ext_modules = 3;
inline int Package::_internal_ext_modules_size() const {
  return ext_modules_.size();
}
inline int Package::ext_modules_size() const {
  return _internal_ext_modules_size();
}
inline void Package::clear_ext_modules() {
  ext_modules_.Clear();
}
inline ::vlsir::circuit::ExternalModule* Package::mutable_ext_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.ext_modules)
  return ext_modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
Package::mutable_ext_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.ext_modules)
  return &ext_modules_;
}
inline const ::vlsir::circuit::ExternalModule& Package::_internal_ext_modules(int index) const {
  return ext_modules_.Get(index);
}
inline const ::vlsir::circuit::ExternalModule& Package::ext_modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.ext_modules)
  return _internal_ext_modules(index);
}
inline ::vlsir::circuit::ExternalModule* Package::_internal_add_ext_modules() {
  return ext_modules_.Add();
}
inline ::vlsir::circuit::ExternalModule* Package::add_ext_modules() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.ext_modules)
  return _internal_add_ext_modules();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
Package::ext_modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.ext_modules)
  return ext_modules_;
}

// string desc = 10;
inline void Package::clear_desc() {
  desc_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Package::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.desc)
  return _internal_desc();
}
inline void Package::set_desc(const std::string& value) {
  _internal_set_desc(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.desc)
}
inline std::string* Package::mutable_desc() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.desc)
  return _internal_mutable_desc();
}
inline const std::string& Package::_internal_desc() const {
  return desc_.Get();
}
inline void Package::_internal_set_desc(const std::string& value) {
  
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Package::set_desc(std::string&& value) {
  
  desc_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Package.desc)
}
inline void Package::set_desc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Package.desc)
}
inline void Package::set_desc(const char* value,
    size_t size) {
  
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Package.desc)
}
inline std::string* Package::_internal_mutable_desc() {
  
  return desc_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Package::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Package::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.desc)
}
inline std::string* Package::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Package.desc)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return desc_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Package::unsafe_arena_set_allocated_desc(
    std::string* desc) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      desc, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Package.desc)
}

// -------------------------------------------------------------------

// Port

// string signal = 1;
inline void Port::clear_signal() {
  signal_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Port::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.signal)
  return _internal_signal();
}
inline void Port::set_signal(const std::string& value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.signal)
}
inline std::string* Port::mutable_signal() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Port.signal)
  return _internal_mutable_signal();
}
inline const std::string& Port::_internal_signal() const {
  return signal_.Get();
}
inline void Port::_internal_set_signal(const std::string& value) {
  
  signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Port::set_signal(std::string&& value) {
  
  signal_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Port.signal)
}
inline void Port::set_signal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Port.signal)
}
inline void Port::set_signal(const char* value,
    size_t size) {
  
  signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Port.signal)
}
inline std::string* Port::_internal_mutable_signal() {
  
  return signal_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Port::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Port.signal)
  return signal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Port::set_allocated_signal(std::string* signal) {
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signal,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Port.signal)
}
inline std::string* Port::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Port.signal)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signal_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Port::unsafe_arena_set_allocated_signal(
    std::string* signal) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signal, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Port.signal)
}

// .vlsir.circuit.Port.Direction direction = 2;
inline void Port::clear_direction() {
  direction_ = 0;
}
inline ::vlsir::circuit::Port_Direction Port::_internal_direction() const {
  return static_cast< ::vlsir::circuit::Port_Direction >(direction_);
}
inline ::vlsir::circuit::Port_Direction Port::direction() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.direction)
  return _internal_direction();
}
inline void Port::_internal_set_direction(::vlsir::circuit::Port_Direction value) {
  
  direction_ = value;
}
inline void Port::set_direction(::vlsir::circuit::Port_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.direction)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.name)
  return _internal_name();
}
inline void Signal::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.name)
}
inline std::string* Signal::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Signal.name)
  return _internal_mutable_name();
}
inline const std::string& Signal::_internal_name() const {
  return name_.Get();
}
inline void Signal::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Signal::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Signal.name)
}
inline void Signal::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Signal.name)
}
inline void Signal::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Signal.name)
}
inline std::string* Signal::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Signal.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Signal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Signal.name)
}
inline std::string* Signal::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Signal.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Signal::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Signal.name)
}

// int64 width = 2;
inline void Signal::clear_width() {
  width_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Signal::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Signal::width() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.width)
  return _internal_width();
}
inline void Signal::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  width_ = value;
}
inline void Signal::set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.width)
}

// -------------------------------------------------------------------

// Slice

// string signal = 1;
inline void Slice::clear_signal() {
  signal_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Slice::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.signal)
  return _internal_signal();
}
inline void Slice::set_signal(const std::string& value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.signal)
}
inline std::string* Slice::mutable_signal() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Slice.signal)
  return _internal_mutable_signal();
}
inline const std::string& Slice::_internal_signal() const {
  return signal_.Get();
}
inline void Slice::_internal_set_signal(const std::string& value) {
  
  signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Slice::set_signal(std::string&& value) {
  
  signal_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Slice.signal)
}
inline void Slice::set_signal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Slice.signal)
}
inline void Slice::set_signal(const char* value,
    size_t size) {
  
  signal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Slice.signal)
}
inline std::string* Slice::_internal_mutable_signal() {
  
  return signal_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Slice::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Slice.signal)
  return signal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Slice::set_allocated_signal(std::string* signal) {
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signal,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Slice.signal)
}
inline std::string* Slice::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Slice.signal)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signal_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Slice::unsafe_arena_set_allocated_signal(
    std::string* signal) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signal != nullptr) {
    
  } else {
    
  }
  signal_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signal, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Slice.signal)
}

// int64 top = 2;
inline void Slice::clear_top() {
  top_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::_internal_top() const {
  return top_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::top() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.top)
  return _internal_top();
}
inline void Slice::_internal_set_top(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  top_ = value;
}
inline void Slice::set_top(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.top)
}

// int64 bot = 3;
inline void Slice::clear_bot() {
  bot_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::_internal_bot() const {
  return bot_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Slice::bot() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.bot)
  return _internal_bot();
}
inline void Slice::_internal_set_bot(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  bot_ = value;
}
inline void Slice::set_bot(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_bot(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.bot)
}

// -------------------------------------------------------------------

// Concat

// repeated .vlsir.circuit.ConnectionTarget parts = 1;
inline int Concat::_internal_parts_size() const {
  return parts_.size();
}
inline int Concat::parts_size() const {
  return _internal_parts_size();
}
inline void Concat::clear_parts() {
  parts_.Clear();
}
inline ::vlsir::circuit::ConnectionTarget* Concat::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Concat.parts)
  return parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >*
Concat::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Concat.parts)
  return &parts_;
}
inline const ::vlsir::circuit::ConnectionTarget& Concat::_internal_parts(int index) const {
  return parts_.Get(index);
}
inline const ::vlsir::circuit::ConnectionTarget& Concat::parts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Concat.parts)
  return _internal_parts(index);
}
inline ::vlsir::circuit::ConnectionTarget* Concat::_internal_add_parts() {
  return parts_.Add();
}
inline ::vlsir::circuit::ConnectionTarget* Concat::add_parts() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Concat.parts)
  return _internal_add_parts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >&
Concat::parts() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Concat.parts)
  return parts_;
}

// -------------------------------------------------------------------

// ConnectionTarget

// string sig = 1;
inline bool ConnectionTarget::_internal_has_sig() const {
  return stype_case() == kSig;
}
inline void ConnectionTarget::set_has_sig() {
  _oneof_case_[0] = kSig;
}
inline void ConnectionTarget::clear_sig() {
  if (_internal_has_sig()) {
    stype_.sig_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_stype();
  }
}
inline const std::string& ConnectionTarget::sig() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.sig)
  return _internal_sig();
}
inline void ConnectionTarget::set_sig(const std::string& value) {
  _internal_set_sig(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.ConnectionTarget.sig)
}
inline std::string* ConnectionTarget::mutable_sig() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.sig)
  return _internal_mutable_sig();
}
inline const std::string& ConnectionTarget::_internal_sig() const {
  if (_internal_has_sig()) {
    return stype_.sig_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ConnectionTarget::_internal_set_sig(const std::string& value) {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionTarget::set_sig(std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.circuit.ConnectionTarget.sig)
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.ConnectionTarget.sig)
}
inline void ConnectionTarget::set_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.ConnectionTarget.sig)
}
inline void ConnectionTarget::set_sig(const char* value,
                             size_t size) {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.ConnectionTarget.sig)
}
inline std::string* ConnectionTarget::_internal_mutable_sig() {
  if (!_internal_has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return stype_.sig_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionTarget::release_sig() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.sig)
  if (_internal_has_sig()) {
    clear_has_stype();
    return stype_.sig_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::set_allocated_sig(std::string* sig) {
  if (has_stype()) {
    clear_stype();
  }
  if (sig != nullptr) {
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(sig);
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ConnectionTarget.sig)
}
inline std::string* ConnectionTarget::unsafe_arena_release_sig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.ConnectionTarget.sig)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_sig()) {
    clear_has_stype();
    return stype_.sig_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::unsafe_arena_set_allocated_sig(std::string* sig) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_sig()) {
    stype_.sig_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_stype();
  if (sig) {
    set_has_sig();
    stype_.sig_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ConnectionTarget.sig)
}

// .vlsir.circuit.Slice slice = 2;
inline bool ConnectionTarget::_internal_has_slice() const {
  return stype_case() == kSlice;
}
inline bool ConnectionTarget::has_slice() const {
  return _internal_has_slice();
}
inline void ConnectionTarget::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void ConnectionTarget::clear_slice() {
  if (_internal_has_slice()) {
    if (GetArena() == nullptr) {
      delete stype_.slice_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Slice* ConnectionTarget::release_slice() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.slice)
  if (_internal_has_slice()) {
    clear_has_stype();
      ::vlsir::circuit::Slice* temp = stype_.slice_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Slice& ConnectionTarget::_internal_slice() const {
  return _internal_has_slice()
      ? *stype_.slice_
      : *reinterpret_cast< ::vlsir::circuit::Slice*>(&::vlsir::circuit::_Slice_default_instance_);
}
inline const ::vlsir::circuit::Slice& ConnectionTarget::slice() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.slice)
  return _internal_slice();
}
inline ::vlsir::circuit::Slice* ConnectionTarget::unsafe_arena_release_slice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.ConnectionTarget.slice)
  if (_internal_has_slice()) {
    clear_has_stype();
    ::vlsir::circuit::Slice* temp = stype_.slice_;
    stype_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::unsafe_arena_set_allocated_slice(::vlsir::circuit::Slice* slice) {
  clear_stype();
  if (slice) {
    set_has_slice();
    stype_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ConnectionTarget.slice)
}
inline ::vlsir::circuit::Slice* ConnectionTarget::_internal_mutable_slice() {
  if (!_internal_has_slice()) {
    clear_stype();
    set_has_slice();
    stype_.slice_ = CreateMaybeMessage< ::vlsir::circuit::Slice >(GetArena());
  }
  return stype_.slice_;
}
inline ::vlsir::circuit::Slice* ConnectionTarget::mutable_slice() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.slice)
  return _internal_mutable_slice();
}

// .vlsir.circuit.Concat concat = 3;
inline bool ConnectionTarget::_internal_has_concat() const {
  return stype_case() == kConcat;
}
inline bool ConnectionTarget::has_concat() const {
  return _internal_has_concat();
}
inline void ConnectionTarget::set_has_concat() {
  _oneof_case_[0] = kConcat;
}
inline void ConnectionTarget::clear_concat() {
  if (_internal_has_concat()) {
    if (GetArena() == nullptr) {
      delete stype_.concat_;
    }
    clear_has_stype();
  }
}
inline ::vlsir::circuit::Concat* ConnectionTarget::release_concat() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.concat)
  if (_internal_has_concat()) {
    clear_has_stype();
      ::vlsir::circuit::Concat* temp = stype_.concat_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stype_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vlsir::circuit::Concat& ConnectionTarget::_internal_concat() const {
  return _internal_has_concat()
      ? *stype_.concat_
      : *reinterpret_cast< ::vlsir::circuit::Concat*>(&::vlsir::circuit::_Concat_default_instance_);
}
inline const ::vlsir::circuit::Concat& ConnectionTarget::concat() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.concat)
  return _internal_concat();
}
inline ::vlsir::circuit::Concat* ConnectionTarget::unsafe_arena_release_concat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.ConnectionTarget.concat)
  if (_internal_has_concat()) {
    clear_has_stype();
    ::vlsir::circuit::Concat* temp = stype_.concat_;
    stype_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionTarget::unsafe_arena_set_allocated_concat(::vlsir::circuit::Concat* concat) {
  clear_stype();
  if (concat) {
    set_has_concat();
    stype_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ConnectionTarget.concat)
}
inline ::vlsir::circuit::Concat* ConnectionTarget::_internal_mutable_concat() {
  if (!_internal_has_concat()) {
    clear_stype();
    set_has_concat();
    stype_.concat_ = CreateMaybeMessage< ::vlsir::circuit::Concat >(GetArena());
  }
  return stype_.concat_;
}
inline ::vlsir::circuit::Concat* ConnectionTarget::mutable_concat() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.concat)
  return _internal_mutable_concat();
}

inline bool ConnectionTarget::has_stype() const {
  return stype_case() != STYPE_NOT_SET;
}
inline void ConnectionTarget::clear_has_stype() {
  _oneof_case_[0] = STYPE_NOT_SET;
}
inline ConnectionTarget::StypeCase ConnectionTarget::stype_case() const {
  return ConnectionTarget::StypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Connection

// string portname = 1;
inline void Connection::clear_portname() {
  portname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Connection::portname() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.portname)
  return _internal_portname();
}
inline void Connection::set_portname(const std::string& value) {
  _internal_set_portname(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Connection.portname)
}
inline std::string* Connection::mutable_portname() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.portname)
  return _internal_mutable_portname();
}
inline const std::string& Connection::_internal_portname() const {
  return portname_.Get();
}
inline void Connection::_internal_set_portname(const std::string& value) {
  
  portname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Connection::set_portname(std::string&& value) {
  
  portname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Connection.portname)
}
inline void Connection::set_portname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  portname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Connection.portname)
}
inline void Connection::set_portname(const char* value,
    size_t size) {
  
  portname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Connection.portname)
}
inline std::string* Connection::_internal_mutable_portname() {
  
  return portname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Connection::release_portname() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.portname)
  return portname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Connection::set_allocated_portname(std::string* portname) {
  if (portname != nullptr) {
    
  } else {
    
  }
  portname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), portname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Connection.portname)
}
inline std::string* Connection::unsafe_arena_release_portname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Connection.portname)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return portname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Connection::unsafe_arena_set_allocated_portname(
    std::string* portname) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (portname != nullptr) {
    
  } else {
    
  }
  portname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      portname, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Connection.portname)
}

// .vlsir.circuit.ConnectionTarget target = 2;
inline bool Connection::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool Connection::has_target() const {
  return _internal_has_target();
}
inline void Connection::clear_target() {
  if (GetArena() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::vlsir::circuit::ConnectionTarget& Connection::_internal_target() const {
  const ::vlsir::circuit::ConnectionTarget* p = target_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::circuit::ConnectionTarget*>(
      &::vlsir::circuit::_ConnectionTarget_default_instance_);
}
inline const ::vlsir::circuit::ConnectionTarget& Connection::target() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.target)
  return _internal_target();
}
inline void Connection::unsafe_arena_set_allocated_target(
    ::vlsir::circuit::ConnectionTarget* target) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Connection.target)
}
inline ::vlsir::circuit::ConnectionTarget* Connection::release_target() {
  auto temp = unsafe_arena_release_target();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.target)
  
  ::vlsir::circuit::ConnectionTarget* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::ConnectionTarget>(GetArena());
    target_ = p;
  }
  return target_;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::mutable_target() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.target)
  return _internal_mutable_target();
}
inline void Connection::set_allocated_target(::vlsir::circuit::ConnectionTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Connection.target)
}

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.name)
  return _internal_name();
}
inline void Instance::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Instance.name)
}
inline std::string* Instance::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.name)
  return _internal_mutable_name();
}
inline const std::string& Instance::_internal_name() const {
  return name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Instance::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Instance.name)
}
inline void Instance::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Instance.name)
}
inline void Instance::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Instance.name)
}
inline std::string* Instance::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.name)
}
inline std::string* Instance::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Instance.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Instance::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Instance.name)
}

// .vlsir.utils.Reference module = 2;
inline bool Instance::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool Instance::has_module() const {
  return _internal_has_module();
}
inline const ::vlsir::utils::Reference& Instance::_internal_module() const {
  const ::vlsir::utils::Reference* p = module_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::utils::Reference*>(
      &::vlsir::utils::_Reference_default_instance_);
}
inline const ::vlsir::utils::Reference& Instance::module() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.module)
  return _internal_module();
}
inline void Instance::unsafe_arena_set_allocated_module(
    ::vlsir::utils::Reference* module) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Instance.module)
}
inline ::vlsir::utils::Reference* Instance::release_module() {
  auto temp = unsafe_arena_release_module();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::utils::Reference* Instance::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.module)
  
  ::vlsir::utils::Reference* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArena());
    module_ = p;
  }
  return module_;
}
inline ::vlsir::utils::Reference* Instance::mutable_module() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.module)
  return _internal_mutable_module();
}
inline void Instance::set_allocated_module(::vlsir::utils::Reference* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module)->GetArena();
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.module)
}

// repeated .vlsir.utils.Param parameters = 3;
inline int Instance::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Instance::parameters_size() const {
  return _internal_parameters_size();
}
inline ::vlsir::utils::Param* Instance::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
Instance::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Instance.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& Instance::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::utils::Param& Instance::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::utils::Param* Instance::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::utils::Param* Instance::add_parameters() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Instance.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
Instance::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Instance.parameters)
  return parameters_;
}

// repeated .vlsir.circuit.Connection connections = 4;
inline int Instance::_internal_connections_size() const {
  return connections_.size();
}
inline int Instance::connections_size() const {
  return _internal_connections_size();
}
inline void Instance::clear_connections() {
  connections_.Clear();
}
inline ::vlsir::circuit::Connection* Instance::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.connections)
  return connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >*
Instance::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Instance.connections)
  return &connections_;
}
inline const ::vlsir::circuit::Connection& Instance::_internal_connections(int index) const {
  return connections_.Get(index);
}
inline const ::vlsir::circuit::Connection& Instance::connections(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.connections)
  return _internal_connections(index);
}
inline ::vlsir::circuit::Connection* Instance::_internal_add_connections() {
  return connections_.Add();
}
inline ::vlsir::circuit::Connection* Instance::add_connections() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Instance.connections)
  return _internal_add_connections();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Connection >&
Instance::connections() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Instance.connections)
  return connections_;
}

// -------------------------------------------------------------------

// Module

// string name = 1;
inline void Module::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.name)
  return _internal_name();
}
inline void Module::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Module.name)
}
inline std::string* Module::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.name)
  return _internal_mutable_name();
}
inline const std::string& Module::_internal_name() const {
  return name_.Get();
}
inline void Module::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Module::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Module.name)
}
inline void Module::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Module.name)
}
inline void Module::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Module.name)
}
inline std::string* Module::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Module.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Module::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Module.name)
}
inline std::string* Module::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Module.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Module::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Module.name)
}

// repeated .vlsir.circuit.Port ports = 2;
inline int Module::_internal_ports_size() const {
  return ports_.size();
}
inline int Module::ports_size() const {
  return _internal_ports_size();
}
inline void Module::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Module::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
Module::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Module::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& Module::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* Module::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* Module::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.ports)
  return _internal_add_ports();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
Module::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.ports)
  return ports_;
}

// repeated .vlsir.circuit.Signal signals = 3;
inline int Module::_internal_signals_size() const {
  return signals_.size();
}
inline int Module::signals_size() const {
  return _internal_signals_size();
}
inline void Module::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::circuit::Signal* Module::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
Module::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& Module::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const ::vlsir::circuit::Signal& Module::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.signals)
  return _internal_signals(index);
}
inline ::vlsir::circuit::Signal* Module::_internal_add_signals() {
  return signals_.Add();
}
inline ::vlsir::circuit::Signal* Module::add_signals() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.signals)
  return _internal_add_signals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
Module::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.signals)
  return signals_;
}

// repeated .vlsir.circuit.Instance instances = 4;
inline int Module::_internal_instances_size() const {
  return instances_.size();
}
inline int Module::instances_size() const {
  return _internal_instances_size();
}
inline void Module::clear_instances() {
  instances_.Clear();
}
inline ::vlsir::circuit::Instance* Module::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >*
Module::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.instances)
  return &instances_;
}
inline const ::vlsir::circuit::Instance& Module::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::vlsir::circuit::Instance& Module::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.instances)
  return _internal_instances(index);
}
inline ::vlsir::circuit::Instance* Module::_internal_add_instances() {
  return instances_.Add();
}
inline ::vlsir::circuit::Instance* Module::add_instances() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.instances)
  return _internal_add_instances();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Instance >&
Module::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.instances)
  return instances_;
}

// repeated .vlsir.utils.Param parameters = 5;
inline int Module::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Module::parameters_size() const {
  return _internal_parameters_size();
}
inline ::vlsir::utils::Param* Module::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
Module::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& Module::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::utils::Param& Module::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::utils::Param* Module::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::utils::Param* Module::add_parameters() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
Module::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// ExternalModule

// .vlsir.utils.QualifiedName name = 1;
inline bool ExternalModule::_internal_has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline bool ExternalModule::has_name() const {
  return _internal_has_name();
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::_internal_name() const {
  const ::vlsir::utils::QualifiedName* p = name_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::utils::QualifiedName*>(
      &::vlsir::utils::_QualifiedName_default_instance_);
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.name)
  return _internal_name();
}
inline void ExternalModule::unsafe_arena_set_allocated_name(
    ::vlsir::utils::QualifiedName* name) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ExternalModule.name)
}
inline ::vlsir::utils::QualifiedName* ExternalModule::release_name() {
  auto temp = unsafe_arena_release_name();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.name)
  
  ::vlsir::utils::QualifiedName* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::_internal_mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::QualifiedName>(GetArena());
    name_ = p;
  }
  return name_;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.name)
  return _internal_mutable_name();
}
inline void ExternalModule::set_allocated_name(::vlsir::utils::QualifiedName* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name)->GetArena();
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.name)
}

// string desc = 2;
inline void ExternalModule::clear_desc() {
  desc_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ExternalModule::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.desc)
  return _internal_desc();
}
inline void ExternalModule::set_desc(const std::string& value) {
  _internal_set_desc(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.ExternalModule.desc)
}
inline std::string* ExternalModule::mutable_desc() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.desc)
  return _internal_mutable_desc();
}
inline const std::string& ExternalModule::_internal_desc() const {
  return desc_.Get();
}
inline void ExternalModule::_internal_set_desc(const std::string& value) {
  
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExternalModule::set_desc(std::string&& value) {
  
  desc_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.ExternalModule.desc)
}
inline void ExternalModule::set_desc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.ExternalModule.desc)
}
inline void ExternalModule::set_desc(const char* value,
    size_t size) {
  
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.ExternalModule.desc)
}
inline std::string* ExternalModule::_internal_mutable_desc() {
  
  return desc_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExternalModule::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExternalModule::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.desc)
}
inline std::string* ExternalModule::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.ExternalModule.desc)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return desc_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ExternalModule::unsafe_arena_set_allocated_desc(
    std::string* desc) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      desc, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.ExternalModule.desc)
}

// repeated .vlsir.circuit.Port ports = 3;
inline int ExternalModule::_internal_ports_size() const {
  return ports_.size();
}
inline int ExternalModule::ports_size() const {
  return _internal_ports_size();
}
inline void ExternalModule::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* ExternalModule::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
ExternalModule::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& ExternalModule::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& ExternalModule::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* ExternalModule::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* ExternalModule::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.ports)
  return _internal_add_ports();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
ExternalModule::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.ports)
  return ports_;
}

// repeated .vlsir.circuit.Signal signals = 4;
inline int ExternalModule::_internal_signals_size() const {
  return signals_.size();
}
inline int ExternalModule::signals_size() const {
  return _internal_signals_size();
}
inline void ExternalModule::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::circuit::Signal* ExternalModule::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >*
ExternalModule::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& ExternalModule::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline const ::vlsir::circuit::Signal& ExternalModule::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.signals)
  return _internal_signals(index);
}
inline ::vlsir::circuit::Signal* ExternalModule::_internal_add_signals() {
  return signals_.Add();
}
inline ::vlsir::circuit::Signal* ExternalModule::add_signals() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.signals)
  return _internal_add_signals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Signal >&
ExternalModule::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.signals)
  return signals_;
}

// repeated .vlsir.utils.Param parameters = 5;
inline int ExternalModule::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ExternalModule::parameters_size() const {
  return _internal_parameters_size();
}
inline ::vlsir::utils::Param* ExternalModule::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >*
ExternalModule::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& ExternalModule::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::vlsir::utils::Param& ExternalModule::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.parameters)
  return _internal_parameters(index);
}
inline ::vlsir::utils::Param* ExternalModule::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::vlsir::utils::Param* ExternalModule::add_parameters() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::utils::Param >&
ExternalModule::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// Interface

// string name = 1;
inline void Interface::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Interface::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.name)
  return _internal_name();
}
inline void Interface::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Interface.name)
}
inline std::string* Interface::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.name)
  return _internal_mutable_name();
}
inline const std::string& Interface::_internal_name() const {
  return name_.Get();
}
inline void Interface::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Interface::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Interface.name)
}
inline void Interface::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Interface.name)
}
inline void Interface::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Interface.name)
}
inline std::string* Interface::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Interface::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Interface.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Interface::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Interface.name)
}
inline std::string* Interface::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.circuit.Interface.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Interface::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.circuit.Interface.name)
}

// repeated .vlsir.circuit.Port ports = 10;
inline int Interface::_internal_ports_size() const {
  return ports_.size();
}
inline int Interface::ports_size() const {
  return _internal_ports_size();
}
inline void Interface::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Interface::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >*
Interface::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Interface.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Interface::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::circuit::Port& Interface::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.ports)
  return _internal_ports(index);
}
inline ::vlsir::circuit::Port* Interface::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::circuit::Port* Interface::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Interface.ports)
  return _internal_add_ports();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::circuit::Port >&
Interface::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Interface.ports)
  return ports_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace circuit
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::circuit::Port_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::circuit::Port_Direction>() {
  return ::vlsir::circuit::Port_Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_circuit_2eproto
