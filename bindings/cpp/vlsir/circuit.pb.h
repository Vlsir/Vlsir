// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: circuit.proto

#ifndef PROTOBUF_INCLUDED_circuit_2eproto
#define PROTOBUF_INCLUDED_circuit_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_circuit_2eproto 

namespace protobuf_circuit_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_circuit_2eproto
namespace vlsir {
namespace circuit {
class Concat;
class ConcatDefaultTypeInternal;
extern ConcatDefaultTypeInternal _Concat_default_instance_;
class Connection;
class ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class ConnectionTarget;
class ConnectionTargetDefaultTypeInternal;
extern ConnectionTargetDefaultTypeInternal _ConnectionTarget_default_instance_;
class ExternalModule;
class ExternalModuleDefaultTypeInternal;
extern ExternalModuleDefaultTypeInternal _ExternalModule_default_instance_;
class Instance;
class InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Interface;
class InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class Module;
class ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class Package;
class PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class Port;
class PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Slice;
class SliceDefaultTypeInternal;
extern SliceDefaultTypeInternal _Slice_default_instance_;
}  // namespace circuit
}  // namespace vlsir
namespace google {
namespace protobuf {
template<> ::vlsir::circuit::Concat* Arena::CreateMaybeMessage<::vlsir::circuit::Concat>(Arena*);
template<> ::vlsir::circuit::Connection* Arena::CreateMaybeMessage<::vlsir::circuit::Connection>(Arena*);
template<> ::vlsir::circuit::ConnectionTarget* Arena::CreateMaybeMessage<::vlsir::circuit::ConnectionTarget>(Arena*);
template<> ::vlsir::circuit::ExternalModule* Arena::CreateMaybeMessage<::vlsir::circuit::ExternalModule>(Arena*);
template<> ::vlsir::circuit::Instance* Arena::CreateMaybeMessage<::vlsir::circuit::Instance>(Arena*);
template<> ::vlsir::circuit::Interface* Arena::CreateMaybeMessage<::vlsir::circuit::Interface>(Arena*);
template<> ::vlsir::circuit::Module* Arena::CreateMaybeMessage<::vlsir::circuit::Module>(Arena*);
template<> ::vlsir::circuit::Package* Arena::CreateMaybeMessage<::vlsir::circuit::Package>(Arena*);
template<> ::vlsir::circuit::Port* Arena::CreateMaybeMessage<::vlsir::circuit::Port>(Arena*);
template<> ::vlsir::circuit::Signal* Arena::CreateMaybeMessage<::vlsir::circuit::Signal>(Arena*);
template<> ::vlsir::circuit::Slice* Arena::CreateMaybeMessage<::vlsir::circuit::Slice>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vlsir {
namespace circuit {

enum Port_Direction {
  Port_Direction_INPUT = 0,
  Port_Direction_OUTPUT = 1,
  Port_Direction_INOUT = 2,
  Port_Direction_NONE = 3,
  Port_Direction_Port_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Port_Direction_Port_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Port_Direction_IsValid(int value);
const Port_Direction Port_Direction_Direction_MIN = Port_Direction_INPUT;
const Port_Direction Port_Direction_Direction_MAX = Port_Direction_NONE;
const int Port_Direction_Direction_ARRAYSIZE = Port_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Port_Direction_descriptor();
inline const ::std::string& Port_Direction_Name(Port_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Port_Direction_descriptor(), value);
}
inline bool Port_Direction_Parse(
    const ::std::string& name, Port_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Port_Direction>(
    Port_Direction_descriptor(), name, value);
}
// ===================================================================

class Package : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Package) */ {
 public:
  Package();
  virtual ~Package();

  Package(const Package& from);

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(Package&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Package& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Package* other);
  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Package* New() const final {
    return CreateMaybeMessage<Package>(NULL);
  }

  Package* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Package& from);
  void MergeFrom(const Package& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.circuit.Module modules = 2;
  int modules_size() const;
  void clear_modules();
  static const int kModulesFieldNumber = 2;
  ::vlsir::circuit::Module* mutable_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Module >*
      mutable_modules();
  const ::vlsir::circuit::Module& modules(int index) const;
  ::vlsir::circuit::Module* add_modules();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Module >&
      modules() const;

  // repeated .vlsir.circuit.ExternalModule ext_modules = 3;
  int ext_modules_size() const;
  void clear_ext_modules();
  static const int kExtModulesFieldNumber = 3;
  ::vlsir::circuit::ExternalModule* mutable_ext_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
      mutable_ext_modules();
  const ::vlsir::circuit::ExternalModule& ext_modules(int index) const;
  ::vlsir::circuit::ExternalModule* add_ext_modules();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
      ext_modules() const;

  // string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string desc = 10;
  void clear_desc();
  static const int kDescFieldNumber = 10;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Package)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Module > modules_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ExternalModule > ext_modules_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Port : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Port) */ {
 public:
  Port();
  virtual ~Port();

  Port(const Port& from);

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(Port&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Port& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Port* other);
  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Port* New() const final {
    return CreateMaybeMessage<Port>(NULL);
  }

  Port* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Port_Direction Direction;
  static const Direction INPUT =
    Port_Direction_INPUT;
  static const Direction OUTPUT =
    Port_Direction_OUTPUT;
  static const Direction INOUT =
    Port_Direction_INOUT;
  static const Direction NONE =
    Port_Direction_NONE;
  static inline bool Direction_IsValid(int value) {
    return Port_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Port_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Port_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Port_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Port_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Port_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Port_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string signal = 1;
  void clear_signal();
  static const int kSignalFieldNumber = 1;
  const ::std::string& signal() const;
  void set_signal(const ::std::string& value);
  #if LANG_CXX11
  void set_signal(::std::string&& value);
  #endif
  void set_signal(const char* value);
  void set_signal(const char* value, size_t size);
  ::std::string* mutable_signal();
  ::std::string* release_signal();
  void set_allocated_signal(::std::string* signal);

  // .vlsir.circuit.Port.Direction direction = 2;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::vlsir::circuit::Port_Direction direction() const;
  void set_direction(::vlsir::circuit::Port_Direction value);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Port)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signal_;
  int direction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(NULL);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::int64 width() const;
  void set_width(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Signal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Slice) */ {
 public:
  Slice();
  virtual ~Slice();

  Slice(const Slice& from);

  inline Slice& operator=(const Slice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Slice(Slice&& from) noexcept
    : Slice() {
    *this = ::std::move(from);
  }

  inline Slice& operator=(Slice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Slice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Slice* internal_default_instance() {
    return reinterpret_cast<const Slice*>(
               &_Slice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Slice* other);
  friend void swap(Slice& a, Slice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Slice* New() const final {
    return CreateMaybeMessage<Slice>(NULL);
  }

  Slice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Slice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Slice& from);
  void MergeFrom(const Slice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string signal = 1;
  void clear_signal();
  static const int kSignalFieldNumber = 1;
  const ::std::string& signal() const;
  void set_signal(const ::std::string& value);
  #if LANG_CXX11
  void set_signal(::std::string&& value);
  #endif
  void set_signal(const char* value);
  void set_signal(const char* value, size_t size);
  ::std::string* mutable_signal();
  ::std::string* release_signal();
  void set_allocated_signal(::std::string* signal);

  // int64 top = 2;
  void clear_top();
  static const int kTopFieldNumber = 2;
  ::google::protobuf::int64 top() const;
  void set_top(::google::protobuf::int64 value);

  // int64 bot = 3;
  void clear_bot();
  static const int kBotFieldNumber = 3;
  ::google::protobuf::int64 bot() const;
  void set_bot(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Slice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signal_;
  ::google::protobuf::int64 top_;
  ::google::protobuf::int64 bot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Concat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Concat) */ {
 public:
  Concat();
  virtual ~Concat();

  Concat(const Concat& from);

  inline Concat& operator=(const Concat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Concat(Concat&& from) noexcept
    : Concat() {
    *this = ::std::move(from);
  }

  inline Concat& operator=(Concat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Concat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Concat* internal_default_instance() {
    return reinterpret_cast<const Concat*>(
               &_Concat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Concat* other);
  friend void swap(Concat& a, Concat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Concat* New() const final {
    return CreateMaybeMessage<Concat>(NULL);
  }

  Concat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Concat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Concat& from);
  void MergeFrom(const Concat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Concat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.circuit.ConnectionTarget parts = 1;
  int parts_size() const;
  void clear_parts();
  static const int kPartsFieldNumber = 1;
  ::vlsir::circuit::ConnectionTarget* mutable_parts(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >*
      mutable_parts();
  const ::vlsir::circuit::ConnectionTarget& parts(int index) const;
  ::vlsir::circuit::ConnectionTarget* add_parts();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >&
      parts() const;

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Concat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget > parts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectionTarget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ConnectionTarget) */ {
 public:
  ConnectionTarget();
  virtual ~ConnectionTarget();

  ConnectionTarget(const ConnectionTarget& from);

  inline ConnectionTarget& operator=(const ConnectionTarget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionTarget(ConnectionTarget&& from) noexcept
    : ConnectionTarget() {
    *this = ::std::move(from);
  }

  inline ConnectionTarget& operator=(ConnectionTarget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionTarget& default_instance();

  enum StypeCase {
    kSig = 1,
    kSlice = 2,
    kConcat = 3,
    STYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionTarget* internal_default_instance() {
    return reinterpret_cast<const ConnectionTarget*>(
               &_ConnectionTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ConnectionTarget* other);
  friend void swap(ConnectionTarget& a, ConnectionTarget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionTarget* New() const final {
    return CreateMaybeMessage<ConnectionTarget>(NULL);
  }

  ConnectionTarget* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionTarget>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionTarget& from);
  void MergeFrom(const ConnectionTarget& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionTarget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sig = 1;
  private:
  bool has_sig() const;
  public:
  void clear_sig();
  static const int kSigFieldNumber = 1;
  const ::std::string& sig() const;
  void set_sig(const ::std::string& value);
  #if LANG_CXX11
  void set_sig(::std::string&& value);
  #endif
  void set_sig(const char* value);
  void set_sig(const char* value, size_t size);
  ::std::string* mutable_sig();
  ::std::string* release_sig();
  void set_allocated_sig(::std::string* sig);

  // .vlsir.circuit.Slice slice = 2;
  bool has_slice() const;
  void clear_slice();
  static const int kSliceFieldNumber = 2;
  private:
  const ::vlsir::circuit::Slice& _internal_slice() const;
  public:
  const ::vlsir::circuit::Slice& slice() const;
  ::vlsir::circuit::Slice* release_slice();
  ::vlsir::circuit::Slice* mutable_slice();
  void set_allocated_slice(::vlsir::circuit::Slice* slice);

  // .vlsir.circuit.Concat concat = 3;
  bool has_concat() const;
  void clear_concat();
  static const int kConcatFieldNumber = 3;
  private:
  const ::vlsir::circuit::Concat& _internal_concat() const;
  public:
  const ::vlsir::circuit::Concat& concat() const;
  ::vlsir::circuit::Concat* release_concat();
  ::vlsir::circuit::Concat* mutable_concat();
  void set_allocated_concat(::vlsir::circuit::Concat* concat);

  void clear_stype();
  StypeCase stype_case() const;
  // @@protoc_insertion_point(class_scope:vlsir.circuit.ConnectionTarget)
 private:
  void set_has_sig();
  void set_has_slice();
  void set_has_concat();

  inline bool has_stype() const;
  inline void clear_has_stype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StypeUnion {
    StypeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr sig_;
    ::vlsir::circuit::Slice* slice_;
    ::vlsir::circuit::Concat* concat_;
  } stype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Connection) */ {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(Connection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Connection* other);
  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Connection* New() const final {
    return CreateMaybeMessage<Connection>(NULL);
  }

  Connection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string portname = 1;
  void clear_portname();
  static const int kPortnameFieldNumber = 1;
  const ::std::string& portname() const;
  void set_portname(const ::std::string& value);
  #if LANG_CXX11
  void set_portname(::std::string&& value);
  #endif
  void set_portname(const char* value);
  void set_portname(const char* value, size_t size);
  ::std::string* mutable_portname();
  ::std::string* release_portname();
  void set_allocated_portname(::std::string* portname);

  // .vlsir.circuit.ConnectionTarget target = 2;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  private:
  const ::vlsir::circuit::ConnectionTarget& _internal_target() const;
  public:
  const ::vlsir::circuit::ConnectionTarget& target() const;
  ::vlsir::circuit::ConnectionTarget* release_target();
  ::vlsir::circuit::ConnectionTarget* mutable_target();
  void set_allocated_target(::vlsir::circuit::ConnectionTarget* target);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Connection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr portname_;
  ::vlsir::circuit::ConnectionTarget* target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Instance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Instance) */ {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(Instance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Instance* other);
  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const final {
    return CreateMaybeMessage<Instance>(NULL);
  }

  Instance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.utils.Param parameters = 3;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 3;
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // repeated .vlsir.circuit.Connection connections = 4;
  int connections_size() const;
  void clear_connections();
  static const int kConnectionsFieldNumber = 4;
  ::vlsir::circuit::Connection* mutable_connections(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Connection >*
      mutable_connections();
  const ::vlsir::circuit::Connection& connections(int index) const;
  ::vlsir::circuit::Connection* add_connections();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Connection >&
      connections() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .vlsir.utils.Reference module = 2;
  bool has_module() const;
  void clear_module();
  static const int kModuleFieldNumber = 2;
  private:
  const ::vlsir::utils::Reference& _internal_module() const;
  public:
  const ::vlsir::utils::Reference& module() const;
  ::vlsir::utils::Reference* release_module();
  ::vlsir::utils::Reference* mutable_module();
  void set_allocated_module(::vlsir::utils::Reference* module);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Instance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Connection > connections_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::vlsir::utils::Reference* module_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Module : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Module) */ {
 public:
  Module();
  virtual ~Module();

  Module(const Module& from);

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(Module&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Module& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Module* other);
  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Module* New() const final {
    return CreateMaybeMessage<Module>(NULL);
  }

  Module* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.circuit.Port ports = 2;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 2;
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Signal signals = 3;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 3;
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.circuit.Instance instances = 4;
  int instances_size() const;
  void clear_instances();
  static const int kInstancesFieldNumber = 4;
  ::vlsir::circuit::Instance* mutable_instances(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Instance >*
      mutable_instances();
  const ::vlsir::circuit::Instance& instances(int index) const;
  ::vlsir::circuit::Instance* add_instances();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Instance >&
      instances() const;

  // repeated .vlsir.utils.Param parameters = 5;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 5;
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Module)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Instance > instances_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExternalModule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.ExternalModule) */ {
 public:
  ExternalModule();
  virtual ~ExternalModule();

  ExternalModule(const ExternalModule& from);

  inline ExternalModule& operator=(const ExternalModule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExternalModule(ExternalModule&& from) noexcept
    : ExternalModule() {
    *this = ::std::move(from);
  }

  inline ExternalModule& operator=(ExternalModule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalModule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternalModule* internal_default_instance() {
    return reinterpret_cast<const ExternalModule*>(
               &_ExternalModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ExternalModule* other);
  friend void swap(ExternalModule& a, ExternalModule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExternalModule* New() const final {
    return CreateMaybeMessage<ExternalModule>(NULL);
  }

  ExternalModule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExternalModule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExternalModule& from);
  void MergeFrom(const ExternalModule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalModule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.circuit.Port ports = 3;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 3;
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // repeated .vlsir.circuit.Signal signals = 4;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 4;
  ::vlsir::circuit::Signal* mutable_signals(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >*
      mutable_signals();
  const ::vlsir::circuit::Signal& signals(int index) const;
  ::vlsir::circuit::Signal* add_signals();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >&
      signals() const;

  // repeated .vlsir.utils.Param parameters = 5;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 5;
  ::vlsir::utils::Param* mutable_parameters(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >*
      mutable_parameters();
  const ::vlsir::utils::Param& parameters(int index) const;
  ::vlsir::utils::Param* add_parameters();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >&
      parameters() const;

  // string desc = 2;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // .vlsir.utils.QualifiedName name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::vlsir::utils::QualifiedName& _internal_name() const;
  public:
  const ::vlsir::utils::QualifiedName& name() const;
  ::vlsir::utils::QualifiedName* release_name();
  ::vlsir::utils::QualifiedName* mutable_name();
  void set_allocated_name(::vlsir::utils::QualifiedName* name);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.ExternalModule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal > signals_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param > parameters_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::vlsir::utils::QualifiedName* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Interface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vlsir.circuit.Interface) */ {
 public:
  Interface();
  virtual ~Interface();

  Interface(const Interface& from);

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(Interface&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Interface& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Interface* other);
  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Interface* New() const final {
    return CreateMaybeMessage<Interface>(NULL);
  }

  Interface* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Interface& from);
  void MergeFrom(const Interface& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vlsir.circuit.Port ports = 10;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 10;
  ::vlsir::circuit::Port* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >*
      mutable_ports();
  const ::vlsir::circuit::Port& ports(int index) const;
  ::vlsir::circuit::Port* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >&
      ports() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:vlsir.circuit.Interface)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port > ports_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_circuit_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Package

// string domain = 1;
inline void Package::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Package::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.domain)
  return domain_.GetNoArena();
}
inline void Package::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.domain)
}
#if LANG_CXX11
inline void Package::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Package.domain)
}
#endif
inline void Package::set_domain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Package.domain)
}
inline void Package::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Package.domain)
}
inline ::std::string* Package::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Package::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Package::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.domain)
}

// repeated .vlsir.circuit.Module modules = 2;
inline int Package::modules_size() const {
  return modules_.size();
}
inline void Package::clear_modules() {
  modules_.Clear();
}
inline ::vlsir::circuit::Module* Package::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.modules)
  return modules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Module >*
Package::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.modules)
  return &modules_;
}
inline const ::vlsir::circuit::Module& Package::modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.modules)
  return modules_.Get(index);
}
inline ::vlsir::circuit::Module* Package::add_modules() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.modules)
  return modules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Module >&
Package::modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.modules)
  return modules_;
}

// repeated .vlsir.circuit.ExternalModule ext_modules = 3;
inline int Package::ext_modules_size() const {
  return ext_modules_.size();
}
inline void Package::clear_ext_modules() {
  ext_modules_.Clear();
}
inline ::vlsir::circuit::ExternalModule* Package::mutable_ext_modules(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.ext_modules)
  return ext_modules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ExternalModule >*
Package::mutable_ext_modules() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Package.ext_modules)
  return &ext_modules_;
}
inline const ::vlsir::circuit::ExternalModule& Package::ext_modules(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.ext_modules)
  return ext_modules_.Get(index);
}
inline ::vlsir::circuit::ExternalModule* Package::add_ext_modules() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Package.ext_modules)
  return ext_modules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ExternalModule >&
Package::ext_modules() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Package.ext_modules)
  return ext_modules_;
}

// string desc = 10;
inline void Package::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Package::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Package.desc)
  return desc_.GetNoArena();
}
inline void Package::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Package.desc)
}
#if LANG_CXX11
inline void Package::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Package.desc)
}
#endif
inline void Package::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Package.desc)
}
inline void Package::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Package.desc)
}
inline ::std::string* Package::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Package.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Package::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Package.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Package::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Package.desc)
}

// -------------------------------------------------------------------

// Port

// string signal = 1;
inline void Port::clear_signal() {
  signal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Port::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.signal)
  return signal_.GetNoArena();
}
inline void Port::set_signal(const ::std::string& value) {
  
  signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.signal)
}
#if LANG_CXX11
inline void Port::set_signal(::std::string&& value) {
  
  signal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Port.signal)
}
#endif
inline void Port::set_signal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Port.signal)
}
inline void Port::set_signal(const char* value, size_t size) {
  
  signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Port.signal)
}
inline ::std::string* Port::mutable_signal() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Port.signal)
  return signal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Port::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Port.signal)
  
  return signal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Port::set_allocated_signal(::std::string* signal) {
  if (signal != NULL) {
    
  } else {
    
  }
  signal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signal);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Port.signal)
}

// .vlsir.circuit.Port.Direction direction = 2;
inline void Port::clear_direction() {
  direction_ = 0;
}
inline ::vlsir::circuit::Port_Direction Port::direction() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Port.direction)
  return static_cast< ::vlsir::circuit::Port_Direction >(direction_);
}
inline void Port::set_direction(::vlsir::circuit::Port_Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:vlsir.circuit.Port.direction)
}

// -------------------------------------------------------------------

// Signal

// string name = 1;
inline void Signal::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.name)
  return name_.GetNoArena();
}
inline void Signal::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.name)
}
#if LANG_CXX11
inline void Signal::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Signal.name)
}
#endif
inline void Signal::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Signal.name)
}
inline void Signal::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Signal.name)
}
inline ::std::string* Signal::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Signal.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Signal.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Signal.name)
}

// int64 width = 2;
inline void Signal::clear_width() {
  width_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Signal::width() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Signal.width)
  return width_;
}
inline void Signal::set_width(::google::protobuf::int64 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:vlsir.circuit.Signal.width)
}

// -------------------------------------------------------------------

// Slice

// string signal = 1;
inline void Slice::clear_signal() {
  signal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Slice::signal() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.signal)
  return signal_.GetNoArena();
}
inline void Slice::set_signal(const ::std::string& value) {
  
  signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.signal)
}
#if LANG_CXX11
inline void Slice::set_signal(::std::string&& value) {
  
  signal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Slice.signal)
}
#endif
inline void Slice::set_signal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Slice.signal)
}
inline void Slice::set_signal(const char* value, size_t size) {
  
  signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Slice.signal)
}
inline ::std::string* Slice::mutable_signal() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Slice.signal)
  return signal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Slice::release_signal() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Slice.signal)
  
  return signal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Slice::set_allocated_signal(::std::string* signal) {
  if (signal != NULL) {
    
  } else {
    
  }
  signal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signal);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Slice.signal)
}

// int64 top = 2;
inline void Slice::clear_top() {
  top_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Slice::top() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.top)
  return top_;
}
inline void Slice::set_top(::google::protobuf::int64 value) {
  
  top_ = value;
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.top)
}

// int64 bot = 3;
inline void Slice::clear_bot() {
  bot_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Slice::bot() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Slice.bot)
  return bot_;
}
inline void Slice::set_bot(::google::protobuf::int64 value) {
  
  bot_ = value;
  // @@protoc_insertion_point(field_set:vlsir.circuit.Slice.bot)
}

// -------------------------------------------------------------------

// Concat

// repeated .vlsir.circuit.ConnectionTarget parts = 1;
inline int Concat::parts_size() const {
  return parts_.size();
}
inline void Concat::clear_parts() {
  parts_.Clear();
}
inline ::vlsir::circuit::ConnectionTarget* Concat::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Concat.parts)
  return parts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >*
Concat::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Concat.parts)
  return &parts_;
}
inline const ::vlsir::circuit::ConnectionTarget& Concat::parts(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Concat.parts)
  return parts_.Get(index);
}
inline ::vlsir::circuit::ConnectionTarget* Concat::add_parts() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Concat.parts)
  return parts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::ConnectionTarget >&
Concat::parts() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Concat.parts)
  return parts_;
}

// -------------------------------------------------------------------

// ConnectionTarget

// string sig = 1;
inline bool ConnectionTarget::has_sig() const {
  return stype_case() == kSig;
}
inline void ConnectionTarget::set_has_sig() {
  _oneof_case_[0] = kSig;
}
inline void ConnectionTarget::clear_sig() {
  if (has_sig()) {
    stype_.sig_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_stype();
  }
}
inline const ::std::string& ConnectionTarget::sig() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.sig)
  if (has_sig()) {
    return stype_.sig_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ConnectionTarget::set_sig(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vlsir.circuit.ConnectionTarget.sig)
  if (!has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.ConnectionTarget.sig)
}
#if LANG_CXX11
inline void ConnectionTarget::set_sig(::std::string&& value) {
  // @@protoc_insertion_point(field_set:vlsir.circuit.ConnectionTarget.sig)
  if (!has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.ConnectionTarget.sig)
}
#endif
inline void ConnectionTarget::set_sig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.ConnectionTarget.sig)
}
inline void ConnectionTarget::set_sig(const char* value, size_t size) {
  if (!has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  stype_.sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.ConnectionTarget.sig)
}
inline ::std::string* ConnectionTarget::mutable_sig() {
  if (!has_sig()) {
    clear_stype();
    set_has_sig();
    stype_.sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.sig)
  return stype_.sig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectionTarget::release_sig() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.sig)
  if (has_sig()) {
    clear_has_stype();
    return stype_.sig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ConnectionTarget::set_allocated_sig(::std::string* sig) {
  if (!has_sig()) {
    stype_.sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_stype();
  if (sig != NULL) {
    set_has_sig();
    stype_.sig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sig);
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ConnectionTarget.sig)
}

// .vlsir.circuit.Slice slice = 2;
inline bool ConnectionTarget::has_slice() const {
  return stype_case() == kSlice;
}
inline void ConnectionTarget::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void ConnectionTarget::clear_slice() {
  if (has_slice()) {
    delete stype_.slice_;
    clear_has_stype();
  }
}
inline const ::vlsir::circuit::Slice& ConnectionTarget::_internal_slice() const {
  return *stype_.slice_;
}
inline ::vlsir::circuit::Slice* ConnectionTarget::release_slice() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.slice)
  if (has_slice()) {
    clear_has_stype();
      ::vlsir::circuit::Slice* temp = stype_.slice_;
    stype_.slice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::circuit::Slice& ConnectionTarget::slice() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.slice)
  return has_slice()
      ? *stype_.slice_
      : *reinterpret_cast< ::vlsir::circuit::Slice*>(&::vlsir::circuit::_Slice_default_instance_);
}
inline ::vlsir::circuit::Slice* ConnectionTarget::mutable_slice() {
  if (!has_slice()) {
    clear_stype();
    set_has_slice();
    stype_.slice_ = CreateMaybeMessage< ::vlsir::circuit::Slice >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.slice)
  return stype_.slice_;
}

// .vlsir.circuit.Concat concat = 3;
inline bool ConnectionTarget::has_concat() const {
  return stype_case() == kConcat;
}
inline void ConnectionTarget::set_has_concat() {
  _oneof_case_[0] = kConcat;
}
inline void ConnectionTarget::clear_concat() {
  if (has_concat()) {
    delete stype_.concat_;
    clear_has_stype();
  }
}
inline const ::vlsir::circuit::Concat& ConnectionTarget::_internal_concat() const {
  return *stype_.concat_;
}
inline ::vlsir::circuit::Concat* ConnectionTarget::release_concat() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ConnectionTarget.concat)
  if (has_concat()) {
    clear_has_stype();
      ::vlsir::circuit::Concat* temp = stype_.concat_;
    stype_.concat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vlsir::circuit::Concat& ConnectionTarget::concat() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ConnectionTarget.concat)
  return has_concat()
      ? *stype_.concat_
      : *reinterpret_cast< ::vlsir::circuit::Concat*>(&::vlsir::circuit::_Concat_default_instance_);
}
inline ::vlsir::circuit::Concat* ConnectionTarget::mutable_concat() {
  if (!has_concat()) {
    clear_stype();
    set_has_concat();
    stype_.concat_ = CreateMaybeMessage< ::vlsir::circuit::Concat >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ConnectionTarget.concat)
  return stype_.concat_;
}

inline bool ConnectionTarget::has_stype() const {
  return stype_case() != STYPE_NOT_SET;
}
inline void ConnectionTarget::clear_has_stype() {
  _oneof_case_[0] = STYPE_NOT_SET;
}
inline ConnectionTarget::StypeCase ConnectionTarget::stype_case() const {
  return ConnectionTarget::StypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Connection

// string portname = 1;
inline void Connection::clear_portname() {
  portname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::portname() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.portname)
  return portname_.GetNoArena();
}
inline void Connection::set_portname(const ::std::string& value) {
  
  portname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Connection.portname)
}
#if LANG_CXX11
inline void Connection::set_portname(::std::string&& value) {
  
  portname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Connection.portname)
}
#endif
inline void Connection::set_portname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  portname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Connection.portname)
}
inline void Connection::set_portname(const char* value, size_t size) {
  
  portname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Connection.portname)
}
inline ::std::string* Connection::mutable_portname() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.portname)
  return portname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_portname() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.portname)
  
  return portname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_portname(::std::string* portname) {
  if (portname != NULL) {
    
  } else {
    
  }
  portname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), portname);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Connection.portname)
}

// .vlsir.circuit.ConnectionTarget target = 2;
inline bool Connection::has_target() const {
  return this != internal_default_instance() && target_ != NULL;
}
inline void Connection::clear_target() {
  if (GetArenaNoVirtual() == NULL && target_ != NULL) {
    delete target_;
  }
  target_ = NULL;
}
inline const ::vlsir::circuit::ConnectionTarget& Connection::_internal_target() const {
  return *target_;
}
inline const ::vlsir::circuit::ConnectionTarget& Connection::target() const {
  const ::vlsir::circuit::ConnectionTarget* p = target_;
  // @@protoc_insertion_point(field_get:vlsir.circuit.Connection.target)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::circuit::ConnectionTarget*>(
      &::vlsir::circuit::_ConnectionTarget_default_instance_);
}
inline ::vlsir::circuit::ConnectionTarget* Connection::release_target() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Connection.target)
  
  ::vlsir::circuit::ConnectionTarget* temp = target_;
  target_ = NULL;
  return temp;
}
inline ::vlsir::circuit::ConnectionTarget* Connection::mutable_target() {
  
  if (target_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::ConnectionTarget>(GetArenaNoVirtual());
    target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Connection.target)
  return target_;
}
inline void Connection::set_allocated_target(::vlsir::circuit::ConnectionTarget* target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete target_;
  }
  if (target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Connection.target)
}

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.name)
  return name_.GetNoArena();
}
inline void Instance::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Instance.name)
}
#if LANG_CXX11
inline void Instance::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Instance.name)
}
#endif
inline void Instance::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Instance.name)
}
inline void Instance::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Instance.name)
}
inline ::std::string* Instance::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instance::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.name)
}

// .vlsir.utils.Reference module = 2;
inline bool Instance::has_module() const {
  return this != internal_default_instance() && module_ != NULL;
}
inline const ::vlsir::utils::Reference& Instance::_internal_module() const {
  return *module_;
}
inline const ::vlsir::utils::Reference& Instance::module() const {
  const ::vlsir::utils::Reference* p = module_;
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.module)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::utils::Reference*>(
      &::vlsir::utils::_Reference_default_instance_);
}
inline ::vlsir::utils::Reference* Instance::release_module() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Instance.module)
  
  ::vlsir::utils::Reference* temp = module_;
  module_ = NULL;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::mutable_module() {
  
  if (module_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArenaNoVirtual());
    module_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.module)
  return module_;
}
inline void Instance::set_allocated_module(::vlsir::utils::Reference* module) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(module_);
  }
  if (module) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      module = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Instance.module)
}

// repeated .vlsir.utils.Param parameters = 3;
inline int Instance::parameters_size() const {
  return parameters_.size();
}
inline ::vlsir::utils::Param* Instance::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.parameters)
  return parameters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >*
Instance::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Instance.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& Instance::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.parameters)
  return parameters_.Get(index);
}
inline ::vlsir::utils::Param* Instance::add_parameters() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Instance.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >&
Instance::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Instance.parameters)
  return parameters_;
}

// repeated .vlsir.circuit.Connection connections = 4;
inline int Instance::connections_size() const {
  return connections_.size();
}
inline void Instance::clear_connections() {
  connections_.Clear();
}
inline ::vlsir::circuit::Connection* Instance::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Instance.connections)
  return connections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Connection >*
Instance::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Instance.connections)
  return &connections_;
}
inline const ::vlsir::circuit::Connection& Instance::connections(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Instance.connections)
  return connections_.Get(index);
}
inline ::vlsir::circuit::Connection* Instance::add_connections() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Instance.connections)
  return connections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Connection >&
Instance::connections() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Instance.connections)
  return connections_;
}

// -------------------------------------------------------------------

// Module

// string name = 1;
inline void Module::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.name)
  return name_.GetNoArena();
}
inline void Module::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Module.name)
}
#if LANG_CXX11
inline void Module::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Module.name)
}
#endif
inline void Module::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Module.name)
}
inline void Module::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Module.name)
}
inline ::std::string* Module::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Module.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Module::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Module.name)
}

// repeated .vlsir.circuit.Port ports = 2;
inline int Module::ports_size() const {
  return ports_.size();
}
inline void Module::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Module::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.ports)
  return ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >*
Module::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Module::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.ports)
  return ports_.Get(index);
}
inline ::vlsir::circuit::Port* Module::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >&
Module::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.ports)
  return ports_;
}

// repeated .vlsir.circuit.Signal signals = 3;
inline int Module::signals_size() const {
  return signals_.size();
}
inline void Module::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::circuit::Signal* Module::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.signals)
  return signals_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >*
Module::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& Module::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.signals)
  return signals_.Get(index);
}
inline ::vlsir::circuit::Signal* Module::add_signals() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.signals)
  return signals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >&
Module::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.signals)
  return signals_;
}

// repeated .vlsir.circuit.Instance instances = 4;
inline int Module::instances_size() const {
  return instances_.size();
}
inline void Module::clear_instances() {
  instances_.Clear();
}
inline ::vlsir::circuit::Instance* Module::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.instances)
  return instances_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Instance >*
Module::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.instances)
  return &instances_;
}
inline const ::vlsir::circuit::Instance& Module::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.instances)
  return instances_.Get(index);
}
inline ::vlsir::circuit::Instance* Module::add_instances() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.instances)
  return instances_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Instance >&
Module::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.instances)
  return instances_;
}

// repeated .vlsir.utils.Param parameters = 5;
inline int Module::parameters_size() const {
  return parameters_.size();
}
inline ::vlsir::utils::Param* Module::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Module.parameters)
  return parameters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >*
Module::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Module.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& Module::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Module.parameters)
  return parameters_.Get(index);
}
inline ::vlsir::utils::Param* Module::add_parameters() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Module.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >&
Module::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Module.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// ExternalModule

// .vlsir.utils.QualifiedName name = 1;
inline bool ExternalModule::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::_internal_name() const {
  return *name_;
}
inline const ::vlsir::utils::QualifiedName& ExternalModule::name() const {
  const ::vlsir::utils::QualifiedName* p = name_;
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.name)
  return p != NULL ? *p : *reinterpret_cast<const ::vlsir::utils::QualifiedName*>(
      &::vlsir::utils::_QualifiedName_default_instance_);
}
inline ::vlsir::utils::QualifiedName* ExternalModule::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.name)
  
  ::vlsir::utils::QualifiedName* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::vlsir::utils::QualifiedName* ExternalModule::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::vlsir::utils::QualifiedName>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.name)
  return name_;
}
inline void ExternalModule::set_allocated_name(::vlsir::utils::QualifiedName* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_);
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.name)
}

// string desc = 2;
inline void ExternalModule::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExternalModule::desc() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.desc)
  return desc_.GetNoArena();
}
inline void ExternalModule::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.ExternalModule.desc)
}
#if LANG_CXX11
inline void ExternalModule::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.ExternalModule.desc)
}
#endif
inline void ExternalModule::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.ExternalModule.desc)
}
inline void ExternalModule::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.ExternalModule.desc)
}
inline ::std::string* ExternalModule::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalModule::release_desc() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.ExternalModule.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalModule::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.ExternalModule.desc)
}

// repeated .vlsir.circuit.Port ports = 3;
inline int ExternalModule::ports_size() const {
  return ports_.size();
}
inline void ExternalModule::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* ExternalModule::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.ports)
  return ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >*
ExternalModule::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& ExternalModule::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.ports)
  return ports_.Get(index);
}
inline ::vlsir::circuit::Port* ExternalModule::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >&
ExternalModule::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.ports)
  return ports_;
}

// repeated .vlsir.circuit.Signal signals = 4;
inline int ExternalModule::signals_size() const {
  return signals_.size();
}
inline void ExternalModule::clear_signals() {
  signals_.Clear();
}
inline ::vlsir::circuit::Signal* ExternalModule::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.signals)
  return signals_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >*
ExternalModule::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.signals)
  return &signals_;
}
inline const ::vlsir::circuit::Signal& ExternalModule::signals(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.signals)
  return signals_.Get(index);
}
inline ::vlsir::circuit::Signal* ExternalModule::add_signals() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.signals)
  return signals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Signal >&
ExternalModule::signals() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.signals)
  return signals_;
}

// repeated .vlsir.utils.Param parameters = 5;
inline int ExternalModule::parameters_size() const {
  return parameters_.size();
}
inline ::vlsir::utils::Param* ExternalModule::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.ExternalModule.parameters)
  return parameters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >*
ExternalModule::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.ExternalModule.parameters)
  return &parameters_;
}
inline const ::vlsir::utils::Param& ExternalModule::parameters(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.ExternalModule.parameters)
  return parameters_.Get(index);
}
inline ::vlsir::utils::Param* ExternalModule::add_parameters() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.ExternalModule.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::utils::Param >&
ExternalModule::parameters() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.ExternalModule.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// Interface

// string name = 1;
inline void Interface::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Interface::name() const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.name)
  return name_.GetNoArena();
}
inline void Interface::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vlsir.circuit.Interface.name)
}
#if LANG_CXX11
inline void Interface::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vlsir.circuit.Interface.name)
}
#endif
inline void Interface::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vlsir.circuit.Interface.name)
}
inline void Interface::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vlsir.circuit.Interface.name)
}
inline ::std::string* Interface::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Interface::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.circuit.Interface.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Interface::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vlsir.circuit.Interface.name)
}

// repeated .vlsir.circuit.Port ports = 10;
inline int Interface::ports_size() const {
  return ports_.size();
}
inline void Interface::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::circuit::Port* Interface::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.circuit.Interface.ports)
  return ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >*
Interface::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.circuit.Interface.ports)
  return &ports_;
}
inline const ::vlsir::circuit::Port& Interface::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.circuit.Interface.ports)
  return ports_.Get(index);
}
inline ::vlsir::circuit::Port* Interface::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.circuit.Interface.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vlsir::circuit::Port >&
Interface::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.circuit.Interface.ports)
  return ports_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace circuit
}  // namespace vlsir

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vlsir::circuit::Port_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::circuit::Port_Direction>() {
  return ::vlsir::circuit::Port_Direction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_circuit_2eproto
