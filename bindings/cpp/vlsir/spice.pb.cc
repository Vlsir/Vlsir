// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spice.proto

#include "spice.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace vlsir {
namespace spice {
PROTOBUF_CONSTEXPR SimInput::SimInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.opts_)*/{}
  , /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.top_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pkg_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SimInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimInputDefaultTypeInternal() {}
  union {
    SimInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimInputDefaultTypeInternal _SimInput_default_instance_;
PROTOBUF_CONSTEXPR SimResult::SimResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SimResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimResultDefaultTypeInternal() {}
  union {
    SimResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimResultDefaultTypeInternal _SimResult_default_instance_;
PROTOBUF_CONSTEXPR SimOptions::SimOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SimOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimOptionsDefaultTypeInternal() {}
  union {
    SimOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimOptionsDefaultTypeInternal _SimOptions_default_instance_;
PROTOBUF_CONSTEXPR Analysis::Analysis(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AnalysisDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnalysisDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnalysisDefaultTypeInternal() {}
  union {
    Analysis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnalysisDefaultTypeInternal _Analysis_default_instance_;
PROTOBUF_CONSTEXPR AnalysisResult::AnalysisResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AnalysisResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnalysisResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnalysisResultDefaultTypeInternal() {}
  union {
    AnalysisResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnalysisResultDefaultTypeInternal _AnalysisResult_default_instance_;
PROTOBUF_CONSTEXPR OpInput::OpInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpInputDefaultTypeInternal() {}
  union {
    OpInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpInputDefaultTypeInternal _OpInput_default_instance_;
PROTOBUF_CONSTEXPR OpResult::OpResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signals_)*/{}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpResultDefaultTypeInternal() {}
  union {
    OpResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpResultDefaultTypeInternal _OpResult_default_instance_;
PROTOBUF_CONSTEXPR DcInput::DcInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.indep_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sweep_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DcInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DcInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DcInputDefaultTypeInternal() {}
  union {
    DcInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DcInputDefaultTypeInternal _DcInput_default_instance_;
PROTOBUF_CONSTEXPR DcResult_MeasurementsEntry_DoNotUse::DcResult_MeasurementsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    DcResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _DcResult_MeasurementsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR DcResult::DcResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signals_)*/{}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.measurements_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.indep_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DcResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DcResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DcResultDefaultTypeInternal() {}
  union {
    DcResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DcResultDefaultTypeInternal _DcResult_default_instance_;
PROTOBUF_CONSTEXPR TranInput_IcEntry_DoNotUse::TranInput_IcEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct TranInput_IcEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranInput_IcEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranInput_IcEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TranInput_IcEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranInput_IcEntry_DoNotUseDefaultTypeInternal _TranInput_IcEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TranInput::TranInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ic_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tstop_)*/0
  , /*decltype(_impl_.tstep_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TranInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranInputDefaultTypeInternal() {}
  union {
    TranInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranInputDefaultTypeInternal _TranInput_default_instance_;
PROTOBUF_CONSTEXPR TranResult_MeasurementsEntry_DoNotUse::TranResult_MeasurementsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TranResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _TranResult_MeasurementsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TranResult::TranResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signals_)*/{}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.measurements_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TranResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranResultDefaultTypeInternal() {}
  union {
    TranResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranResultDefaultTypeInternal _TranResult_default_instance_;
PROTOBUF_CONSTEXPR ComplexNum::ComplexNum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.re_)*/0
  , /*decltype(_impl_.im_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ComplexNumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComplexNumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComplexNumDefaultTypeInternal() {}
  union {
    ComplexNum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComplexNumDefaultTypeInternal _ComplexNum_default_instance_;
PROTOBUF_CONSTEXPR AcInput::AcInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstart_)*/0
  , /*decltype(_impl_.fstop_)*/0
  , /*decltype(_impl_.npts_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AcInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcInputDefaultTypeInternal() {}
  union {
    AcInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcInputDefaultTypeInternal _AcInput_default_instance_;
PROTOBUF_CONSTEXPR AcResult_MeasurementsEntry_DoNotUse::AcResult_MeasurementsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AcResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _AcResult_MeasurementsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR AcResult::AcResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.freq_)*/{}
  , /*decltype(_impl_.signals_)*/{}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.measurements_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AcResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcResultDefaultTypeInternal() {}
  union {
    AcResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcResultDefaultTypeInternal _AcResult_default_instance_;
PROTOBUF_CONSTEXPR NoiseInput::NoiseInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_p_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_n_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.input_source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstart_)*/0
  , /*decltype(_impl_.fstop_)*/0
  , /*decltype(_impl_.npts_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NoiseInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoiseInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoiseInputDefaultTypeInternal() {}
  union {
    NoiseInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoiseInputDefaultTypeInternal _NoiseInput_default_instance_;
PROTOBUF_CONSTEXPR NoiseResult_IntegratedNoiseEntry_DoNotUse::NoiseResult_IntegratedNoiseEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NoiseResult_IntegratedNoiseEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoiseResult_IntegratedNoiseEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoiseResult_IntegratedNoiseEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NoiseResult_IntegratedNoiseEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoiseResult_IntegratedNoiseEntry_DoNotUseDefaultTypeInternal _NoiseResult_IntegratedNoiseEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR NoiseResult_MeasurementsEntry_DoNotUse::NoiseResult_MeasurementsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NoiseResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoiseResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoiseResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NoiseResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoiseResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _NoiseResult_MeasurementsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR NoiseResult::NoiseResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signals_)*/{}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.integrated_noise_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.measurements_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NoiseResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoiseResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoiseResultDefaultTypeInternal() {}
  union {
    NoiseResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoiseResultDefaultTypeInternal _NoiseResult_default_instance_;
PROTOBUF_CONSTEXPR SweepInput::SweepInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.variable_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sweep_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SweepInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SweepInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SweepInputDefaultTypeInternal() {}
  union {
    SweepInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SweepInputDefaultTypeInternal _SweepInput_default_instance_;
PROTOBUF_CONSTEXPR SweepResult::SweepResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.variable_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sweep_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SweepResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SweepResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SweepResultDefaultTypeInternal() {}
  union {
    SweepResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SweepResultDefaultTypeInternal _SweepResult_default_instance_;
PROTOBUF_CONSTEXPR MonteInput::MonteInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.npts_)*/int64_t{0}
  , /*decltype(_impl_.seed_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonteInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonteInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonteInputDefaultTypeInternal() {}
  union {
    MonteInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonteInputDefaultTypeInternal _MonteInput_default_instance_;
PROTOBUF_CONSTEXPR MonteResult::MonteResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.an_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.variable_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sweep_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonteResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonteResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonteResultDefaultTypeInternal() {}
  union {
    MonteResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonteResultDefaultTypeInternal _MonteResult_default_instance_;
PROTOBUF_CONSTEXPR CustomAnalysisInput::CustomAnalysisInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctrls_)*/{}
  , /*decltype(_impl_.analysis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cmd_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CustomAnalysisInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomAnalysisInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomAnalysisInputDefaultTypeInternal() {}
  union {
    CustomAnalysisInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomAnalysisInputDefaultTypeInternal _CustomAnalysisInput_default_instance_;
PROTOBUF_CONSTEXPR CustomAnalysisResult::CustomAnalysisResult(
    ::_pbi::ConstantInitialized) {}
struct CustomAnalysisResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomAnalysisResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomAnalysisResultDefaultTypeInternal() {}
  union {
    CustomAnalysisResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomAnalysisResultDefaultTypeInternal _CustomAnalysisResult_default_instance_;
PROTOBUF_CONSTEXPR Sweep::Sweep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tp_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SweepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SweepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SweepDefaultTypeInternal() {}
  union {
    Sweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SweepDefaultTypeInternal _Sweep_default_instance_;
PROTOBUF_CONSTEXPR LinearSweep::LinearSweep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.stop_)*/0
  , /*decltype(_impl_.step_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LinearSweepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearSweepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearSweepDefaultTypeInternal() {}
  union {
    LinearSweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearSweepDefaultTypeInternal _LinearSweep_default_instance_;
PROTOBUF_CONSTEXPR LogSweep::LogSweep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.stop_)*/0
  , /*decltype(_impl_.npts_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogSweepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogSweepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogSweepDefaultTypeInternal() {}
  union {
    LogSweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogSweepDefaultTypeInternal _LogSweep_default_instance_;
PROTOBUF_CONSTEXPR PointSweep::PointSweep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.stop_)*/0
  , /*decltype(_impl_.npts_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointSweepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointSweepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointSweepDefaultTypeInternal() {}
  union {
    PointSweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointSweepDefaultTypeInternal _PointSweep_default_instance_;
PROTOBUF_CONSTEXPR Control::Control(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctrl_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ControlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlDefaultTypeInternal() {}
  union {
    Control _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlDefaultTypeInternal _Control_default_instance_;
PROTOBUF_CONSTEXPR Save::Save(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.save_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveDefaultTypeInternal() {}
  union {
    Save _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveDefaultTypeInternal _Save_default_instance_;
PROTOBUF_CONSTEXPR Include::Include(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IncludeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IncludeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IncludeDefaultTypeInternal() {}
  union {
    Include _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IncludeDefaultTypeInternal _Include_default_instance_;
PROTOBUF_CONSTEXPR LibInclude::LibInclude(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.section_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LibIncludeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibIncludeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibIncludeDefaultTypeInternal() {}
  union {
    LibInclude _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibIncludeDefaultTypeInternal _LibInclude_default_instance_;
PROTOBUF_CONSTEXPR Meas::Meas(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.analysis_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MeasDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeasDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeasDefaultTypeInternal() {}
  union {
    Meas _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeasDefaultTypeInternal _Meas_default_instance_;
PROTOBUF_CONSTEXPR Signal::Signal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quantity_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalDefaultTypeInternal() {}
  union {
    Signal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalDefaultTypeInternal _Signal_default_instance_;
}  // namespace spice
}  // namespace vlsir
static ::_pb::Metadata file_level_metadata_spice_2eproto[38];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_spice_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_spice_2eproto = nullptr;

const uint32_t TableStruct_spice_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _impl_.pkg_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _impl_.top_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _impl_.opts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _impl_.an_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _impl_.ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimResult, _impl_.an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Analysis, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Analysis, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Analysis, _impl_.an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AnalysisResult, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AnalysisResult, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AnalysisResult, _impl_.an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpInput, _impl_.ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, _impl_.signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, _impl_.indep_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, _impl_.sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, _impl_.ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _impl_.indep_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _impl_.signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _impl_.measurements_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _impl_.tstop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _impl_.tstep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _impl_.ic_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _impl_.ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, _impl_.signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, _impl_.measurements_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::ComplexNum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::ComplexNum, _impl_.re_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::ComplexNum, _impl_.im_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _impl_.fstart_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _impl_.fstop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _impl_.npts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _impl_.ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _impl_.freq_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _impl_.signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _impl_.measurements_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.output_p_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.output_n_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.input_source_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.fstart_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.fstop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.npts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseInput, _impl_.ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult, _impl_.signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult, _impl_.integrated_noise_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::NoiseResult, _impl_.measurements_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _impl_.variable_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _impl_.sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _impl_.an_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _impl_.ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, _impl_.variable_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, _impl_.sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, _impl_.an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _impl_.npts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _impl_.seed_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _impl_.an_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _impl_.ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, _impl_.variable_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, _impl_.sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, _impl_.an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, _impl_.analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, _impl_.cmd_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, _impl_.ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Sweep, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Sweep, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Sweep, _impl_.tp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, _impl_.stop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, _impl_.step_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, _impl_.stop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, _impl_.npts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, _impl_.stop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, _impl_.npts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Control, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Control, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Control, _impl_.ctrl_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Save, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Save, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Save, _impl_.save_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Include, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Include, _impl_.path_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LibInclude, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LibInclude, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LibInclude, _impl_.section_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, _impl_.analysis_type_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, _impl_.expr_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Signal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Signal, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Signal, _impl_.quantity_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vlsir::spice::SimInput)},
  { 11, -1, -1, sizeof(::vlsir::spice::SimResult)},
  { 18, -1, -1, sizeof(::vlsir::spice::SimOptions)},
  { 26, -1, -1, sizeof(::vlsir::spice::Analysis)},
  { 41, -1, -1, sizeof(::vlsir::spice::AnalysisResult)},
  { 56, -1, -1, sizeof(::vlsir::spice::OpInput)},
  { 64, -1, -1, sizeof(::vlsir::spice::OpResult)},
  { 73, -1, -1, sizeof(::vlsir::spice::DcInput)},
  { 83, 91, -1, sizeof(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse)},
  { 93, -1, -1, sizeof(::vlsir::spice::DcResult)},
  { 104, 112, -1, sizeof(::vlsir::spice::TranInput_IcEntry_DoNotUse)},
  { 114, -1, -1, sizeof(::vlsir::spice::TranInput)},
  { 125, 133, -1, sizeof(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse)},
  { 135, -1, -1, sizeof(::vlsir::spice::TranResult)},
  { 145, -1, -1, sizeof(::vlsir::spice::ComplexNum)},
  { 153, -1, -1, sizeof(::vlsir::spice::AcInput)},
  { 164, 172, -1, sizeof(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse)},
  { 174, -1, -1, sizeof(::vlsir::spice::AcResult)},
  { 185, -1, -1, sizeof(::vlsir::spice::NoiseInput)},
  { 199, 207, -1, sizeof(::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse)},
  { 209, 217, -1, sizeof(::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse)},
  { 219, -1, -1, sizeof(::vlsir::spice::NoiseResult)},
  { 230, -1, -1, sizeof(::vlsir::spice::SweepInput)},
  { 241, -1, -1, sizeof(::vlsir::spice::SweepResult)},
  { 251, -1, -1, sizeof(::vlsir::spice::MonteInput)},
  { 262, -1, -1, sizeof(::vlsir::spice::MonteResult)},
  { 272, -1, -1, sizeof(::vlsir::spice::CustomAnalysisInput)},
  { 281, -1, -1, sizeof(::vlsir::spice::CustomAnalysisResult)},
  { 287, -1, -1, sizeof(::vlsir::spice::Sweep)},
  { 297, -1, -1, sizeof(::vlsir::spice::LinearSweep)},
  { 306, -1, -1, sizeof(::vlsir::spice::LogSweep)},
  { 315, -1, -1, sizeof(::vlsir::spice::PointSweep)},
  { 324, -1, -1, sizeof(::vlsir::spice::Control)},
  { 337, -1, -1, sizeof(::vlsir::spice::Save)},
  { 346, -1, -1, sizeof(::vlsir::spice::Include)},
  { 353, -1, -1, sizeof(::vlsir::spice::LibInclude)},
  { 361, -1, -1, sizeof(::vlsir::spice::Meas)},
  { 370, -1, -1, sizeof(::vlsir::spice::Signal)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::vlsir::spice::_SimInput_default_instance_._instance,
  &::vlsir::spice::_SimResult_default_instance_._instance,
  &::vlsir::spice::_SimOptions_default_instance_._instance,
  &::vlsir::spice::_Analysis_default_instance_._instance,
  &::vlsir::spice::_AnalysisResult_default_instance_._instance,
  &::vlsir::spice::_OpInput_default_instance_._instance,
  &::vlsir::spice::_OpResult_default_instance_._instance,
  &::vlsir::spice::_DcInput_default_instance_._instance,
  &::vlsir::spice::_DcResult_MeasurementsEntry_DoNotUse_default_instance_._instance,
  &::vlsir::spice::_DcResult_default_instance_._instance,
  &::vlsir::spice::_TranInput_IcEntry_DoNotUse_default_instance_._instance,
  &::vlsir::spice::_TranInput_default_instance_._instance,
  &::vlsir::spice::_TranResult_MeasurementsEntry_DoNotUse_default_instance_._instance,
  &::vlsir::spice::_TranResult_default_instance_._instance,
  &::vlsir::spice::_ComplexNum_default_instance_._instance,
  &::vlsir::spice::_AcInput_default_instance_._instance,
  &::vlsir::spice::_AcResult_MeasurementsEntry_DoNotUse_default_instance_._instance,
  &::vlsir::spice::_AcResult_default_instance_._instance,
  &::vlsir::spice::_NoiseInput_default_instance_._instance,
  &::vlsir::spice::_NoiseResult_IntegratedNoiseEntry_DoNotUse_default_instance_._instance,
  &::vlsir::spice::_NoiseResult_MeasurementsEntry_DoNotUse_default_instance_._instance,
  &::vlsir::spice::_NoiseResult_default_instance_._instance,
  &::vlsir::spice::_SweepInput_default_instance_._instance,
  &::vlsir::spice::_SweepResult_default_instance_._instance,
  &::vlsir::spice::_MonteInput_default_instance_._instance,
  &::vlsir::spice::_MonteResult_default_instance_._instance,
  &::vlsir::spice::_CustomAnalysisInput_default_instance_._instance,
  &::vlsir::spice::_CustomAnalysisResult_default_instance_._instance,
  &::vlsir::spice::_Sweep_default_instance_._instance,
  &::vlsir::spice::_LinearSweep_default_instance_._instance,
  &::vlsir::spice::_LogSweep_default_instance_._instance,
  &::vlsir::spice::_PointSweep_default_instance_._instance,
  &::vlsir::spice::_Control_default_instance_._instance,
  &::vlsir::spice::_Save_default_instance_._instance,
  &::vlsir::spice::_Include_default_instance_._instance,
  &::vlsir::spice::_LibInclude_default_instance_._instance,
  &::vlsir::spice::_Meas_default_instance_._instance,
  &::vlsir::spice::_Signal_default_instance_._instance,
};

const char descriptor_table_protodef_spice_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013spice.proto\022\013vlsir.spice\032\013utils.proto\032"
  "\rcircuit.proto\"\253\001\n\010SimInput\022#\n\003pkg\030\001 \001(\013"
  "2\026.vlsir.circuit.Package\022\013\n\003top\030\002 \001(\t\022%\n"
  "\004opts\030\n \003(\0132\027.vlsir.spice.SimOptions\022!\n\002"
  "an\030\013 \003(\0132\025.vlsir.spice.Analysis\022#\n\005ctrls"
  "\030\014 \003(\0132\024.vlsir.spice.Control\"4\n\tSimResul"
  "t\022\'\n\002an\030\001 \003(\0132\033.vlsir.spice.AnalysisResu"
  "lt\"B\n\nSimOptions\022\014\n\004name\030\001 \001(\t\022&\n\005value\030"
  "\002 \001(\0132\027.vlsir.utils.ParamValue\"\326\002\n\010Analy"
  "sis\022\"\n\002op\030\001 \001(\0132\024.vlsir.spice.OpInputH\000\022"
  "\"\n\002dc\030\002 \001(\0132\024.vlsir.spice.DcInputH\000\022&\n\004t"
  "ran\030\003 \001(\0132\026.vlsir.spice.TranInputH\000\022\"\n\002a"
  "c\030\004 \001(\0132\024.vlsir.spice.AcInputH\000\022(\n\005noise"
  "\030\005 \001(\0132\027.vlsir.spice.NoiseInputH\000\022(\n\005swe"
  "ep\030\n \001(\0132\027.vlsir.spice.SweepInputH\000\022(\n\005m"
  "onte\030\013 \001(\0132\027.vlsir.spice.MonteInputH\000\0222\n"
  "\006custom\030\024 \001(\0132 .vlsir.spice.CustomAnalys"
  "isInputH\000B\004\n\002an\"\344\002\n\016AnalysisResult\022#\n\002op"
  "\030\001 \001(\0132\025.vlsir.spice.OpResultH\000\022#\n\002dc\030\002 "
  "\001(\0132\025.vlsir.spice.DcResultH\000\022\'\n\004tran\030\003 \001"
  "(\0132\027.vlsir.spice.TranResultH\000\022#\n\002ac\030\004 \001("
  "\0132\025.vlsir.spice.AcResultH\000\022)\n\005noise\030\005 \001("
  "\0132\030.vlsir.spice.NoiseResultH\000\022)\n\005sweep\030\n"
  " \001(\0132\030.vlsir.spice.SweepResultH\000\022)\n\005mont"
  "e\030\013 \001(\0132\030.vlsir.spice.MonteResultH\000\0223\n\006c"
  "ustom\030\024 \001(\0132!.vlsir.spice.CustomAnalysis"
  "ResultH\000B\004\n\002an\"E\n\007OpInput\022\025\n\ranalysis_na"
  "me\030\001 \001(\t\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spice.Co"
  "ntrol\"L\n\010OpResult\022\025\n\ranalysis_name\030\001 \001(\t"
  "\022\017\n\007signals\030\003 \003(\t\022\014\n\004data\030\005 \003(\001J\004\010\002\020\003J\004\010"
  "\004\020\005\"|\n\007DcInput\022\025\n\ranalysis_name\030\001 \001(\t\022\022\n"
  "\nindep_name\030\002 \001(\t\022!\n\005sweep\030\003 \001(\0132\022.vlsir"
  ".spice.Sweep\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spic"
  "e.Control\"\316\001\n\010DcResult\022\025\n\ranalysis_name\030"
  "\001 \001(\t\022\022\n\nindep_name\030\002 \001(\t\022\017\n\007signals\030\003 \003"
  "(\t\022\014\n\004data\030\005 \003(\001\022=\n\014measurements\030\n \003(\0132\'"
  ".vlsir.spice.DcResult.MeasurementsEntry\032"
  "3\n\021MeasurementsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005val"
  "ue\030\002 \001(\001:\0028\001J\004\010\004\020\005\"\274\001\n\tTranInput\022\025\n\ranal"
  "ysis_name\030\001 \001(\t\022\r\n\005tstop\030\002 \001(\001\022\r\n\005tstep\030"
  "\003 \001(\001\022*\n\002ic\030\004 \003(\0132\036.vlsir.spice.TranInpu"
  "t.IcEntry\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spice.C"
  "ontrol\032)\n\007IcEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030"
  "\002 \001(\001:\0028\001\"\304\001\n\nTranResult\022\025\n\ranalysis_nam"
  "e\030\001 \001(\t\022\017\n\007signals\030\003 \003(\t\022\014\n\004data\030\005 \003(\001\022\?"
  "\n\014measurements\030\n \003(\0132).vlsir.spice.TranR"
  "esult.MeasurementsEntry\0323\n\021MeasurementsE"
  "ntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001J\004\010\002"
  "\020\003J\004\010\004\020\005\"$\n\nComplexNum\022\n\n\002re\030\001 \001(\001\022\n\n\002im"
  "\030\002 \001(\001\"r\n\007AcInput\022\025\n\ranalysis_name\030\001 \001(\t"
  "\022\016\n\006fstart\030\002 \001(\001\022\r\n\005fstop\030\003 \001(\001\022\014\n\004npts\030"
  "\004 \001(\004\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spice.Contr"
  "ol\"\341\001\n\010AcResult\022\025\n\ranalysis_name\030\001 \001(\t\022\014"
  "\n\004freq\030\002 \003(\001\022\017\n\007signals\030\003 \003(\t\022%\n\004data\030\005 "
  "\003(\0132\027.vlsir.spice.ComplexNum\022=\n\014measurem"
  "ents\030\n \003(\0132\'.vlsir.spice.AcResult.Measur"
  "ementsEntry\0323\n\021MeasurementsEntry\022\013\n\003key\030"
  "\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001J\004\010\004\020\005\"\257\001\n\nNoise"
  "Input\022\025\n\ranalysis_name\030\001 \001(\t\022\020\n\010output_p"
  "\030\002 \001(\t\022\020\n\010output_n\030\003 \001(\t\022\024\n\014input_source"
  "\030\004 \001(\t\022\016\n\006fstart\030\n \001(\001\022\r\n\005fstop\030\013 \001(\001\022\014\n"
  "\004npts\030\014 \001(\004\022#\n\005ctrls\030\024 \003(\0132\024.vlsir.spice"
  ".Control\"\307\002\n\013NoiseResult\022\025\n\ranalysis_nam"
  "e\030\001 \001(\t\022\017\n\007signals\030\003 \003(\t\022\014\n\004data\030\005 \003(\001\022G"
  "\n\020integrated_noise\030\n \003(\0132-.vlsir.spice.N"
  "oiseResult.IntegratedNoiseEntry\022@\n\014measu"
  "rements\030\013 \003(\0132*.vlsir.spice.NoiseResult."
  "MeasurementsEntry\0326\n\024IntegratedNoiseEntr"
  "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001\0323\n\021Mea"
  "surementsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001"
  "(\001:\0028\001J\004\010\002\020\003J\004\010\004\020\005\"\240\001\n\nSweepInput\022\025\n\rana"
  "lysis_name\030\001 \001(\t\022\020\n\010variable\030\002 \001(\t\022!\n\005sw"
  "eep\030\003 \001(\0132\022.vlsir.spice.Sweep\022!\n\002an\030\004 \003("
  "\0132\025.vlsir.spice.Analysis\022#\n\005ctrls\030\005 \003(\0132"
  "\024.vlsir.spice.Control\"\202\001\n\013SweepResult\022\025\n"
  "\ranalysis_name\030\001 \001(\t\022\020\n\010variable\030\002 \001(\t\022!"
  "\n\005sweep\030\003 \001(\0132\022.vlsir.spice.Sweep\022\'\n\002an\030"
  "\004 \003(\0132\033.vlsir.spice.AnalysisResult\"\207\001\n\nM"
  "onteInput\022\025\n\ranalysis_name\030\001 \001(\t\022\014\n\004npts"
  "\030\002 \001(\003\022\014\n\004seed\030\003 \001(\003\022!\n\002an\030\004 \003(\0132\025.vlsir"
  ".spice.Analysis\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.s"
  "pice.Control\"\202\001\n\013MonteResult\022\025\n\ranalysis"
  "_name\030\001 \001(\t\022\020\n\010variable\030\002 \001(\t\022!\n\005sweep\030\003"
  " \001(\0132\022.vlsir.spice.Sweep\022\'\n\002an\030\004 \003(\0132\033.v"
  "lsir.spice.AnalysisResult\"^\n\023CustomAnaly"
  "sisInput\022\025\n\ranalysis_name\030\001 \001(\t\022\013\n\003cmd\030\002"
  " \001(\t\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spice.Contro"
  "l\"\026\n\024CustomAnalysisResult\"\212\001\n\005Sweep\022*\n\006l"
  "inear\030\001 \001(\0132\030.vlsir.spice.LinearSweepH\000\022"
  "$\n\003log\030\002 \001(\0132\025.vlsir.spice.LogSweepH\000\022)\n"
  "\006points\030\003 \001(\0132\027.vlsir.spice.PointSweepH\000"
  "B\004\n\002tp\"8\n\013LinearSweep\022\r\n\005start\030\001 \001(\001\022\014\n\004"
  "stop\030\002 \001(\001\022\014\n\004step\030\003 \001(\001\"5\n\010LogSweep\022\r\n\005"
  "start\030\001 \001(\001\022\014\n\004stop\030\002 \001(\001\022\014\n\004npts\030\003 \001(\001\""
  "8\n\nPointSweep\022\016\n\006points\030\001 \003(\001\022\014\n\004stop\030\002 "
  "\001(\001\022\014\n\004npts\030\003 \001(\001\"\340\001\n\007Control\022\'\n\007include"
  "\030\001 \001(\0132\024.vlsir.spice.IncludeH\000\022&\n\003lib\030\002 "
  "\001(\0132\027.vlsir.spice.LibIncludeH\000\022!\n\004save\030\005"
  " \001(\0132\021.vlsir.spice.SaveH\000\022!\n\004meas\030\006 \001(\0132"
  "\021.vlsir.spice.MeasH\000\022#\n\005param\030\007 \001(\0132\022.vl"
  "sir.utils.ParamH\000\022\021\n\007literal\030\n \001(\tH\000B\006\n\004"
  "ctrl\"k\n\004Save\022*\n\004mode\030\001 \001(\0162\032.vlsir.spice"
  ".Save.SaveModeH\000\022\020\n\006signal\030\002 \001(\tH\000\"\035\n\010Sa"
  "veMode\022\010\n\004NONE\020\000\022\007\n\003ALL\020\001B\006\n\004save\"\027\n\007Inc"
  "lude\022\014\n\004path\030\001 \001(\t\"+\n\nLibInclude\022\014\n\004path"
  "\030\001 \001(\t\022\017\n\007section\030\002 \001(\t\"9\n\004Meas\022\025\n\ranaly"
  "sis_type\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\014\n\004expr\030\003 \001"
  "(\t\"v\n\006Signal\022\014\n\004name\030\001 \001(\t\022.\n\010quantity\030\002"
  " \001(\0162\034.vlsir.spice.Signal.Quantity\".\n\010Qu"
  "antity\022\013\n\007VOLTAGE\020\000\022\013\n\007CURRENT\020\001\022\010\n\004NONE"
  "\020\0032=\n\005Spice\0224\n\003Sim\022\025.vlsir.spice.SimInpu"
  "t\032\026.vlsir.spice.SimResultb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_spice_2eproto_deps[2] = {
  &::descriptor_table_circuit_2eproto,
  &::descriptor_table_utils_2eproto,
};
static ::_pbi::once_flag descriptor_table_spice_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_spice_2eproto = {
    false, false, 4473, descriptor_table_protodef_spice_2eproto,
    "spice.proto",
    &descriptor_table_spice_2eproto_once, descriptor_table_spice_2eproto_deps, 2, 38,
    schemas, file_default_instances, TableStruct_spice_2eproto::offsets,
    file_level_metadata_spice_2eproto, file_level_enum_descriptors_spice_2eproto,
    file_level_service_descriptors_spice_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_spice_2eproto_getter() {
  return &descriptor_table_spice_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_spice_2eproto(&descriptor_table_spice_2eproto);
namespace vlsir {
namespace spice {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Save_SaveMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spice_2eproto);
  return file_level_enum_descriptors_spice_2eproto[0];
}
bool Save_SaveMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Save_SaveMode Save::NONE;
constexpr Save_SaveMode Save::ALL;
constexpr Save_SaveMode Save::SaveMode_MIN;
constexpr Save_SaveMode Save::SaveMode_MAX;
constexpr int Save::SaveMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Signal_Quantity_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spice_2eproto);
  return file_level_enum_descriptors_spice_2eproto[1];
}
bool Signal_Quantity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Signal_Quantity Signal::VOLTAGE;
constexpr Signal_Quantity Signal::CURRENT;
constexpr Signal_Quantity Signal::NONE;
constexpr Signal_Quantity Signal::Quantity_MIN;
constexpr Signal_Quantity Signal::Quantity_MAX;
constexpr int Signal::Quantity_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SimInput::_Internal {
 public:
  static const ::vlsir::circuit::Package& pkg(const SimInput* msg);
};

const ::vlsir::circuit::Package&
SimInput::_Internal::pkg(const SimInput* msg) {
  return *msg->_impl_.pkg_;
}
void SimInput::clear_pkg() {
  if (GetArenaForAllocation() == nullptr && _impl_.pkg_ != nullptr) {
    delete _impl_.pkg_;
  }
  _impl_.pkg_ = nullptr;
}
SimInput::SimInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SimInput)
}
SimInput::SimInput(const SimInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SimInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.opts_){from._impl_.opts_}
    , decltype(_impl_.an_){from._impl_.an_}
    , decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.top_){}
    , decltype(_impl_.pkg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.top_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.top_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_top().empty()) {
    _this->_impl_.top_.Set(from._internal_top(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_pkg()) {
    _this->_impl_.pkg_ = new ::vlsir::circuit::Package(*from._impl_.pkg_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SimInput)
}

inline void SimInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.opts_){arena}
    , decltype(_impl_.an_){arena}
    , decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.top_){}
    , decltype(_impl_.pkg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.top_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.top_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SimInput::~SimInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SimInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SimInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.opts_.~RepeatedPtrField();
  _impl_.an_.~RepeatedPtrField();
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.top_.Destroy();
  if (this != internal_default_instance()) delete _impl_.pkg_;
}

void SimInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SimInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SimInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.opts_.Clear();
  _impl_.an_.Clear();
  _impl_.ctrls_.Clear();
  _impl_.top_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.pkg_ != nullptr) {
    delete _impl_.pkg_;
  }
  _impl_.pkg_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.circuit.Package pkg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pkg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_top();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.SimInput.top"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.SimOptions opts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_opts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Analysis an = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SimInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.circuit.Package pkg = 1;
  if (this->_internal_has_pkg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pkg(this),
        _Internal::pkg(this).GetCachedSize(), target, stream);
  }

  // string top = 2;
  if (!this->_internal_top().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_top().data(), static_cast<int>(this->_internal_top().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SimInput.top");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_top(), target);
  }

  // repeated .vlsir.spice.SimOptions opts = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_opts_size()); i < n; i++) {
    const auto& repfield = this->_internal_opts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.Analysis an = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_an_size()); i < n; i++) {
    const auto& repfield = this->_internal_an(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SimInput)
  return target;
}

size_t SimInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SimInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.SimOptions opts = 10;
  total_size += 1UL * this->_internal_opts_size();
  for (const auto& msg : this->_impl_.opts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Analysis an = 11;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->_impl_.an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Control ctrls = 12;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string top = 2;
  if (!this->_internal_top().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_top());
  }

  // .vlsir.circuit.Package pkg = 1;
  if (this->_internal_has_pkg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pkg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SimInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimInput::GetClassData() const { return &_class_data_; }


void SimInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SimInput*>(&to_msg);
  auto& from = static_cast<const SimInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SimInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.opts_.MergeFrom(from._impl_.opts_);
  _this->_impl_.an_.MergeFrom(from._impl_.an_);
  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_top().empty()) {
    _this->_internal_set_top(from._internal_top());
  }
  if (from._internal_has_pkg()) {
    _this->_internal_mutable_pkg()->::vlsir::circuit::Package::MergeFrom(
        from._internal_pkg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimInput::CopyFrom(const SimInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SimInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimInput::IsInitialized() const {
  return true;
}

void SimInput::InternalSwap(SimInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.opts_.InternalSwap(&other->_impl_.opts_);
  _impl_.an_.InternalSwap(&other->_impl_.an_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.top_, lhs_arena,
      &other->_impl_.top_, rhs_arena
  );
  swap(_impl_.pkg_, other->_impl_.pkg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[0]);
}

// ===================================================================

class SimResult::_Internal {
 public:
};

SimResult::SimResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SimResult)
}
SimResult::SimResult(const SimResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SimResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){from._impl_.an_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SimResult)
}

inline void SimResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SimResult::~SimResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SimResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SimResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.an_.~RepeatedPtrField();
}

void SimResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SimResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SimResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.an_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vlsir.spice.AnalysisResult an = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SimResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_an_size()); i < n; i++) {
    const auto& repfield = this->_internal_an(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SimResult)
  return target;
}

size_t SimResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SimResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 1;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->_impl_.an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SimResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimResult::GetClassData() const { return &_class_data_; }


void SimResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SimResult*>(&to_msg);
  auto& from = static_cast<const SimResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SimResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.an_.MergeFrom(from._impl_.an_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimResult::CopyFrom(const SimResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SimResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimResult::IsInitialized() const {
  return true;
}

void SimResult::InternalSwap(SimResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.an_.InternalSwap(&other->_impl_.an_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[1]);
}

// ===================================================================

class SimOptions::_Internal {
 public:
  static const ::vlsir::utils::ParamValue& value(const SimOptions* msg);
};

const ::vlsir::utils::ParamValue&
SimOptions::_Internal::value(const SimOptions* msg) {
  return *msg->_impl_.value_;
}
void SimOptions::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
SimOptions::SimOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SimOptions)
}
SimOptions::SimOptions(const SimOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SimOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::vlsir::utils::ParamValue(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SimOptions)
}

inline void SimOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SimOptions::~SimOptions() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SimOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SimOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void SimOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SimOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SimOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.SimOptions.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.ParamValue value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SimOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SimOptions.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.utils.ParamValue value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SimOptions)
  return target;
}

size_t SimOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SimOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.utils.ParamValue value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SimOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimOptions::GetClassData() const { return &_class_data_; }


void SimOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SimOptions*>(&to_msg);
  auto& from = static_cast<const SimOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SimOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::vlsir::utils::ParamValue::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimOptions::CopyFrom(const SimOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SimOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimOptions::IsInitialized() const {
  return true;
}

void SimOptions::InternalSwap(SimOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[2]);
}

// ===================================================================

class Analysis::_Internal {
 public:
  static const ::vlsir::spice::OpInput& op(const Analysis* msg);
  static const ::vlsir::spice::DcInput& dc(const Analysis* msg);
  static const ::vlsir::spice::TranInput& tran(const Analysis* msg);
  static const ::vlsir::spice::AcInput& ac(const Analysis* msg);
  static const ::vlsir::spice::NoiseInput& noise(const Analysis* msg);
  static const ::vlsir::spice::SweepInput& sweep(const Analysis* msg);
  static const ::vlsir::spice::MonteInput& monte(const Analysis* msg);
  static const ::vlsir::spice::CustomAnalysisInput& custom(const Analysis* msg);
};

const ::vlsir::spice::OpInput&
Analysis::_Internal::op(const Analysis* msg) {
  return *msg->_impl_.an_.op_;
}
const ::vlsir::spice::DcInput&
Analysis::_Internal::dc(const Analysis* msg) {
  return *msg->_impl_.an_.dc_;
}
const ::vlsir::spice::TranInput&
Analysis::_Internal::tran(const Analysis* msg) {
  return *msg->_impl_.an_.tran_;
}
const ::vlsir::spice::AcInput&
Analysis::_Internal::ac(const Analysis* msg) {
  return *msg->_impl_.an_.ac_;
}
const ::vlsir::spice::NoiseInput&
Analysis::_Internal::noise(const Analysis* msg) {
  return *msg->_impl_.an_.noise_;
}
const ::vlsir::spice::SweepInput&
Analysis::_Internal::sweep(const Analysis* msg) {
  return *msg->_impl_.an_.sweep_;
}
const ::vlsir::spice::MonteInput&
Analysis::_Internal::monte(const Analysis* msg) {
  return *msg->_impl_.an_.monte_;
}
const ::vlsir::spice::CustomAnalysisInput&
Analysis::_Internal::custom(const Analysis* msg) {
  return *msg->_impl_.an_.custom_;
}
void Analysis::set_allocated_op(::vlsir::spice::OpInput* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(op);
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    set_has_op();
    _impl_.an_.op_ = op;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.op)
}
void Analysis::set_allocated_dc(::vlsir::spice::DcInput* dc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (dc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dc);
    if (message_arena != submessage_arena) {
      dc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dc, submessage_arena);
    }
    set_has_dc();
    _impl_.an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.dc)
}
void Analysis::set_allocated_tran(::vlsir::spice::TranInput* tran) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (tran) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tran);
    if (message_arena != submessage_arena) {
      tran = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tran, submessage_arena);
    }
    set_has_tran();
    _impl_.an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.tran)
}
void Analysis::set_allocated_ac(::vlsir::spice::AcInput* ac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (ac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ac);
    if (message_arena != submessage_arena) {
      ac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ac, submessage_arena);
    }
    set_has_ac();
    _impl_.an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.ac)
}
void Analysis::set_allocated_noise(::vlsir::spice::NoiseInput* noise) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (noise) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(noise);
    if (message_arena != submessage_arena) {
      noise = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, noise, submessage_arena);
    }
    set_has_noise();
    _impl_.an_.noise_ = noise;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.noise)
}
void Analysis::set_allocated_sweep(::vlsir::spice::SweepInput* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    set_has_sweep();
    _impl_.an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.sweep)
}
void Analysis::set_allocated_monte(::vlsir::spice::MonteInput* monte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (monte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monte);
    if (message_arena != submessage_arena) {
      monte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monte, submessage_arena);
    }
    set_has_monte();
    _impl_.an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.monte)
}
void Analysis::set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    _impl_.an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.custom)
}
Analysis::Analysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Analysis)
}
Analysis::Analysis(const Analysis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Analysis* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_an();
  switch (from.an_case()) {
    case kOp: {
      _this->_internal_mutable_op()->::vlsir::spice::OpInput::MergeFrom(
          from._internal_op());
      break;
    }
    case kDc: {
      _this->_internal_mutable_dc()->::vlsir::spice::DcInput::MergeFrom(
          from._internal_dc());
      break;
    }
    case kTran: {
      _this->_internal_mutable_tran()->::vlsir::spice::TranInput::MergeFrom(
          from._internal_tran());
      break;
    }
    case kAc: {
      _this->_internal_mutable_ac()->::vlsir::spice::AcInput::MergeFrom(
          from._internal_ac());
      break;
    }
    case kNoise: {
      _this->_internal_mutable_noise()->::vlsir::spice::NoiseInput::MergeFrom(
          from._internal_noise());
      break;
    }
    case kSweep: {
      _this->_internal_mutable_sweep()->::vlsir::spice::SweepInput::MergeFrom(
          from._internal_sweep());
      break;
    }
    case kMonte: {
      _this->_internal_mutable_monte()->::vlsir::spice::MonteInput::MergeFrom(
          from._internal_monte());
      break;
    }
    case kCustom: {
      _this->_internal_mutable_custom()->::vlsir::spice::CustomAnalysisInput::MergeFrom(
          from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Analysis)
}

inline void Analysis::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_an();
}

Analysis::~Analysis() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Analysis)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Analysis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_an()) {
    clear_an();
  }
}

void Analysis::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Analysis::clear_an() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Analysis)
  switch (an_case()) {
    case kOp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.op_;
      }
      break;
    }
    case kDc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.dc_;
      }
      break;
    }
    case kTran: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.tran_;
      }
      break;
    }
    case kAc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.ac_;
      }
      break;
    }
    case kNoise: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.noise_;
      }
      break;
    }
    case kSweep: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.sweep_;
      }
      break;
    }
    case kMonte: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.monte_;
      }
      break;
    }
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.custom_;
      }
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = AN_NOT_SET;
}


void Analysis::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Analysis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_an();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Analysis::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.OpInput op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_op(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.DcInput dc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.TranInput tran = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tran(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.AcInput ac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.NoiseInput noise = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_noise(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.SweepInput sweep = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.MonteInput monte = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_monte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.CustomAnalysisInput custom = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Analysis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Analysis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.OpInput op = 1;
  if (_internal_has_op()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::op(this),
        _Internal::op(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.DcInput dc = 2;
  if (_internal_has_dc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dc(this),
        _Internal::dc(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.TranInput tran = 3;
  if (_internal_has_tran()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tran(this),
        _Internal::tran(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.AcInput ac = 4;
  if (_internal_has_ac()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ac(this),
        _Internal::ac(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.NoiseInput noise = 5;
  if (_internal_has_noise()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::noise(this),
        _Internal::noise(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.SweepInput sweep = 10;
  if (_internal_has_sweep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sweep(this),
        _Internal::sweep(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.MonteInput monte = 11;
  if (_internal_has_monte()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::monte(this),
        _Internal::monte(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.CustomAnalysisInput custom = 20;
  if (_internal_has_custom()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::custom(this),
        _Internal::custom(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Analysis)
  return target;
}

size_t Analysis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Analysis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (an_case()) {
    // .vlsir.spice.OpInput op = 1;
    case kOp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.op_);
      break;
    }
    // .vlsir.spice.DcInput dc = 2;
    case kDc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.dc_);
      break;
    }
    // .vlsir.spice.TranInput tran = 3;
    case kTran: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.tran_);
      break;
    }
    // .vlsir.spice.AcInput ac = 4;
    case kAc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.ac_);
      break;
    }
    // .vlsir.spice.NoiseInput noise = 5;
    case kNoise: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.noise_);
      break;
    }
    // .vlsir.spice.SweepInput sweep = 10;
    case kSweep: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.sweep_);
      break;
    }
    // .vlsir.spice.MonteInput monte = 11;
    case kMonte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.monte_);
      break;
    }
    // .vlsir.spice.CustomAnalysisInput custom = 20;
    case kCustom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.custom_);
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Analysis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Analysis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Analysis::GetClassData() const { return &_class_data_; }


void Analysis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Analysis*>(&to_msg);
  auto& from = static_cast<const Analysis&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Analysis)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.an_case()) {
    case kOp: {
      _this->_internal_mutable_op()->::vlsir::spice::OpInput::MergeFrom(
          from._internal_op());
      break;
    }
    case kDc: {
      _this->_internal_mutable_dc()->::vlsir::spice::DcInput::MergeFrom(
          from._internal_dc());
      break;
    }
    case kTran: {
      _this->_internal_mutable_tran()->::vlsir::spice::TranInput::MergeFrom(
          from._internal_tran());
      break;
    }
    case kAc: {
      _this->_internal_mutable_ac()->::vlsir::spice::AcInput::MergeFrom(
          from._internal_ac());
      break;
    }
    case kNoise: {
      _this->_internal_mutable_noise()->::vlsir::spice::NoiseInput::MergeFrom(
          from._internal_noise());
      break;
    }
    case kSweep: {
      _this->_internal_mutable_sweep()->::vlsir::spice::SweepInput::MergeFrom(
          from._internal_sweep());
      break;
    }
    case kMonte: {
      _this->_internal_mutable_monte()->::vlsir::spice::MonteInput::MergeFrom(
          from._internal_monte());
      break;
    }
    case kCustom: {
      _this->_internal_mutable_custom()->::vlsir::spice::CustomAnalysisInput::MergeFrom(
          from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Analysis::CopyFrom(const Analysis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Analysis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Analysis::IsInitialized() const {
  return true;
}

void Analysis::InternalSwap(Analysis* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.an_, other->_impl_.an_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Analysis::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[3]);
}

// ===================================================================

class AnalysisResult::_Internal {
 public:
  static const ::vlsir::spice::OpResult& op(const AnalysisResult* msg);
  static const ::vlsir::spice::DcResult& dc(const AnalysisResult* msg);
  static const ::vlsir::spice::TranResult& tran(const AnalysisResult* msg);
  static const ::vlsir::spice::AcResult& ac(const AnalysisResult* msg);
  static const ::vlsir::spice::NoiseResult& noise(const AnalysisResult* msg);
  static const ::vlsir::spice::SweepResult& sweep(const AnalysisResult* msg);
  static const ::vlsir::spice::MonteResult& monte(const AnalysisResult* msg);
  static const ::vlsir::spice::CustomAnalysisResult& custom(const AnalysisResult* msg);
};

const ::vlsir::spice::OpResult&
AnalysisResult::_Internal::op(const AnalysisResult* msg) {
  return *msg->_impl_.an_.op_;
}
const ::vlsir::spice::DcResult&
AnalysisResult::_Internal::dc(const AnalysisResult* msg) {
  return *msg->_impl_.an_.dc_;
}
const ::vlsir::spice::TranResult&
AnalysisResult::_Internal::tran(const AnalysisResult* msg) {
  return *msg->_impl_.an_.tran_;
}
const ::vlsir::spice::AcResult&
AnalysisResult::_Internal::ac(const AnalysisResult* msg) {
  return *msg->_impl_.an_.ac_;
}
const ::vlsir::spice::NoiseResult&
AnalysisResult::_Internal::noise(const AnalysisResult* msg) {
  return *msg->_impl_.an_.noise_;
}
const ::vlsir::spice::SweepResult&
AnalysisResult::_Internal::sweep(const AnalysisResult* msg) {
  return *msg->_impl_.an_.sweep_;
}
const ::vlsir::spice::MonteResult&
AnalysisResult::_Internal::monte(const AnalysisResult* msg) {
  return *msg->_impl_.an_.monte_;
}
const ::vlsir::spice::CustomAnalysisResult&
AnalysisResult::_Internal::custom(const AnalysisResult* msg) {
  return *msg->_impl_.an_.custom_;
}
void AnalysisResult::set_allocated_op(::vlsir::spice::OpResult* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(op);
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    set_has_op();
    _impl_.an_.op_ = op;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.op)
}
void AnalysisResult::set_allocated_dc(::vlsir::spice::DcResult* dc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (dc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dc);
    if (message_arena != submessage_arena) {
      dc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dc, submessage_arena);
    }
    set_has_dc();
    _impl_.an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.dc)
}
void AnalysisResult::set_allocated_tran(::vlsir::spice::TranResult* tran) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (tran) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tran);
    if (message_arena != submessage_arena) {
      tran = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tran, submessage_arena);
    }
    set_has_tran();
    _impl_.an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.tran)
}
void AnalysisResult::set_allocated_ac(::vlsir::spice::AcResult* ac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (ac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ac);
    if (message_arena != submessage_arena) {
      ac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ac, submessage_arena);
    }
    set_has_ac();
    _impl_.an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.ac)
}
void AnalysisResult::set_allocated_noise(::vlsir::spice::NoiseResult* noise) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (noise) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(noise);
    if (message_arena != submessage_arena) {
      noise = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, noise, submessage_arena);
    }
    set_has_noise();
    _impl_.an_.noise_ = noise;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.noise)
}
void AnalysisResult::set_allocated_sweep(::vlsir::spice::SweepResult* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    set_has_sweep();
    _impl_.an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.sweep)
}
void AnalysisResult::set_allocated_monte(::vlsir::spice::MonteResult* monte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (monte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monte);
    if (message_arena != submessage_arena) {
      monte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monte, submessage_arena);
    }
    set_has_monte();
    _impl_.an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.monte)
}
void AnalysisResult::set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    _impl_.an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.custom)
}
AnalysisResult::AnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.AnalysisResult)
}
AnalysisResult::AnalysisResult(const AnalysisResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnalysisResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_an();
  switch (from.an_case()) {
    case kOp: {
      _this->_internal_mutable_op()->::vlsir::spice::OpResult::MergeFrom(
          from._internal_op());
      break;
    }
    case kDc: {
      _this->_internal_mutable_dc()->::vlsir::spice::DcResult::MergeFrom(
          from._internal_dc());
      break;
    }
    case kTran: {
      _this->_internal_mutable_tran()->::vlsir::spice::TranResult::MergeFrom(
          from._internal_tran());
      break;
    }
    case kAc: {
      _this->_internal_mutable_ac()->::vlsir::spice::AcResult::MergeFrom(
          from._internal_ac());
      break;
    }
    case kNoise: {
      _this->_internal_mutable_noise()->::vlsir::spice::NoiseResult::MergeFrom(
          from._internal_noise());
      break;
    }
    case kSweep: {
      _this->_internal_mutable_sweep()->::vlsir::spice::SweepResult::MergeFrom(
          from._internal_sweep());
      break;
    }
    case kMonte: {
      _this->_internal_mutable_monte()->::vlsir::spice::MonteResult::MergeFrom(
          from._internal_monte());
      break;
    }
    case kCustom: {
      _this->_internal_mutable_custom()->::vlsir::spice::CustomAnalysisResult::MergeFrom(
          from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.AnalysisResult)
}

inline void AnalysisResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_an();
}

AnalysisResult::~AnalysisResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.AnalysisResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnalysisResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_an()) {
    clear_an();
  }
}

void AnalysisResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnalysisResult::clear_an() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.AnalysisResult)
  switch (an_case()) {
    case kOp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.op_;
      }
      break;
    }
    case kDc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.dc_;
      }
      break;
    }
    case kTran: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.tran_;
      }
      break;
    }
    case kAc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.ac_;
      }
      break;
    }
    case kNoise: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.noise_;
      }
      break;
    }
    case kSweep: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.sweep_;
      }
      break;
    }
    case kMonte: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.monte_;
      }
      break;
    }
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.an_.custom_;
      }
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = AN_NOT_SET;
}


void AnalysisResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.AnalysisResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_an();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnalysisResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.OpResult op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_op(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.DcResult dc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.TranResult tran = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tran(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.AcResult ac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.NoiseResult noise = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_noise(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.SweepResult sweep = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.MonteResult monte = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_monte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.CustomAnalysisResult custom = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnalysisResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.AnalysisResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.OpResult op = 1;
  if (_internal_has_op()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::op(this),
        _Internal::op(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.DcResult dc = 2;
  if (_internal_has_dc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dc(this),
        _Internal::dc(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.TranResult tran = 3;
  if (_internal_has_tran()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tran(this),
        _Internal::tran(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.AcResult ac = 4;
  if (_internal_has_ac()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ac(this),
        _Internal::ac(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.NoiseResult noise = 5;
  if (_internal_has_noise()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::noise(this),
        _Internal::noise(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.SweepResult sweep = 10;
  if (_internal_has_sweep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sweep(this),
        _Internal::sweep(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.MonteResult monte = 11;
  if (_internal_has_monte()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::monte(this),
        _Internal::monte(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.CustomAnalysisResult custom = 20;
  if (_internal_has_custom()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::custom(this),
        _Internal::custom(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.AnalysisResult)
  return target;
}

size_t AnalysisResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.AnalysisResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (an_case()) {
    // .vlsir.spice.OpResult op = 1;
    case kOp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.op_);
      break;
    }
    // .vlsir.spice.DcResult dc = 2;
    case kDc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.dc_);
      break;
    }
    // .vlsir.spice.TranResult tran = 3;
    case kTran: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.tran_);
      break;
    }
    // .vlsir.spice.AcResult ac = 4;
    case kAc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.ac_);
      break;
    }
    // .vlsir.spice.NoiseResult noise = 5;
    case kNoise: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.noise_);
      break;
    }
    // .vlsir.spice.SweepResult sweep = 10;
    case kSweep: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.sweep_);
      break;
    }
    // .vlsir.spice.MonteResult monte = 11;
    case kMonte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.monte_);
      break;
    }
    // .vlsir.spice.CustomAnalysisResult custom = 20;
    case kCustom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.an_.custom_);
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnalysisResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnalysisResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnalysisResult::GetClassData() const { return &_class_data_; }


void AnalysisResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnalysisResult*>(&to_msg);
  auto& from = static_cast<const AnalysisResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.AnalysisResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.an_case()) {
    case kOp: {
      _this->_internal_mutable_op()->::vlsir::spice::OpResult::MergeFrom(
          from._internal_op());
      break;
    }
    case kDc: {
      _this->_internal_mutable_dc()->::vlsir::spice::DcResult::MergeFrom(
          from._internal_dc());
      break;
    }
    case kTran: {
      _this->_internal_mutable_tran()->::vlsir::spice::TranResult::MergeFrom(
          from._internal_tran());
      break;
    }
    case kAc: {
      _this->_internal_mutable_ac()->::vlsir::spice::AcResult::MergeFrom(
          from._internal_ac());
      break;
    }
    case kNoise: {
      _this->_internal_mutable_noise()->::vlsir::spice::NoiseResult::MergeFrom(
          from._internal_noise());
      break;
    }
    case kSweep: {
      _this->_internal_mutable_sweep()->::vlsir::spice::SweepResult::MergeFrom(
          from._internal_sweep());
      break;
    }
    case kMonte: {
      _this->_internal_mutable_monte()->::vlsir::spice::MonteResult::MergeFrom(
          from._internal_monte());
      break;
    }
    case kCustom: {
      _this->_internal_mutable_custom()->::vlsir::spice::CustomAnalysisResult::MergeFrom(
          from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnalysisResult::CopyFrom(const AnalysisResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.AnalysisResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalysisResult::IsInitialized() const {
  return true;
}

void AnalysisResult::InternalSwap(AnalysisResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.an_, other->_impl_.an_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnalysisResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[4]);
}

// ===================================================================

class OpInput::_Internal {
 public:
};

OpInput::OpInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.OpInput)
}
OpInput::OpInput(const OpInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.OpInput)
}

inline void OpInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OpInput::~OpInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.OpInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
}

void OpInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.OpInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.OpInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.OpInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.OpInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.OpInput)
  return target;
}

size_t OpInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.OpInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpInput::GetClassData() const { return &_class_data_; }


void OpInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpInput*>(&to_msg);
  auto& from = static_cast<const OpInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.OpInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpInput::CopyFrom(const OpInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.OpInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpInput::IsInitialized() const {
  return true;
}

void OpInput::InternalSwap(OpInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata OpInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[5]);
}

// ===================================================================

class OpResult::_Internal {
 public:
};

OpResult::OpResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.OpResult)
}
OpResult::OpResult(const OpResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){from._impl_.signals_}
    , decltype(_impl_.data_){from._impl_.data_}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.OpResult)
}

inline void OpResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){arena}
    , decltype(_impl_.data_){arena}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OpResult::~OpResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.OpResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signals_.~RepeatedPtrField();
  _impl_.data_.~RepeatedField();
  _impl_.analysis_name_.Destroy();
}

void OpResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.OpResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signals_.Clear();
  _impl_.data_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.OpResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.OpResult.signals"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.OpResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.OpResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.OpResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.OpResult)
  return target;
}

size_t OpResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.OpResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signals_.size());
  for (int i = 0, n = _impl_.signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpResult::GetClassData() const { return &_class_data_; }


void OpResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpResult*>(&to_msg);
  auto& from = static_cast<const OpResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.OpResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpResult::CopyFrom(const OpResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.OpResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpResult::IsInitialized() const {
  return true;
}

void OpResult::InternalSwap(OpResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.signals_.InternalSwap(&other->_impl_.signals_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata OpResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[6]);
}

// ===================================================================

class DcInput::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const DcInput* msg);
};

const ::vlsir::spice::Sweep&
DcInput::_Internal::sweep(const DcInput* msg) {
  return *msg->_impl_.sweep_;
}
DcInput::DcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.DcInput)
}
DcInput::DcInput(const DcInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DcInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.indep_name_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.indep_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indep_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_indep_name().empty()) {
    _this->_impl_.indep_name_.Set(from._internal_indep_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    _this->_impl_.sweep_ = new ::vlsir::spice::Sweep(*from._impl_.sweep_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.DcInput)
}

inline void DcInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.indep_name_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.indep_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indep_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DcInput::~DcInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.DcInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DcInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
  _impl_.indep_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sweep_;
}

void DcInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DcInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.DcInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.indep_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.sweep_ != nullptr) {
    delete _impl_.sweep_;
  }
  _impl_.sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DcInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.DcInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string indep_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_indep_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.DcInput.indep_name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DcInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.DcInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_indep_name().data(), static_cast<int>(this->_internal_indep_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcInput.indep_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_indep_name(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sweep(this),
        _Internal::sweep(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.DcInput)
  return target;
}

size_t DcInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.DcInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_indep_name());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DcInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DcInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DcInput::GetClassData() const { return &_class_data_; }


void DcInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DcInput*>(&to_msg);
  auto& from = static_cast<const DcInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.DcInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_indep_name().empty()) {
    _this->_internal_set_indep_name(from._internal_indep_name());
  }
  if (from._internal_has_sweep()) {
    _this->_internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(
        from._internal_sweep());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DcInput::CopyFrom(const DcInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.DcInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DcInput::IsInitialized() const {
  return true;
}

void DcInput::InternalSwap(DcInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.indep_name_, lhs_arena,
      &other->_impl_.indep_name_, rhs_arena
  );
  swap(_impl_.sweep_, other->_impl_.sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DcInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[7]);
}

// ===================================================================

DcResult_MeasurementsEntry_DoNotUse::DcResult_MeasurementsEntry_DoNotUse() {}
DcResult_MeasurementsEntry_DoNotUse::DcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void DcResult_MeasurementsEntry_DoNotUse::MergeFrom(const DcResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata DcResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[8]);
}

// ===================================================================

class DcResult::_Internal {
 public:
};

DcResult::DcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &DcResult::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.DcResult)
}
DcResult::DcResult(const DcResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DcResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){from._impl_.signals_}
    , decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_.measurements_)*/{}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.indep_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.indep_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indep_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_indep_name().empty()) {
    _this->_impl_.indep_name_.Set(from._internal_indep_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.DcResult)
}

inline void DcResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){arena}
    , decltype(_impl_.data_){arena}
    , /*decltype(_impl_.measurements_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.indep_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.indep_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indep_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DcResult::~DcResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.DcResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void DcResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signals_.~RepeatedPtrField();
  _impl_.data_.~RepeatedField();
  _impl_.measurements_.Destruct();
  _impl_.measurements_.~MapField();
  _impl_.analysis_name_.Destroy();
  _impl_.indep_name_.Destroy();
}

void DcResult::ArenaDtor(void* object) {
  DcResult* _this = reinterpret_cast< DcResult* >(object);
  _this->_impl_.measurements_.Destruct();
}
void DcResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DcResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.DcResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signals_.Clear();
  _impl_.data_.Clear();
  _impl_.measurements_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.indep_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DcResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.DcResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string indep_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_indep_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.DcResult.indep_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.DcResult.signals"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DcResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.DcResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_indep_name().data(), static_cast<int>(this->_internal_indep_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcResult.indep_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_indep_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  // map<string, double> measurements = 10;
  if (!this->_internal_measurements().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = DcResult_MeasurementsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_measurements();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vlsir.spice.DcResult.MeasurementsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.DcResult)
  return target;
}

size_t DcResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.DcResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signals_.size());
  for (int i = 0, n = _impl_.signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // map<string, double> measurements = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += DcResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_indep_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DcResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DcResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DcResult::GetClassData() const { return &_class_data_; }


void DcResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DcResult*>(&to_msg);
  auto& from = static_cast<const DcResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.DcResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_indep_name().empty()) {
    _this->_internal_set_indep_name(from._internal_indep_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DcResult::CopyFrom(const DcResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.DcResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DcResult::IsInitialized() const {
  return true;
}

void DcResult::InternalSwap(DcResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.signals_.InternalSwap(&other->_impl_.signals_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  _impl_.measurements_.InternalSwap(&other->_impl_.measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.indep_name_, lhs_arena,
      &other->_impl_.indep_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DcResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[9]);
}

// ===================================================================

TranInput_IcEntry_DoNotUse::TranInput_IcEntry_DoNotUse() {}
TranInput_IcEntry_DoNotUse::TranInput_IcEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TranInput_IcEntry_DoNotUse::MergeFrom(const TranInput_IcEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata TranInput_IcEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[10]);
}

// ===================================================================

class TranInput::_Internal {
 public:
};

TranInput::TranInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &TranInput::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.TranInput)
}
TranInput::TranInput(const TranInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.ic_)*/{}
    , decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.tstop_){}
    , decltype(_impl_.tstep_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ic_.MergeFrom(from._impl_.ic_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.tstop_, &from._impl_.tstop_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tstep_) -
    reinterpret_cast<char*>(&_impl_.tstop_)) + sizeof(_impl_.tstep_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.TranInput)
}

inline void TranInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.ic_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.tstop_){0}
    , decltype(_impl_.tstep_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TranInput::~TranInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.TranInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void TranInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ic_.Destruct();
  _impl_.ic_.~MapField();
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
}

void TranInput::ArenaDtor(void* object) {
  TranInput* _this = reinterpret_cast< TranInput* >(object);
  _this->_impl_.ic_.Destruct();
}
void TranInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.TranInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ic_.Clear();
  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  ::memset(&_impl_.tstop_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tstep_) -
      reinterpret_cast<char*>(&_impl_.tstop_)) + sizeof(_impl_.tstep_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.TranInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // double tstop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.tstop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double tstep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.tstep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> ic = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.ic_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TranInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.TranInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.TranInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // double tstop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tstop = this->_internal_tstop();
  uint64_t raw_tstop;
  memcpy(&raw_tstop, &tmp_tstop, sizeof(tmp_tstop));
  if (raw_tstop != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_tstop(), target);
  }

  // double tstep = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tstep = this->_internal_tstep();
  uint64_t raw_tstep;
  memcpy(&raw_tstep, &tmp_tstep, sizeof(tmp_tstep));
  if (raw_tstep != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_tstep(), target);
  }

  // map<string, double> ic = 4;
  if (!this->_internal_ic().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = TranInput_IcEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_ic();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vlsir.spice.TranInput.IcEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.TranInput)
  return target;
}

size_t TranInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.TranInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> ic = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ic_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_ic().begin();
      it != this->_internal_ic().end(); ++it) {
    total_size += TranInput_IcEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // double tstop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tstop = this->_internal_tstop();
  uint64_t raw_tstop;
  memcpy(&raw_tstop, &tmp_tstop, sizeof(tmp_tstop));
  if (raw_tstop != 0) {
    total_size += 1 + 8;
  }

  // double tstep = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tstep = this->_internal_tstep();
  uint64_t raw_tstep;
  memcpy(&raw_tstep, &tmp_tstep, sizeof(tmp_tstep));
  if (raw_tstep != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranInput::GetClassData() const { return &_class_data_; }


void TranInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranInput*>(&to_msg);
  auto& from = static_cast<const TranInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.TranInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ic_.MergeFrom(from._impl_.ic_);
  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tstop = from._internal_tstop();
  uint64_t raw_tstop;
  memcpy(&raw_tstop, &tmp_tstop, sizeof(tmp_tstop));
  if (raw_tstop != 0) {
    _this->_internal_set_tstop(from._internal_tstop());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tstep = from._internal_tstep();
  uint64_t raw_tstep;
  memcpy(&raw_tstep, &tmp_tstep, sizeof(tmp_tstep));
  if (raw_tstep != 0) {
    _this->_internal_set_tstep(from._internal_tstep());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranInput::CopyFrom(const TranInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.TranInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranInput::IsInitialized() const {
  return true;
}

void TranInput::InternalSwap(TranInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ic_.InternalSwap(&other->_impl_.ic_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TranInput, _impl_.tstep_)
      + sizeof(TranInput::_impl_.tstep_)
      - PROTOBUF_FIELD_OFFSET(TranInput, _impl_.tstop_)>(
          reinterpret_cast<char*>(&_impl_.tstop_),
          reinterpret_cast<char*>(&other->_impl_.tstop_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TranInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[11]);
}

// ===================================================================

TranResult_MeasurementsEntry_DoNotUse::TranResult_MeasurementsEntry_DoNotUse() {}
TranResult_MeasurementsEntry_DoNotUse::TranResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TranResult_MeasurementsEntry_DoNotUse::MergeFrom(const TranResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata TranResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[12]);
}

// ===================================================================

class TranResult::_Internal {
 public:
};

TranResult::TranResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &TranResult::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.TranResult)
}
TranResult::TranResult(const TranResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){from._impl_.signals_}
    , decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_.measurements_)*/{}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.TranResult)
}

inline void TranResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){arena}
    , decltype(_impl_.data_){arena}
    , /*decltype(_impl_.measurements_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TranResult::~TranResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.TranResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void TranResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signals_.~RepeatedPtrField();
  _impl_.data_.~RepeatedField();
  _impl_.measurements_.Destruct();
  _impl_.measurements_.~MapField();
  _impl_.analysis_name_.Destroy();
}

void TranResult::ArenaDtor(void* object) {
  TranResult* _this = reinterpret_cast< TranResult* >(object);
  _this->_impl_.measurements_.Destruct();
}
void TranResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.TranResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signals_.Clear();
  _impl_.data_.Clear();
  _impl_.measurements_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.TranResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.TranResult.signals"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TranResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.TranResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.TranResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.TranResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  // map<string, double> measurements = 10;
  if (!this->_internal_measurements().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = TranResult_MeasurementsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_measurements();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vlsir.spice.TranResult.MeasurementsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.TranResult)
  return target;
}

size_t TranResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.TranResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signals_.size());
  for (int i = 0, n = _impl_.signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // map<string, double> measurements = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += TranResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranResult::GetClassData() const { return &_class_data_; }


void TranResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranResult*>(&to_msg);
  auto& from = static_cast<const TranResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.TranResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranResult::CopyFrom(const TranResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.TranResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranResult::IsInitialized() const {
  return true;
}

void TranResult::InternalSwap(TranResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.signals_.InternalSwap(&other->_impl_.signals_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  _impl_.measurements_.InternalSwap(&other->_impl_.measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TranResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[13]);
}

// ===================================================================

class ComplexNum::_Internal {
 public:
};

ComplexNum::ComplexNum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.ComplexNum)
}
ComplexNum::ComplexNum(const ComplexNum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ComplexNum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.re_){}
    , decltype(_impl_.im_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.re_, &from._impl_.re_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.im_) -
    reinterpret_cast<char*>(&_impl_.re_)) + sizeof(_impl_.im_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.ComplexNum)
}

inline void ComplexNum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.re_){0}
    , decltype(_impl_.im_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ComplexNum::~ComplexNum() {
  // @@protoc_insertion_point(destructor:vlsir.spice.ComplexNum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComplexNum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ComplexNum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ComplexNum::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.ComplexNum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.re_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.im_) -
      reinterpret_cast<char*>(&_impl_.re_)) + sizeof(_impl_.im_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComplexNum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double re = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.re_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double im = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.im_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComplexNum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.ComplexNum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double re = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_re = this->_internal_re();
  uint64_t raw_re;
  memcpy(&raw_re, &tmp_re, sizeof(tmp_re));
  if (raw_re != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_re(), target);
  }

  // double im = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_im = this->_internal_im();
  uint64_t raw_im;
  memcpy(&raw_im, &tmp_im, sizeof(tmp_im));
  if (raw_im != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_im(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.ComplexNum)
  return target;
}

size_t ComplexNum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.ComplexNum)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double re = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_re = this->_internal_re();
  uint64_t raw_re;
  memcpy(&raw_re, &tmp_re, sizeof(tmp_re));
  if (raw_re != 0) {
    total_size += 1 + 8;
  }

  // double im = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_im = this->_internal_im();
  uint64_t raw_im;
  memcpy(&raw_im, &tmp_im, sizeof(tmp_im));
  if (raw_im != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComplexNum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ComplexNum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComplexNum::GetClassData() const { return &_class_data_; }


void ComplexNum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ComplexNum*>(&to_msg);
  auto& from = static_cast<const ComplexNum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.ComplexNum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_re = from._internal_re();
  uint64_t raw_re;
  memcpy(&raw_re, &tmp_re, sizeof(tmp_re));
  if (raw_re != 0) {
    _this->_internal_set_re(from._internal_re());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_im = from._internal_im();
  uint64_t raw_im;
  memcpy(&raw_im, &tmp_im, sizeof(tmp_im));
  if (raw_im != 0) {
    _this->_internal_set_im(from._internal_im());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComplexNum::CopyFrom(const ComplexNum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.ComplexNum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComplexNum::IsInitialized() const {
  return true;
}

void ComplexNum::InternalSwap(ComplexNum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ComplexNum, _impl_.im_)
      + sizeof(ComplexNum::_impl_.im_)
      - PROTOBUF_FIELD_OFFSET(ComplexNum, _impl_.re_)>(
          reinterpret_cast<char*>(&_impl_.re_),
          reinterpret_cast<char*>(&other->_impl_.re_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ComplexNum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[14]);
}

// ===================================================================

class AcInput::_Internal {
 public:
};

AcInput::AcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.AcInput)
}
AcInput::AcInput(const AcInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AcInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.fstart_){}
    , decltype(_impl_.fstop_){}
    , decltype(_impl_.npts_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.fstart_, &from._impl_.fstart_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.npts_) -
    reinterpret_cast<char*>(&_impl_.fstart_)) + sizeof(_impl_.npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.AcInput)
}

inline void AcInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.fstart_){0}
    , decltype(_impl_.fstop_){0}
    , decltype(_impl_.npts_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AcInput::~AcInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.AcInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AcInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
}

void AcInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AcInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.AcInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  ::memset(&_impl_.fstart_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.npts_) -
      reinterpret_cast<char*>(&_impl_.fstart_)) + sizeof(_impl_.npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.AcInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // double fstart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.fstart_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fstop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.fstop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint64 npts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.npts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.AcInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.AcInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // double fstart = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstart = this->_internal_fstart();
  uint64_t raw_fstart;
  memcpy(&raw_fstart, &tmp_fstart, sizeof(tmp_fstart));
  if (raw_fstart != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_fstart(), target);
  }

  // double fstop = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstop = this->_internal_fstop();
  uint64_t raw_fstop;
  memcpy(&raw_fstop, &tmp_fstop, sizeof(tmp_fstop));
  if (raw_fstop != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_fstop(), target);
  }

  // uint64 npts = 4;
  if (this->_internal_npts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_npts(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.AcInput)
  return target;
}

size_t AcInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.AcInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // double fstart = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstart = this->_internal_fstart();
  uint64_t raw_fstart;
  memcpy(&raw_fstart, &tmp_fstart, sizeof(tmp_fstart));
  if (raw_fstart != 0) {
    total_size += 1 + 8;
  }

  // double fstop = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstop = this->_internal_fstop();
  uint64_t raw_fstop;
  memcpy(&raw_fstop, &tmp_fstop, sizeof(tmp_fstop));
  if (raw_fstop != 0) {
    total_size += 1 + 8;
  }

  // uint64 npts = 4;
  if (this->_internal_npts() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_npts());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AcInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AcInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AcInput::GetClassData() const { return &_class_data_; }


void AcInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AcInput*>(&to_msg);
  auto& from = static_cast<const AcInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.AcInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstart = from._internal_fstart();
  uint64_t raw_fstart;
  memcpy(&raw_fstart, &tmp_fstart, sizeof(tmp_fstart));
  if (raw_fstart != 0) {
    _this->_internal_set_fstart(from._internal_fstart());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstop = from._internal_fstop();
  uint64_t raw_fstop;
  memcpy(&raw_fstop, &tmp_fstop, sizeof(tmp_fstop));
  if (raw_fstop != 0) {
    _this->_internal_set_fstop(from._internal_fstop());
  }
  if (from._internal_npts() != 0) {
    _this->_internal_set_npts(from._internal_npts());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AcInput::CopyFrom(const AcInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.AcInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcInput::IsInitialized() const {
  return true;
}

void AcInput::InternalSwap(AcInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AcInput, _impl_.npts_)
      + sizeof(AcInput::_impl_.npts_)
      - PROTOBUF_FIELD_OFFSET(AcInput, _impl_.fstart_)>(
          reinterpret_cast<char*>(&_impl_.fstart_),
          reinterpret_cast<char*>(&other->_impl_.fstart_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AcInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[15]);
}

// ===================================================================

AcResult_MeasurementsEntry_DoNotUse::AcResult_MeasurementsEntry_DoNotUse() {}
AcResult_MeasurementsEntry_DoNotUse::AcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void AcResult_MeasurementsEntry_DoNotUse::MergeFrom(const AcResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata AcResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[16]);
}

// ===================================================================

class AcResult::_Internal {
 public:
};

AcResult::AcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &AcResult::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.AcResult)
}
AcResult::AcResult(const AcResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AcResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.freq_){from._impl_.freq_}
    , decltype(_impl_.signals_){from._impl_.signals_}
    , decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_.measurements_)*/{}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.AcResult)
}

inline void AcResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.freq_){arena}
    , decltype(_impl_.signals_){arena}
    , decltype(_impl_.data_){arena}
    , /*decltype(_impl_.measurements_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AcResult::~AcResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.AcResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void AcResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.freq_.~RepeatedField();
  _impl_.signals_.~RepeatedPtrField();
  _impl_.data_.~RepeatedPtrField();
  _impl_.measurements_.Destruct();
  _impl_.measurements_.~MapField();
  _impl_.analysis_name_.Destroy();
}

void AcResult::ArenaDtor(void* object) {
  AcResult* _this = reinterpret_cast< AcResult* >(object);
  _this->_impl_.measurements_.Destruct();
}
void AcResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AcResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.AcResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.freq_.Clear();
  _impl_.signals_.Clear();
  _impl_.data_.Clear();
  _impl_.measurements_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.AcResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated double freq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_freq(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 17) {
          _internal_add_freq(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.AcResult.signals"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.ComplexNum data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.AcResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.AcResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated double freq = 2;
  if (this->_internal_freq_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_freq(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.AcResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated .vlsir.spice.ComplexNum data = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, double> measurements = 10;
  if (!this->_internal_measurements().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = AcResult_MeasurementsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_measurements();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vlsir.spice.AcResult.MeasurementsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.AcResult)
  return target;
}

size_t AcResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.AcResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double freq = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_freq_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signals_.size());
  for (int i = 0, n = _impl_.signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.signals_.Get(i));
  }

  // repeated .vlsir.spice.ComplexNum data = 5;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->_impl_.data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, double> measurements = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += AcResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AcResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AcResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AcResult::GetClassData() const { return &_class_data_; }


void AcResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AcResult*>(&to_msg);
  auto& from = static_cast<const AcResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.AcResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.freq_.MergeFrom(from._impl_.freq_);
  _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AcResult::CopyFrom(const AcResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.AcResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcResult::IsInitialized() const {
  return true;
}

void AcResult::InternalSwap(AcResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.freq_.InternalSwap(&other->_impl_.freq_);
  _impl_.signals_.InternalSwap(&other->_impl_.signals_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  _impl_.measurements_.InternalSwap(&other->_impl_.measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AcResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[17]);
}

// ===================================================================

class NoiseInput::_Internal {
 public:
};

NoiseInput::NoiseInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.NoiseInput)
}
NoiseInput::NoiseInput(const NoiseInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoiseInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.output_p_){}
    , decltype(_impl_.output_n_){}
    , decltype(_impl_.input_source_){}
    , decltype(_impl_.fstart_){}
    , decltype(_impl_.fstop_){}
    , decltype(_impl_.npts_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.output_p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_p_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_output_p().empty()) {
    _this->_impl_.output_p_.Set(from._internal_output_p(), 
      _this->GetArenaForAllocation());
  }
  _impl_.output_n_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_n_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_output_n().empty()) {
    _this->_impl_.output_n_.Set(from._internal_output_n(), 
      _this->GetArenaForAllocation());
  }
  _impl_.input_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_input_source().empty()) {
    _this->_impl_.input_source_.Set(from._internal_input_source(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.fstart_, &from._impl_.fstart_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.npts_) -
    reinterpret_cast<char*>(&_impl_.fstart_)) + sizeof(_impl_.npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.NoiseInput)
}

inline void NoiseInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.output_p_){}
    , decltype(_impl_.output_n_){}
    , decltype(_impl_.input_source_){}
    , decltype(_impl_.fstart_){0}
    , decltype(_impl_.fstop_){0}
    , decltype(_impl_.npts_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.output_p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_p_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.output_n_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_n_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.input_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NoiseInput::~NoiseInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.NoiseInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoiseInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
  _impl_.output_p_.Destroy();
  _impl_.output_n_.Destroy();
  _impl_.input_source_.Destroy();
}

void NoiseInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoiseInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.NoiseInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.output_p_.ClearToEmpty();
  _impl_.output_n_.ClearToEmpty();
  _impl_.input_source_.ClearToEmpty();
  ::memset(&_impl_.fstart_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.npts_) -
      reinterpret_cast<char*>(&_impl_.fstart_)) + sizeof(_impl_.npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoiseInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.NoiseInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string output_p = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_output_p();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.NoiseInput.output_p"));
        } else
          goto handle_unusual;
        continue;
      // string output_n = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_output_n();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.NoiseInput.output_n"));
        } else
          goto handle_unusual;
        continue;
      // string input_source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_input_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.NoiseInput.input_source"));
        } else
          goto handle_unusual;
        continue;
      // double fstart = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.fstart_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fstop = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.fstop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint64 npts = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.npts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoiseInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.NoiseInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.NoiseInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string output_p = 2;
  if (!this->_internal_output_p().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_output_p().data(), static_cast<int>(this->_internal_output_p().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.NoiseInput.output_p");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_output_p(), target);
  }

  // string output_n = 3;
  if (!this->_internal_output_n().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_output_n().data(), static_cast<int>(this->_internal_output_n().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.NoiseInput.output_n");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_output_n(), target);
  }

  // string input_source = 4;
  if (!this->_internal_input_source().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input_source().data(), static_cast<int>(this->_internal_input_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.NoiseInput.input_source");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_input_source(), target);
  }

  // double fstart = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstart = this->_internal_fstart();
  uint64_t raw_fstart;
  memcpy(&raw_fstart, &tmp_fstart, sizeof(tmp_fstart));
  if (raw_fstart != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_fstart(), target);
  }

  // double fstop = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstop = this->_internal_fstop();
  uint64_t raw_fstop;
  memcpy(&raw_fstop, &tmp_fstop, sizeof(tmp_fstop));
  if (raw_fstop != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_fstop(), target);
  }

  // uint64 npts = 12;
  if (this->_internal_npts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_npts(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.NoiseInput)
  return target;
}

size_t NoiseInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.NoiseInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 20;
  total_size += 2UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string output_p = 2;
  if (!this->_internal_output_p().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_output_p());
  }

  // string output_n = 3;
  if (!this->_internal_output_n().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_output_n());
  }

  // string input_source = 4;
  if (!this->_internal_input_source().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_input_source());
  }

  // double fstart = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstart = this->_internal_fstart();
  uint64_t raw_fstart;
  memcpy(&raw_fstart, &tmp_fstart, sizeof(tmp_fstart));
  if (raw_fstart != 0) {
    total_size += 1 + 8;
  }

  // double fstop = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstop = this->_internal_fstop();
  uint64_t raw_fstop;
  memcpy(&raw_fstop, &tmp_fstop, sizeof(tmp_fstop));
  if (raw_fstop != 0) {
    total_size += 1 + 8;
  }

  // uint64 npts = 12;
  if (this->_internal_npts() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_npts());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoiseInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoiseInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoiseInput::GetClassData() const { return &_class_data_; }


void NoiseInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoiseInput*>(&to_msg);
  auto& from = static_cast<const NoiseInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.NoiseInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_output_p().empty()) {
    _this->_internal_set_output_p(from._internal_output_p());
  }
  if (!from._internal_output_n().empty()) {
    _this->_internal_set_output_n(from._internal_output_n());
  }
  if (!from._internal_input_source().empty()) {
    _this->_internal_set_input_source(from._internal_input_source());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstart = from._internal_fstart();
  uint64_t raw_fstart;
  memcpy(&raw_fstart, &tmp_fstart, sizeof(tmp_fstart));
  if (raw_fstart != 0) {
    _this->_internal_set_fstart(from._internal_fstart());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fstop = from._internal_fstop();
  uint64_t raw_fstop;
  memcpy(&raw_fstop, &tmp_fstop, sizeof(tmp_fstop));
  if (raw_fstop != 0) {
    _this->_internal_set_fstop(from._internal_fstop());
  }
  if (from._internal_npts() != 0) {
    _this->_internal_set_npts(from._internal_npts());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoiseInput::CopyFrom(const NoiseInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.NoiseInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoiseInput::IsInitialized() const {
  return true;
}

void NoiseInput::InternalSwap(NoiseInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.output_p_, lhs_arena,
      &other->_impl_.output_p_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.output_n_, lhs_arena,
      &other->_impl_.output_n_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.input_source_, lhs_arena,
      &other->_impl_.input_source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NoiseInput, _impl_.npts_)
      + sizeof(NoiseInput::_impl_.npts_)
      - PROTOBUF_FIELD_OFFSET(NoiseInput, _impl_.fstart_)>(
          reinterpret_cast<char*>(&_impl_.fstart_),
          reinterpret_cast<char*>(&other->_impl_.fstart_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NoiseInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[18]);
}

// ===================================================================

NoiseResult_IntegratedNoiseEntry_DoNotUse::NoiseResult_IntegratedNoiseEntry_DoNotUse() {}
NoiseResult_IntegratedNoiseEntry_DoNotUse::NoiseResult_IntegratedNoiseEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NoiseResult_IntegratedNoiseEntry_DoNotUse::MergeFrom(const NoiseResult_IntegratedNoiseEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NoiseResult_IntegratedNoiseEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[19]);
}

// ===================================================================

NoiseResult_MeasurementsEntry_DoNotUse::NoiseResult_MeasurementsEntry_DoNotUse() {}
NoiseResult_MeasurementsEntry_DoNotUse::NoiseResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NoiseResult_MeasurementsEntry_DoNotUse::MergeFrom(const NoiseResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NoiseResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[20]);
}

// ===================================================================

class NoiseResult::_Internal {
 public:
};

NoiseResult::NoiseResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &NoiseResult::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.NoiseResult)
}
NoiseResult::NoiseResult(const NoiseResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoiseResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){from._impl_.signals_}
    , decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_.integrated_noise_)*/{}
    , /*decltype(_impl_.measurements_)*/{}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.integrated_noise_.MergeFrom(from._impl_.integrated_noise_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.NoiseResult)
}

inline void NoiseResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){arena}
    , decltype(_impl_.data_){arena}
    , /*decltype(_impl_.integrated_noise_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.measurements_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.analysis_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NoiseResult::~NoiseResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.NoiseResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void NoiseResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signals_.~RepeatedPtrField();
  _impl_.data_.~RepeatedField();
  _impl_.integrated_noise_.Destruct();
  _impl_.integrated_noise_.~MapField();
  _impl_.measurements_.Destruct();
  _impl_.measurements_.~MapField();
  _impl_.analysis_name_.Destroy();
}

void NoiseResult::ArenaDtor(void* object) {
  NoiseResult* _this = reinterpret_cast< NoiseResult* >(object);
  _this->_impl_.integrated_noise_.Destruct();
  _this->_impl_.measurements_.Destruct();
}
void NoiseResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoiseResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.NoiseResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signals_.Clear();
  _impl_.data_.Clear();
  _impl_.integrated_noise_.Clear();
  _impl_.measurements_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoiseResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.NoiseResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.NoiseResult.signals"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> integrated_noise = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.integrated_noise_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoiseResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.NoiseResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.NoiseResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.NoiseResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  // map<string, double> integrated_noise = 10;
  if (!this->_internal_integrated_noise().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = NoiseResult_IntegratedNoiseEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_integrated_noise();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vlsir.spice.NoiseResult.IntegratedNoiseEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, double> measurements = 11;
  if (!this->_internal_measurements().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = NoiseResult_MeasurementsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_measurements();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vlsir.spice.NoiseResult.MeasurementsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.NoiseResult)
  return target;
}

size_t NoiseResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.NoiseResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signals_.size());
  for (int i = 0, n = _impl_.signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // map<string, double> integrated_noise = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_integrated_noise_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_integrated_noise().begin();
      it != this->_internal_integrated_noise().end(); ++it) {
    total_size += NoiseResult_IntegratedNoiseEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, double> measurements = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += NoiseResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoiseResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoiseResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoiseResult::GetClassData() const { return &_class_data_; }


void NoiseResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoiseResult*>(&to_msg);
  auto& from = static_cast<const NoiseResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.NoiseResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.integrated_noise_.MergeFrom(from._impl_.integrated_noise_);
  _this->_impl_.measurements_.MergeFrom(from._impl_.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoiseResult::CopyFrom(const NoiseResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.NoiseResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoiseResult::IsInitialized() const {
  return true;
}

void NoiseResult::InternalSwap(NoiseResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.signals_.InternalSwap(&other->_impl_.signals_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  _impl_.integrated_noise_.InternalSwap(&other->_impl_.integrated_noise_);
  _impl_.measurements_.InternalSwap(&other->_impl_.measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NoiseResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[21]);
}

// ===================================================================

class SweepInput::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const SweepInput* msg);
};

const ::vlsir::spice::Sweep&
SweepInput::_Internal::sweep(const SweepInput* msg) {
  return *msg->_impl_.sweep_;
}
SweepInput::SweepInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SweepInput)
}
SweepInput::SweepInput(const SweepInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SweepInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){from._impl_.an_}
    , decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.variable_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.variable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.variable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_variable().empty()) {
    _this->_impl_.variable_.Set(from._internal_variable(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    _this->_impl_.sweep_ = new ::vlsir::spice::Sweep(*from._impl_.sweep_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SweepInput)
}

inline void SweepInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){arena}
    , decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.variable_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.variable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.variable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SweepInput::~SweepInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SweepInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SweepInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.an_.~RepeatedPtrField();
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
  _impl_.variable_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sweep_;
}

void SweepInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SweepInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SweepInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.an_.Clear();
  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.variable_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.sweep_ != nullptr) {
    delete _impl_.sweep_;
  }
  _impl_.sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SweepInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.SweepInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string variable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_variable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.SweepInput.variable"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Analysis an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SweepInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SweepInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_variable().data(), static_cast<int>(this->_internal_variable().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepInput.variable");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_variable(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sweep(this),
        _Internal::sweep(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.Analysis an = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_an_size()); i < n; i++) {
    const auto& repfield = this->_internal_an(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SweepInput)
  return target;
}

size_t SweepInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SweepInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Analysis an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->_impl_.an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_variable());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SweepInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SweepInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SweepInput::GetClassData() const { return &_class_data_; }


void SweepInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SweepInput*>(&to_msg);
  auto& from = static_cast<const SweepInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SweepInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.an_.MergeFrom(from._impl_.an_);
  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_variable().empty()) {
    _this->_internal_set_variable(from._internal_variable());
  }
  if (from._internal_has_sweep()) {
    _this->_internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(
        from._internal_sweep());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SweepInput::CopyFrom(const SweepInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SweepInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SweepInput::IsInitialized() const {
  return true;
}

void SweepInput::InternalSwap(SweepInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.an_.InternalSwap(&other->_impl_.an_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.variable_, lhs_arena,
      &other->_impl_.variable_, rhs_arena
  );
  swap(_impl_.sweep_, other->_impl_.sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SweepInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[22]);
}

// ===================================================================

class SweepResult::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const SweepResult* msg);
};

const ::vlsir::spice::Sweep&
SweepResult::_Internal::sweep(const SweepResult* msg) {
  return *msg->_impl_.sweep_;
}
SweepResult::SweepResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SweepResult)
}
SweepResult::SweepResult(const SweepResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SweepResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){from._impl_.an_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.variable_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.variable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.variable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_variable().empty()) {
    _this->_impl_.variable_.Set(from._internal_variable(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    _this->_impl_.sweep_ = new ::vlsir::spice::Sweep(*from._impl_.sweep_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SweepResult)
}

inline void SweepResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.variable_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.variable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.variable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SweepResult::~SweepResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SweepResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SweepResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.an_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
  _impl_.variable_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sweep_;
}

void SweepResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SweepResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SweepResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.an_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.variable_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.sweep_ != nullptr) {
    delete _impl_.sweep_;
  }
  _impl_.sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SweepResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.SweepResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string variable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_variable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.SweepResult.variable"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.AnalysisResult an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SweepResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SweepResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_variable().data(), static_cast<int>(this->_internal_variable().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepResult.variable");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_variable(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sweep(this),
        _Internal::sweep(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.AnalysisResult an = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_an_size()); i < n; i++) {
    const auto& repfield = this->_internal_an(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SweepResult)
  return target;
}

size_t SweepResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SweepResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->_impl_.an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_variable());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SweepResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SweepResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SweepResult::GetClassData() const { return &_class_data_; }


void SweepResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SweepResult*>(&to_msg);
  auto& from = static_cast<const SweepResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SweepResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.an_.MergeFrom(from._impl_.an_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_variable().empty()) {
    _this->_internal_set_variable(from._internal_variable());
  }
  if (from._internal_has_sweep()) {
    _this->_internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(
        from._internal_sweep());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SweepResult::CopyFrom(const SweepResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SweepResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SweepResult::IsInitialized() const {
  return true;
}

void SweepResult::InternalSwap(SweepResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.an_.InternalSwap(&other->_impl_.an_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.variable_, lhs_arena,
      &other->_impl_.variable_, rhs_arena
  );
  swap(_impl_.sweep_, other->_impl_.sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SweepResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[23]);
}

// ===================================================================

class MonteInput::_Internal {
 public:
};

MonteInput::MonteInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.MonteInput)
}
MonteInput::MonteInput(const MonteInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonteInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){from._impl_.an_}
    , decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.npts_){}
    , decltype(_impl_.seed_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.npts_, &from._impl_.npts_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seed_) -
    reinterpret_cast<char*>(&_impl_.npts_)) + sizeof(_impl_.seed_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.MonteInput)
}

inline void MonteInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){arena}
    , decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.npts_){int64_t{0}}
    , decltype(_impl_.seed_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MonteInput::~MonteInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.MonteInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonteInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.an_.~RepeatedPtrField();
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
}

void MonteInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonteInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.MonteInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.an_.Clear();
  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  ::memset(&_impl_.npts_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.seed_) -
      reinterpret_cast<char*>(&_impl_.npts_)) + sizeof(_impl_.seed_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonteInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.MonteInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // int64 npts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.npts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 seed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Analysis an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonteInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.MonteInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.MonteInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // int64 npts = 2;
  if (this->_internal_npts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_npts(), target);
  }

  // int64 seed = 3;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_seed(), target);
  }

  // repeated .vlsir.spice.Analysis an = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_an_size()); i < n; i++) {
    const auto& repfield = this->_internal_an(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.MonteInput)
  return target;
}

size_t MonteInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.MonteInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Analysis an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->_impl_.an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // int64 npts = 2;
  if (this->_internal_npts() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_npts());
  }

  // int64 seed = 3;
  if (this->_internal_seed() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonteInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonteInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonteInput::GetClassData() const { return &_class_data_; }


void MonteInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonteInput*>(&to_msg);
  auto& from = static_cast<const MonteInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.MonteInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.an_.MergeFrom(from._impl_.an_);
  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (from._internal_npts() != 0) {
    _this->_internal_set_npts(from._internal_npts());
  }
  if (from._internal_seed() != 0) {
    _this->_internal_set_seed(from._internal_seed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonteInput::CopyFrom(const MonteInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.MonteInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonteInput::IsInitialized() const {
  return true;
}

void MonteInput::InternalSwap(MonteInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.an_.InternalSwap(&other->_impl_.an_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonteInput, _impl_.seed_)
      + sizeof(MonteInput::_impl_.seed_)
      - PROTOBUF_FIELD_OFFSET(MonteInput, _impl_.npts_)>(
          reinterpret_cast<char*>(&_impl_.npts_),
          reinterpret_cast<char*>(&other->_impl_.npts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MonteInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[24]);
}

// ===================================================================

class MonteResult::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const MonteResult* msg);
};

const ::vlsir::spice::Sweep&
MonteResult::_Internal::sweep(const MonteResult* msg) {
  return *msg->_impl_.sweep_;
}
MonteResult::MonteResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.MonteResult)
}
MonteResult::MonteResult(const MonteResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonteResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){from._impl_.an_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.variable_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.variable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.variable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_variable().empty()) {
    _this->_impl_.variable_.Set(from._internal_variable(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    _this->_impl_.sweep_ = new ::vlsir::spice::Sweep(*from._impl_.sweep_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.MonteResult)
}

inline void MonteResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.an_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.variable_){}
    , decltype(_impl_.sweep_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.variable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.variable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MonteResult::~MonteResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.MonteResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonteResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.an_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
  _impl_.variable_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sweep_;
}

void MonteResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonteResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.MonteResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.an_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.variable_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.sweep_ != nullptr) {
    delete _impl_.sweep_;
  }
  _impl_.sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonteResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.MonteResult.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string variable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_variable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.MonteResult.variable"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.AnalysisResult an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonteResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.MonteResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.MonteResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_variable().data(), static_cast<int>(this->_internal_variable().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.MonteResult.variable");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_variable(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sweep(this),
        _Internal::sweep(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.spice.AnalysisResult an = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_an_size()); i < n; i++) {
    const auto& repfield = this->_internal_an(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.MonteResult)
  return target;
}

size_t MonteResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.MonteResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->_impl_.an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_variable());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonteResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonteResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonteResult::GetClassData() const { return &_class_data_; }


void MonteResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonteResult*>(&to_msg);
  auto& from = static_cast<const MonteResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.MonteResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.an_.MergeFrom(from._impl_.an_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_variable().empty()) {
    _this->_internal_set_variable(from._internal_variable());
  }
  if (from._internal_has_sweep()) {
    _this->_internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(
        from._internal_sweep());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonteResult::CopyFrom(const MonteResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.MonteResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonteResult::IsInitialized() const {
  return true;
}

void MonteResult::InternalSwap(MonteResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.an_.InternalSwap(&other->_impl_.an_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.variable_, lhs_arena,
      &other->_impl_.variable_, rhs_arena
  );
  swap(_impl_.sweep_, other->_impl_.sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MonteResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[25]);
}

// ===================================================================

class CustomAnalysisInput::_Internal {
 public:
};

CustomAnalysisInput::CustomAnalysisInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.CustomAnalysisInput)
}
CustomAnalysisInput::CustomAnalysisInput(const CustomAnalysisInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CustomAnalysisInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){from._impl_.ctrls_}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.cmd_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    _this->_impl_.analysis_name_.Set(from._internal_analysis_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cmd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cmd().empty()) {
    _this->_impl_.cmd_.Set(from._internal_cmd(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.CustomAnalysisInput)
}

inline void CustomAnalysisInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrls_){arena}
    , decltype(_impl_.analysis_name_){}
    , decltype(_impl_.cmd_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomAnalysisInput::~CustomAnalysisInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.CustomAnalysisInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CustomAnalysisInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ctrls_.~RepeatedPtrField();
  _impl_.analysis_name_.Destroy();
  _impl_.cmd_.Destroy();
}

void CustomAnalysisInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CustomAnalysisInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.CustomAnalysisInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctrls_.Clear();
  _impl_.analysis_name_.ClearToEmpty();
  _impl_.cmd_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CustomAnalysisInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.CustomAnalysisInput.analysis_name"));
        } else
          goto handle_unusual;
        continue;
      // string cmd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cmd();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.CustomAnalysisInput.cmd"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomAnalysisInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.CustomAnalysisInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.CustomAnalysisInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string cmd = 2;
  if (!this->_internal_cmd().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cmd().data(), static_cast<int>(this->_internal_cmd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.CustomAnalysisInput.cmd");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cmd(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ctrls_size()); i < n; i++) {
    const auto& repfield = this->_internal_ctrls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.CustomAnalysisInput)
  return target;
}

size_t CustomAnalysisInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.CustomAnalysisInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->_impl_.ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string cmd = 2;
  if (!this->_internal_cmd().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cmd());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CustomAnalysisInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CustomAnalysisInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CustomAnalysisInput::GetClassData() const { return &_class_data_; }


void CustomAnalysisInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CustomAnalysisInput*>(&to_msg);
  auto& from = static_cast<const CustomAnalysisInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.CustomAnalysisInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ctrls_.MergeFrom(from._impl_.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _this->_internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_cmd().empty()) {
    _this->_internal_set_cmd(from._internal_cmd());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CustomAnalysisInput::CopyFrom(const CustomAnalysisInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.CustomAnalysisInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomAnalysisInput::IsInitialized() const {
  return true;
}

void CustomAnalysisInput::InternalSwap(CustomAnalysisInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ctrls_.InternalSwap(&other->_impl_.ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_name_, lhs_arena,
      &other->_impl_.analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cmd_, lhs_arena,
      &other->_impl_.cmd_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CustomAnalysisInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[26]);
}

// ===================================================================

class CustomAnalysisResult::_Internal {
 public:
};

CustomAnalysisResult::CustomAnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.CustomAnalysisResult)
}
CustomAnalysisResult::CustomAnalysisResult(const CustomAnalysisResult& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CustomAnalysisResult* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.CustomAnalysisResult)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CustomAnalysisResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CustomAnalysisResult::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CustomAnalysisResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[27]);
}

// ===================================================================

class Sweep::_Internal {
 public:
  static const ::vlsir::spice::LinearSweep& linear(const Sweep* msg);
  static const ::vlsir::spice::LogSweep& log(const Sweep* msg);
  static const ::vlsir::spice::PointSweep& points(const Sweep* msg);
};

const ::vlsir::spice::LinearSweep&
Sweep::_Internal::linear(const Sweep* msg) {
  return *msg->_impl_.tp_.linear_;
}
const ::vlsir::spice::LogSweep&
Sweep::_Internal::log(const Sweep* msg) {
  return *msg->_impl_.tp_.log_;
}
const ::vlsir::spice::PointSweep&
Sweep::_Internal::points(const Sweep* msg) {
  return *msg->_impl_.tp_.points_;
}
void Sweep::set_allocated_linear(::vlsir::spice::LinearSweep* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tp();
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
    _impl_.tp_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Sweep.linear)
}
void Sweep::set_allocated_log(::vlsir::spice::LogSweep* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tp();
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    set_has_log();
    _impl_.tp_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Sweep.log)
}
void Sweep::set_allocated_points(::vlsir::spice::PointSweep* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tp();
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(points);
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    set_has_points();
    _impl_.tp_.points_ = points;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Sweep.points)
}
Sweep::Sweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Sweep)
}
Sweep::Sweep(const Sweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Sweep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tp_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_tp();
  switch (from.tp_case()) {
    case kLinear: {
      _this->_internal_mutable_linear()->::vlsir::spice::LinearSweep::MergeFrom(
          from._internal_linear());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::vlsir::spice::LogSweep::MergeFrom(
          from._internal_log());
      break;
    }
    case kPoints: {
      _this->_internal_mutable_points()->::vlsir::spice::PointSweep::MergeFrom(
          from._internal_points());
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Sweep)
}

inline void Sweep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tp_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_tp();
}

Sweep::~Sweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Sweep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Sweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_tp()) {
    clear_tp();
  }
}

void Sweep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Sweep::clear_tp() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Sweep)
  switch (tp_case()) {
    case kLinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.tp_.linear_;
      }
      break;
    }
    case kLog: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.tp_.log_;
      }
      break;
    }
    case kPoints: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.tp_.points_;
      }
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TP_NOT_SET;
}


void Sweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Sweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_tp();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sweep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.LinearSweep linear = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.LogSweep log = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_log(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.PointSweep points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_points(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Sweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.LinearSweep linear = 1;
  if (_internal_has_linear()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::linear(this),
        _Internal::linear(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.LogSweep log = 2;
  if (_internal_has_log()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::log(this),
        _Internal::log(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.PointSweep points = 3;
  if (_internal_has_points()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::points(this),
        _Internal::points(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Sweep)
  return target;
}

size_t Sweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Sweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (tp_case()) {
    // .vlsir.spice.LinearSweep linear = 1;
    case kLinear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tp_.linear_);
      break;
    }
    // .vlsir.spice.LogSweep log = 2;
    case kLog: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tp_.log_);
      break;
    }
    // .vlsir.spice.PointSweep points = 3;
    case kPoints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tp_.points_);
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Sweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sweep::GetClassData() const { return &_class_data_; }


void Sweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Sweep*>(&to_msg);
  auto& from = static_cast<const Sweep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Sweep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.tp_case()) {
    case kLinear: {
      _this->_internal_mutable_linear()->::vlsir::spice::LinearSweep::MergeFrom(
          from._internal_linear());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::vlsir::spice::LogSweep::MergeFrom(
          from._internal_log());
      break;
    }
    case kPoints: {
      _this->_internal_mutable_points()->::vlsir::spice::PointSweep::MergeFrom(
          from._internal_points());
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sweep::CopyFrom(const Sweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Sweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sweep::IsInitialized() const {
  return true;
}

void Sweep::InternalSwap(Sweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.tp_, other->_impl_.tp_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Sweep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[28]);
}

// ===================================================================

class LinearSweep::_Internal {
 public:
};

LinearSweep::LinearSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.LinearSweep)
}
LinearSweep::LinearSweep(const LinearSweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinearSweep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){}
    , decltype(_impl_.stop_){}
    , decltype(_impl_.step_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_, &from._impl_.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.step_) -
    reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.step_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.LinearSweep)
}

inline void LinearSweep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){0}
    , decltype(_impl_.stop_){0}
    , decltype(_impl_.step_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LinearSweep::~LinearSweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.LinearSweep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinearSweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LinearSweep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinearSweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.LinearSweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.step_) -
      reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.step_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearSweep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.stop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double step = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearSweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.LinearSweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double start = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start = this->_internal_start();
  uint64_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_start(), target);
  }

  // double stop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = this->_internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop(), target);
  }

  // double step = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_step = this->_internal_step();
  uint64_t raw_step;
  memcpy(&raw_step, &tmp_step, sizeof(tmp_step));
  if (raw_step != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_step(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.LinearSweep)
  return target;
}

size_t LinearSweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.LinearSweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double start = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start = this->_internal_start();
  uint64_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    total_size += 1 + 8;
  }

  // double stop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = this->_internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    total_size += 1 + 8;
  }

  // double step = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_step = this->_internal_step();
  uint64_t raw_step;
  memcpy(&raw_step, &tmp_step, sizeof(tmp_step));
  if (raw_step != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearSweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinearSweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearSweep::GetClassData() const { return &_class_data_; }


void LinearSweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinearSweep*>(&to_msg);
  auto& from = static_cast<const LinearSweep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.LinearSweep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start = from._internal_start();
  uint64_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    _this->_internal_set_start(from._internal_start());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = from._internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    _this->_internal_set_stop(from._internal_stop());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_step = from._internal_step();
  uint64_t raw_step;
  memcpy(&raw_step, &tmp_step, sizeof(tmp_step));
  if (raw_step != 0) {
    _this->_internal_set_step(from._internal_step());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearSweep::CopyFrom(const LinearSweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.LinearSweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearSweep::IsInitialized() const {
  return true;
}

void LinearSweep::InternalSwap(LinearSweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LinearSweep, _impl_.step_)
      + sizeof(LinearSweep::_impl_.step_)
      - PROTOBUF_FIELD_OFFSET(LinearSweep, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearSweep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[29]);
}

// ===================================================================

class LogSweep::_Internal {
 public:
};

LogSweep::LogSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.LogSweep)
}
LogSweep::LogSweep(const LogSweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogSweep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){}
    , decltype(_impl_.stop_){}
    , decltype(_impl_.npts_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_, &from._impl_.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.npts_) -
    reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.LogSweep)
}

inline void LogSweep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){0}
    , decltype(_impl_.stop_){0}
    , decltype(_impl_.npts_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LogSweep::~LogSweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.LogSweep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogSweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogSweep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogSweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.LogSweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.npts_) -
      reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogSweep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.stop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double npts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.npts_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogSweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.LogSweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double start = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start = this->_internal_start();
  uint64_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_start(), target);
  }

  // double stop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = this->_internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop(), target);
  }

  // double npts = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_npts = this->_internal_npts();
  uint64_t raw_npts;
  memcpy(&raw_npts, &tmp_npts, sizeof(tmp_npts));
  if (raw_npts != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_npts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.LogSweep)
  return target;
}

size_t LogSweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.LogSweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double start = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start = this->_internal_start();
  uint64_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    total_size += 1 + 8;
  }

  // double stop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = this->_internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    total_size += 1 + 8;
  }

  // double npts = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_npts = this->_internal_npts();
  uint64_t raw_npts;
  memcpy(&raw_npts, &tmp_npts, sizeof(tmp_npts));
  if (raw_npts != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogSweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogSweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogSweep::GetClassData() const { return &_class_data_; }


void LogSweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogSweep*>(&to_msg);
  auto& from = static_cast<const LogSweep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.LogSweep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start = from._internal_start();
  uint64_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    _this->_internal_set_start(from._internal_start());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = from._internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    _this->_internal_set_stop(from._internal_stop());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_npts = from._internal_npts();
  uint64_t raw_npts;
  memcpy(&raw_npts, &tmp_npts, sizeof(tmp_npts));
  if (raw_npts != 0) {
    _this->_internal_set_npts(from._internal_npts());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogSweep::CopyFrom(const LogSweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.LogSweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogSweep::IsInitialized() const {
  return true;
}

void LogSweep::InternalSwap(LogSweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogSweep, _impl_.npts_)
      + sizeof(LogSweep::_impl_.npts_)
      - PROTOBUF_FIELD_OFFSET(LogSweep, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogSweep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[30]);
}

// ===================================================================

class PointSweep::_Internal {
 public:
};

PointSweep::PointSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.PointSweep)
}
PointSweep::PointSweep(const PointSweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointSweep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.stop_){}
    , decltype(_impl_.npts_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.stop_, &from._impl_.stop_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.npts_) -
    reinterpret_cast<char*>(&_impl_.stop_)) + sizeof(_impl_.npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.PointSweep)
}

inline void PointSweep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena}
    , decltype(_impl_.stop_){0}
    , decltype(_impl_.npts_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointSweep::~PointSweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.PointSweep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointSweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedField();
}

void PointSweep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointSweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.PointSweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  ::memset(&_impl_.stop_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.npts_) -
      reinterpret_cast<char*>(&_impl_.stop_)) + sizeof(_impl_.npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointSweep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_points(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_points(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.stop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double npts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.npts_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointSweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.PointSweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  // double stop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = this->_internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop(), target);
  }

  // double npts = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_npts = this->_internal_npts();
  uint64_t raw_npts;
  memcpy(&raw_npts, &tmp_npts, sizeof(tmp_npts));
  if (raw_npts != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_npts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.PointSweep)
  return target;
}

size_t PointSweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.PointSweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double points = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_points_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // double stop = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = this->_internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    total_size += 1 + 8;
  }

  // double npts = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_npts = this->_internal_npts();
  uint64_t raw_npts;
  memcpy(&raw_npts, &tmp_npts, sizeof(tmp_npts));
  if (raw_npts != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointSweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointSweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointSweep::GetClassData() const { return &_class_data_; }


void PointSweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointSweep*>(&to_msg);
  auto& from = static_cast<const PointSweep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.PointSweep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop = from._internal_stop();
  uint64_t raw_stop;
  memcpy(&raw_stop, &tmp_stop, sizeof(tmp_stop));
  if (raw_stop != 0) {
    _this->_internal_set_stop(from._internal_stop());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_npts = from._internal_npts();
  uint64_t raw_npts;
  memcpy(&raw_npts, &tmp_npts, sizeof(tmp_npts));
  if (raw_npts != 0) {
    _this->_internal_set_npts(from._internal_npts());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointSweep::CopyFrom(const PointSweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.PointSweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointSweep::IsInitialized() const {
  return true;
}

void PointSweep::InternalSwap(PointSweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointSweep, _impl_.npts_)
      + sizeof(PointSweep::_impl_.npts_)
      - PROTOBUF_FIELD_OFFSET(PointSweep, _impl_.stop_)>(
          reinterpret_cast<char*>(&_impl_.stop_),
          reinterpret_cast<char*>(&other->_impl_.stop_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointSweep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[31]);
}

// ===================================================================

class Control::_Internal {
 public:
  static const ::vlsir::spice::Include& include(const Control* msg);
  static const ::vlsir::spice::LibInclude& lib(const Control* msg);
  static const ::vlsir::spice::Save& save(const Control* msg);
  static const ::vlsir::spice::Meas& meas(const Control* msg);
  static const ::vlsir::utils::Param& param(const Control* msg);
};

const ::vlsir::spice::Include&
Control::_Internal::include(const Control* msg) {
  return *msg->_impl_.ctrl_.include_;
}
const ::vlsir::spice::LibInclude&
Control::_Internal::lib(const Control* msg) {
  return *msg->_impl_.ctrl_.lib_;
}
const ::vlsir::spice::Save&
Control::_Internal::save(const Control* msg) {
  return *msg->_impl_.ctrl_.save_;
}
const ::vlsir::spice::Meas&
Control::_Internal::meas(const Control* msg) {
  return *msg->_impl_.ctrl_.meas_;
}
const ::vlsir::utils::Param&
Control::_Internal::param(const Control* msg) {
  return *msg->_impl_.ctrl_.param_;
}
void Control::set_allocated_include(::vlsir::spice::Include* include) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (include) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(include);
    if (message_arena != submessage_arena) {
      include = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, include, submessage_arena);
    }
    set_has_include();
    _impl_.ctrl_.include_ = include;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.include)
}
void Control::set_allocated_lib(::vlsir::spice::LibInclude* lib) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (lib) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lib);
    if (message_arena != submessage_arena) {
      lib = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lib, submessage_arena);
    }
    set_has_lib();
    _impl_.ctrl_.lib_ = lib;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.lib)
}
void Control::set_allocated_save(::vlsir::spice::Save* save) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (save) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save);
    if (message_arena != submessage_arena) {
      save = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save, submessage_arena);
    }
    set_has_save();
    _impl_.ctrl_.save_ = save;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.save)
}
void Control::set_allocated_meas(::vlsir::spice::Meas* meas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (meas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meas);
    if (message_arena != submessage_arena) {
      meas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meas, submessage_arena);
    }
    set_has_meas();
    _impl_.ctrl_.meas_ = meas;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.meas)
}
void Control::set_allocated_param(::vlsir::utils::Param* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param));
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    set_has_param();
    _impl_.ctrl_.param_ = param;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.param)
}
void Control::clear_param() {
  if (_internal_has_param()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ctrl_.param_;
    }
    clear_has_ctrl();
  }
}
Control::Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Control)
}
Control::Control(const Control& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Control* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrl_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ctrl();
  switch (from.ctrl_case()) {
    case kInclude: {
      _this->_internal_mutable_include()->::vlsir::spice::Include::MergeFrom(
          from._internal_include());
      break;
    }
    case kLib: {
      _this->_internal_mutable_lib()->::vlsir::spice::LibInclude::MergeFrom(
          from._internal_lib());
      break;
    }
    case kSave: {
      _this->_internal_mutable_save()->::vlsir::spice::Save::MergeFrom(
          from._internal_save());
      break;
    }
    case kMeas: {
      _this->_internal_mutable_meas()->::vlsir::spice::Meas::MergeFrom(
          from._internal_meas());
      break;
    }
    case kParam: {
      _this->_internal_mutable_param()->::vlsir::utils::Param::MergeFrom(
          from._internal_param());
      break;
    }
    case kLiteral: {
      _this->_internal_set_literal(from._internal_literal());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Control)
}

inline void Control::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ctrl_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ctrl();
}

Control::~Control() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Control)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Control::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ctrl()) {
    clear_ctrl();
  }
}

void Control::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Control::clear_ctrl() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Control)
  switch (ctrl_case()) {
    case kInclude: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ctrl_.include_;
      }
      break;
    }
    case kLib: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ctrl_.lib_;
      }
      break;
    }
    case kSave: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ctrl_.save_;
      }
      break;
    }
    case kMeas: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ctrl_.meas_;
      }
      break;
    }
    case kParam: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ctrl_.param_;
      }
      break;
    }
    case kLiteral: {
      _impl_.ctrl_.literal_.Destroy();
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CTRL_NOT_SET;
}


void Control::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Control)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ctrl();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Control::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.Include include = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_include(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.LibInclude lib = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lib(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Save save = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_save(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Meas meas = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_meas(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.Param param = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_param(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string literal = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_literal();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Control.literal"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Control::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Control)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.Include include = 1;
  if (_internal_has_include()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::include(this),
        _Internal::include(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.LibInclude lib = 2;
  if (_internal_has_lib()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::lib(this),
        _Internal::lib(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.Save save = 5;
  if (_internal_has_save()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::save(this),
        _Internal::save(this).GetCachedSize(), target, stream);
  }

  // .vlsir.spice.Meas meas = 6;
  if (_internal_has_meas()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::meas(this),
        _Internal::meas(this).GetCachedSize(), target, stream);
  }

  // .vlsir.utils.Param param = 7;
  if (_internal_has_param()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::param(this),
        _Internal::param(this).GetCachedSize(), target, stream);
  }

  // string literal = 10;
  if (_internal_has_literal()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_literal().data(), static_cast<int>(this->_internal_literal().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Control.literal");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_literal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Control)
  return target;
}

size_t Control::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Control)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ctrl_case()) {
    // .vlsir.spice.Include include = 1;
    case kInclude: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ctrl_.include_);
      break;
    }
    // .vlsir.spice.LibInclude lib = 2;
    case kLib: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ctrl_.lib_);
      break;
    }
    // .vlsir.spice.Save save = 5;
    case kSave: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ctrl_.save_);
      break;
    }
    // .vlsir.spice.Meas meas = 6;
    case kMeas: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ctrl_.meas_);
      break;
    }
    // .vlsir.utils.Param param = 7;
    case kParam: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ctrl_.param_);
      break;
    }
    // string literal = 10;
    case kLiteral: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_literal());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Control::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Control::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Control::GetClassData() const { return &_class_data_; }


void Control::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Control*>(&to_msg);
  auto& from = static_cast<const Control&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Control)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ctrl_case()) {
    case kInclude: {
      _this->_internal_mutable_include()->::vlsir::spice::Include::MergeFrom(
          from._internal_include());
      break;
    }
    case kLib: {
      _this->_internal_mutable_lib()->::vlsir::spice::LibInclude::MergeFrom(
          from._internal_lib());
      break;
    }
    case kSave: {
      _this->_internal_mutable_save()->::vlsir::spice::Save::MergeFrom(
          from._internal_save());
      break;
    }
    case kMeas: {
      _this->_internal_mutable_meas()->::vlsir::spice::Meas::MergeFrom(
          from._internal_meas());
      break;
    }
    case kParam: {
      _this->_internal_mutable_param()->::vlsir::utils::Param::MergeFrom(
          from._internal_param());
      break;
    }
    case kLiteral: {
      _this->_internal_set_literal(from._internal_literal());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Control::CopyFrom(const Control& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Control)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Control::IsInitialized() const {
  return true;
}

void Control::InternalSwap(Control* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ctrl_, other->_impl_.ctrl_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Control::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[32]);
}

// ===================================================================

class Save::_Internal {
 public:
};

Save::Save(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Save)
}
Save::Save(const Save& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Save* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.save_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_save();
  switch (from.save_case()) {
    case kMode: {
      _this->_internal_set_mode(from._internal_mode());
      break;
    }
    case kSignal: {
      _this->_internal_set_signal(from._internal_signal());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Save)
}

inline void Save::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.save_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_save();
}

Save::~Save() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Save)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Save::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_save()) {
    clear_save();
  }
}

void Save::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Save::clear_save() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Save)
  switch (save_case()) {
    case kMode: {
      // No need to clear
      break;
    }
    case kSignal: {
      _impl_.save_.signal_.Destroy();
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SAVE_NOT_SET;
}


void Save::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Save)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_save();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Save::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.Save.SaveMode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::vlsir::spice::Save_SaveMode>(val));
        } else
          goto handle_unusual;
        continue;
      // string signal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signal();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Save.signal"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Save::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Save)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.Save.SaveMode mode = 1;
  if (_internal_has_mode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // string signal = 2;
  if (_internal_has_signal()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_signal().data(), static_cast<int>(this->_internal_signal().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Save.signal");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_signal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Save)
  return target;
}

size_t Save::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Save)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (save_case()) {
    // .vlsir.spice.Save.SaveMode mode = 1;
    case kMode: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
      break;
    }
    // string signal = 2;
    case kSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signal());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Save::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Save::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Save::GetClassData() const { return &_class_data_; }


void Save::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Save*>(&to_msg);
  auto& from = static_cast<const Save&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Save)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.save_case()) {
    case kMode: {
      _this->_internal_set_mode(from._internal_mode());
      break;
    }
    case kSignal: {
      _this->_internal_set_signal(from._internal_signal());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Save::CopyFrom(const Save& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Save)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Save::IsInitialized() const {
  return true;
}

void Save::InternalSwap(Save* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.save_, other->_impl_.save_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Save::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[33]);
}

// ===================================================================

class Include::_Internal {
 public:
};

Include::Include(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Include)
}
Include::Include(const Include& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Include* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Include)
}

inline void Include::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Include::~Include() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Include)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Include::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void Include::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Include::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Include)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Include::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Include.path"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Include::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Include)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Include.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Include)
  return target;
}

size_t Include::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Include)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Include::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Include::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Include::GetClassData() const { return &_class_data_; }


void Include::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Include*>(&to_msg);
  auto& from = static_cast<const Include&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Include)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Include::CopyFrom(const Include& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Include)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Include::IsInitialized() const {
  return true;
}

void Include::InternalSwap(Include* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Include::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[34]);
}

// ===================================================================

class LibInclude::_Internal {
 public:
};

LibInclude::LibInclude(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.LibInclude)
}
LibInclude::LibInclude(const LibInclude& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibInclude* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.section_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.section_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.section_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_section().empty()) {
    _this->_impl_.section_.Set(from._internal_section(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.LibInclude)
}

inline void LibInclude::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.section_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.section_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.section_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibInclude::~LibInclude() {
  // @@protoc_insertion_point(destructor:vlsir.spice.LibInclude)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibInclude::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.section_.Destroy();
}

void LibInclude::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibInclude::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.LibInclude)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _impl_.section_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibInclude::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.LibInclude.path"));
        } else
          goto handle_unusual;
        continue;
      // string section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_section();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.LibInclude.section"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibInclude::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.LibInclude)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.LibInclude.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // string section = 2;
  if (!this->_internal_section().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_section().data(), static_cast<int>(this->_internal_section().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.LibInclude.section");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_section(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.LibInclude)
  return target;
}

size_t LibInclude::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.LibInclude)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // string section = 2;
  if (!this->_internal_section().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_section());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibInclude::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibInclude::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibInclude::GetClassData() const { return &_class_data_; }


void LibInclude::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibInclude*>(&to_msg);
  auto& from = static_cast<const LibInclude&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.LibInclude)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (!from._internal_section().empty()) {
    _this->_internal_set_section(from._internal_section());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibInclude::CopyFrom(const LibInclude& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.LibInclude)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibInclude::IsInitialized() const {
  return true;
}

void LibInclude::InternalSwap(LibInclude* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.section_, lhs_arena,
      &other->_impl_.section_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LibInclude::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[35]);
}

// ===================================================================

class Meas::_Internal {
 public:
};

Meas::Meas(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Meas)
}
Meas::Meas(const Meas& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Meas* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.analysis_type_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.expr_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.analysis_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_type().empty()) {
    _this->_impl_.analysis_type_.Set(from._internal_analysis_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.expr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expr().empty()) {
    _this->_impl_.expr_.Set(from._internal_expr(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Meas)
}

inline void Meas::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.analysis_type_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.expr_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.analysis_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.expr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Meas::~Meas() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Meas)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meas::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.analysis_type_.Destroy();
  _impl_.name_.Destroy();
  _impl_.expr_.Destroy();
}

void Meas::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Meas::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Meas)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.analysis_type_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.expr_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Meas::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Meas.analysis_type"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Meas.name"));
        } else
          goto handle_unusual;
        continue;
      // string expr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_expr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Meas.expr"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meas::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Meas)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_type = 1;
  if (!this->_internal_analysis_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_type().data(), static_cast<int>(this->_internal_analysis_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Meas.analysis_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_type(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Meas.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string expr = 3;
  if (!this->_internal_expr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_expr().data(), static_cast<int>(this->_internal_expr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Meas.expr");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_expr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Meas)
  return target;
}

size_t Meas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Meas)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string analysis_type = 1;
  if (!this->_internal_analysis_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_type());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string expr = 3;
  if (!this->_internal_expr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_expr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Meas::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Meas::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Meas::GetClassData() const { return &_class_data_; }


void Meas::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Meas*>(&to_msg);
  auto& from = static_cast<const Meas&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Meas)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_analysis_type().empty()) {
    _this->_internal_set_analysis_type(from._internal_analysis_type());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_expr().empty()) {
    _this->_internal_set_expr(from._internal_expr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Meas::CopyFrom(const Meas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Meas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meas::IsInitialized() const {
  return true;
}

void Meas::InternalSwap(Meas* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_type_, lhs_arena,
      &other->_impl_.analysis_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.expr_, lhs_arena,
      &other->_impl_.expr_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Meas::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[36]);
}

// ===================================================================

class Signal::_Internal {
 public:
};

Signal::Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Signal)
}
Signal::Signal(const Signal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Signal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.quantity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.quantity_ = from._impl_.quantity_;
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Signal)
}

inline void Signal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.quantity_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Signal::~Signal() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Signal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Signal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Signal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Signal::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Signal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.quantity_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.spice.Signal.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Signal.Quantity quantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quantity(static_cast<::vlsir::spice::Signal_Quantity>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Signal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Signal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Signal.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.spice.Signal.Quantity quantity = 2;
  if (this->_internal_quantity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_quantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Signal)
  return target;
}

size_t Signal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Signal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.spice.Signal.Quantity quantity = 2;
  if (this->_internal_quantity() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_quantity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Signal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signal::GetClassData() const { return &_class_data_; }


void Signal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Signal*>(&to_msg);
  auto& from = static_cast<const Signal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Signal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_quantity() != 0) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signal::CopyFrom(const Signal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Signal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signal::IsInitialized() const {
  return true;
}

void Signal::InternalSwap(Signal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.quantity_, other->_impl_.quantity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Signal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[37]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace spice
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vlsir::spice::SimInput*
Arena::CreateMaybeMessage< ::vlsir::spice::SimInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SimInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SimResult*
Arena::CreateMaybeMessage< ::vlsir::spice::SimResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SimResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SimOptions*
Arena::CreateMaybeMessage< ::vlsir::spice::SimOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SimOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Analysis*
Arena::CreateMaybeMessage< ::vlsir::spice::Analysis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Analysis >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AnalysisResult*
Arena::CreateMaybeMessage< ::vlsir::spice::AnalysisResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AnalysisResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::OpInput*
Arena::CreateMaybeMessage< ::vlsir::spice::OpInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::OpInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::OpResult*
Arena::CreateMaybeMessage< ::vlsir::spice::OpResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::OpResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::DcInput*
Arena::CreateMaybeMessage< ::vlsir::spice::DcInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::DcInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::DcResult*
Arena::CreateMaybeMessage< ::vlsir::spice::DcResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::DcResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranInput_IcEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vlsir::spice::TranInput_IcEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranInput_IcEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranInput*
Arena::CreateMaybeMessage< ::vlsir::spice::TranInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranResult*
Arena::CreateMaybeMessage< ::vlsir::spice::TranResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::ComplexNum*
Arena::CreateMaybeMessage< ::vlsir::spice::ComplexNum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::ComplexNum >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AcInput*
Arena::CreateMaybeMessage< ::vlsir::spice::AcInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AcInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AcResult*
Arena::CreateMaybeMessage< ::vlsir::spice::AcResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AcResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::NoiseInput*
Arena::CreateMaybeMessage< ::vlsir::spice::NoiseInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::NoiseInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::NoiseResult_IntegratedNoiseEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::NoiseResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::NoiseResult*
Arena::CreateMaybeMessage< ::vlsir::spice::NoiseResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::NoiseResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SweepInput*
Arena::CreateMaybeMessage< ::vlsir::spice::SweepInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SweepInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SweepResult*
Arena::CreateMaybeMessage< ::vlsir::spice::SweepResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SweepResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::MonteInput*
Arena::CreateMaybeMessage< ::vlsir::spice::MonteInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::MonteInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::MonteResult*
Arena::CreateMaybeMessage< ::vlsir::spice::MonteResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::MonteResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::CustomAnalysisInput*
Arena::CreateMaybeMessage< ::vlsir::spice::CustomAnalysisInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::CustomAnalysisInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::CustomAnalysisResult*
Arena::CreateMaybeMessage< ::vlsir::spice::CustomAnalysisResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::CustomAnalysisResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Sweep*
Arena::CreateMaybeMessage< ::vlsir::spice::Sweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Sweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::LinearSweep*
Arena::CreateMaybeMessage< ::vlsir::spice::LinearSweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::LinearSweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::LogSweep*
Arena::CreateMaybeMessage< ::vlsir::spice::LogSweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::LogSweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::PointSweep*
Arena::CreateMaybeMessage< ::vlsir::spice::PointSweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::PointSweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Control*
Arena::CreateMaybeMessage< ::vlsir::spice::Control >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Control >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Save*
Arena::CreateMaybeMessage< ::vlsir::spice::Save >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Save >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Include*
Arena::CreateMaybeMessage< ::vlsir::spice::Include >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Include >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::LibInclude*
Arena::CreateMaybeMessage< ::vlsir::spice::LibInclude >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::LibInclude >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Meas*
Arena::CreateMaybeMessage< ::vlsir::spice::Meas >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Meas >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Signal*
Arena::CreateMaybeMessage< ::vlsir::spice::Signal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Signal >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
