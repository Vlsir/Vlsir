// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spice.proto

#include "spice.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace vlsir {
namespace spice {
constexpr SimInput::SimInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : opts_()
  , an_()
  , ctrls_()
  , top_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , pkg_(nullptr){}
struct SimInputDefaultTypeInternal {
  constexpr SimInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimInputDefaultTypeInternal() {}
  union {
    SimInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimInputDefaultTypeInternal _SimInput_default_instance_;
constexpr SimResult::SimResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : an_(){}
struct SimResultDefaultTypeInternal {
  constexpr SimResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimResultDefaultTypeInternal() {}
  union {
    SimResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimResultDefaultTypeInternal _SimResult_default_instance_;
constexpr SimOptions::SimOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : temp_(0)
  , tnom_(0)
  , gmin_(0)
  , iabstol_(0)
  , reltol_(0){}
struct SimOptionsDefaultTypeInternal {
  constexpr SimOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimOptionsDefaultTypeInternal() {}
  union {
    SimOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimOptionsDefaultTypeInternal _SimOptions_default_instance_;
constexpr Analysis::Analysis(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct AnalysisDefaultTypeInternal {
  constexpr AnalysisDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnalysisDefaultTypeInternal() {}
  union {
    Analysis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnalysisDefaultTypeInternal _Analysis_default_instance_;
constexpr AnalysisResult::AnalysisResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct AnalysisResultDefaultTypeInternal {
  constexpr AnalysisResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnalysisResultDefaultTypeInternal() {}
  union {
    AnalysisResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnalysisResultDefaultTypeInternal _AnalysisResult_default_instance_;
constexpr OpInput::OpInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct OpInputDefaultTypeInternal {
  constexpr OpInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OpInputDefaultTypeInternal() {}
  union {
    OpInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OpInputDefaultTypeInternal _OpInput_default_instance_;
constexpr OpResult::OpResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signals_()
  , data_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct OpResultDefaultTypeInternal {
  constexpr OpResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OpResultDefaultTypeInternal() {}
  union {
    OpResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OpResultDefaultTypeInternal _OpResult_default_instance_;
constexpr DcInput::DcInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , indep_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sweep_(nullptr){}
struct DcInputDefaultTypeInternal {
  constexpr DcInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DcInputDefaultTypeInternal() {}
  union {
    DcInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DcInputDefaultTypeInternal _DcInput_default_instance_;
constexpr DcResult_MeasurementsEntry_DoNotUse::DcResult_MeasurementsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  constexpr DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    DcResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _DcResult_MeasurementsEntry_DoNotUse_default_instance_;
constexpr DcResult::DcResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signals_()
  , data_()
  , measurements_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , indep_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DcResultDefaultTypeInternal {
  constexpr DcResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DcResultDefaultTypeInternal() {}
  union {
    DcResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DcResultDefaultTypeInternal _DcResult_default_instance_;
constexpr TranInput_IcEntry_DoNotUse::TranInput_IcEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TranInput_IcEntry_DoNotUseDefaultTypeInternal {
  constexpr TranInput_IcEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TranInput_IcEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TranInput_IcEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TranInput_IcEntry_DoNotUseDefaultTypeInternal _TranInput_IcEntry_DoNotUse_default_instance_;
constexpr TranInput::TranInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ic_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , tstop_(0)
  , tstep_(0){}
struct TranInputDefaultTypeInternal {
  constexpr TranInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TranInputDefaultTypeInternal() {}
  union {
    TranInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TranInputDefaultTypeInternal _TranInput_default_instance_;
constexpr TranResult_MeasurementsEntry_DoNotUse::TranResult_MeasurementsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  constexpr TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TranResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TranResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _TranResult_MeasurementsEntry_DoNotUse_default_instance_;
constexpr TranResult::TranResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signals_()
  , data_()
  , measurements_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct TranResultDefaultTypeInternal {
  constexpr TranResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TranResultDefaultTypeInternal() {}
  union {
    TranResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TranResultDefaultTypeInternal _TranResult_default_instance_;
constexpr ComplexNum::ComplexNum(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : re_(0)
  , im_(0){}
struct ComplexNumDefaultTypeInternal {
  constexpr ComplexNumDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ComplexNumDefaultTypeInternal() {}
  union {
    ComplexNum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ComplexNumDefaultTypeInternal _ComplexNum_default_instance_;
constexpr AcInput::AcInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fstart_(0)
  , fstop_(0)
  , npts_(uint64_t{0u}){}
struct AcInputDefaultTypeInternal {
  constexpr AcInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AcInputDefaultTypeInternal() {}
  union {
    AcInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AcInputDefaultTypeInternal _AcInput_default_instance_;
constexpr AcResult_MeasurementsEntry_DoNotUse::AcResult_MeasurementsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal {
  constexpr AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AcResult_MeasurementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AcResult_MeasurementsEntry_DoNotUseDefaultTypeInternal _AcResult_MeasurementsEntry_DoNotUse_default_instance_;
constexpr AcResult::AcResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : freq_()
  , signals_()
  , data_()
  , measurements_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AcResultDefaultTypeInternal {
  constexpr AcResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AcResultDefaultTypeInternal() {}
  union {
    AcResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AcResultDefaultTypeInternal _AcResult_default_instance_;
constexpr SweepInput::SweepInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : an_()
  , ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , variable_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sweep_(nullptr){}
struct SweepInputDefaultTypeInternal {
  constexpr SweepInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SweepInputDefaultTypeInternal() {}
  union {
    SweepInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SweepInputDefaultTypeInternal _SweepInput_default_instance_;
constexpr SweepResult::SweepResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : an_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , variable_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sweep_(nullptr){}
struct SweepResultDefaultTypeInternal {
  constexpr SweepResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SweepResultDefaultTypeInternal() {}
  union {
    SweepResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SweepResultDefaultTypeInternal _SweepResult_default_instance_;
constexpr MonteInput::MonteInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : an_()
  , ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , npts_(int64_t{0})
  , seed_(int64_t{0}){}
struct MonteInputDefaultTypeInternal {
  constexpr MonteInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MonteInputDefaultTypeInternal() {}
  union {
    MonteInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MonteInputDefaultTypeInternal _MonteInput_default_instance_;
constexpr MonteResult::MonteResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : an_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , variable_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sweep_(nullptr){}
struct MonteResultDefaultTypeInternal {
  constexpr MonteResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MonteResultDefaultTypeInternal() {}
  union {
    MonteResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MonteResultDefaultTypeInternal _MonteResult_default_instance_;
constexpr CustomAnalysisInput::CustomAnalysisInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ctrls_()
  , analysis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cmd_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CustomAnalysisInputDefaultTypeInternal {
  constexpr CustomAnalysisInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CustomAnalysisInputDefaultTypeInternal() {}
  union {
    CustomAnalysisInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CustomAnalysisInputDefaultTypeInternal _CustomAnalysisInput_default_instance_;
constexpr CustomAnalysisResult::CustomAnalysisResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CustomAnalysisResultDefaultTypeInternal {
  constexpr CustomAnalysisResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CustomAnalysisResultDefaultTypeInternal() {}
  union {
    CustomAnalysisResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CustomAnalysisResultDefaultTypeInternal _CustomAnalysisResult_default_instance_;
constexpr Sweep::Sweep(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SweepDefaultTypeInternal {
  constexpr SweepDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SweepDefaultTypeInternal() {}
  union {
    Sweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SweepDefaultTypeInternal _Sweep_default_instance_;
constexpr LinearSweep::LinearSweep(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : start_(0)
  , stop_(0)
  , step_(0){}
struct LinearSweepDefaultTypeInternal {
  constexpr LinearSweepDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LinearSweepDefaultTypeInternal() {}
  union {
    LinearSweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LinearSweepDefaultTypeInternal _LinearSweep_default_instance_;
constexpr LogSweep::LogSweep(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : start_(0)
  , stop_(0)
  , npts_(0){}
struct LogSweepDefaultTypeInternal {
  constexpr LogSweepDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogSweepDefaultTypeInternal() {}
  union {
    LogSweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogSweepDefaultTypeInternal _LogSweep_default_instance_;
constexpr PointSweep::PointSweep(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : points_()
  , stop_(0)
  , npts_(0){}
struct PointSweepDefaultTypeInternal {
  constexpr PointSweepDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PointSweepDefaultTypeInternal() {}
  union {
    PointSweep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PointSweepDefaultTypeInternal _PointSweep_default_instance_;
constexpr Control::Control(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ControlDefaultTypeInternal {
  constexpr ControlDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ControlDefaultTypeInternal() {}
  union {
    Control _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ControlDefaultTypeInternal _Control_default_instance_;
constexpr Save::Save(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SaveDefaultTypeInternal {
  constexpr SaveDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SaveDefaultTypeInternal() {}
  union {
    Save _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SaveDefaultTypeInternal _Save_default_instance_;
constexpr Include::Include(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct IncludeDefaultTypeInternal {
  constexpr IncludeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IncludeDefaultTypeInternal() {}
  union {
    Include _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IncludeDefaultTypeInternal _Include_default_instance_;
constexpr LibInclude::LibInclude(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , section_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct LibIncludeDefaultTypeInternal {
  constexpr LibIncludeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LibIncludeDefaultTypeInternal() {}
  union {
    LibInclude _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LibIncludeDefaultTypeInternal _LibInclude_default_instance_;
constexpr Meas::Meas(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : analysis_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , expr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct MeasDefaultTypeInternal {
  constexpr MeasDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MeasDefaultTypeInternal() {}
  union {
    Meas _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MeasDefaultTypeInternal _Meas_default_instance_;
constexpr Signal::Signal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , quantity_(0)
{}
struct SignalDefaultTypeInternal {
  constexpr SignalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignalDefaultTypeInternal() {}
  union {
    Signal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignalDefaultTypeInternal _Signal_default_instance_;
}  // namespace spice
}  // namespace vlsir
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_spice_2eproto[34];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_spice_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_spice_2eproto = nullptr;

const uint32_t TableStruct_spice_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, pkg_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, top_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, opts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, an_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimInput, ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimResult, an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, temp_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, tnom_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, gmin_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, iabstol_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SimOptions, reltol_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Analysis, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Analysis, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Analysis, an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AnalysisResult, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AnalysisResult, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AnalysisResult, an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpInput, ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::OpResult, data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, indep_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcInput, ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, indep_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::DcResult, measurements_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput_IcEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, tstop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, tstep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, ic_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranInput, ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::TranResult, measurements_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::ComplexNum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::ComplexNum, re_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::ComplexNum, im_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, fstart_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, fstop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, npts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcInput, ctrls_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, freq_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, signals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, data_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::AcResult, measurements_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, variable_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, an_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepInput, ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, variable_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::SweepResult, an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, npts_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, seed_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, an_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteInput, ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, variable_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, sweep_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::MonteResult, an_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, analysis_name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, cmd_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisInput, ctrls_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::CustomAnalysisResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Sweep, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Sweep, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Sweep, tp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, start_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, stop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LinearSweep, step_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, start_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, stop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LogSweep, npts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, points_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, stop_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::PointSweep, npts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Control, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Control, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Control, ctrl_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Save, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Save, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Save, save_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Include, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Include, path_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LibInclude, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LibInclude, path_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::LibInclude, section_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, analysis_type_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Meas, expr_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Signal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Signal, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::spice::Signal, quantity_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vlsir::spice::SimInput)},
  { 11, -1, -1, sizeof(::vlsir::spice::SimResult)},
  { 18, -1, -1, sizeof(::vlsir::spice::SimOptions)},
  { 29, -1, -1, sizeof(::vlsir::spice::Analysis)},
  { 43, -1, -1, sizeof(::vlsir::spice::AnalysisResult)},
  { 57, -1, -1, sizeof(::vlsir::spice::OpInput)},
  { 65, -1, -1, sizeof(::vlsir::spice::OpResult)},
  { 74, -1, -1, sizeof(::vlsir::spice::DcInput)},
  { 84, 92, -1, sizeof(::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse)},
  { 94, -1, -1, sizeof(::vlsir::spice::DcResult)},
  { 105, 113, -1, sizeof(::vlsir::spice::TranInput_IcEntry_DoNotUse)},
  { 115, -1, -1, sizeof(::vlsir::spice::TranInput)},
  { 126, 134, -1, sizeof(::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse)},
  { 136, -1, -1, sizeof(::vlsir::spice::TranResult)},
  { 146, -1, -1, sizeof(::vlsir::spice::ComplexNum)},
  { 154, -1, -1, sizeof(::vlsir::spice::AcInput)},
  { 165, 173, -1, sizeof(::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse)},
  { 175, -1, -1, sizeof(::vlsir::spice::AcResult)},
  { 186, -1, -1, sizeof(::vlsir::spice::SweepInput)},
  { 197, -1, -1, sizeof(::vlsir::spice::SweepResult)},
  { 207, -1, -1, sizeof(::vlsir::spice::MonteInput)},
  { 218, -1, -1, sizeof(::vlsir::spice::MonteResult)},
  { 228, -1, -1, sizeof(::vlsir::spice::CustomAnalysisInput)},
  { 237, -1, -1, sizeof(::vlsir::spice::CustomAnalysisResult)},
  { 243, -1, -1, sizeof(::vlsir::spice::Sweep)},
  { 253, -1, -1, sizeof(::vlsir::spice::LinearSweep)},
  { 262, -1, -1, sizeof(::vlsir::spice::LogSweep)},
  { 271, -1, -1, sizeof(::vlsir::spice::PointSweep)},
  { 280, -1, -1, sizeof(::vlsir::spice::Control)},
  { 293, -1, -1, sizeof(::vlsir::spice::Save)},
  { 302, -1, -1, sizeof(::vlsir::spice::Include)},
  { 309, -1, -1, sizeof(::vlsir::spice::LibInclude)},
  { 317, -1, -1, sizeof(::vlsir::spice::Meas)},
  { 326, -1, -1, sizeof(::vlsir::spice::Signal)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_SimInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_SimResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_SimOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Analysis_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_AnalysisResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_OpInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_OpResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_DcInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_DcResult_MeasurementsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_DcResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_TranInput_IcEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_TranInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_TranResult_MeasurementsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_TranResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_ComplexNum_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_AcInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_AcResult_MeasurementsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_AcResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_SweepInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_SweepResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_MonteInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_MonteResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_CustomAnalysisInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_CustomAnalysisResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Sweep_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_LinearSweep_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_LogSweep_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_PointSweep_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Control_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Save_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Include_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_LibInclude_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Meas_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::spice::_Signal_default_instance_),
};

const char descriptor_table_protodef_spice_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013spice.proto\022\013vlsir.spice\032\013utils.proto\032"
  "\rcircuit.proto\"\253\001\n\010SimInput\022#\n\003pkg\030\001 \001(\013"
  "2\026.vlsir.circuit.Package\022\013\n\003top\030\002 \001(\t\022%\n"
  "\004opts\030\n \003(\0132\027.vlsir.spice.SimOptions\022!\n\002"
  "an\030\013 \003(\0132\025.vlsir.spice.Analysis\022#\n\005ctrls"
  "\030\014 \003(\0132\024.vlsir.spice.Control\"4\n\tSimResul"
  "t\022\'\n\002an\030\001 \003(\0132\033.vlsir.spice.AnalysisResu"
  "lt\"W\n\nSimOptions\022\014\n\004temp\030\001 \001(\001\022\014\n\004tnom\030\002"
  " \001(\001\022\014\n\004gmin\030\003 \001(\001\022\017\n\007iabstol\030\004 \001(\001\022\016\n\006r"
  "eltol\030\005 \001(\001\"\254\002\n\010Analysis\022\"\n\002op\030\001 \001(\0132\024.v"
  "lsir.spice.OpInputH\000\022\"\n\002dc\030\002 \001(\0132\024.vlsir"
  ".spice.DcInputH\000\022&\n\004tran\030\003 \001(\0132\026.vlsir.s"
  "pice.TranInputH\000\022\"\n\002ac\030\004 \001(\0132\024.vlsir.spi"
  "ce.AcInputH\000\022(\n\005sweep\030\n \001(\0132\027.vlsir.spic"
  "e.SweepInputH\000\022(\n\005monte\030\013 \001(\0132\027.vlsir.sp"
  "ice.MonteInputH\000\0222\n\006custom\030\024 \001(\0132 .vlsir"
  ".spice.CustomAnalysisInputH\000B\004\n\002an\"\271\002\n\016A"
  "nalysisResult\022#\n\002op\030\001 \001(\0132\025.vlsir.spice."
  "OpResultH\000\022#\n\002dc\030\002 \001(\0132\025.vlsir.spice.DcR"
  "esultH\000\022\'\n\004tran\030\003 \001(\0132\027.vlsir.spice.Tran"
  "ResultH\000\022#\n\002ac\030\004 \001(\0132\025.vlsir.spice.AcRes"
  "ultH\000\022)\n\005sweep\030\n \001(\0132\030.vlsir.spice.Sweep"
  "ResultH\000\022)\n\005monte\030\013 \001(\0132\030.vlsir.spice.Mo"
  "nteResultH\000\0223\n\006custom\030\024 \001(\0132!.vlsir.spic"
  "e.CustomAnalysisResultH\000B\004\n\002an\"E\n\007OpInpu"
  "t\022\025\n\ranalysis_name\030\001 \001(\t\022#\n\005ctrls\030\005 \003(\0132"
  "\024.vlsir.spice.Control\"L\n\010OpResult\022\025\n\rana"
  "lysis_name\030\001 \001(\t\022\017\n\007signals\030\003 \003(\t\022\014\n\004dat"
  "a\030\005 \003(\001J\004\010\002\020\003J\004\010\004\020\005\"|\n\007DcInput\022\025\n\ranalys"
  "is_name\030\001 \001(\t\022\022\n\nindep_name\030\002 \001(\t\022!\n\005swe"
  "ep\030\003 \001(\0132\022.vlsir.spice.Sweep\022#\n\005ctrls\030\005 "
  "\003(\0132\024.vlsir.spice.Control\"\316\001\n\010DcResult\022\025"
  "\n\ranalysis_name\030\001 \001(\t\022\022\n\nindep_name\030\002 \001("
  "\t\022\017\n\007signals\030\003 \003(\t\022\014\n\004data\030\005 \003(\001\022=\n\014meas"
  "urements\030\n \003(\0132\'.vlsir.spice.DcResult.Me"
  "asurementsEntry\0323\n\021MeasurementsEntry\022\013\n\003"
  "key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001J\004\010\004\020\005\"\274\001\n\tT"
  "ranInput\022\025\n\ranalysis_name\030\001 \001(\t\022\r\n\005tstop"
  "\030\002 \001(\001\022\r\n\005tstep\030\003 \001(\001\022*\n\002ic\030\004 \003(\0132\036.vlsi"
  "r.spice.TranInput.IcEntry\022#\n\005ctrls\030\005 \003(\013"
  "2\024.vlsir.spice.Control\032)\n\007IcEntry\022\013\n\003key"
  "\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001\"\304\001\n\nTranResult"
  "\022\025\n\ranalysis_name\030\001 \001(\t\022\017\n\007signals\030\003 \003(\t"
  "\022\014\n\004data\030\005 \003(\001\022\?\n\014measurements\030\n \003(\0132).v"
  "lsir.spice.TranResult.MeasurementsEntry\032"
  "3\n\021MeasurementsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005val"
  "ue\030\002 \001(\001:\0028\001J\004\010\002\020\003J\004\010\004\020\005\"$\n\nComplexNum\022\n"
  "\n\002re\030\001 \001(\001\022\n\n\002im\030\002 \001(\001\"r\n\007AcInput\022\025\n\rana"
  "lysis_name\030\001 \001(\t\022\016\n\006fstart\030\002 \001(\001\022\r\n\005fsto"
  "p\030\003 \001(\001\022\014\n\004npts\030\004 \001(\004\022#\n\005ctrls\030\005 \003(\0132\024.v"
  "lsir.spice.Control\"\341\001\n\010AcResult\022\025\n\ranaly"
  "sis_name\030\001 \001(\t\022\014\n\004freq\030\002 \003(\001\022\017\n\007signals\030"
  "\003 \003(\t\022%\n\004data\030\005 \003(\0132\027.vlsir.spice.Comple"
  "xNum\022=\n\014measurements\030\n \003(\0132\'.vlsir.spice"
  ".AcResult.MeasurementsEntry\0323\n\021Measureme"
  "ntsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001"
  "J\004\010\004\020\005\"\240\001\n\nSweepInput\022\025\n\ranalysis_name\030\001"
  " \001(\t\022\020\n\010variable\030\002 \001(\t\022!\n\005sweep\030\003 \001(\0132\022."
  "vlsir.spice.Sweep\022!\n\002an\030\004 \003(\0132\025.vlsir.sp"
  "ice.Analysis\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spic"
  "e.Control\"\202\001\n\013SweepResult\022\025\n\ranalysis_na"
  "me\030\001 \001(\t\022\020\n\010variable\030\002 \001(\t\022!\n\005sweep\030\003 \001("
  "\0132\022.vlsir.spice.Sweep\022\'\n\002an\030\004 \003(\0132\033.vlsi"
  "r.spice.AnalysisResult\"\207\001\n\nMonteInput\022\025\n"
  "\ranalysis_name\030\001 \001(\t\022\014\n\004npts\030\002 \001(\003\022\014\n\004se"
  "ed\030\003 \001(\003\022!\n\002an\030\004 \003(\0132\025.vlsir.spice.Analy"
  "sis\022#\n\005ctrls\030\005 \003(\0132\024.vlsir.spice.Control"
  "\"\202\001\n\013MonteResult\022\025\n\ranalysis_name\030\001 \001(\t\022"
  "\020\n\010variable\030\002 \001(\t\022!\n\005sweep\030\003 \001(\0132\022.vlsir"
  ".spice.Sweep\022\'\n\002an\030\004 \003(\0132\033.vlsir.spice.A"
  "nalysisResult\"^\n\023CustomAnalysisInput\022\025\n\r"
  "analysis_name\030\001 \001(\t\022\013\n\003cmd\030\002 \001(\t\022#\n\005ctrl"
  "s\030\005 \003(\0132\024.vlsir.spice.Control\"\026\n\024CustomA"
  "nalysisResult\"\212\001\n\005Sweep\022*\n\006linear\030\001 \001(\0132"
  "\030.vlsir.spice.LinearSweepH\000\022$\n\003log\030\002 \001(\013"
  "2\025.vlsir.spice.LogSweepH\000\022)\n\006points\030\003 \001("
  "\0132\027.vlsir.spice.PointSweepH\000B\004\n\002tp\"8\n\013Li"
  "nearSweep\022\r\n\005start\030\001 \001(\001\022\014\n\004stop\030\002 \001(\001\022\014"
  "\n\004step\030\003 \001(\001\"5\n\010LogSweep\022\r\n\005start\030\001 \001(\001\022"
  "\014\n\004stop\030\002 \001(\001\022\014\n\004npts\030\003 \001(\001\"8\n\nPointSwee"
  "p\022\016\n\006points\030\001 \003(\001\022\014\n\004stop\030\002 \001(\001\022\014\n\004npts\030"
  "\003 \001(\001\"\340\001\n\007Control\022\'\n\007include\030\001 \001(\0132\024.vls"
  "ir.spice.IncludeH\000\022&\n\003lib\030\002 \001(\0132\027.vlsir."
  "spice.LibIncludeH\000\022!\n\004save\030\005 \001(\0132\021.vlsir"
  ".spice.SaveH\000\022!\n\004meas\030\006 \001(\0132\021.vlsir.spic"
  "e.MeasH\000\022#\n\005param\030\007 \001(\0132\022.vlsir.utils.Pa"
  "ramH\000\022\021\n\007literal\030\n \001(\tH\000B\006\n\004ctrl\"k\n\004Save"
  "\022*\n\004mode\030\001 \001(\0162\032.vlsir.spice.Save.SaveMo"
  "deH\000\022\020\n\006signal\030\002 \001(\tH\000\"\035\n\010SaveMode\022\010\n\004NO"
  "NE\020\000\022\007\n\003ALL\020\001B\006\n\004save\"\027\n\007Include\022\014\n\004path"
  "\030\001 \001(\t\"+\n\nLibInclude\022\014\n\004path\030\001 \001(\t\022\017\n\007se"
  "ction\030\002 \001(\t\"9\n\004Meas\022\025\n\ranalysis_type\030\001 \001"
  "(\t\022\014\n\004name\030\002 \001(\t\022\014\n\004expr\030\003 \001(\t\"v\n\006Signal"
  "\022\014\n\004name\030\001 \001(\t\022.\n\010quantity\030\002 \001(\0162\034.vlsir"
  ".spice.Signal.Quantity\".\n\010Quantity\022\013\n\007VO"
  "LTAGE\020\000\022\013\n\007CURRENT\020\001\022\010\n\004NONE\020\0032=\n\005Spice\022"
  "4\n\003Sim\022\025.vlsir.spice.SimInput\032\026.vlsir.sp"
  "ice.SimResultb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_spice_2eproto_deps[2] = {
  &::descriptor_table_circuit_2eproto,
  &::descriptor_table_utils_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_spice_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spice_2eproto = {
  false, false, 3901, descriptor_table_protodef_spice_2eproto, "spice.proto", 
  &descriptor_table_spice_2eproto_once, descriptor_table_spice_2eproto_deps, 2, 34,
  schemas, file_default_instances, TableStruct_spice_2eproto::offsets,
  file_level_metadata_spice_2eproto, file_level_enum_descriptors_spice_2eproto, file_level_service_descriptors_spice_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_spice_2eproto_getter() {
  return &descriptor_table_spice_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_spice_2eproto(&descriptor_table_spice_2eproto);
namespace vlsir {
namespace spice {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Save_SaveMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spice_2eproto);
  return file_level_enum_descriptors_spice_2eproto[0];
}
bool Save_SaveMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Save_SaveMode Save::NONE;
constexpr Save_SaveMode Save::ALL;
constexpr Save_SaveMode Save::SaveMode_MIN;
constexpr Save_SaveMode Save::SaveMode_MAX;
constexpr int Save::SaveMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Signal_Quantity_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spice_2eproto);
  return file_level_enum_descriptors_spice_2eproto[1];
}
bool Signal_Quantity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Signal_Quantity Signal::VOLTAGE;
constexpr Signal_Quantity Signal::CURRENT;
constexpr Signal_Quantity Signal::NONE;
constexpr Signal_Quantity Signal::Quantity_MIN;
constexpr Signal_Quantity Signal::Quantity_MAX;
constexpr int Signal::Quantity_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SimInput::_Internal {
 public:
  static const ::vlsir::circuit::Package& pkg(const SimInput* msg);
};

const ::vlsir::circuit::Package&
SimInput::_Internal::pkg(const SimInput* msg) {
  return *msg->pkg_;
}
void SimInput::clear_pkg() {
  if (GetArenaForAllocation() == nullptr && pkg_ != nullptr) {
    delete pkg_;
  }
  pkg_ = nullptr;
}
SimInput::SimInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  opts_(arena),
  an_(arena),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SimInput)
}
SimInput::SimInput(const SimInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      opts_(from.opts_),
      an_(from.an_),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  top_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    top_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_top().empty()) {
    top_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_top(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_pkg()) {
    pkg_ = new ::vlsir::circuit::Package(*from.pkg_);
  } else {
    pkg_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SimInput)
}

inline void SimInput::SharedCtor() {
top_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  top_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
pkg_ = nullptr;
}

SimInput::~SimInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SimInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  top_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pkg_;
}

void SimInput::ArenaDtor(void* object) {
  SimInput* _this = reinterpret_cast< SimInput* >(object);
  (void)_this;
}
void SimInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SimInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  opts_.Clear();
  an_.Clear();
  ctrls_.Clear();
  top_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && pkg_ != nullptr) {
    delete pkg_;
  }
  pkg_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.circuit.Package pkg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pkg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_top();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.SimInput.top"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.SimOptions opts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_opts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Analysis an = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SimInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.circuit.Package pkg = 1;
  if (this->_internal_has_pkg()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pkg(this), target, stream);
  }

  // string top = 2;
  if (!this->_internal_top().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_top().data(), static_cast<int>(this->_internal_top().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SimInput.top");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_top(), target);
  }

  // repeated .vlsir.spice.SimOptions opts = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_opts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_opts(i), target, stream);
  }

  // repeated .vlsir.spice.Analysis an = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_an_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_an(i), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SimInput)
  return target;
}

size_t SimInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SimInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.SimOptions opts = 10;
  total_size += 1UL * this->_internal_opts_size();
  for (const auto& msg : this->opts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Analysis an = 11;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Control ctrls = 12;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string top = 2;
  if (!this->_internal_top().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_top());
  }

  // .vlsir.circuit.Package pkg = 1;
  if (this->_internal_has_pkg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pkg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimInput::GetClassData() const { return &_class_data_; }

void SimInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimInput *>(to)->MergeFrom(
      static_cast<const SimInput &>(from));
}


void SimInput::MergeFrom(const SimInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SimInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  opts_.MergeFrom(from.opts_);
  an_.MergeFrom(from.an_);
  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_top().empty()) {
    _internal_set_top(from._internal_top());
  }
  if (from._internal_has_pkg()) {
    _internal_mutable_pkg()->::vlsir::circuit::Package::MergeFrom(from._internal_pkg());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimInput::CopyFrom(const SimInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SimInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimInput::IsInitialized() const {
  return true;
}

void SimInput::InternalSwap(SimInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  opts_.InternalSwap(&other->opts_);
  an_.InternalSwap(&other->an_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &top_, lhs_arena,
      &other->top_, rhs_arena
  );
  swap(pkg_, other->pkg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[0]);
}

// ===================================================================

class SimResult::_Internal {
 public:
};

SimResult::SimResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  an_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SimResult)
}
SimResult::SimResult(const SimResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      an_(from.an_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SimResult)
}

inline void SimResult::SharedCtor() {
}

SimResult::~SimResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SimResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SimResult::ArenaDtor(void* object) {
  SimResult* _this = reinterpret_cast< SimResult* >(object);
  (void)_this;
}
void SimResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SimResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  an_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vlsir.spice.AnalysisResult an = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SimResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_an_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_an(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SimResult)
  return target;
}

size_t SimResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SimResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 1;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimResult::GetClassData() const { return &_class_data_; }

void SimResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimResult *>(to)->MergeFrom(
      static_cast<const SimResult &>(from));
}


void SimResult::MergeFrom(const SimResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SimResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  an_.MergeFrom(from.an_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimResult::CopyFrom(const SimResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SimResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimResult::IsInitialized() const {
  return true;
}

void SimResult::InternalSwap(SimResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  an_.InternalSwap(&other->an_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[1]);
}

// ===================================================================

class SimOptions::_Internal {
 public:
};

SimOptions::SimOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SimOptions)
}
SimOptions::SimOptions(const SimOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&temp_, &from.temp_,
    static_cast<size_t>(reinterpret_cast<char*>(&reltol_) -
    reinterpret_cast<char*>(&temp_)) + sizeof(reltol_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SimOptions)
}

inline void SimOptions::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&temp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reltol_) -
    reinterpret_cast<char*>(&temp_)) + sizeof(reltol_));
}

SimOptions::~SimOptions() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SimOptions)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SimOptions::ArenaDtor(void* object) {
  SimOptions* _this = reinterpret_cast< SimOptions* >(object);
  (void)_this;
}
void SimOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SimOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&temp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reltol_) -
      reinterpret_cast<char*>(&temp_)) + sizeof(reltol_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double temp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          temp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double tnom = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          tnom_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double gmin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          gmin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double iabstol = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          iabstol_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reltol = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          reltol_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SimOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double temp = 1;
  if (!(this->_internal_temp() <= 0 && this->_internal_temp() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_temp(), target);
  }

  // double tnom = 2;
  if (!(this->_internal_tnom() <= 0 && this->_internal_tnom() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_tnom(), target);
  }

  // double gmin = 3;
  if (!(this->_internal_gmin() <= 0 && this->_internal_gmin() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_gmin(), target);
  }

  // double iabstol = 4;
  if (!(this->_internal_iabstol() <= 0 && this->_internal_iabstol() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_iabstol(), target);
  }

  // double reltol = 5;
  if (!(this->_internal_reltol() <= 0 && this->_internal_reltol() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_reltol(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SimOptions)
  return target;
}

size_t SimOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SimOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double temp = 1;
  if (!(this->_internal_temp() <= 0 && this->_internal_temp() >= 0)) {
    total_size += 1 + 8;
  }

  // double tnom = 2;
  if (!(this->_internal_tnom() <= 0 && this->_internal_tnom() >= 0)) {
    total_size += 1 + 8;
  }

  // double gmin = 3;
  if (!(this->_internal_gmin() <= 0 && this->_internal_gmin() >= 0)) {
    total_size += 1 + 8;
  }

  // double iabstol = 4;
  if (!(this->_internal_iabstol() <= 0 && this->_internal_iabstol() >= 0)) {
    total_size += 1 + 8;
  }

  // double reltol = 5;
  if (!(this->_internal_reltol() <= 0 && this->_internal_reltol() >= 0)) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimOptions::GetClassData() const { return &_class_data_; }

void SimOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimOptions *>(to)->MergeFrom(
      static_cast<const SimOptions &>(from));
}


void SimOptions::MergeFrom(const SimOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SimOptions)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from._internal_temp() <= 0 && from._internal_temp() >= 0)) {
    _internal_set_temp(from._internal_temp());
  }
  if (!(from._internal_tnom() <= 0 && from._internal_tnom() >= 0)) {
    _internal_set_tnom(from._internal_tnom());
  }
  if (!(from._internal_gmin() <= 0 && from._internal_gmin() >= 0)) {
    _internal_set_gmin(from._internal_gmin());
  }
  if (!(from._internal_iabstol() <= 0 && from._internal_iabstol() >= 0)) {
    _internal_set_iabstol(from._internal_iabstol());
  }
  if (!(from._internal_reltol() <= 0 && from._internal_reltol() >= 0)) {
    _internal_set_reltol(from._internal_reltol());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimOptions::CopyFrom(const SimOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SimOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimOptions::IsInitialized() const {
  return true;
}

void SimOptions::InternalSwap(SimOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimOptions, reltol_)
      + sizeof(SimOptions::reltol_)
      - PROTOBUF_FIELD_OFFSET(SimOptions, temp_)>(
          reinterpret_cast<char*>(&temp_),
          reinterpret_cast<char*>(&other->temp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[2]);
}

// ===================================================================

class Analysis::_Internal {
 public:
  static const ::vlsir::spice::OpInput& op(const Analysis* msg);
  static const ::vlsir::spice::DcInput& dc(const Analysis* msg);
  static const ::vlsir::spice::TranInput& tran(const Analysis* msg);
  static const ::vlsir::spice::AcInput& ac(const Analysis* msg);
  static const ::vlsir::spice::SweepInput& sweep(const Analysis* msg);
  static const ::vlsir::spice::MonteInput& monte(const Analysis* msg);
  static const ::vlsir::spice::CustomAnalysisInput& custom(const Analysis* msg);
};

const ::vlsir::spice::OpInput&
Analysis::_Internal::op(const Analysis* msg) {
  return *msg->an_.op_;
}
const ::vlsir::spice::DcInput&
Analysis::_Internal::dc(const Analysis* msg) {
  return *msg->an_.dc_;
}
const ::vlsir::spice::TranInput&
Analysis::_Internal::tran(const Analysis* msg) {
  return *msg->an_.tran_;
}
const ::vlsir::spice::AcInput&
Analysis::_Internal::ac(const Analysis* msg) {
  return *msg->an_.ac_;
}
const ::vlsir::spice::SweepInput&
Analysis::_Internal::sweep(const Analysis* msg) {
  return *msg->an_.sweep_;
}
const ::vlsir::spice::MonteInput&
Analysis::_Internal::monte(const Analysis* msg) {
  return *msg->an_.monte_;
}
const ::vlsir::spice::CustomAnalysisInput&
Analysis::_Internal::custom(const Analysis* msg) {
  return *msg->an_.custom_;
}
void Analysis::set_allocated_op(::vlsir::spice::OpInput* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::OpInput>::GetOwningArena(op);
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    set_has_op();
    an_.op_ = op;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.op)
}
void Analysis::set_allocated_dc(::vlsir::spice::DcInput* dc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (dc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::DcInput>::GetOwningArena(dc);
    if (message_arena != submessage_arena) {
      dc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dc, submessage_arena);
    }
    set_has_dc();
    an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.dc)
}
void Analysis::set_allocated_tran(::vlsir::spice::TranInput* tran) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (tran) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::TranInput>::GetOwningArena(tran);
    if (message_arena != submessage_arena) {
      tran = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tran, submessage_arena);
    }
    set_has_tran();
    an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.tran)
}
void Analysis::set_allocated_ac(::vlsir::spice::AcInput* ac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (ac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::AcInput>::GetOwningArena(ac);
    if (message_arena != submessage_arena) {
      ac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ac, submessage_arena);
    }
    set_has_ac();
    an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.ac)
}
void Analysis::set_allocated_sweep(::vlsir::spice::SweepInput* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::SweepInput>::GetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    set_has_sweep();
    an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.sweep)
}
void Analysis::set_allocated_monte(::vlsir::spice::MonteInput* monte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (monte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::MonteInput>::GetOwningArena(monte);
    if (message_arena != submessage_arena) {
      monte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monte, submessage_arena);
    }
    set_has_monte();
    an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.monte)
}
void Analysis::set_allocated_custom(::vlsir::spice::CustomAnalysisInput* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::CustomAnalysisInput>::GetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Analysis.custom)
}
Analysis::Analysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Analysis)
}
Analysis::Analysis(const Analysis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_an();
  switch (from.an_case()) {
    case kOp: {
      _internal_mutable_op()->::vlsir::spice::OpInput::MergeFrom(from._internal_op());
      break;
    }
    case kDc: {
      _internal_mutable_dc()->::vlsir::spice::DcInput::MergeFrom(from._internal_dc());
      break;
    }
    case kTran: {
      _internal_mutable_tran()->::vlsir::spice::TranInput::MergeFrom(from._internal_tran());
      break;
    }
    case kAc: {
      _internal_mutable_ac()->::vlsir::spice::AcInput::MergeFrom(from._internal_ac());
      break;
    }
    case kSweep: {
      _internal_mutable_sweep()->::vlsir::spice::SweepInput::MergeFrom(from._internal_sweep());
      break;
    }
    case kMonte: {
      _internal_mutable_monte()->::vlsir::spice::MonteInput::MergeFrom(from._internal_monte());
      break;
    }
    case kCustom: {
      _internal_mutable_custom()->::vlsir::spice::CustomAnalysisInput::MergeFrom(from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Analysis)
}

inline void Analysis::SharedCtor() {
clear_has_an();
}

Analysis::~Analysis() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Analysis)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Analysis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_an()) {
    clear_an();
  }
}

void Analysis::ArenaDtor(void* object) {
  Analysis* _this = reinterpret_cast< Analysis* >(object);
  (void)_this;
}
void Analysis::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Analysis::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Analysis::clear_an() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Analysis)
  switch (an_case()) {
    case kOp: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.op_;
      }
      break;
    }
    case kDc: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.dc_;
      }
      break;
    }
    case kTran: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.tran_;
      }
      break;
    }
    case kAc: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.ac_;
      }
      break;
    }
    case kSweep: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.sweep_;
      }
      break;
    }
    case kMonte: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.monte_;
      }
      break;
    }
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.custom_;
      }
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = AN_NOT_SET;
}


void Analysis::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Analysis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_an();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Analysis::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.OpInput op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_op(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.DcInput dc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.TranInput tran = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tran(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.AcInput ac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.SweepInput sweep = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.MonteInput monte = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_monte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.CustomAnalysisInput custom = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Analysis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Analysis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.OpInput op = 1;
  if (_internal_has_op()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::op(this), target, stream);
  }

  // .vlsir.spice.DcInput dc = 2;
  if (_internal_has_dc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dc(this), target, stream);
  }

  // .vlsir.spice.TranInput tran = 3;
  if (_internal_has_tran()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::tran(this), target, stream);
  }

  // .vlsir.spice.AcInput ac = 4;
  if (_internal_has_ac()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ac(this), target, stream);
  }

  // .vlsir.spice.SweepInput sweep = 10;
  if (_internal_has_sweep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::sweep(this), target, stream);
  }

  // .vlsir.spice.MonteInput monte = 11;
  if (_internal_has_monte()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::monte(this), target, stream);
  }

  // .vlsir.spice.CustomAnalysisInput custom = 20;
  if (_internal_has_custom()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::custom(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Analysis)
  return target;
}

size_t Analysis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Analysis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (an_case()) {
    // .vlsir.spice.OpInput op = 1;
    case kOp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.op_);
      break;
    }
    // .vlsir.spice.DcInput dc = 2;
    case kDc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.dc_);
      break;
    }
    // .vlsir.spice.TranInput tran = 3;
    case kTran: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.tran_);
      break;
    }
    // .vlsir.spice.AcInput ac = 4;
    case kAc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.ac_);
      break;
    }
    // .vlsir.spice.SweepInput sweep = 10;
    case kSweep: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.sweep_);
      break;
    }
    // .vlsir.spice.MonteInput monte = 11;
    case kMonte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.monte_);
      break;
    }
    // .vlsir.spice.CustomAnalysisInput custom = 20;
    case kCustom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.custom_);
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Analysis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Analysis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Analysis::GetClassData() const { return &_class_data_; }

void Analysis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Analysis *>(to)->MergeFrom(
      static_cast<const Analysis &>(from));
}


void Analysis::MergeFrom(const Analysis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Analysis)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.an_case()) {
    case kOp: {
      _internal_mutable_op()->::vlsir::spice::OpInput::MergeFrom(from._internal_op());
      break;
    }
    case kDc: {
      _internal_mutable_dc()->::vlsir::spice::DcInput::MergeFrom(from._internal_dc());
      break;
    }
    case kTran: {
      _internal_mutable_tran()->::vlsir::spice::TranInput::MergeFrom(from._internal_tran());
      break;
    }
    case kAc: {
      _internal_mutable_ac()->::vlsir::spice::AcInput::MergeFrom(from._internal_ac());
      break;
    }
    case kSweep: {
      _internal_mutable_sweep()->::vlsir::spice::SweepInput::MergeFrom(from._internal_sweep());
      break;
    }
    case kMonte: {
      _internal_mutable_monte()->::vlsir::spice::MonteInput::MergeFrom(from._internal_monte());
      break;
    }
    case kCustom: {
      _internal_mutable_custom()->::vlsir::spice::CustomAnalysisInput::MergeFrom(from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Analysis::CopyFrom(const Analysis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Analysis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Analysis::IsInitialized() const {
  return true;
}

void Analysis::InternalSwap(Analysis* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(an_, other->an_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Analysis::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[3]);
}

// ===================================================================

class AnalysisResult::_Internal {
 public:
  static const ::vlsir::spice::OpResult& op(const AnalysisResult* msg);
  static const ::vlsir::spice::DcResult& dc(const AnalysisResult* msg);
  static const ::vlsir::spice::TranResult& tran(const AnalysisResult* msg);
  static const ::vlsir::spice::AcResult& ac(const AnalysisResult* msg);
  static const ::vlsir::spice::SweepResult& sweep(const AnalysisResult* msg);
  static const ::vlsir::spice::MonteResult& monte(const AnalysisResult* msg);
  static const ::vlsir::spice::CustomAnalysisResult& custom(const AnalysisResult* msg);
};

const ::vlsir::spice::OpResult&
AnalysisResult::_Internal::op(const AnalysisResult* msg) {
  return *msg->an_.op_;
}
const ::vlsir::spice::DcResult&
AnalysisResult::_Internal::dc(const AnalysisResult* msg) {
  return *msg->an_.dc_;
}
const ::vlsir::spice::TranResult&
AnalysisResult::_Internal::tran(const AnalysisResult* msg) {
  return *msg->an_.tran_;
}
const ::vlsir::spice::AcResult&
AnalysisResult::_Internal::ac(const AnalysisResult* msg) {
  return *msg->an_.ac_;
}
const ::vlsir::spice::SweepResult&
AnalysisResult::_Internal::sweep(const AnalysisResult* msg) {
  return *msg->an_.sweep_;
}
const ::vlsir::spice::MonteResult&
AnalysisResult::_Internal::monte(const AnalysisResult* msg) {
  return *msg->an_.monte_;
}
const ::vlsir::spice::CustomAnalysisResult&
AnalysisResult::_Internal::custom(const AnalysisResult* msg) {
  return *msg->an_.custom_;
}
void AnalysisResult::set_allocated_op(::vlsir::spice::OpResult* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::OpResult>::GetOwningArena(op);
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    set_has_op();
    an_.op_ = op;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.op)
}
void AnalysisResult::set_allocated_dc(::vlsir::spice::DcResult* dc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (dc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::DcResult>::GetOwningArena(dc);
    if (message_arena != submessage_arena) {
      dc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dc, submessage_arena);
    }
    set_has_dc();
    an_.dc_ = dc;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.dc)
}
void AnalysisResult::set_allocated_tran(::vlsir::spice::TranResult* tran) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (tran) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::TranResult>::GetOwningArena(tran);
    if (message_arena != submessage_arena) {
      tran = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tran, submessage_arena);
    }
    set_has_tran();
    an_.tran_ = tran;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.tran)
}
void AnalysisResult::set_allocated_ac(::vlsir::spice::AcResult* ac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (ac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::AcResult>::GetOwningArena(ac);
    if (message_arena != submessage_arena) {
      ac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ac, submessage_arena);
    }
    set_has_ac();
    an_.ac_ = ac;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.ac)
}
void AnalysisResult::set_allocated_sweep(::vlsir::spice::SweepResult* sweep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (sweep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::SweepResult>::GetOwningArena(sweep);
    if (message_arena != submessage_arena) {
      sweep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sweep, submessage_arena);
    }
    set_has_sweep();
    an_.sweep_ = sweep;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.sweep)
}
void AnalysisResult::set_allocated_monte(::vlsir::spice::MonteResult* monte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (monte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::MonteResult>::GetOwningArena(monte);
    if (message_arena != submessage_arena) {
      monte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monte, submessage_arena);
    }
    set_has_monte();
    an_.monte_ = monte;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.monte)
}
void AnalysisResult::set_allocated_custom(::vlsir::spice::CustomAnalysisResult* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_an();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::CustomAnalysisResult>::GetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    an_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.AnalysisResult.custom)
}
AnalysisResult::AnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.AnalysisResult)
}
AnalysisResult::AnalysisResult(const AnalysisResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_an();
  switch (from.an_case()) {
    case kOp: {
      _internal_mutable_op()->::vlsir::spice::OpResult::MergeFrom(from._internal_op());
      break;
    }
    case kDc: {
      _internal_mutable_dc()->::vlsir::spice::DcResult::MergeFrom(from._internal_dc());
      break;
    }
    case kTran: {
      _internal_mutable_tran()->::vlsir::spice::TranResult::MergeFrom(from._internal_tran());
      break;
    }
    case kAc: {
      _internal_mutable_ac()->::vlsir::spice::AcResult::MergeFrom(from._internal_ac());
      break;
    }
    case kSweep: {
      _internal_mutable_sweep()->::vlsir::spice::SweepResult::MergeFrom(from._internal_sweep());
      break;
    }
    case kMonte: {
      _internal_mutable_monte()->::vlsir::spice::MonteResult::MergeFrom(from._internal_monte());
      break;
    }
    case kCustom: {
      _internal_mutable_custom()->::vlsir::spice::CustomAnalysisResult::MergeFrom(from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.AnalysisResult)
}

inline void AnalysisResult::SharedCtor() {
clear_has_an();
}

AnalysisResult::~AnalysisResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.AnalysisResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AnalysisResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_an()) {
    clear_an();
  }
}

void AnalysisResult::ArenaDtor(void* object) {
  AnalysisResult* _this = reinterpret_cast< AnalysisResult* >(object);
  (void)_this;
}
void AnalysisResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnalysisResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnalysisResult::clear_an() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.AnalysisResult)
  switch (an_case()) {
    case kOp: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.op_;
      }
      break;
    }
    case kDc: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.dc_;
      }
      break;
    }
    case kTran: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.tran_;
      }
      break;
    }
    case kAc: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.ac_;
      }
      break;
    }
    case kSweep: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.sweep_;
      }
      break;
    }
    case kMonte: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.monte_;
      }
      break;
    }
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete an_.custom_;
      }
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = AN_NOT_SET;
}


void AnalysisResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.AnalysisResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_an();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnalysisResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.OpResult op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_op(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.DcResult dc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.TranResult tran = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tran(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.AcResult ac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.SweepResult sweep = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.MonteResult monte = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_monte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.CustomAnalysisResult custom = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnalysisResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.AnalysisResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.OpResult op = 1;
  if (_internal_has_op()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::op(this), target, stream);
  }

  // .vlsir.spice.DcResult dc = 2;
  if (_internal_has_dc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dc(this), target, stream);
  }

  // .vlsir.spice.TranResult tran = 3;
  if (_internal_has_tran()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::tran(this), target, stream);
  }

  // .vlsir.spice.AcResult ac = 4;
  if (_internal_has_ac()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ac(this), target, stream);
  }

  // .vlsir.spice.SweepResult sweep = 10;
  if (_internal_has_sweep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::sweep(this), target, stream);
  }

  // .vlsir.spice.MonteResult monte = 11;
  if (_internal_has_monte()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::monte(this), target, stream);
  }

  // .vlsir.spice.CustomAnalysisResult custom = 20;
  if (_internal_has_custom()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::custom(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.AnalysisResult)
  return target;
}

size_t AnalysisResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.AnalysisResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (an_case()) {
    // .vlsir.spice.OpResult op = 1;
    case kOp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.op_);
      break;
    }
    // .vlsir.spice.DcResult dc = 2;
    case kDc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.dc_);
      break;
    }
    // .vlsir.spice.TranResult tran = 3;
    case kTran: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.tran_);
      break;
    }
    // .vlsir.spice.AcResult ac = 4;
    case kAc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.ac_);
      break;
    }
    // .vlsir.spice.SweepResult sweep = 10;
    case kSweep: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.sweep_);
      break;
    }
    // .vlsir.spice.MonteResult monte = 11;
    case kMonte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.monte_);
      break;
    }
    // .vlsir.spice.CustomAnalysisResult custom = 20;
    case kCustom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *an_.custom_);
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnalysisResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AnalysisResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnalysisResult::GetClassData() const { return &_class_data_; }

void AnalysisResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AnalysisResult *>(to)->MergeFrom(
      static_cast<const AnalysisResult &>(from));
}


void AnalysisResult::MergeFrom(const AnalysisResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.AnalysisResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.an_case()) {
    case kOp: {
      _internal_mutable_op()->::vlsir::spice::OpResult::MergeFrom(from._internal_op());
      break;
    }
    case kDc: {
      _internal_mutable_dc()->::vlsir::spice::DcResult::MergeFrom(from._internal_dc());
      break;
    }
    case kTran: {
      _internal_mutable_tran()->::vlsir::spice::TranResult::MergeFrom(from._internal_tran());
      break;
    }
    case kAc: {
      _internal_mutable_ac()->::vlsir::spice::AcResult::MergeFrom(from._internal_ac());
      break;
    }
    case kSweep: {
      _internal_mutable_sweep()->::vlsir::spice::SweepResult::MergeFrom(from._internal_sweep());
      break;
    }
    case kMonte: {
      _internal_mutable_monte()->::vlsir::spice::MonteResult::MergeFrom(from._internal_monte());
      break;
    }
    case kCustom: {
      _internal_mutable_custom()->::vlsir::spice::CustomAnalysisResult::MergeFrom(from._internal_custom());
      break;
    }
    case AN_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnalysisResult::CopyFrom(const AnalysisResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.AnalysisResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalysisResult::IsInitialized() const {
  return true;
}

void AnalysisResult::InternalSwap(AnalysisResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(an_, other->an_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnalysisResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[4]);
}

// ===================================================================

class OpInput::_Internal {
 public:
};

OpInput::OpInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.OpInput)
}
OpInput::OpInput(const OpInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.OpInput)
}

inline void OpInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OpInput::~OpInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.OpInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OpInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void OpInput::ArenaDtor(void* object) {
  OpInput* _this = reinterpret_cast< OpInput* >(object);
  (void)_this;
}
void OpInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OpInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OpInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.OpInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.OpInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.OpInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.OpInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.OpInput)
  return target;
}

size_t OpInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.OpInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OpInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpInput::GetClassData() const { return &_class_data_; }

void OpInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OpInput *>(to)->MergeFrom(
      static_cast<const OpInput &>(from));
}


void OpInput::MergeFrom(const OpInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.OpInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpInput::CopyFrom(const OpInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.OpInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpInput::IsInitialized() const {
  return true;
}

void OpInput::InternalSwap(OpInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata OpInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[5]);
}

// ===================================================================

class OpResult::_Internal {
 public:
};

OpResult::OpResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  signals_(arena),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.OpResult)
}
OpResult::OpResult(const OpResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      signals_(from.signals_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.OpResult)
}

inline void OpResult::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OpResult::~OpResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.OpResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OpResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void OpResult::ArenaDtor(void* object) {
  OpResult* _this = reinterpret_cast< OpResult* >(object);
  (void)_this;
}
void OpResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OpResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OpResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.OpResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signals_.Clear();
  data_.Clear();
  analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.OpResult.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.OpResult.signals"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.OpResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.OpResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.OpResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.OpResult)
  return target;
}

size_t OpResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.OpResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(signals_.size());
  for (int i = 0, n = signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OpResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpResult::GetClassData() const { return &_class_data_; }

void OpResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OpResult *>(to)->MergeFrom(
      static_cast<const OpResult &>(from));
}


void OpResult::MergeFrom(const OpResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.OpResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  signals_.MergeFrom(from.signals_);
  data_.MergeFrom(from.data_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpResult::CopyFrom(const OpResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.OpResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpResult::IsInitialized() const {
  return true;
}

void OpResult::InternalSwap(OpResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  signals_.InternalSwap(&other->signals_);
  data_.InternalSwap(&other->data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata OpResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[6]);
}

// ===================================================================

class DcInput::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const DcInput* msg);
};

const ::vlsir::spice::Sweep&
DcInput::_Internal::sweep(const DcInput* msg) {
  return *msg->sweep_;
}
DcInput::DcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.DcInput)
}
DcInput::DcInput(const DcInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  indep_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_indep_name().empty()) {
    indep_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_indep_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    sweep_ = new ::vlsir::spice::Sweep(*from.sweep_);
  } else {
    sweep_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.DcInput)
}

inline void DcInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
indep_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sweep_ = nullptr;
}

DcInput::~DcInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.DcInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DcInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  indep_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sweep_;
}

void DcInput::ArenaDtor(void* object) {
  DcInput* _this = reinterpret_cast< DcInput* >(object);
  (void)_this;
}
void DcInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DcInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DcInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.DcInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  indep_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DcInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.DcInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string indep_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_indep_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.DcInput.indep_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DcInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.DcInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_indep_name().data(), static_cast<int>(this->_internal_indep_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcInput.indep_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_indep_name(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::sweep(this), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.DcInput)
  return target;
}

size_t DcInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.DcInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_indep_name());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DcInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DcInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DcInput::GetClassData() const { return &_class_data_; }

void DcInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DcInput *>(to)->MergeFrom(
      static_cast<const DcInput &>(from));
}


void DcInput::MergeFrom(const DcInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.DcInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_indep_name().empty()) {
    _internal_set_indep_name(from._internal_indep_name());
  }
  if (from._internal_has_sweep()) {
    _internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(from._internal_sweep());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DcInput::CopyFrom(const DcInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.DcInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DcInput::IsInitialized() const {
  return true;
}

void DcInput::InternalSwap(DcInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &indep_name_, lhs_arena,
      &other->indep_name_, rhs_arena
  );
  swap(sweep_, other->sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DcInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[7]);
}

// ===================================================================

DcResult_MeasurementsEntry_DoNotUse::DcResult_MeasurementsEntry_DoNotUse() {}
DcResult_MeasurementsEntry_DoNotUse::DcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void DcResult_MeasurementsEntry_DoNotUse::MergeFrom(const DcResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata DcResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[8]);
}

// ===================================================================

class DcResult::_Internal {
 public:
};

DcResult::DcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  signals_(arena),
  data_(arena),
  measurements_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.DcResult)
}
DcResult::DcResult(const DcResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      signals_(from.signals_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  measurements_.MergeFrom(from.measurements_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  indep_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_indep_name().empty()) {
    indep_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_indep_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.DcResult)
}

inline void DcResult::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
indep_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  indep_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DcResult::~DcResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.DcResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DcResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  indep_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DcResult::ArenaDtor(void* object) {
  DcResult* _this = reinterpret_cast< DcResult* >(object);
  (void)_this;
  _this->measurements_. ~MapField();
}
inline void DcResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &DcResult::ArenaDtor);
  }
}
void DcResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DcResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.DcResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signals_.Clear();
  data_.Clear();
  measurements_.Clear();
  analysis_name_.ClearToEmpty();
  indep_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DcResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.DcResult.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string indep_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_indep_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.DcResult.indep_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.DcResult.signals"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DcResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.DcResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_indep_name().data(), static_cast<int>(this->_internal_indep_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcResult.indep_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_indep_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.DcResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  // map<string, double> measurements = 10;
  if (!this->_internal_measurements().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "vlsir.spice.DcResult.MeasurementsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_measurements().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_measurements().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_measurements().begin();
          it != this->_internal_measurements().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = DcResult_MeasurementsEntry_DoNotUse::Funcs::InternalSerialize(10, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_measurements().begin();
          it != this->_internal_measurements().end(); ++it) {
        target = DcResult_MeasurementsEntry_DoNotUse::Funcs::InternalSerialize(10, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.DcResult)
  return target;
}

size_t DcResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.DcResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(signals_.size());
  for (int i = 0, n = signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // map<string, double> measurements = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += DcResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string indep_name = 2;
  if (!this->_internal_indep_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_indep_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DcResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DcResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DcResult::GetClassData() const { return &_class_data_; }

void DcResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DcResult *>(to)->MergeFrom(
      static_cast<const DcResult &>(from));
}


void DcResult::MergeFrom(const DcResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.DcResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  signals_.MergeFrom(from.signals_);
  data_.MergeFrom(from.data_);
  measurements_.MergeFrom(from.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_indep_name().empty()) {
    _internal_set_indep_name(from._internal_indep_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DcResult::CopyFrom(const DcResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.DcResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DcResult::IsInitialized() const {
  return true;
}

void DcResult::InternalSwap(DcResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  signals_.InternalSwap(&other->signals_);
  data_.InternalSwap(&other->data_);
  measurements_.InternalSwap(&other->measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &indep_name_, lhs_arena,
      &other->indep_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DcResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[9]);
}

// ===================================================================

TranInput_IcEntry_DoNotUse::TranInput_IcEntry_DoNotUse() {}
TranInput_IcEntry_DoNotUse::TranInput_IcEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TranInput_IcEntry_DoNotUse::MergeFrom(const TranInput_IcEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata TranInput_IcEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[10]);
}

// ===================================================================

class TranInput::_Internal {
 public:
};

TranInput::TranInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ic_(arena),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.TranInput)
}
TranInput::TranInput(const TranInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ic_.MergeFrom(from.ic_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&tstop_, &from.tstop_,
    static_cast<size_t>(reinterpret_cast<char*>(&tstep_) -
    reinterpret_cast<char*>(&tstop_)) + sizeof(tstep_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.TranInput)
}

inline void TranInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tstop_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tstep_) -
    reinterpret_cast<char*>(&tstop_)) + sizeof(tstep_));
}

TranInput::~TranInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.TranInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TranInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TranInput::ArenaDtor(void* object) {
  TranInput* _this = reinterpret_cast< TranInput* >(object);
  (void)_this;
  _this->ic_. ~MapField();
}
inline void TranInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &TranInput::ArenaDtor);
  }
}
void TranInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TranInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.TranInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ic_.Clear();
  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  ::memset(&tstop_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tstep_) -
      reinterpret_cast<char*>(&tstop_)) + sizeof(tstep_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.TranInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double tstop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          tstop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double tstep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          tstep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> ic = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&ic_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TranInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.TranInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.TranInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // double tstop = 2;
  if (!(this->_internal_tstop() <= 0 && this->_internal_tstop() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_tstop(), target);
  }

  // double tstep = 3;
  if (!(this->_internal_tstep() <= 0 && this->_internal_tstep() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_tstep(), target);
  }

  // map<string, double> ic = 4;
  if (!this->_internal_ic().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "vlsir.spice.TranInput.IcEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_ic().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_ic().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_ic().begin();
          it != this->_internal_ic().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = TranInput_IcEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_ic().begin();
          it != this->_internal_ic().end(); ++it) {
        target = TranInput_IcEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.TranInput)
  return target;
}

size_t TranInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.TranInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> ic = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ic_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_ic().begin();
      it != this->_internal_ic().end(); ++it) {
    total_size += TranInput_IcEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // double tstop = 2;
  if (!(this->_internal_tstop() <= 0 && this->_internal_tstop() >= 0)) {
    total_size += 1 + 8;
  }

  // double tstep = 3;
  if (!(this->_internal_tstep() <= 0 && this->_internal_tstep() >= 0)) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TranInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranInput::GetClassData() const { return &_class_data_; }

void TranInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TranInput *>(to)->MergeFrom(
      static_cast<const TranInput &>(from));
}


void TranInput::MergeFrom(const TranInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.TranInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ic_.MergeFrom(from.ic_);
  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!(from._internal_tstop() <= 0 && from._internal_tstop() >= 0)) {
    _internal_set_tstop(from._internal_tstop());
  }
  if (!(from._internal_tstep() <= 0 && from._internal_tstep() >= 0)) {
    _internal_set_tstep(from._internal_tstep());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranInput::CopyFrom(const TranInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.TranInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranInput::IsInitialized() const {
  return true;
}

void TranInput::InternalSwap(TranInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ic_.InternalSwap(&other->ic_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TranInput, tstep_)
      + sizeof(TranInput::tstep_)
      - PROTOBUF_FIELD_OFFSET(TranInput, tstop_)>(
          reinterpret_cast<char*>(&tstop_),
          reinterpret_cast<char*>(&other->tstop_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TranInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[11]);
}

// ===================================================================

TranResult_MeasurementsEntry_DoNotUse::TranResult_MeasurementsEntry_DoNotUse() {}
TranResult_MeasurementsEntry_DoNotUse::TranResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TranResult_MeasurementsEntry_DoNotUse::MergeFrom(const TranResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata TranResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[12]);
}

// ===================================================================

class TranResult::_Internal {
 public:
};

TranResult::TranResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  signals_(arena),
  data_(arena),
  measurements_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.TranResult)
}
TranResult::TranResult(const TranResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      signals_(from.signals_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  measurements_.MergeFrom(from.measurements_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.TranResult)
}

inline void TranResult::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TranResult::~TranResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.TranResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TranResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TranResult::ArenaDtor(void* object) {
  TranResult* _this = reinterpret_cast< TranResult* >(object);
  (void)_this;
  _this->measurements_. ~MapField();
}
inline void TranResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &TranResult::ArenaDtor);
  }
}
void TranResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TranResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.TranResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signals_.Clear();
  data_.Clear();
  measurements_.Clear();
  analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.TranResult.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.TranResult.signals"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TranResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.TranResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.TranResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.TranResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated double data = 5;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_data(), target);
  }

  // map<string, double> measurements = 10;
  if (!this->_internal_measurements().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "vlsir.spice.TranResult.MeasurementsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_measurements().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_measurements().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_measurements().begin();
          it != this->_internal_measurements().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = TranResult_MeasurementsEntry_DoNotUse::Funcs::InternalSerialize(10, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_measurements().begin();
          it != this->_internal_measurements().end(); ++it) {
        target = TranResult_MeasurementsEntry_DoNotUse::Funcs::InternalSerialize(10, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.TranResult)
  return target;
}

size_t TranResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.TranResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(signals_.size());
  for (int i = 0, n = signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      signals_.Get(i));
  }

  // repeated double data = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // map<string, double> measurements = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += TranResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TranResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranResult::GetClassData() const { return &_class_data_; }

void TranResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TranResult *>(to)->MergeFrom(
      static_cast<const TranResult &>(from));
}


void TranResult::MergeFrom(const TranResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.TranResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  signals_.MergeFrom(from.signals_);
  data_.MergeFrom(from.data_);
  measurements_.MergeFrom(from.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranResult::CopyFrom(const TranResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.TranResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranResult::IsInitialized() const {
  return true;
}

void TranResult::InternalSwap(TranResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  signals_.InternalSwap(&other->signals_);
  data_.InternalSwap(&other->data_);
  measurements_.InternalSwap(&other->measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TranResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[13]);
}

// ===================================================================

class ComplexNum::_Internal {
 public:
};

ComplexNum::ComplexNum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.ComplexNum)
}
ComplexNum::ComplexNum(const ComplexNum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&re_, &from.re_,
    static_cast<size_t>(reinterpret_cast<char*>(&im_) -
    reinterpret_cast<char*>(&re_)) + sizeof(im_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.ComplexNum)
}

inline void ComplexNum::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&re_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&im_) -
    reinterpret_cast<char*>(&re_)) + sizeof(im_));
}

ComplexNum::~ComplexNum() {
  // @@protoc_insertion_point(destructor:vlsir.spice.ComplexNum)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ComplexNum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ComplexNum::ArenaDtor(void* object) {
  ComplexNum* _this = reinterpret_cast< ComplexNum* >(object);
  (void)_this;
}
void ComplexNum::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ComplexNum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ComplexNum::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.ComplexNum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&re_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&im_) -
      reinterpret_cast<char*>(&re_)) + sizeof(im_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComplexNum::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double re = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          re_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double im = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          im_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComplexNum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.ComplexNum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double re = 1;
  if (!(this->_internal_re() <= 0 && this->_internal_re() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_re(), target);
  }

  // double im = 2;
  if (!(this->_internal_im() <= 0 && this->_internal_im() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_im(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.ComplexNum)
  return target;
}

size_t ComplexNum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.ComplexNum)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double re = 1;
  if (!(this->_internal_re() <= 0 && this->_internal_re() >= 0)) {
    total_size += 1 + 8;
  }

  // double im = 2;
  if (!(this->_internal_im() <= 0 && this->_internal_im() >= 0)) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComplexNum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ComplexNum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComplexNum::GetClassData() const { return &_class_data_; }

void ComplexNum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ComplexNum *>(to)->MergeFrom(
      static_cast<const ComplexNum &>(from));
}


void ComplexNum::MergeFrom(const ComplexNum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.ComplexNum)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from._internal_re() <= 0 && from._internal_re() >= 0)) {
    _internal_set_re(from._internal_re());
  }
  if (!(from._internal_im() <= 0 && from._internal_im() >= 0)) {
    _internal_set_im(from._internal_im());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComplexNum::CopyFrom(const ComplexNum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.ComplexNum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComplexNum::IsInitialized() const {
  return true;
}

void ComplexNum::InternalSwap(ComplexNum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ComplexNum, im_)
      + sizeof(ComplexNum::im_)
      - PROTOBUF_FIELD_OFFSET(ComplexNum, re_)>(
          reinterpret_cast<char*>(&re_),
          reinterpret_cast<char*>(&other->re_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ComplexNum::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[14]);
}

// ===================================================================

class AcInput::_Internal {
 public:
};

AcInput::AcInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.AcInput)
}
AcInput::AcInput(const AcInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&fstart_, &from.fstart_,
    static_cast<size_t>(reinterpret_cast<char*>(&npts_) -
    reinterpret_cast<char*>(&fstart_)) + sizeof(npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.AcInput)
}

inline void AcInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fstart_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&npts_) -
    reinterpret_cast<char*>(&fstart_)) + sizeof(npts_));
}

AcInput::~AcInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.AcInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AcInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AcInput::ArenaDtor(void* object) {
  AcInput* _this = reinterpret_cast< AcInput* >(object);
  (void)_this;
}
void AcInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AcInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AcInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.AcInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  ::memset(&fstart_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&npts_) -
      reinterpret_cast<char*>(&fstart_)) + sizeof(npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.AcInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fstart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          fstart_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fstop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          fstop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint64 npts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          npts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.AcInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.AcInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // double fstart = 2;
  if (!(this->_internal_fstart() <= 0 && this->_internal_fstart() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_fstart(), target);
  }

  // double fstop = 3;
  if (!(this->_internal_fstop() <= 0 && this->_internal_fstop() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_fstop(), target);
  }

  // uint64 npts = 4;
  if (this->_internal_npts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_npts(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.AcInput)
  return target;
}

size_t AcInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.AcInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // double fstart = 2;
  if (!(this->_internal_fstart() <= 0 && this->_internal_fstart() >= 0)) {
    total_size += 1 + 8;
  }

  // double fstop = 3;
  if (!(this->_internal_fstop() <= 0 && this->_internal_fstop() >= 0)) {
    total_size += 1 + 8;
  }

  // uint64 npts = 4;
  if (this->_internal_npts() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_npts());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AcInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AcInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AcInput::GetClassData() const { return &_class_data_; }

void AcInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AcInput *>(to)->MergeFrom(
      static_cast<const AcInput &>(from));
}


void AcInput::MergeFrom(const AcInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.AcInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!(from._internal_fstart() <= 0 && from._internal_fstart() >= 0)) {
    _internal_set_fstart(from._internal_fstart());
  }
  if (!(from._internal_fstop() <= 0 && from._internal_fstop() >= 0)) {
    _internal_set_fstop(from._internal_fstop());
  }
  if (from._internal_npts() != 0) {
    _internal_set_npts(from._internal_npts());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AcInput::CopyFrom(const AcInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.AcInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcInput::IsInitialized() const {
  return true;
}

void AcInput::InternalSwap(AcInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AcInput, npts_)
      + sizeof(AcInput::npts_)
      - PROTOBUF_FIELD_OFFSET(AcInput, fstart_)>(
          reinterpret_cast<char*>(&fstart_),
          reinterpret_cast<char*>(&other->fstart_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AcInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[15]);
}

// ===================================================================

AcResult_MeasurementsEntry_DoNotUse::AcResult_MeasurementsEntry_DoNotUse() {}
AcResult_MeasurementsEntry_DoNotUse::AcResult_MeasurementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void AcResult_MeasurementsEntry_DoNotUse::MergeFrom(const AcResult_MeasurementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata AcResult_MeasurementsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[16]);
}

// ===================================================================

class AcResult::_Internal {
 public:
};

AcResult::AcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  freq_(arena),
  signals_(arena),
  data_(arena),
  measurements_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.AcResult)
}
AcResult::AcResult(const AcResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      freq_(from.freq_),
      signals_(from.signals_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  measurements_.MergeFrom(from.measurements_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.AcResult)
}

inline void AcResult::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AcResult::~AcResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.AcResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AcResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AcResult::ArenaDtor(void* object) {
  AcResult* _this = reinterpret_cast< AcResult* >(object);
  (void)_this;
  _this->measurements_. ~MapField();
}
inline void AcResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &AcResult::ArenaDtor);
  }
}
void AcResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AcResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.AcResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  freq_.Clear();
  signals_.Clear();
  data_.Clear();
  measurements_.Clear();
  analysis_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.AcResult.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double freq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_freq(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 17) {
          _internal_add_freq(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated string signals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signals();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.AcResult.signals"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.ComplexNum data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> measurements = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&measurements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.AcResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.AcResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // repeated double freq = 2;
  if (this->_internal_freq_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_freq(), target);
  }

  // repeated string signals = 3;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    const auto& s = this->_internal_signals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.AcResult.signals");
    target = stream->WriteString(3, s, target);
  }

  // repeated .vlsir.spice.ComplexNum data = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_data_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_data(i), target, stream);
  }

  // map<string, double> measurements = 10;
  if (!this->_internal_measurements().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "vlsir.spice.AcResult.MeasurementsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_measurements().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_measurements().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_measurements().begin();
          it != this->_internal_measurements().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = AcResult_MeasurementsEntry_DoNotUse::Funcs::InternalSerialize(10, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_measurements().begin();
          it != this->_internal_measurements().end(); ++it) {
        target = AcResult_MeasurementsEntry_DoNotUse::Funcs::InternalSerialize(10, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.AcResult)
  return target;
}

size_t AcResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.AcResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double freq = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_freq_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated string signals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(signals_.size());
  for (int i = 0, n = signals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      signals_.Get(i));
  }

  // repeated .vlsir.spice.ComplexNum data = 5;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, double> measurements = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_measurements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_measurements().begin();
      it != this->_internal_measurements().end(); ++it) {
    total_size += AcResult_MeasurementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AcResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AcResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AcResult::GetClassData() const { return &_class_data_; }

void AcResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AcResult *>(to)->MergeFrom(
      static_cast<const AcResult &>(from));
}


void AcResult::MergeFrom(const AcResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.AcResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  freq_.MergeFrom(from.freq_);
  signals_.MergeFrom(from.signals_);
  data_.MergeFrom(from.data_);
  measurements_.MergeFrom(from.measurements_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AcResult::CopyFrom(const AcResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.AcResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcResult::IsInitialized() const {
  return true;
}

void AcResult::InternalSwap(AcResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  freq_.InternalSwap(&other->freq_);
  signals_.InternalSwap(&other->signals_);
  data_.InternalSwap(&other->data_);
  measurements_.InternalSwap(&other->measurements_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AcResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[17]);
}

// ===================================================================

class SweepInput::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const SweepInput* msg);
};

const ::vlsir::spice::Sweep&
SweepInput::_Internal::sweep(const SweepInput* msg) {
  return *msg->sweep_;
}
SweepInput::SweepInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  an_(arena),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SweepInput)
}
SweepInput::SweepInput(const SweepInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      an_(from.an_),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  variable_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_variable().empty()) {
    variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_variable(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    sweep_ = new ::vlsir::spice::Sweep(*from.sweep_);
  } else {
    sweep_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SweepInput)
}

inline void SweepInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
variable_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sweep_ = nullptr;
}

SweepInput::~SweepInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SweepInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SweepInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  variable_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sweep_;
}

void SweepInput::ArenaDtor(void* object) {
  SweepInput* _this = reinterpret_cast< SweepInput* >(object);
  (void)_this;
}
void SweepInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SweepInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SweepInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SweepInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  an_.Clear();
  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  variable_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SweepInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.SweepInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string variable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_variable();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.SweepInput.variable"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Analysis an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SweepInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SweepInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_variable().data(), static_cast<int>(this->_internal_variable().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepInput.variable");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_variable(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::sweep(this), target, stream);
  }

  // repeated .vlsir.spice.Analysis an = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_an_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_an(i), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SweepInput)
  return target;
}

size_t SweepInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SweepInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Analysis an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_variable());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SweepInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SweepInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SweepInput::GetClassData() const { return &_class_data_; }

void SweepInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SweepInput *>(to)->MergeFrom(
      static_cast<const SweepInput &>(from));
}


void SweepInput::MergeFrom(const SweepInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SweepInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  an_.MergeFrom(from.an_);
  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_variable().empty()) {
    _internal_set_variable(from._internal_variable());
  }
  if (from._internal_has_sweep()) {
    _internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(from._internal_sweep());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SweepInput::CopyFrom(const SweepInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SweepInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SweepInput::IsInitialized() const {
  return true;
}

void SweepInput::InternalSwap(SweepInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  an_.InternalSwap(&other->an_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &variable_, lhs_arena,
      &other->variable_, rhs_arena
  );
  swap(sweep_, other->sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SweepInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[18]);
}

// ===================================================================

class SweepResult::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const SweepResult* msg);
};

const ::vlsir::spice::Sweep&
SweepResult::_Internal::sweep(const SweepResult* msg) {
  return *msg->sweep_;
}
SweepResult::SweepResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  an_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.SweepResult)
}
SweepResult::SweepResult(const SweepResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      an_(from.an_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  variable_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_variable().empty()) {
    variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_variable(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    sweep_ = new ::vlsir::spice::Sweep(*from.sweep_);
  } else {
    sweep_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.SweepResult)
}

inline void SweepResult::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
variable_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sweep_ = nullptr;
}

SweepResult::~SweepResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.SweepResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SweepResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  variable_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sweep_;
}

void SweepResult::ArenaDtor(void* object) {
  SweepResult* _this = reinterpret_cast< SweepResult* >(object);
  (void)_this;
}
void SweepResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SweepResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SweepResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.SweepResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  an_.Clear();
  analysis_name_.ClearToEmpty();
  variable_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SweepResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.SweepResult.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string variable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_variable();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.SweepResult.variable"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.AnalysisResult an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SweepResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.SweepResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_variable().data(), static_cast<int>(this->_internal_variable().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.SweepResult.variable");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_variable(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::sweep(this), target, stream);
  }

  // repeated .vlsir.spice.AnalysisResult an = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_an_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_an(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.SweepResult)
  return target;
}

size_t SweepResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.SweepResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_variable());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SweepResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SweepResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SweepResult::GetClassData() const { return &_class_data_; }

void SweepResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SweepResult *>(to)->MergeFrom(
      static_cast<const SweepResult &>(from));
}


void SweepResult::MergeFrom(const SweepResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.SweepResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  an_.MergeFrom(from.an_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_variable().empty()) {
    _internal_set_variable(from._internal_variable());
  }
  if (from._internal_has_sweep()) {
    _internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(from._internal_sweep());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SweepResult::CopyFrom(const SweepResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.SweepResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SweepResult::IsInitialized() const {
  return true;
}

void SweepResult::InternalSwap(SweepResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  an_.InternalSwap(&other->an_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &variable_, lhs_arena,
      &other->variable_, rhs_arena
  );
  swap(sweep_, other->sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SweepResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[19]);
}

// ===================================================================

class MonteInput::_Internal {
 public:
};

MonteInput::MonteInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  an_(arena),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.MonteInput)
}
MonteInput::MonteInput(const MonteInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      an_(from.an_),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&npts_, &from.npts_,
    static_cast<size_t>(reinterpret_cast<char*>(&seed_) -
    reinterpret_cast<char*>(&npts_)) + sizeof(seed_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.MonteInput)
}

inline void MonteInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&npts_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seed_) -
    reinterpret_cast<char*>(&npts_)) + sizeof(seed_));
}

MonteInput::~MonteInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.MonteInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MonteInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MonteInput::ArenaDtor(void* object) {
  MonteInput* _this = reinterpret_cast< MonteInput* >(object);
  (void)_this;
}
void MonteInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MonteInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MonteInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.MonteInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  an_.Clear();
  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  ::memset(&npts_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&seed_) -
      reinterpret_cast<char*>(&npts_)) + sizeof(seed_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonteInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.MonteInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 npts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          npts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 seed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Analysis an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonteInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.MonteInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.MonteInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // int64 npts = 2;
  if (this->_internal_npts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_npts(), target);
  }

  // int64 seed = 3;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_seed(), target);
  }

  // repeated .vlsir.spice.Analysis an = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_an_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_an(i), target, stream);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.MonteInput)
  return target;
}

size_t MonteInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.MonteInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Analysis an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // int64 npts = 2;
  if (this->_internal_npts() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_npts());
  }

  // int64 seed = 3;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonteInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MonteInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonteInput::GetClassData() const { return &_class_data_; }

void MonteInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MonteInput *>(to)->MergeFrom(
      static_cast<const MonteInput &>(from));
}


void MonteInput::MergeFrom(const MonteInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.MonteInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  an_.MergeFrom(from.an_);
  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (from._internal_npts() != 0) {
    _internal_set_npts(from._internal_npts());
  }
  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonteInput::CopyFrom(const MonteInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.MonteInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonteInput::IsInitialized() const {
  return true;
}

void MonteInput::InternalSwap(MonteInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  an_.InternalSwap(&other->an_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonteInput, seed_)
      + sizeof(MonteInput::seed_)
      - PROTOBUF_FIELD_OFFSET(MonteInput, npts_)>(
          reinterpret_cast<char*>(&npts_),
          reinterpret_cast<char*>(&other->npts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MonteInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[20]);
}

// ===================================================================

class MonteResult::_Internal {
 public:
  static const ::vlsir::spice::Sweep& sweep(const MonteResult* msg);
};

const ::vlsir::spice::Sweep&
MonteResult::_Internal::sweep(const MonteResult* msg) {
  return *msg->sweep_;
}
MonteResult::MonteResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  an_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.MonteResult)
}
MonteResult::MonteResult(const MonteResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      an_(from.an_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  variable_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_variable().empty()) {
    variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_variable(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sweep()) {
    sweep_ = new ::vlsir::spice::Sweep(*from.sweep_);
  } else {
    sweep_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.MonteResult)
}

inline void MonteResult::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
variable_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sweep_ = nullptr;
}

MonteResult::~MonteResult() {
  // @@protoc_insertion_point(destructor:vlsir.spice.MonteResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MonteResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  variable_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sweep_;
}

void MonteResult::ArenaDtor(void* object) {
  MonteResult* _this = reinterpret_cast< MonteResult* >(object);
  (void)_this;
}
void MonteResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MonteResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MonteResult::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.MonteResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  an_.Clear();
  analysis_name_.ClearToEmpty();
  variable_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && sweep_ != nullptr) {
    delete sweep_;
  }
  sweep_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonteResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.MonteResult.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string variable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_variable();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.MonteResult.variable"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Sweep sweep = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sweep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.AnalysisResult an = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_an(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonteResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.MonteResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.MonteResult.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_variable().data(), static_cast<int>(this->_internal_variable().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.MonteResult.variable");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_variable(), target);
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::sweep(this), target, stream);
  }

  // repeated .vlsir.spice.AnalysisResult an = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_an_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_an(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.MonteResult)
  return target;
}

size_t MonteResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.MonteResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.AnalysisResult an = 4;
  total_size += 1UL * this->_internal_an_size();
  for (const auto& msg : this->an_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string variable = 2;
  if (!this->_internal_variable().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_variable());
  }

  // .vlsir.spice.Sweep sweep = 3;
  if (this->_internal_has_sweep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sweep_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonteResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MonteResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonteResult::GetClassData() const { return &_class_data_; }

void MonteResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MonteResult *>(to)->MergeFrom(
      static_cast<const MonteResult &>(from));
}


void MonteResult::MergeFrom(const MonteResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.MonteResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  an_.MergeFrom(from.an_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_variable().empty()) {
    _internal_set_variable(from._internal_variable());
  }
  if (from._internal_has_sweep()) {
    _internal_mutable_sweep()->::vlsir::spice::Sweep::MergeFrom(from._internal_sweep());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonteResult::CopyFrom(const MonteResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.MonteResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonteResult::IsInitialized() const {
  return true;
}

void MonteResult::InternalSwap(MonteResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  an_.InternalSwap(&other->an_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &variable_, lhs_arena,
      &other->variable_, rhs_arena
  );
  swap(sweep_, other->sweep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MonteResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[21]);
}

// ===================================================================

class CustomAnalysisInput::_Internal {
 public:
};

CustomAnalysisInput::CustomAnalysisInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ctrls_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.CustomAnalysisInput)
}
CustomAnalysisInput::CustomAnalysisInput(const CustomAnalysisInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ctrls_(from.ctrls_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_name().empty()) {
    analysis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_name(), 
      GetArenaForAllocation());
  }
  cmd_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cmd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cmd().empty()) {
    cmd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cmd(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.CustomAnalysisInput)
}

inline void CustomAnalysisInput::SharedCtor() {
analysis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cmd_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cmd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomAnalysisInput::~CustomAnalysisInput() {
  // @@protoc_insertion_point(destructor:vlsir.spice.CustomAnalysisInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CustomAnalysisInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cmd_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CustomAnalysisInput::ArenaDtor(void* object) {
  CustomAnalysisInput* _this = reinterpret_cast< CustomAnalysisInput* >(object);
  (void)_this;
}
void CustomAnalysisInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CustomAnalysisInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CustomAnalysisInput::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.CustomAnalysisInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ctrls_.Clear();
  analysis_name_.ClearToEmpty();
  cmd_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CustomAnalysisInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.CustomAnalysisInput.analysis_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string cmd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cmd();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.CustomAnalysisInput.cmd"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.spice.Control ctrls = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ctrls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomAnalysisInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.CustomAnalysisInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_name().data(), static_cast<int>(this->_internal_analysis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.CustomAnalysisInput.analysis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_name(), target);
  }

  // string cmd = 2;
  if (!this->_internal_cmd().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cmd().data(), static_cast<int>(this->_internal_cmd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.CustomAnalysisInput.cmd");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cmd(), target);
  }

  // repeated .vlsir.spice.Control ctrls = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ctrls_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_ctrls(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.CustomAnalysisInput)
  return target;
}

size_t CustomAnalysisInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.CustomAnalysisInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.spice.Control ctrls = 5;
  total_size += 1UL * this->_internal_ctrls_size();
  for (const auto& msg : this->ctrls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string analysis_name = 1;
  if (!this->_internal_analysis_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_name());
  }

  // string cmd = 2;
  if (!this->_internal_cmd().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cmd());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CustomAnalysisInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CustomAnalysisInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CustomAnalysisInput::GetClassData() const { return &_class_data_; }

void CustomAnalysisInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CustomAnalysisInput *>(to)->MergeFrom(
      static_cast<const CustomAnalysisInput &>(from));
}


void CustomAnalysisInput::MergeFrom(const CustomAnalysisInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.CustomAnalysisInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ctrls_.MergeFrom(from.ctrls_);
  if (!from._internal_analysis_name().empty()) {
    _internal_set_analysis_name(from._internal_analysis_name());
  }
  if (!from._internal_cmd().empty()) {
    _internal_set_cmd(from._internal_cmd());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CustomAnalysisInput::CopyFrom(const CustomAnalysisInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.CustomAnalysisInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomAnalysisInput::IsInitialized() const {
  return true;
}

void CustomAnalysisInput::InternalSwap(CustomAnalysisInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ctrls_.InternalSwap(&other->ctrls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_name_, lhs_arena,
      &other->analysis_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &cmd_, lhs_arena,
      &other->cmd_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CustomAnalysisInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[22]);
}

// ===================================================================

class CustomAnalysisResult::_Internal {
 public:
};

CustomAnalysisResult::CustomAnalysisResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.CustomAnalysisResult)
}
CustomAnalysisResult::CustomAnalysisResult(const CustomAnalysisResult& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.CustomAnalysisResult)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CustomAnalysisResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CustomAnalysisResult::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CustomAnalysisResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[23]);
}

// ===================================================================

class Sweep::_Internal {
 public:
  static const ::vlsir::spice::LinearSweep& linear(const Sweep* msg);
  static const ::vlsir::spice::LogSweep& log(const Sweep* msg);
  static const ::vlsir::spice::PointSweep& points(const Sweep* msg);
};

const ::vlsir::spice::LinearSweep&
Sweep::_Internal::linear(const Sweep* msg) {
  return *msg->tp_.linear_;
}
const ::vlsir::spice::LogSweep&
Sweep::_Internal::log(const Sweep* msg) {
  return *msg->tp_.log_;
}
const ::vlsir::spice::PointSweep&
Sweep::_Internal::points(const Sweep* msg) {
  return *msg->tp_.points_;
}
void Sweep::set_allocated_linear(::vlsir::spice::LinearSweep* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tp();
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::LinearSweep>::GetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
    tp_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Sweep.linear)
}
void Sweep::set_allocated_log(::vlsir::spice::LogSweep* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tp();
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::LogSweep>::GetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    set_has_log();
    tp_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Sweep.log)
}
void Sweep::set_allocated_points(::vlsir::spice::PointSweep* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_tp();
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::PointSweep>::GetOwningArena(points);
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    set_has_points();
    tp_.points_ = points;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Sweep.points)
}
Sweep::Sweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Sweep)
}
Sweep::Sweep(const Sweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_tp();
  switch (from.tp_case()) {
    case kLinear: {
      _internal_mutable_linear()->::vlsir::spice::LinearSweep::MergeFrom(from._internal_linear());
      break;
    }
    case kLog: {
      _internal_mutable_log()->::vlsir::spice::LogSweep::MergeFrom(from._internal_log());
      break;
    }
    case kPoints: {
      _internal_mutable_points()->::vlsir::spice::PointSweep::MergeFrom(from._internal_points());
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Sweep)
}

inline void Sweep::SharedCtor() {
clear_has_tp();
}

Sweep::~Sweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Sweep)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Sweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_tp()) {
    clear_tp();
  }
}

void Sweep::ArenaDtor(void* object) {
  Sweep* _this = reinterpret_cast< Sweep* >(object);
  (void)_this;
}
void Sweep::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Sweep::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Sweep::clear_tp() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Sweep)
  switch (tp_case()) {
    case kLinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete tp_.linear_;
      }
      break;
    }
    case kLog: {
      if (GetArenaForAllocation() == nullptr) {
        delete tp_.log_;
      }
      break;
    }
    case kPoints: {
      if (GetArenaForAllocation() == nullptr) {
        delete tp_.points_;
      }
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TP_NOT_SET;
}


void Sweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Sweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_tp();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sweep::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.LinearSweep linear = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.LogSweep log = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_log(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.PointSweep points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_points(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Sweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.LinearSweep linear = 1;
  if (_internal_has_linear()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::linear(this), target, stream);
  }

  // .vlsir.spice.LogSweep log = 2;
  if (_internal_has_log()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::log(this), target, stream);
  }

  // .vlsir.spice.PointSweep points = 3;
  if (_internal_has_points()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::points(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Sweep)
  return target;
}

size_t Sweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Sweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (tp_case()) {
    // .vlsir.spice.LinearSweep linear = 1;
    case kLinear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tp_.linear_);
      break;
    }
    // .vlsir.spice.LogSweep log = 2;
    case kLog: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tp_.log_);
      break;
    }
    // .vlsir.spice.PointSweep points = 3;
    case kPoints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tp_.points_);
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Sweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sweep::GetClassData() const { return &_class_data_; }

void Sweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Sweep *>(to)->MergeFrom(
      static_cast<const Sweep &>(from));
}


void Sweep::MergeFrom(const Sweep& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Sweep)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.tp_case()) {
    case kLinear: {
      _internal_mutable_linear()->::vlsir::spice::LinearSweep::MergeFrom(from._internal_linear());
      break;
    }
    case kLog: {
      _internal_mutable_log()->::vlsir::spice::LogSweep::MergeFrom(from._internal_log());
      break;
    }
    case kPoints: {
      _internal_mutable_points()->::vlsir::spice::PointSweep::MergeFrom(from._internal_points());
      break;
    }
    case TP_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sweep::CopyFrom(const Sweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Sweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sweep::IsInitialized() const {
  return true;
}

void Sweep::InternalSwap(Sweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(tp_, other->tp_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Sweep::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[24]);
}

// ===================================================================

class LinearSweep::_Internal {
 public:
};

LinearSweep::LinearSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.LinearSweep)
}
LinearSweep::LinearSweep(const LinearSweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&start_, &from.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&step_) -
    reinterpret_cast<char*>(&start_)) + sizeof(step_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.LinearSweep)
}

inline void LinearSweep::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&step_) -
    reinterpret_cast<char*>(&start_)) + sizeof(step_));
}

LinearSweep::~LinearSweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.LinearSweep)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LinearSweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LinearSweep::ArenaDtor(void* object) {
  LinearSweep* _this = reinterpret_cast< LinearSweep* >(object);
  (void)_this;
}
void LinearSweep::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LinearSweep::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LinearSweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.LinearSweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&step_) -
      reinterpret_cast<char*>(&start_)) + sizeof(step_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearSweep::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          stop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double step = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearSweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.LinearSweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double start = 1;
  if (!(this->_internal_start() <= 0 && this->_internal_start() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_start(), target);
  }

  // double stop = 2;
  if (!(this->_internal_stop() <= 0 && this->_internal_stop() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop(), target);
  }

  // double step = 3;
  if (!(this->_internal_step() <= 0 && this->_internal_step() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_step(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.LinearSweep)
  return target;
}

size_t LinearSweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.LinearSweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double start = 1;
  if (!(this->_internal_start() <= 0 && this->_internal_start() >= 0)) {
    total_size += 1 + 8;
  }

  // double stop = 2;
  if (!(this->_internal_stop() <= 0 && this->_internal_stop() >= 0)) {
    total_size += 1 + 8;
  }

  // double step = 3;
  if (!(this->_internal_step() <= 0 && this->_internal_step() >= 0)) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearSweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LinearSweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearSweep::GetClassData() const { return &_class_data_; }

void LinearSweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LinearSweep *>(to)->MergeFrom(
      static_cast<const LinearSweep &>(from));
}


void LinearSweep::MergeFrom(const LinearSweep& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.LinearSweep)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from._internal_start() <= 0 && from._internal_start() >= 0)) {
    _internal_set_start(from._internal_start());
  }
  if (!(from._internal_stop() <= 0 && from._internal_stop() >= 0)) {
    _internal_set_stop(from._internal_stop());
  }
  if (!(from._internal_step() <= 0 && from._internal_step() >= 0)) {
    _internal_set_step(from._internal_step());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearSweep::CopyFrom(const LinearSweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.LinearSweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearSweep::IsInitialized() const {
  return true;
}

void LinearSweep::InternalSwap(LinearSweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LinearSweep, step_)
      + sizeof(LinearSweep::step_)
      - PROTOBUF_FIELD_OFFSET(LinearSweep, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearSweep::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[25]);
}

// ===================================================================

class LogSweep::_Internal {
 public:
};

LogSweep::LogSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.LogSweep)
}
LogSweep::LogSweep(const LogSweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&start_, &from.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&npts_) -
    reinterpret_cast<char*>(&start_)) + sizeof(npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.LogSweep)
}

inline void LogSweep::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&npts_) -
    reinterpret_cast<char*>(&start_)) + sizeof(npts_));
}

LogSweep::~LogSweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.LogSweep)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LogSweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogSweep::ArenaDtor(void* object) {
  LogSweep* _this = reinterpret_cast< LogSweep* >(object);
  (void)_this;
}
void LogSweep::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogSweep::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogSweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.LogSweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&npts_) -
      reinterpret_cast<char*>(&start_)) + sizeof(npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogSweep::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          stop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double npts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          npts_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogSweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.LogSweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double start = 1;
  if (!(this->_internal_start() <= 0 && this->_internal_start() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_start(), target);
  }

  // double stop = 2;
  if (!(this->_internal_stop() <= 0 && this->_internal_stop() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop(), target);
  }

  // double npts = 3;
  if (!(this->_internal_npts() <= 0 && this->_internal_npts() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_npts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.LogSweep)
  return target;
}

size_t LogSweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.LogSweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double start = 1;
  if (!(this->_internal_start() <= 0 && this->_internal_start() >= 0)) {
    total_size += 1 + 8;
  }

  // double stop = 2;
  if (!(this->_internal_stop() <= 0 && this->_internal_stop() >= 0)) {
    total_size += 1 + 8;
  }

  // double npts = 3;
  if (!(this->_internal_npts() <= 0 && this->_internal_npts() >= 0)) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogSweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LogSweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogSweep::GetClassData() const { return &_class_data_; }

void LogSweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogSweep *>(to)->MergeFrom(
      static_cast<const LogSweep &>(from));
}


void LogSweep::MergeFrom(const LogSweep& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.LogSweep)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from._internal_start() <= 0 && from._internal_start() >= 0)) {
    _internal_set_start(from._internal_start());
  }
  if (!(from._internal_stop() <= 0 && from._internal_stop() >= 0)) {
    _internal_set_stop(from._internal_stop());
  }
  if (!(from._internal_npts() <= 0 && from._internal_npts() >= 0)) {
    _internal_set_npts(from._internal_npts());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogSweep::CopyFrom(const LogSweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.LogSweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogSweep::IsInitialized() const {
  return true;
}

void LogSweep::InternalSwap(LogSweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogSweep, npts_)
      + sizeof(LogSweep::npts_)
      - PROTOBUF_FIELD_OFFSET(LogSweep, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogSweep::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[26]);
}

// ===================================================================

class PointSweep::_Internal {
 public:
};

PointSweep::PointSweep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  points_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.PointSweep)
}
PointSweep::PointSweep(const PointSweep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      points_(from.points_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&stop_, &from.stop_,
    static_cast<size_t>(reinterpret_cast<char*>(&npts_) -
    reinterpret_cast<char*>(&stop_)) + sizeof(npts_));
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.PointSweep)
}

inline void PointSweep::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stop_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&npts_) -
    reinterpret_cast<char*>(&stop_)) + sizeof(npts_));
}

PointSweep::~PointSweep() {
  // @@protoc_insertion_point(destructor:vlsir.spice.PointSweep)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PointSweep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointSweep::ArenaDtor(void* object) {
  PointSweep* _this = reinterpret_cast< PointSweep* >(object);
  (void)_this;
}
void PointSweep::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PointSweep::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PointSweep::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.PointSweep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  ::memset(&stop_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&npts_) -
      reinterpret_cast<char*>(&stop_)) + sizeof(npts_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointSweep::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_points(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_points(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          stop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double npts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          npts_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointSweep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.PointSweep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double points = 1;
  if (this->_internal_points_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_points(), target);
  }

  // double stop = 2;
  if (!(this->_internal_stop() <= 0 && this->_internal_stop() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop(), target);
  }

  // double npts = 3;
  if (!(this->_internal_npts() <= 0 && this->_internal_npts() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_npts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.PointSweep)
  return target;
}

size_t PointSweep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.PointSweep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double points = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_points_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // double stop = 2;
  if (!(this->_internal_stop() <= 0 && this->_internal_stop() >= 0)) {
    total_size += 1 + 8;
  }

  // double npts = 3;
  if (!(this->_internal_npts() <= 0 && this->_internal_npts() >= 0)) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointSweep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PointSweep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointSweep::GetClassData() const { return &_class_data_; }

void PointSweep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PointSweep *>(to)->MergeFrom(
      static_cast<const PointSweep &>(from));
}


void PointSweep::MergeFrom(const PointSweep& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.PointSweep)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  if (!(from._internal_stop() <= 0 && from._internal_stop() >= 0)) {
    _internal_set_stop(from._internal_stop());
  }
  if (!(from._internal_npts() <= 0 && from._internal_npts() >= 0)) {
    _internal_set_npts(from._internal_npts());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointSweep::CopyFrom(const PointSweep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.PointSweep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointSweep::IsInitialized() const {
  return true;
}

void PointSweep::InternalSwap(PointSweep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  points_.InternalSwap(&other->points_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointSweep, npts_)
      + sizeof(PointSweep::npts_)
      - PROTOBUF_FIELD_OFFSET(PointSweep, stop_)>(
          reinterpret_cast<char*>(&stop_),
          reinterpret_cast<char*>(&other->stop_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointSweep::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[27]);
}

// ===================================================================

class Control::_Internal {
 public:
  static const ::vlsir::spice::Include& include(const Control* msg);
  static const ::vlsir::spice::LibInclude& lib(const Control* msg);
  static const ::vlsir::spice::Save& save(const Control* msg);
  static const ::vlsir::spice::Meas& meas(const Control* msg);
  static const ::vlsir::utils::Param& param(const Control* msg);
};

const ::vlsir::spice::Include&
Control::_Internal::include(const Control* msg) {
  return *msg->ctrl_.include_;
}
const ::vlsir::spice::LibInclude&
Control::_Internal::lib(const Control* msg) {
  return *msg->ctrl_.lib_;
}
const ::vlsir::spice::Save&
Control::_Internal::save(const Control* msg) {
  return *msg->ctrl_.save_;
}
const ::vlsir::spice::Meas&
Control::_Internal::meas(const Control* msg) {
  return *msg->ctrl_.meas_;
}
const ::vlsir::utils::Param&
Control::_Internal::param(const Control* msg) {
  return *msg->ctrl_.param_;
}
void Control::set_allocated_include(::vlsir::spice::Include* include) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (include) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Include>::GetOwningArena(include);
    if (message_arena != submessage_arena) {
      include = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, include, submessage_arena);
    }
    set_has_include();
    ctrl_.include_ = include;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.include)
}
void Control::set_allocated_lib(::vlsir::spice::LibInclude* lib) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (lib) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::LibInclude>::GetOwningArena(lib);
    if (message_arena != submessage_arena) {
      lib = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lib, submessage_arena);
    }
    set_has_lib();
    ctrl_.lib_ = lib;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.lib)
}
void Control::set_allocated_save(::vlsir::spice::Save* save) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (save) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Save>::GetOwningArena(save);
    if (message_arena != submessage_arena) {
      save = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save, submessage_arena);
    }
    set_has_save();
    ctrl_.save_ = save;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.save)
}
void Control::set_allocated_meas(::vlsir::spice::Meas* meas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (meas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vlsir::spice::Meas>::GetOwningArena(meas);
    if (message_arena != submessage_arena) {
      meas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meas, submessage_arena);
    }
    set_has_meas();
    ctrl_.meas_ = meas;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.meas)
}
void Control::set_allocated_param(::vlsir::utils::Param* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ctrl();
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param));
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    set_has_param();
    ctrl_.param_ = param;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.spice.Control.param)
}
void Control::clear_param() {
  if (_internal_has_param()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ctrl_.param_;
    }
    clear_has_ctrl();
  }
}
Control::Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Control)
}
Control::Control(const Control& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ctrl();
  switch (from.ctrl_case()) {
    case kInclude: {
      _internal_mutable_include()->::vlsir::spice::Include::MergeFrom(from._internal_include());
      break;
    }
    case kLib: {
      _internal_mutable_lib()->::vlsir::spice::LibInclude::MergeFrom(from._internal_lib());
      break;
    }
    case kSave: {
      _internal_mutable_save()->::vlsir::spice::Save::MergeFrom(from._internal_save());
      break;
    }
    case kMeas: {
      _internal_mutable_meas()->::vlsir::spice::Meas::MergeFrom(from._internal_meas());
      break;
    }
    case kParam: {
      _internal_mutable_param()->::vlsir::utils::Param::MergeFrom(from._internal_param());
      break;
    }
    case kLiteral: {
      _internal_set_literal(from._internal_literal());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Control)
}

inline void Control::SharedCtor() {
clear_has_ctrl();
}

Control::~Control() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Control)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Control::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ctrl()) {
    clear_ctrl();
  }
}

void Control::ArenaDtor(void* object) {
  Control* _this = reinterpret_cast< Control* >(object);
  (void)_this;
}
void Control::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Control::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Control::clear_ctrl() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Control)
  switch (ctrl_case()) {
    case kInclude: {
      if (GetArenaForAllocation() == nullptr) {
        delete ctrl_.include_;
      }
      break;
    }
    case kLib: {
      if (GetArenaForAllocation() == nullptr) {
        delete ctrl_.lib_;
      }
      break;
    }
    case kSave: {
      if (GetArenaForAllocation() == nullptr) {
        delete ctrl_.save_;
      }
      break;
    }
    case kMeas: {
      if (GetArenaForAllocation() == nullptr) {
        delete ctrl_.meas_;
      }
      break;
    }
    case kParam: {
      if (GetArenaForAllocation() == nullptr) {
        delete ctrl_.param_;
      }
      break;
    }
    case kLiteral: {
      ctrl_.literal_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CTRL_NOT_SET;
}


void Control::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Control)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ctrl();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Control::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.Include include = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_include(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.LibInclude lib = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lib(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Save save = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_save(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Meas meas = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_meas(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.Param param = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_param(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string literal = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_literal();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Control.literal"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Control::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Control)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.Include include = 1;
  if (_internal_has_include()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::include(this), target, stream);
  }

  // .vlsir.spice.LibInclude lib = 2;
  if (_internal_has_lib()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::lib(this), target, stream);
  }

  // .vlsir.spice.Save save = 5;
  if (_internal_has_save()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::save(this), target, stream);
  }

  // .vlsir.spice.Meas meas = 6;
  if (_internal_has_meas()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::meas(this), target, stream);
  }

  // .vlsir.utils.Param param = 7;
  if (_internal_has_param()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::param(this), target, stream);
  }

  // string literal = 10;
  if (_internal_has_literal()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_literal().data(), static_cast<int>(this->_internal_literal().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Control.literal");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_literal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Control)
  return target;
}

size_t Control::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Control)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ctrl_case()) {
    // .vlsir.spice.Include include = 1;
    case kInclude: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ctrl_.include_);
      break;
    }
    // .vlsir.spice.LibInclude lib = 2;
    case kLib: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ctrl_.lib_);
      break;
    }
    // .vlsir.spice.Save save = 5;
    case kSave: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ctrl_.save_);
      break;
    }
    // .vlsir.spice.Meas meas = 6;
    case kMeas: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ctrl_.meas_);
      break;
    }
    // .vlsir.utils.Param param = 7;
    case kParam: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ctrl_.param_);
      break;
    }
    // string literal = 10;
    case kLiteral: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_literal());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Control::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Control::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Control::GetClassData() const { return &_class_data_; }

void Control::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Control *>(to)->MergeFrom(
      static_cast<const Control &>(from));
}


void Control::MergeFrom(const Control& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Control)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ctrl_case()) {
    case kInclude: {
      _internal_mutable_include()->::vlsir::spice::Include::MergeFrom(from._internal_include());
      break;
    }
    case kLib: {
      _internal_mutable_lib()->::vlsir::spice::LibInclude::MergeFrom(from._internal_lib());
      break;
    }
    case kSave: {
      _internal_mutable_save()->::vlsir::spice::Save::MergeFrom(from._internal_save());
      break;
    }
    case kMeas: {
      _internal_mutable_meas()->::vlsir::spice::Meas::MergeFrom(from._internal_meas());
      break;
    }
    case kParam: {
      _internal_mutable_param()->::vlsir::utils::Param::MergeFrom(from._internal_param());
      break;
    }
    case kLiteral: {
      _internal_set_literal(from._internal_literal());
      break;
    }
    case CTRL_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Control::CopyFrom(const Control& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Control)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Control::IsInitialized() const {
  return true;
}

void Control::InternalSwap(Control* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(ctrl_, other->ctrl_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Control::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[28]);
}

// ===================================================================

class Save::_Internal {
 public:
};

Save::Save(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Save)
}
Save::Save(const Save& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_save();
  switch (from.save_case()) {
    case kMode: {
      _internal_set_mode(from._internal_mode());
      break;
    }
    case kSignal: {
      _internal_set_signal(from._internal_signal());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Save)
}

inline void Save::SharedCtor() {
clear_has_save();
}

Save::~Save() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Save)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Save::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_save()) {
    clear_save();
  }
}

void Save::ArenaDtor(void* object) {
  Save* _this = reinterpret_cast< Save* >(object);
  (void)_this;
}
void Save::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Save::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Save::clear_save() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.spice.Save)
  switch (save_case()) {
    case kMode: {
      // No need to clear
      break;
    }
    case kSignal: {
      save_.signal_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SAVE_NOT_SET;
}


void Save::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Save)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_save();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Save::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.spice.Save.SaveMode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::vlsir::spice::Save_SaveMode>(val));
        } else
          goto handle_unusual;
        continue;
      // string signal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signal();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Save.signal"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Save::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Save)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.spice.Save.SaveMode mode = 1;
  if (_internal_has_mode()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // string signal = 2;
  if (_internal_has_signal()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_signal().data(), static_cast<int>(this->_internal_signal().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Save.signal");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_signal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Save)
  return target;
}

size_t Save::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Save)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (save_case()) {
    // .vlsir.spice.Save.SaveMode mode = 1;
    case kMode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
      break;
    }
    // string signal = 2;
    case kSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signal());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Save::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Save::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Save::GetClassData() const { return &_class_data_; }

void Save::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Save *>(to)->MergeFrom(
      static_cast<const Save &>(from));
}


void Save::MergeFrom(const Save& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Save)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.save_case()) {
    case kMode: {
      _internal_set_mode(from._internal_mode());
      break;
    }
    case kSignal: {
      _internal_set_signal(from._internal_signal());
      break;
    }
    case SAVE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Save::CopyFrom(const Save& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Save)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Save::IsInitialized() const {
  return true;
}

void Save::InternalSwap(Save* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(save_, other->save_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Save::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[29]);
}

// ===================================================================

class Include::_Internal {
 public:
};

Include::Include(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Include)
}
Include::Include(const Include& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_path(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Include)
}

inline void Include::SharedCtor() {
path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Include::~Include() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Include)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Include::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Include::ArenaDtor(void* object) {
  Include* _this = reinterpret_cast< Include* >(object);
  (void)_this;
}
void Include::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Include::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Include::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Include)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Include::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Include.path"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Include::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Include)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Include.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Include)
  return target;
}

size_t Include::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Include)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Include::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Include::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Include::GetClassData() const { return &_class_data_; }

void Include::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Include *>(to)->MergeFrom(
      static_cast<const Include &>(from));
}


void Include::MergeFrom(const Include& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Include)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _internal_set_path(from._internal_path());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Include::CopyFrom(const Include& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Include)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Include::IsInitialized() const {
  return true;
}

void Include::InternalSwap(Include* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &path_, lhs_arena,
      &other->path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Include::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[30]);
}

// ===================================================================

class LibInclude::_Internal {
 public:
};

LibInclude::LibInclude(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.LibInclude)
}
LibInclude::LibInclude(const LibInclude& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_path(), 
      GetArenaForAllocation());
  }
  section_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    section_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_section().empty()) {
    section_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_section(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.LibInclude)
}

inline void LibInclude::SharedCtor() {
path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
section_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  section_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibInclude::~LibInclude() {
  // @@protoc_insertion_point(destructor:vlsir.spice.LibInclude)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LibInclude::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  section_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LibInclude::ArenaDtor(void* object) {
  LibInclude* _this = reinterpret_cast< LibInclude* >(object);
  (void)_this;
}
void LibInclude::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LibInclude::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LibInclude::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.LibInclude)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_.ClearToEmpty();
  section_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibInclude::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.LibInclude.path"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_section();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.LibInclude.section"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibInclude::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.LibInclude)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.LibInclude.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // string section = 2;
  if (!this->_internal_section().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_section().data(), static_cast<int>(this->_internal_section().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.LibInclude.section");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_section(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.LibInclude)
  return target;
}

size_t LibInclude::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.LibInclude)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // string section = 2;
  if (!this->_internal_section().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_section());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibInclude::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LibInclude::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibInclude::GetClassData() const { return &_class_data_; }

void LibInclude::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LibInclude *>(to)->MergeFrom(
      static_cast<const LibInclude &>(from));
}


void LibInclude::MergeFrom(const LibInclude& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.LibInclude)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _internal_set_path(from._internal_path());
  }
  if (!from._internal_section().empty()) {
    _internal_set_section(from._internal_section());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibInclude::CopyFrom(const LibInclude& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.LibInclude)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibInclude::IsInitialized() const {
  return true;
}

void LibInclude::InternalSwap(LibInclude* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &path_, lhs_arena,
      &other->path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &section_, lhs_arena,
      &other->section_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LibInclude::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[31]);
}

// ===================================================================

class Meas::_Internal {
 public:
};

Meas::Meas(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Meas)
}
Meas::Meas(const Meas& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  analysis_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    analysis_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_type().empty()) {
    analysis_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_analysis_type(), 
      GetArenaForAllocation());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  expr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    expr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expr().empty()) {
    expr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_expr(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Meas)
}

inline void Meas::SharedCtor() {
analysis_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  analysis_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
expr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  expr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Meas::~Meas() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Meas)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Meas::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  analysis_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  expr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Meas::ArenaDtor(void* object) {
  Meas* _this = reinterpret_cast< Meas* >(object);
  (void)_this;
}
void Meas::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Meas::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Meas::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Meas)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  analysis_type_.ClearToEmpty();
  name_.ClearToEmpty();
  expr_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Meas::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string analysis_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_analysis_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Meas.analysis_type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Meas.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string expr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_expr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Meas.expr"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meas::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Meas)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string analysis_type = 1;
  if (!this->_internal_analysis_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_type().data(), static_cast<int>(this->_internal_analysis_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Meas.analysis_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_analysis_type(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Meas.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string expr = 3;
  if (!this->_internal_expr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_expr().data(), static_cast<int>(this->_internal_expr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Meas.expr");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_expr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Meas)
  return target;
}

size_t Meas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Meas)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string analysis_type = 1;
  if (!this->_internal_analysis_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_type());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string expr = 3;
  if (!this->_internal_expr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_expr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Meas::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Meas::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Meas::GetClassData() const { return &_class_data_; }

void Meas::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Meas *>(to)->MergeFrom(
      static_cast<const Meas &>(from));
}


void Meas::MergeFrom(const Meas& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Meas)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_analysis_type().empty()) {
    _internal_set_analysis_type(from._internal_analysis_type());
  }
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_expr().empty()) {
    _internal_set_expr(from._internal_expr());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Meas::CopyFrom(const Meas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Meas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meas::IsInitialized() const {
  return true;
}

void Meas::InternalSwap(Meas* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &analysis_type_, lhs_arena,
      &other->analysis_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &expr_, lhs_arena,
      &other->expr_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Meas::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[32]);
}

// ===================================================================

class Signal::_Internal {
 public:
};

Signal::Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:vlsir.spice.Signal)
}
Signal::Signal(const Signal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  quantity_ = from.quantity_;
  // @@protoc_insertion_point(copy_constructor:vlsir.spice.Signal)
}

inline void Signal::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
quantity_ = 0;
}

Signal::~Signal() {
  // @@protoc_insertion_point(destructor:vlsir.spice.Signal)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Signal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Signal::ArenaDtor(void* object) {
  Signal* _this = reinterpret_cast< Signal* >(object);
  (void)_this;
}
void Signal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Signal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Signal::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.spice.Signal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  quantity_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.spice.Signal.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.spice.Signal.Quantity quantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quantity(static_cast<::vlsir::spice::Signal_Quantity>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Signal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.spice.Signal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.spice.Signal.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.spice.Signal.Quantity quantity = 2;
  if (this->_internal_quantity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_quantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.spice.Signal)
  return target;
}

size_t Signal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.spice.Signal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.spice.Signal.Quantity quantity = 2;
  if (this->_internal_quantity() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quantity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Signal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signal::GetClassData() const { return &_class_data_; }

void Signal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Signal *>(to)->MergeFrom(
      static_cast<const Signal &>(from));
}


void Signal::MergeFrom(const Signal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.spice.Signal)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_quantity() != 0) {
    _internal_set_quantity(from._internal_quantity());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signal::CopyFrom(const Signal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.spice.Signal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signal::IsInitialized() const {
  return true;
}

void Signal::InternalSwap(Signal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(quantity_, other->quantity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Signal::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_spice_2eproto_getter, &descriptor_table_spice_2eproto_once,
      file_level_metadata_spice_2eproto[33]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace spice
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vlsir::spice::SimInput* Arena::CreateMaybeMessage< ::vlsir::spice::SimInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SimInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SimResult* Arena::CreateMaybeMessage< ::vlsir::spice::SimResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SimResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SimOptions* Arena::CreateMaybeMessage< ::vlsir::spice::SimOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SimOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Analysis* Arena::CreateMaybeMessage< ::vlsir::spice::Analysis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Analysis >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AnalysisResult* Arena::CreateMaybeMessage< ::vlsir::spice::AnalysisResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AnalysisResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::OpInput* Arena::CreateMaybeMessage< ::vlsir::spice::OpInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::OpInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::OpResult* Arena::CreateMaybeMessage< ::vlsir::spice::OpResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::OpResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::DcInput* Arena::CreateMaybeMessage< ::vlsir::spice::DcInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::DcInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage< ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::DcResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::DcResult* Arena::CreateMaybeMessage< ::vlsir::spice::DcResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::DcResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranInput_IcEntry_DoNotUse* Arena::CreateMaybeMessage< ::vlsir::spice::TranInput_IcEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranInput_IcEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranInput* Arena::CreateMaybeMessage< ::vlsir::spice::TranInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage< ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::TranResult* Arena::CreateMaybeMessage< ::vlsir::spice::TranResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::TranResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::ComplexNum* Arena::CreateMaybeMessage< ::vlsir::spice::ComplexNum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::ComplexNum >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AcInput* Arena::CreateMaybeMessage< ::vlsir::spice::AcInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AcInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse* Arena::CreateMaybeMessage< ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AcResult_MeasurementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::AcResult* Arena::CreateMaybeMessage< ::vlsir::spice::AcResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::AcResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SweepInput* Arena::CreateMaybeMessage< ::vlsir::spice::SweepInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SweepInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::SweepResult* Arena::CreateMaybeMessage< ::vlsir::spice::SweepResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::SweepResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::MonteInput* Arena::CreateMaybeMessage< ::vlsir::spice::MonteInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::MonteInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::MonteResult* Arena::CreateMaybeMessage< ::vlsir::spice::MonteResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::MonteResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::CustomAnalysisInput* Arena::CreateMaybeMessage< ::vlsir::spice::CustomAnalysisInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::CustomAnalysisInput >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::CustomAnalysisResult* Arena::CreateMaybeMessage< ::vlsir::spice::CustomAnalysisResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::CustomAnalysisResult >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Sweep* Arena::CreateMaybeMessage< ::vlsir::spice::Sweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Sweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::LinearSweep* Arena::CreateMaybeMessage< ::vlsir::spice::LinearSweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::LinearSweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::LogSweep* Arena::CreateMaybeMessage< ::vlsir::spice::LogSweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::LogSweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::PointSweep* Arena::CreateMaybeMessage< ::vlsir::spice::PointSweep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::PointSweep >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Control* Arena::CreateMaybeMessage< ::vlsir::spice::Control >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Control >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Save* Arena::CreateMaybeMessage< ::vlsir::spice::Save >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Save >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Include* Arena::CreateMaybeMessage< ::vlsir::spice::Include >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Include >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::LibInclude* Arena::CreateMaybeMessage< ::vlsir::spice::LibInclude >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::LibInclude >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Meas* Arena::CreateMaybeMessage< ::vlsir::spice::Meas >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Meas >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::spice::Signal* Arena::CreateMaybeMessage< ::vlsir::spice::Signal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::spice::Signal >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
