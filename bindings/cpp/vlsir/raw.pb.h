// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raw.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_raw_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_raw_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
#include "circuit.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_raw_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_raw_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_raw_2eproto;
namespace vlsir {
namespace raw {
class Abstract;
class AbstractDefaultTypeInternal;
extern AbstractDefaultTypeInternal _Abstract_default_instance_;
class AbstractPort;
class AbstractPortDefaultTypeInternal;
extern AbstractPortDefaultTypeInternal _AbstractPort_default_instance_;
class Cell;
class CellDefaultTypeInternal;
extern CellDefaultTypeInternal _Cell_default_instance_;
class Instance;
class InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Layer;
class LayerDefaultTypeInternal;
extern LayerDefaultTypeInternal _Layer_default_instance_;
class LayerShapes;
class LayerShapesDefaultTypeInternal;
extern LayerShapesDefaultTypeInternal _LayerShapes_default_instance_;
class Layout;
class LayoutDefaultTypeInternal;
extern LayoutDefaultTypeInternal _Layout_default_instance_;
class Library;
class LibraryDefaultTypeInternal;
extern LibraryDefaultTypeInternal _Library_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Rectangle;
class RectangleDefaultTypeInternal;
extern RectangleDefaultTypeInternal _Rectangle_default_instance_;
class TextElement;
class TextElementDefaultTypeInternal;
extern TextElementDefaultTypeInternal _TextElement_default_instance_;
}  // namespace raw
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::raw::Abstract* Arena::CreateMaybeMessage<::vlsir::raw::Abstract>(Arena*);
template<> ::vlsir::raw::AbstractPort* Arena::CreateMaybeMessage<::vlsir::raw::AbstractPort>(Arena*);
template<> ::vlsir::raw::Cell* Arena::CreateMaybeMessage<::vlsir::raw::Cell>(Arena*);
template<> ::vlsir::raw::Instance* Arena::CreateMaybeMessage<::vlsir::raw::Instance>(Arena*);
template<> ::vlsir::raw::Layer* Arena::CreateMaybeMessage<::vlsir::raw::Layer>(Arena*);
template<> ::vlsir::raw::LayerShapes* Arena::CreateMaybeMessage<::vlsir::raw::LayerShapes>(Arena*);
template<> ::vlsir::raw::Layout* Arena::CreateMaybeMessage<::vlsir::raw::Layout>(Arena*);
template<> ::vlsir::raw::Library* Arena::CreateMaybeMessage<::vlsir::raw::Library>(Arena*);
template<> ::vlsir::raw::Path* Arena::CreateMaybeMessage<::vlsir::raw::Path>(Arena*);
template<> ::vlsir::raw::Point* Arena::CreateMaybeMessage<::vlsir::raw::Point>(Arena*);
template<> ::vlsir::raw::Polygon* Arena::CreateMaybeMessage<::vlsir::raw::Polygon>(Arena*);
template<> ::vlsir::raw::Rectangle* Arena::CreateMaybeMessage<::vlsir::raw::Rectangle>(Arena*);
template<> ::vlsir::raw::TextElement* Arena::CreateMaybeMessage<::vlsir::raw::TextElement>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace raw {

enum Units : int {
  MICRO = 0,
  NANO = 1,
  ANGSTROM = 2,
  Units_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Units_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Units_IsValid(int value);
constexpr Units Units_MIN = MICRO;
constexpr Units Units_MAX = ANGSTROM;
constexpr int Units_ARRAYSIZE = Units_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Units_descriptor();
template<typename T>
inline const std::string& Units_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Units>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Units_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Units_descriptor(), enum_t_value);
}
inline bool Units_Parse(
    const std::string& name, Units* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Units>(
    Units_descriptor(), name, value);
}
// ===================================================================

class Point PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Point) */ {
 public:
  inline Point() : Point(nullptr) {};
  virtual ~Point();

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(nullptr);
  }

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int64 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int64 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int64 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 x_;
  ::PROTOBUF_NAMESPACE_ID::int64 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Layer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Layer) */ {
 public:
  inline Layer() : Layer(nullptr) {};
  virtual ~Layer();

  Layer(const Layer& from);
  Layer(Layer&& from) noexcept
    : Layer() {
    *this = ::std::move(from);
  }

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layer& operator=(Layer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Layer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Layer* internal_default_instance() {
    return reinterpret_cast<const Layer*>(
               &_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Layer& a, Layer& b) {
    a.Swap(&b);
  }
  inline void Swap(Layer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Layer* New() const final {
    return CreateMaybeMessage<Layer>(nullptr);
  }

  Layer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Layer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Layer";
  }
  protected:
  explicit Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kPurposeFieldNumber = 2,
  };
  // int64 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::int64 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 purpose = 2;
  void clear_purpose();
  ::PROTOBUF_NAMESPACE_ID::int64 purpose() const;
  void set_purpose(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_purpose() const;
  void _internal_set_purpose(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Layer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 number_;
  ::PROTOBUF_NAMESPACE_ID::int64 purpose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Rectangle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Rectangle) */ {
 public:
  inline Rectangle() : Rectangle(nullptr) {};
  virtual ~Rectangle();

  Rectangle(const Rectangle& from);
  Rectangle(Rectangle&& from) noexcept
    : Rectangle() {
    *this = ::std::move(from);
  }

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rectangle& operator=(Rectangle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Rectangle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rectangle* internal_default_instance() {
    return reinterpret_cast<const Rectangle*>(
               &_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Rectangle& a, Rectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Rectangle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rectangle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Rectangle* New() const final {
    return CreateMaybeMessage<Rectangle>(nullptr);
  }

  Rectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Rectangle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rectangle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Rectangle";
  }
  protected:
  explicit Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kLowerLeftFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string net = 1;
  void clear_net();
  const std::string& net() const;
  void set_net(const std::string& value);
  void set_net(std::string&& value);
  void set_net(const char* value);
  void set_net(const char* value, size_t size);
  std::string* mutable_net();
  std::string* release_net();
  void set_allocated_net(std::string* net);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_net();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_net(
      std::string* net);
  private:
  const std::string& _internal_net() const;
  void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // .vlsir.raw.Point lower_left = 2;
  bool has_lower_left() const;
  private:
  bool _internal_has_lower_left() const;
  public:
  void clear_lower_left();
  const ::vlsir::raw::Point& lower_left() const;
  ::vlsir::raw::Point* release_lower_left();
  ::vlsir::raw::Point* mutable_lower_left();
  void set_allocated_lower_left(::vlsir::raw::Point* lower_left);
  private:
  const ::vlsir::raw::Point& _internal_lower_left() const;
  ::vlsir::raw::Point* _internal_mutable_lower_left();
  public:
  void unsafe_arena_set_allocated_lower_left(
      ::vlsir::raw::Point* lower_left);
  ::vlsir::raw::Point* unsafe_arena_release_lower_left();

  // int64 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int64 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Rectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
  ::vlsir::raw::Point* lower_left_;
  ::PROTOBUF_NAMESPACE_ID::int64 width_;
  ::PROTOBUF_NAMESPACE_ID::int64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Polygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {};
  virtual ~Polygon();

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(nullptr);
  }

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 2,
    kNetFieldNumber = 1,
  };
  // repeated .vlsir.raw.Point vertices = 2;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::vlsir::raw::Point* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
      mutable_vertices();
  private:
  const ::vlsir::raw::Point& _internal_vertices(int index) const;
  ::vlsir::raw::Point* _internal_add_vertices();
  public:
  const ::vlsir::raw::Point& vertices(int index) const;
  ::vlsir::raw::Point* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
      vertices() const;

  // string net = 1;
  void clear_net();
  const std::string& net() const;
  void set_net(const std::string& value);
  void set_net(std::string&& value);
  void set_net(const char* value);
  void set_net(const char* value, size_t size);
  std::string* mutable_net();
  std::string* release_net();
  void set_allocated_net(std::string* net);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_net();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_net(
      std::string* net);
  private:
  const std::string& _internal_net() const;
  void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point > vertices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Path PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Path) */ {
 public:
  inline Path() : Path(nullptr) {};
  virtual ~Path();

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Path& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return CreateMaybeMessage<Path>(nullptr);
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kNetFieldNumber = 1,
    kWidthFieldNumber = 3,
  };
  // repeated .vlsir.raw.Point points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::vlsir::raw::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
      mutable_points();
  private:
  const ::vlsir::raw::Point& _internal_points(int index) const;
  ::vlsir::raw::Point* _internal_add_points();
  public:
  const ::vlsir::raw::Point& points(int index) const;
  ::vlsir::raw::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
      points() const;

  // string net = 1;
  void clear_net();
  const std::string& net() const;
  void set_net(const std::string& value);
  void set_net(std::string&& value);
  void set_net(const char* value);
  void set_net(const char* value, size_t size);
  std::string* mutable_net();
  std::string* release_net();
  void set_allocated_net(std::string* net);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_net();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_net(
      std::string* net);
  private:
  const std::string& _internal_net() const;
  void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // int64 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int64 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point > points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
  ::PROTOBUF_NAMESPACE_ID::int64 width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class LayerShapes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.LayerShapes) */ {
 public:
  inline LayerShapes() : LayerShapes(nullptr) {};
  virtual ~LayerShapes();

  LayerShapes(const LayerShapes& from);
  LayerShapes(LayerShapes&& from) noexcept
    : LayerShapes() {
    *this = ::std::move(from);
  }

  inline LayerShapes& operator=(const LayerShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerShapes& operator=(LayerShapes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LayerShapes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LayerShapes* internal_default_instance() {
    return reinterpret_cast<const LayerShapes*>(
               &_LayerShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LayerShapes& a, LayerShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerShapes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerShapes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LayerShapes* New() const final {
    return CreateMaybeMessage<LayerShapes>(nullptr);
  }

  LayerShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LayerShapes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LayerShapes& from);
  void MergeFrom(const LayerShapes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerShapes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.LayerShapes";
  }
  protected:
  explicit LayerShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRectanglesFieldNumber = 2,
    kPolygonsFieldNumber = 3,
    kPathsFieldNumber = 4,
    kLayerFieldNumber = 1,
  };
  // repeated .vlsir.raw.Rectangle rectangles = 2;
  int rectangles_size() const;
  private:
  int _internal_rectangles_size() const;
  public:
  void clear_rectangles();
  ::vlsir::raw::Rectangle* mutable_rectangles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >*
      mutable_rectangles();
  private:
  const ::vlsir::raw::Rectangle& _internal_rectangles(int index) const;
  ::vlsir::raw::Rectangle* _internal_add_rectangles();
  public:
  const ::vlsir::raw::Rectangle& rectangles(int index) const;
  ::vlsir::raw::Rectangle* add_rectangles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >&
      rectangles() const;

  // repeated .vlsir.raw.Polygon polygons = 3;
  int polygons_size() const;
  private:
  int _internal_polygons_size() const;
  public:
  void clear_polygons();
  ::vlsir::raw::Polygon* mutable_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >*
      mutable_polygons();
  private:
  const ::vlsir::raw::Polygon& _internal_polygons(int index) const;
  ::vlsir::raw::Polygon* _internal_add_polygons();
  public:
  const ::vlsir::raw::Polygon& polygons(int index) const;
  ::vlsir::raw::Polygon* add_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >&
      polygons() const;

  // repeated .vlsir.raw.Path paths = 4;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::vlsir::raw::Path* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >*
      mutable_paths();
  private:
  const ::vlsir::raw::Path& _internal_paths(int index) const;
  ::vlsir::raw::Path* _internal_add_paths();
  public:
  const ::vlsir::raw::Path& paths(int index) const;
  ::vlsir::raw::Path* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >&
      paths() const;

  // .vlsir.raw.Layer layer = 1;
  bool has_layer() const;
  private:
  bool _internal_has_layer() const;
  public:
  void clear_layer();
  const ::vlsir::raw::Layer& layer() const;
  ::vlsir::raw::Layer* release_layer();
  ::vlsir::raw::Layer* mutable_layer();
  void set_allocated_layer(::vlsir::raw::Layer* layer);
  private:
  const ::vlsir::raw::Layer& _internal_layer() const;
  ::vlsir::raw::Layer* _internal_mutable_layer();
  public:
  void unsafe_arena_set_allocated_layer(
      ::vlsir::raw::Layer* layer);
  ::vlsir::raw::Layer* unsafe_arena_release_layer();

  // @@protoc_insertion_point(class_scope:vlsir.raw.LayerShapes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle > rectangles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon > polygons_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path > paths_;
  ::vlsir::raw::Layer* layer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class TextElement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.TextElement) */ {
 public:
  inline TextElement() : TextElement(nullptr) {};
  virtual ~TextElement();

  TextElement(const TextElement& from);
  TextElement(TextElement&& from) noexcept
    : TextElement() {
    *this = ::std::move(from);
  }

  inline TextElement& operator=(const TextElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextElement& operator=(TextElement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextElement* internal_default_instance() {
    return reinterpret_cast<const TextElement*>(
               &_TextElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TextElement& a, TextElement& b) {
    a.Swap(&b);
  }
  inline void Swap(TextElement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextElement* New() const final {
    return CreateMaybeMessage<TextElement>(nullptr);
  }

  TextElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextElement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextElement& from);
  void MergeFrom(const TextElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextElement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.TextElement";
  }
  protected:
  explicit TextElement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringFieldNumber = 1,
    kLocFieldNumber = 2,
  };
  // string string = 1;
  void clear_string();
  const std::string& string() const;
  void set_string(const std::string& value);
  void set_string(std::string&& value);
  void set_string(const char* value);
  void set_string(const char* value, size_t size);
  std::string* mutable_string();
  std::string* release_string();
  void set_allocated_string(std::string* string);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_string();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_string(
      std::string* string);
  private:
  const std::string& _internal_string() const;
  void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  // .vlsir.raw.Point loc = 2;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::vlsir::raw::Point& loc() const;
  ::vlsir::raw::Point* release_loc();
  ::vlsir::raw::Point* mutable_loc();
  void set_allocated_loc(::vlsir::raw::Point* loc);
  private:
  const ::vlsir::raw::Point& _internal_loc() const;
  ::vlsir::raw::Point* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::vlsir::raw::Point* loc);
  ::vlsir::raw::Point* unsafe_arena_release_loc();

  // @@protoc_insertion_point(class_scope:vlsir.raw.TextElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
  ::vlsir::raw::Point* loc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Instance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {};
  virtual ~Instance();

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Instance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const final {
    return CreateMaybeMessage<Instance>(nullptr);
  }

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCellFieldNumber = 3,
    kOriginLocationFieldNumber = 4,
    kReflectVertFieldNumber = 6,
    kRotationClockwiseDegreesFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.utils.Reference cell = 3;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::vlsir::utils::Reference& cell() const;
  ::vlsir::utils::Reference* release_cell();
  ::vlsir::utils::Reference* mutable_cell();
  void set_allocated_cell(::vlsir::utils::Reference* cell);
  private:
  const ::vlsir::utils::Reference& _internal_cell() const;
  ::vlsir::utils::Reference* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::vlsir::utils::Reference* cell);
  ::vlsir::utils::Reference* unsafe_arena_release_cell();

  // .vlsir.raw.Point origin_location = 4;
  bool has_origin_location() const;
  private:
  bool _internal_has_origin_location() const;
  public:
  void clear_origin_location();
  const ::vlsir::raw::Point& origin_location() const;
  ::vlsir::raw::Point* release_origin_location();
  ::vlsir::raw::Point* mutable_origin_location();
  void set_allocated_origin_location(::vlsir::raw::Point* origin_location);
  private:
  const ::vlsir::raw::Point& _internal_origin_location() const;
  ::vlsir::raw::Point* _internal_mutable_origin_location();
  public:
  void unsafe_arena_set_allocated_origin_location(
      ::vlsir::raw::Point* origin_location);
  ::vlsir::raw::Point* unsafe_arena_release_origin_location();

  // bool reflect_vert = 6;
  void clear_reflect_vert();
  bool reflect_vert() const;
  void set_reflect_vert(bool value);
  private:
  bool _internal_reflect_vert() const;
  void _internal_set_reflect_vert(bool value);
  public:

  // int32 rotation_clockwise_degrees = 7;
  void clear_rotation_clockwise_degrees();
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_clockwise_degrees() const;
  void set_rotation_clockwise_degrees(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rotation_clockwise_degrees() const;
  void _internal_set_rotation_clockwise_degrees(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::utils::Reference* cell_;
  ::vlsir::raw::Point* origin_location_;
  bool reflect_vert_;
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_clockwise_degrees_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Layout PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Layout) */ {
 public:
  inline Layout() : Layout(nullptr) {};
  virtual ~Layout();

  Layout(const Layout& from);
  Layout(Layout&& from) noexcept
    : Layout() {
    *this = ::std::move(from);
  }

  inline Layout& operator=(const Layout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layout& operator=(Layout&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Layout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Layout* internal_default_instance() {
    return reinterpret_cast<const Layout*>(
               &_Layout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Layout& a, Layout& b) {
    a.Swap(&b);
  }
  inline void Swap(Layout* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Layout* New() const final {
    return CreateMaybeMessage<Layout>(nullptr);
  }

  Layout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Layout>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Layout& from);
  void MergeFrom(const Layout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Layout";
  }
  protected:
  explicit Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 2,
    kInstancesFieldNumber = 3,
    kAnnotationsFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.raw.LayerShapes shapes = 2;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::vlsir::raw::LayerShapes* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
      mutable_shapes();
  private:
  const ::vlsir::raw::LayerShapes& _internal_shapes(int index) const;
  ::vlsir::raw::LayerShapes* _internal_add_shapes();
  public:
  const ::vlsir::raw::LayerShapes& shapes(int index) const;
  ::vlsir::raw::LayerShapes* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
      shapes() const;

  // repeated .vlsir.raw.Instance instances = 3;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::raw::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >*
      mutable_instances();
  private:
  const ::vlsir::raw::Instance& _internal_instances(int index) const;
  ::vlsir::raw::Instance* _internal_add_instances();
  public:
  const ::vlsir::raw::Instance& instances(int index) const;
  ::vlsir::raw::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >&
      instances() const;

  // repeated .vlsir.raw.TextElement annotations = 4;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  ::vlsir::raw::TextElement* mutable_annotations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >*
      mutable_annotations();
  private:
  const ::vlsir::raw::TextElement& _internal_annotations(int index) const;
  ::vlsir::raw::TextElement* _internal_add_annotations();
  public:
  const ::vlsir::raw::TextElement& annotations(int index) const;
  ::vlsir::raw::TextElement* add_annotations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >&
      annotations() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Layout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes > shapes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance > instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement > annotations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Abstract PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Abstract) */ {
 public:
  inline Abstract() : Abstract(nullptr) {};
  virtual ~Abstract();

  Abstract(const Abstract& from);
  Abstract(Abstract&& from) noexcept
    : Abstract() {
    *this = ::std::move(from);
  }

  inline Abstract& operator=(const Abstract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Abstract& operator=(Abstract&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Abstract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Abstract* internal_default_instance() {
    return reinterpret_cast<const Abstract*>(
               &_Abstract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Abstract& a, Abstract& b) {
    a.Swap(&b);
  }
  inline void Swap(Abstract* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Abstract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Abstract* New() const final {
    return CreateMaybeMessage<Abstract>(nullptr);
  }

  Abstract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Abstract>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Abstract& from);
  void MergeFrom(const Abstract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Abstract* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Abstract";
  }
  protected:
  explicit Abstract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 4,
    kBlockagesFieldNumber = 5,
    kNameFieldNumber = 1,
    kOutlineFieldNumber = 2,
  };
  // repeated .vlsir.raw.AbstractPort ports = 4;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::raw::AbstractPort* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >*
      mutable_ports();
  private:
  const ::vlsir::raw::AbstractPort& _internal_ports(int index) const;
  ::vlsir::raw::AbstractPort* _internal_add_ports();
  public:
  const ::vlsir::raw::AbstractPort& ports(int index) const;
  ::vlsir::raw::AbstractPort* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >&
      ports() const;

  // repeated .vlsir.raw.LayerShapes blockages = 5;
  int blockages_size() const;
  private:
  int _internal_blockages_size() const;
  public:
  void clear_blockages();
  ::vlsir::raw::LayerShapes* mutable_blockages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
      mutable_blockages();
  private:
  const ::vlsir::raw::LayerShapes& _internal_blockages(int index) const;
  ::vlsir::raw::LayerShapes* _internal_add_blockages();
  public:
  const ::vlsir::raw::LayerShapes& blockages(int index) const;
  ::vlsir::raw::LayerShapes* add_blockages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
      blockages() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.raw.Polygon outline = 2;
  bool has_outline() const;
  private:
  bool _internal_has_outline() const;
  public:
  void clear_outline();
  const ::vlsir::raw::Polygon& outline() const;
  ::vlsir::raw::Polygon* release_outline();
  ::vlsir::raw::Polygon* mutable_outline();
  void set_allocated_outline(::vlsir::raw::Polygon* outline);
  private:
  const ::vlsir::raw::Polygon& _internal_outline() const;
  ::vlsir::raw::Polygon* _internal_mutable_outline();
  public:
  void unsafe_arena_set_allocated_outline(
      ::vlsir::raw::Polygon* outline);
  ::vlsir::raw::Polygon* unsafe_arena_release_outline();

  // @@protoc_insertion_point(class_scope:vlsir.raw.Abstract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort > ports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes > blockages_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::raw::Polygon* outline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class AbstractPort PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.AbstractPort) */ {
 public:
  inline AbstractPort() : AbstractPort(nullptr) {};
  virtual ~AbstractPort();

  AbstractPort(const AbstractPort& from);
  AbstractPort(AbstractPort&& from) noexcept
    : AbstractPort() {
    *this = ::std::move(from);
  }

  inline AbstractPort& operator=(const AbstractPort& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbstractPort& operator=(AbstractPort&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbstractPort& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbstractPort* internal_default_instance() {
    return reinterpret_cast<const AbstractPort*>(
               &_AbstractPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AbstractPort& a, AbstractPort& b) {
    a.Swap(&b);
  }
  inline void Swap(AbstractPort* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbstractPort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbstractPort* New() const final {
    return CreateMaybeMessage<AbstractPort>(nullptr);
  }

  AbstractPort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbstractPort>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbstractPort& from);
  void MergeFrom(const AbstractPort& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbstractPort* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.AbstractPort";
  }
  protected:
  explicit AbstractPort(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 2,
    kNetFieldNumber = 1,
  };
  // repeated .vlsir.raw.LayerShapes shapes = 2;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::vlsir::raw::LayerShapes* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
      mutable_shapes();
  private:
  const ::vlsir::raw::LayerShapes& _internal_shapes(int index) const;
  ::vlsir::raw::LayerShapes* _internal_add_shapes();
  public:
  const ::vlsir::raw::LayerShapes& shapes(int index) const;
  ::vlsir::raw::LayerShapes* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
      shapes() const;

  // string net = 1;
  void clear_net();
  const std::string& net() const;
  void set_net(const std::string& value);
  void set_net(std::string&& value);
  void set_net(const char* value);
  void set_net(const char* value, size_t size);
  std::string* mutable_net();
  std::string* release_net();
  void set_allocated_net(std::string* net);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_net();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_net(
      std::string* net);
  private:
  const std::string& _internal_net() const;
  void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.AbstractPort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes > shapes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Cell PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Cell) */ {
 public:
  inline Cell() : Cell(nullptr) {};
  virtual ~Cell();

  Cell(const Cell& from);
  Cell(Cell&& from) noexcept
    : Cell() {
    *this = ::std::move(from);
  }

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cell& operator=(Cell&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cell* internal_default_instance() {
    return reinterpret_cast<const Cell*>(
               &_Cell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Cell& a, Cell& b) {
    a.Swap(&b);
  }
  inline void Swap(Cell* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cell* New() const final {
    return CreateMaybeMessage<Cell>(nullptr);
  }

  Cell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cell>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cell* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Cell";
  }
  protected:
  explicit Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kInterfaceFieldNumber = 10,
    kModuleFieldNumber = 11,
    kAbstractFieldNumber = 12,
    kLayoutFieldNumber = 13,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.circuit.Interface interface = 10;
  bool has_interface() const;
  private:
  bool _internal_has_interface() const;
  public:
  void clear_interface();
  const ::vlsir::circuit::Interface& interface() const;
  ::vlsir::circuit::Interface* release_interface();
  ::vlsir::circuit::Interface* mutable_interface();
  void set_allocated_interface(::vlsir::circuit::Interface* interface);
  private:
  const ::vlsir::circuit::Interface& _internal_interface() const;
  ::vlsir::circuit::Interface* _internal_mutable_interface();
  public:
  void unsafe_arena_set_allocated_interface(
      ::vlsir::circuit::Interface* interface);
  ::vlsir::circuit::Interface* unsafe_arena_release_interface();

  // .vlsir.circuit.Module module = 11;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::vlsir::circuit::Module& module() const;
  ::vlsir::circuit::Module* release_module();
  ::vlsir::circuit::Module* mutable_module();
  void set_allocated_module(::vlsir::circuit::Module* module);
  private:
  const ::vlsir::circuit::Module& _internal_module() const;
  ::vlsir::circuit::Module* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::vlsir::circuit::Module* module);
  ::vlsir::circuit::Module* unsafe_arena_release_module();

  // .vlsir.raw.Abstract abstract = 12;
  bool has_abstract() const;
  private:
  bool _internal_has_abstract() const;
  public:
  void clear_abstract();
  const ::vlsir::raw::Abstract& abstract() const;
  ::vlsir::raw::Abstract* release_abstract();
  ::vlsir::raw::Abstract* mutable_abstract();
  void set_allocated_abstract(::vlsir::raw::Abstract* abstract);
  private:
  const ::vlsir::raw::Abstract& _internal_abstract() const;
  ::vlsir::raw::Abstract* _internal_mutable_abstract();
  public:
  void unsafe_arena_set_allocated_abstract(
      ::vlsir::raw::Abstract* abstract);
  ::vlsir::raw::Abstract* unsafe_arena_release_abstract();

  // .vlsir.raw.Layout layout = 13;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const ::vlsir::raw::Layout& layout() const;
  ::vlsir::raw::Layout* release_layout();
  ::vlsir::raw::Layout* mutable_layout();
  void set_allocated_layout(::vlsir::raw::Layout* layout);
  private:
  const ::vlsir::raw::Layout& _internal_layout() const;
  ::vlsir::raw::Layout* _internal_mutable_layout();
  public:
  void unsafe_arena_set_allocated_layout(
      ::vlsir::raw::Layout* layout);
  ::vlsir::raw::Layout* unsafe_arena_release_layout();

  // @@protoc_insertion_point(class_scope:vlsir.raw.Cell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vlsir::circuit::Interface* interface_;
  ::vlsir::circuit::Module* module_;
  ::vlsir::raw::Abstract* abstract_;
  ::vlsir::raw::Layout* layout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// -------------------------------------------------------------------

class Library PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Library) */ {
 public:
  inline Library() : Library(nullptr) {};
  virtual ~Library();

  Library(const Library& from);
  Library(Library&& from) noexcept
    : Library() {
    *this = ::std::move(from);
  }

  inline Library& operator=(const Library& from) {
    CopyFrom(from);
    return *this;
  }
  inline Library& operator=(Library&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Library& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Library* internal_default_instance() {
    return reinterpret_cast<const Library*>(
               &_Library_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Library& a, Library& b) {
    a.Swap(&b);
  }
  inline void Swap(Library* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Library* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Library* New() const final {
    return CreateMaybeMessage<Library>(nullptr);
  }

  Library* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Library>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Library& from);
  void MergeFrom(const Library& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Library* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Library";
  }
  protected:
  explicit Library(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_raw_2eproto);
    return ::descriptor_table_raw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellsFieldNumber = 10,
    kDomainFieldNumber = 1,
    kAuthorFieldNumber = 20,
    kUnitsFieldNumber = 2,
  };
  // repeated .vlsir.raw.Cell cells = 10;
  int cells_size() const;
  private:
  int _internal_cells_size() const;
  public:
  void clear_cells();
  ::vlsir::raw::Cell* mutable_cells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >*
      mutable_cells();
  private:
  const ::vlsir::raw::Cell& _internal_cells(int index) const;
  ::vlsir::raw::Cell* _internal_add_cells();
  public:
  const ::vlsir::raw::Cell& cells(int index) const;
  ::vlsir::raw::Cell* add_cells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >&
      cells() const;

  // string domain = 1;
  void clear_domain();
  const std::string& domain() const;
  void set_domain(const std::string& value);
  void set_domain(std::string&& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  std::string* mutable_domain();
  std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_domain();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_domain(
      std::string* domain);
  private:
  const std::string& _internal_domain() const;
  void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // .vlsir.utils.AuthorMetadata author = 20;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const ::vlsir::utils::AuthorMetadata& author() const;
  ::vlsir::utils::AuthorMetadata* release_author();
  ::vlsir::utils::AuthorMetadata* mutable_author();
  void set_allocated_author(::vlsir::utils::AuthorMetadata* author);
  private:
  const ::vlsir::utils::AuthorMetadata& _internal_author() const;
  ::vlsir::utils::AuthorMetadata* _internal_mutable_author();
  public:
  void unsafe_arena_set_allocated_author(
      ::vlsir::utils::AuthorMetadata* author);
  ::vlsir::utils::AuthorMetadata* unsafe_arena_release_author();

  // .vlsir.raw.Units units = 2;
  void clear_units();
  ::vlsir::raw::Units units() const;
  void set_units(::vlsir::raw::Units value);
  private:
  ::vlsir::raw::Units _internal_units() const;
  void _internal_set_units(::vlsir::raw::Units value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Library)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell > cells_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::vlsir::utils::AuthorMetadata* author_;
  int units_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raw_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// int64 x = 1;
inline void Point::clear_x() {
  x_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Point::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Point::x() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  x_ = value;
}
inline void Point::set_x(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Point.x)
}

// int64 y = 2;
inline void Point::clear_y() {
  y_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Point::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Point::y() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  y_ = value;
}
inline void Point::set_y(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Point.y)
}

// -------------------------------------------------------------------

// Layer

// int64 number = 1;
inline void Layer::clear_number() {
  number_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Layer::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Layer::number() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layer.number)
  return _internal_number();
}
inline void Layer::_internal_set_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  number_ = value;
}
inline void Layer::set_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Layer.number)
}

// int64 purpose = 2;
inline void Layer::clear_purpose() {
  purpose_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Layer::_internal_purpose() const {
  return purpose_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Layer::purpose() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layer.purpose)
  return _internal_purpose();
}
inline void Layer::_internal_set_purpose(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  purpose_ = value;
}
inline void Layer::set_purpose(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_purpose(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Layer.purpose)
}

// -------------------------------------------------------------------

// Rectangle

// string net = 1;
inline void Rectangle::clear_net() {
  net_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Rectangle::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.net)
  return _internal_net();
}
inline void Rectangle::set_net(const std::string& value) {
  _internal_set_net(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Rectangle.net)
}
inline std::string* Rectangle::mutable_net() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Rectangle.net)
  return _internal_mutable_net();
}
inline const std::string& Rectangle::_internal_net() const {
  return net_.Get();
}
inline void Rectangle::_internal_set_net(const std::string& value) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Rectangle::set_net(std::string&& value) {
  
  net_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Rectangle.net)
}
inline void Rectangle::set_net(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Rectangle.net)
}
inline void Rectangle::set_net(const char* value,
    size_t size) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Rectangle.net)
}
inline std::string* Rectangle::_internal_mutable_net() {
  
  return net_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Rectangle::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Rectangle.net)
  return net_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Rectangle::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  net_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), net,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Rectangle.net)
}
inline std::string* Rectangle::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Rectangle.net)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return net_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Rectangle::unsafe_arena_set_allocated_net(
    std::string* net) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (net != nullptr) {
    
  } else {
    
  }
  net_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      net, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Rectangle.net)
}

// .vlsir.raw.Point lower_left = 2;
inline bool Rectangle::_internal_has_lower_left() const {
  return this != internal_default_instance() && lower_left_ != nullptr;
}
inline bool Rectangle::has_lower_left() const {
  return _internal_has_lower_left();
}
inline void Rectangle::clear_lower_left() {
  if (GetArena() == nullptr && lower_left_ != nullptr) {
    delete lower_left_;
  }
  lower_left_ = nullptr;
}
inline const ::vlsir::raw::Point& Rectangle::_internal_lower_left() const {
  const ::vlsir::raw::Point* p = lower_left_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Point*>(
      &::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& Rectangle::lower_left() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.lower_left)
  return _internal_lower_left();
}
inline void Rectangle::unsafe_arena_set_allocated_lower_left(
    ::vlsir::raw::Point* lower_left) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lower_left_);
  }
  lower_left_ = lower_left;
  if (lower_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Rectangle.lower_left)
}
inline ::vlsir::raw::Point* Rectangle::release_lower_left() {
  auto temp = unsafe_arena_release_lower_left();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Point* Rectangle::unsafe_arena_release_lower_left() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Rectangle.lower_left)
  
  ::vlsir::raw::Point* temp = lower_left_;
  lower_left_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Point* Rectangle::_internal_mutable_lower_left() {
  
  if (lower_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Point>(GetArena());
    lower_left_ = p;
  }
  return lower_left_;
}
inline ::vlsir::raw::Point* Rectangle::mutable_lower_left() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Rectangle.lower_left)
  return _internal_mutable_lower_left();
}
inline void Rectangle::set_allocated_lower_left(::vlsir::raw::Point* lower_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lower_left_;
  }
  if (lower_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lower_left);
    if (message_arena != submessage_arena) {
      lower_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lower_left, submessage_arena);
    }
    
  } else {
    
  }
  lower_left_ = lower_left;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Rectangle.lower_left)
}

// int64 width = 3;
inline void Rectangle::clear_width() {
  width_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Rectangle::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Rectangle::width() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.width)
  return _internal_width();
}
inline void Rectangle::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  width_ = value;
}
inline void Rectangle::set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Rectangle.width)
}

// int64 height = 4;
inline void Rectangle::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Rectangle::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Rectangle::height() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.height)
  return _internal_height();
}
inline void Rectangle::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  height_ = value;
}
inline void Rectangle::set_height(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Rectangle.height)
}

// -------------------------------------------------------------------

// Polygon

// string net = 1;
inline void Polygon::clear_net() {
  net_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Polygon::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Polygon.net)
  return _internal_net();
}
inline void Polygon::set_net(const std::string& value) {
  _internal_set_net(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Polygon.net)
}
inline std::string* Polygon::mutable_net() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Polygon.net)
  return _internal_mutable_net();
}
inline const std::string& Polygon::_internal_net() const {
  return net_.Get();
}
inline void Polygon::_internal_set_net(const std::string& value) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Polygon::set_net(std::string&& value) {
  
  net_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Polygon.net)
}
inline void Polygon::set_net(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Polygon.net)
}
inline void Polygon::set_net(const char* value,
    size_t size) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Polygon.net)
}
inline std::string* Polygon::_internal_mutable_net() {
  
  return net_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Polygon::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Polygon.net)
  return net_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Polygon::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  net_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), net,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Polygon.net)
}
inline std::string* Polygon::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Polygon.net)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return net_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Polygon::unsafe_arena_set_allocated_net(
    std::string* net) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (net != nullptr) {
    
  } else {
    
  }
  net_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      net, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Polygon.net)
}

// repeated .vlsir.raw.Point vertices = 2;
inline int Polygon::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Polygon::vertices_size() const {
  return _internal_vertices_size();
}
inline void Polygon::clear_vertices() {
  vertices_.Clear();
}
inline ::vlsir::raw::Point* Polygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Polygon.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
Polygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Polygon.vertices)
  return &vertices_;
}
inline const ::vlsir::raw::Point& Polygon::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::vlsir::raw::Point& Polygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Polygon.vertices)
  return _internal_vertices(index);
}
inline ::vlsir::raw::Point* Polygon::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::vlsir::raw::Point* Polygon::add_vertices() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Polygon.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
Polygon::vertices() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Polygon.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// Path

// string net = 1;
inline void Path::clear_net() {
  net_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Path::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Path.net)
  return _internal_net();
}
inline void Path::set_net(const std::string& value) {
  _internal_set_net(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Path.net)
}
inline std::string* Path::mutable_net() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Path.net)
  return _internal_mutable_net();
}
inline const std::string& Path::_internal_net() const {
  return net_.Get();
}
inline void Path::_internal_set_net(const std::string& value) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Path::set_net(std::string&& value) {
  
  net_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Path.net)
}
inline void Path::set_net(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Path.net)
}
inline void Path::set_net(const char* value,
    size_t size) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Path.net)
}
inline std::string* Path::_internal_mutable_net() {
  
  return net_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Path::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Path.net)
  return net_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Path::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  net_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), net,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Path.net)
}
inline std::string* Path::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Path.net)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return net_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Path::unsafe_arena_set_allocated_net(
    std::string* net) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (net != nullptr) {
    
  } else {
    
  }
  net_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      net, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Path.net)
}

// repeated .vlsir.raw.Point points = 2;
inline int Path::_internal_points_size() const {
  return points_.size();
}
inline int Path::points_size() const {
  return _internal_points_size();
}
inline void Path::clear_points() {
  points_.Clear();
}
inline ::vlsir::raw::Point* Path::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Path.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
Path::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Path.points)
  return &points_;
}
inline const ::vlsir::raw::Point& Path::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::vlsir::raw::Point& Path::points(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Path.points)
  return _internal_points(index);
}
inline ::vlsir::raw::Point* Path::_internal_add_points() {
  return points_.Add();
}
inline ::vlsir::raw::Point* Path::add_points() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Path.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
Path::points() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Path.points)
  return points_;
}

// int64 width = 3;
inline void Path::clear_width() {
  width_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Path::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Path::width() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Path.width)
  return _internal_width();
}
inline void Path::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  width_ = value;
}
inline void Path::set_width(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Path.width)
}

// -------------------------------------------------------------------

// LayerShapes

// .vlsir.raw.Layer layer = 1;
inline bool LayerShapes::_internal_has_layer() const {
  return this != internal_default_instance() && layer_ != nullptr;
}
inline bool LayerShapes::has_layer() const {
  return _internal_has_layer();
}
inline void LayerShapes::clear_layer() {
  if (GetArena() == nullptr && layer_ != nullptr) {
    delete layer_;
  }
  layer_ = nullptr;
}
inline const ::vlsir::raw::Layer& LayerShapes::_internal_layer() const {
  const ::vlsir::raw::Layer* p = layer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Layer*>(
      &::vlsir::raw::_Layer_default_instance_);
}
inline const ::vlsir::raw::Layer& LayerShapes::layer() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.layer)
  return _internal_layer();
}
inline void LayerShapes::unsafe_arena_set_allocated_layer(
    ::vlsir::raw::Layer* layer) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(layer_);
  }
  layer_ = layer;
  if (layer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.LayerShapes.layer)
}
inline ::vlsir::raw::Layer* LayerShapes::release_layer() {
  auto temp = unsafe_arena_release_layer();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Layer* LayerShapes::unsafe_arena_release_layer() {
  // @@protoc_insertion_point(field_release:vlsir.raw.LayerShapes.layer)
  
  ::vlsir::raw::Layer* temp = layer_;
  layer_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layer* LayerShapes::_internal_mutable_layer() {
  
  if (layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layer>(GetArena());
    layer_ = p;
  }
  return layer_;
}
inline ::vlsir::raw::Layer* LayerShapes::mutable_layer() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.layer)
  return _internal_mutable_layer();
}
inline void LayerShapes::set_allocated_layer(::vlsir::raw::Layer* layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete layer_;
  }
  if (layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(layer);
    if (message_arena != submessage_arena) {
      layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer, submessage_arena);
    }
    
  } else {
    
  }
  layer_ = layer;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.LayerShapes.layer)
}

// repeated .vlsir.raw.Rectangle rectangles = 2;
inline int LayerShapes::_internal_rectangles_size() const {
  return rectangles_.size();
}
inline int LayerShapes::rectangles_size() const {
  return _internal_rectangles_size();
}
inline void LayerShapes::clear_rectangles() {
  rectangles_.Clear();
}
inline ::vlsir::raw::Rectangle* LayerShapes::mutable_rectangles(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.rectangles)
  return rectangles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >*
LayerShapes::mutable_rectangles() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.LayerShapes.rectangles)
  return &rectangles_;
}
inline const ::vlsir::raw::Rectangle& LayerShapes::_internal_rectangles(int index) const {
  return rectangles_.Get(index);
}
inline const ::vlsir::raw::Rectangle& LayerShapes::rectangles(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.rectangles)
  return _internal_rectangles(index);
}
inline ::vlsir::raw::Rectangle* LayerShapes::_internal_add_rectangles() {
  return rectangles_.Add();
}
inline ::vlsir::raw::Rectangle* LayerShapes::add_rectangles() {
  // @@protoc_insertion_point(field_add:vlsir.raw.LayerShapes.rectangles)
  return _internal_add_rectangles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >&
LayerShapes::rectangles() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.LayerShapes.rectangles)
  return rectangles_;
}

// repeated .vlsir.raw.Polygon polygons = 3;
inline int LayerShapes::_internal_polygons_size() const {
  return polygons_.size();
}
inline int LayerShapes::polygons_size() const {
  return _internal_polygons_size();
}
inline void LayerShapes::clear_polygons() {
  polygons_.Clear();
}
inline ::vlsir::raw::Polygon* LayerShapes::mutable_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.polygons)
  return polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >*
LayerShapes::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.LayerShapes.polygons)
  return &polygons_;
}
inline const ::vlsir::raw::Polygon& LayerShapes::_internal_polygons(int index) const {
  return polygons_.Get(index);
}
inline const ::vlsir::raw::Polygon& LayerShapes::polygons(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.polygons)
  return _internal_polygons(index);
}
inline ::vlsir::raw::Polygon* LayerShapes::_internal_add_polygons() {
  return polygons_.Add();
}
inline ::vlsir::raw::Polygon* LayerShapes::add_polygons() {
  // @@protoc_insertion_point(field_add:vlsir.raw.LayerShapes.polygons)
  return _internal_add_polygons();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >&
LayerShapes::polygons() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.LayerShapes.polygons)
  return polygons_;
}

// repeated .vlsir.raw.Path paths = 4;
inline int LayerShapes::_internal_paths_size() const {
  return paths_.size();
}
inline int LayerShapes::paths_size() const {
  return _internal_paths_size();
}
inline void LayerShapes::clear_paths() {
  paths_.Clear();
}
inline ::vlsir::raw::Path* LayerShapes::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.paths)
  return paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >*
LayerShapes::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.LayerShapes.paths)
  return &paths_;
}
inline const ::vlsir::raw::Path& LayerShapes::_internal_paths(int index) const {
  return paths_.Get(index);
}
inline const ::vlsir::raw::Path& LayerShapes::paths(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.paths)
  return _internal_paths(index);
}
inline ::vlsir::raw::Path* LayerShapes::_internal_add_paths() {
  return paths_.Add();
}
inline ::vlsir::raw::Path* LayerShapes::add_paths() {
  // @@protoc_insertion_point(field_add:vlsir.raw.LayerShapes.paths)
  return _internal_add_paths();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >&
LayerShapes::paths() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.LayerShapes.paths)
  return paths_;
}

// -------------------------------------------------------------------

// TextElement

// string string = 1;
inline void TextElement::clear_string() {
  string_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TextElement::string() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.TextElement.string)
  return _internal_string();
}
inline void TextElement::set_string(const std::string& value) {
  _internal_set_string(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.TextElement.string)
}
inline std::string* TextElement::mutable_string() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.TextElement.string)
  return _internal_mutable_string();
}
inline const std::string& TextElement::_internal_string() const {
  return string_.Get();
}
inline void TextElement::_internal_set_string(const std::string& value) {
  
  string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextElement::set_string(std::string&& value) {
  
  string_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.TextElement.string)
}
inline void TextElement::set_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.TextElement.string)
}
inline void TextElement::set_string(const char* value,
    size_t size) {
  
  string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.TextElement.string)
}
inline std::string* TextElement::_internal_mutable_string() {
  
  return string_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextElement::release_string() {
  // @@protoc_insertion_point(field_release:vlsir.raw.TextElement.string)
  return string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextElement::set_allocated_string(std::string* string) {
  if (string != nullptr) {
    
  } else {
    
  }
  string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.TextElement.string)
}
inline std::string* TextElement::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.TextElement.string)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return string_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TextElement::unsafe_arena_set_allocated_string(
    std::string* string) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (string != nullptr) {
    
  } else {
    
  }
  string_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      string, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.TextElement.string)
}

// .vlsir.raw.Point loc = 2;
inline bool TextElement::_internal_has_loc() const {
  return this != internal_default_instance() && loc_ != nullptr;
}
inline bool TextElement::has_loc() const {
  return _internal_has_loc();
}
inline void TextElement::clear_loc() {
  if (GetArena() == nullptr && loc_ != nullptr) {
    delete loc_;
  }
  loc_ = nullptr;
}
inline const ::vlsir::raw::Point& TextElement::_internal_loc() const {
  const ::vlsir::raw::Point* p = loc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Point*>(
      &::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& TextElement::loc() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.TextElement.loc)
  return _internal_loc();
}
inline void TextElement::unsafe_arena_set_allocated_loc(
    ::vlsir::raw::Point* loc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(loc_);
  }
  loc_ = loc;
  if (loc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.TextElement.loc)
}
inline ::vlsir::raw::Point* TextElement::release_loc() {
  auto temp = unsafe_arena_release_loc();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Point* TextElement::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:vlsir.raw.TextElement.loc)
  
  ::vlsir::raw::Point* temp = loc_;
  loc_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Point* TextElement::_internal_mutable_loc() {
  
  if (loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Point>(GetArena());
    loc_ = p;
  }
  return loc_;
}
inline ::vlsir::raw::Point* TextElement::mutable_loc() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.TextElement.loc)
  return _internal_mutable_loc();
}
inline void TextElement::set_allocated_loc(::vlsir::raw::Point* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    
  } else {
    
  }
  loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.TextElement.loc)
}

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.name)
  return _internal_name();
}
inline void Instance::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Instance.name)
}
inline std::string* Instance::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Instance.name)
  return _internal_mutable_name();
}
inline const std::string& Instance::_internal_name() const {
  return name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Instance::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Instance.name)
}
inline void Instance::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Instance.name)
}
inline void Instance::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Instance.name)
}
inline std::string* Instance::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Instance.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Instance.name)
}
inline std::string* Instance::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Instance.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Instance::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Instance.name)
}

// .vlsir.utils.Reference cell = 3;
inline bool Instance::_internal_has_cell() const {
  return this != internal_default_instance() && cell_ != nullptr;
}
inline bool Instance::has_cell() const {
  return _internal_has_cell();
}
inline const ::vlsir::utils::Reference& Instance::_internal_cell() const {
  const ::vlsir::utils::Reference* p = cell_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::utils::Reference*>(
      &::vlsir::utils::_Reference_default_instance_);
}
inline const ::vlsir::utils::Reference& Instance::cell() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.cell)
  return _internal_cell();
}
inline void Instance::unsafe_arena_set_allocated_cell(
    ::vlsir::utils::Reference* cell) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_);
  }
  cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Instance.cell)
}
inline ::vlsir::utils::Reference* Instance::release_cell() {
  auto temp = unsafe_arena_release_cell();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::utils::Reference* Instance::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Instance.cell)
  
  ::vlsir::utils::Reference* temp = cell_;
  cell_ = nullptr;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::_internal_mutable_cell() {
  
  if (cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArena());
    cell_ = p;
  }
  return cell_;
}
inline ::vlsir::utils::Reference* Instance::mutable_cell() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Instance.cell)
  return _internal_mutable_cell();
}
inline void Instance::set_allocated_cell(::vlsir::utils::Reference* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell)->GetArena();
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Instance.cell)
}

// .vlsir.raw.Point origin_location = 4;
inline bool Instance::_internal_has_origin_location() const {
  return this != internal_default_instance() && origin_location_ != nullptr;
}
inline bool Instance::has_origin_location() const {
  return _internal_has_origin_location();
}
inline void Instance::clear_origin_location() {
  if (GetArena() == nullptr && origin_location_ != nullptr) {
    delete origin_location_;
  }
  origin_location_ = nullptr;
}
inline const ::vlsir::raw::Point& Instance::_internal_origin_location() const {
  const ::vlsir::raw::Point* p = origin_location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Point*>(
      &::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& Instance::origin_location() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.origin_location)
  return _internal_origin_location();
}
inline void Instance::unsafe_arena_set_allocated_origin_location(
    ::vlsir::raw::Point* origin_location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_location_);
  }
  origin_location_ = origin_location;
  if (origin_location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Instance.origin_location)
}
inline ::vlsir::raw::Point* Instance::release_origin_location() {
  auto temp = unsafe_arena_release_origin_location();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Point* Instance::unsafe_arena_release_origin_location() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Instance.origin_location)
  
  ::vlsir::raw::Point* temp = origin_location_;
  origin_location_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Point* Instance::_internal_mutable_origin_location() {
  
  if (origin_location_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Point>(GetArena());
    origin_location_ = p;
  }
  return origin_location_;
}
inline ::vlsir::raw::Point* Instance::mutable_origin_location() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Instance.origin_location)
  return _internal_mutable_origin_location();
}
inline void Instance::set_allocated_origin_location(::vlsir::raw::Point* origin_location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete origin_location_;
  }
  if (origin_location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(origin_location);
    if (message_arena != submessage_arena) {
      origin_location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin_location, submessage_arena);
    }
    
  } else {
    
  }
  origin_location_ = origin_location;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Instance.origin_location)
}

// bool reflect_vert = 6;
inline void Instance::clear_reflect_vert() {
  reflect_vert_ = false;
}
inline bool Instance::_internal_reflect_vert() const {
  return reflect_vert_;
}
inline bool Instance::reflect_vert() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.reflect_vert)
  return _internal_reflect_vert();
}
inline void Instance::_internal_set_reflect_vert(bool value) {
  
  reflect_vert_ = value;
}
inline void Instance::set_reflect_vert(bool value) {
  _internal_set_reflect_vert(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Instance.reflect_vert)
}

// int32 rotation_clockwise_degrees = 7;
inline void Instance::clear_rotation_clockwise_degrees() {
  rotation_clockwise_degrees_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Instance::_internal_rotation_clockwise_degrees() const {
  return rotation_clockwise_degrees_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Instance::rotation_clockwise_degrees() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.rotation_clockwise_degrees)
  return _internal_rotation_clockwise_degrees();
}
inline void Instance::_internal_set_rotation_clockwise_degrees(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rotation_clockwise_degrees_ = value;
}
inline void Instance::set_rotation_clockwise_degrees(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rotation_clockwise_degrees(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Instance.rotation_clockwise_degrees)
}

// -------------------------------------------------------------------

// Layout

// string name = 1;
inline void Layout::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Layout::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.name)
  return _internal_name();
}
inline void Layout::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Layout.name)
}
inline std::string* Layout::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.name)
  return _internal_mutable_name();
}
inline const std::string& Layout::_internal_name() const {
  return name_.Get();
}
inline void Layout::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Layout::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Layout.name)
}
inline void Layout::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Layout.name)
}
inline void Layout::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Layout.name)
}
inline std::string* Layout::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Layout::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Layout.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Layout::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Layout.name)
}
inline std::string* Layout::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Layout.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Layout::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Layout.name)
}

// repeated .vlsir.raw.LayerShapes shapes = 2;
inline int Layout::_internal_shapes_size() const {
  return shapes_.size();
}
inline int Layout::shapes_size() const {
  return _internal_shapes_size();
}
inline void Layout::clear_shapes() {
  shapes_.Clear();
}
inline ::vlsir::raw::LayerShapes* Layout::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
Layout::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Layout.shapes)
  return &shapes_;
}
inline const ::vlsir::raw::LayerShapes& Layout::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::vlsir::raw::LayerShapes& Layout::shapes(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.shapes)
  return _internal_shapes(index);
}
inline ::vlsir::raw::LayerShapes* Layout::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::vlsir::raw::LayerShapes* Layout::add_shapes() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Layout.shapes)
  return _internal_add_shapes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
Layout::shapes() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Layout.shapes)
  return shapes_;
}

// repeated .vlsir.raw.Instance instances = 3;
inline int Layout::_internal_instances_size() const {
  return instances_.size();
}
inline int Layout::instances_size() const {
  return _internal_instances_size();
}
inline void Layout::clear_instances() {
  instances_.Clear();
}
inline ::vlsir::raw::Instance* Layout::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >*
Layout::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Layout.instances)
  return &instances_;
}
inline const ::vlsir::raw::Instance& Layout::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::vlsir::raw::Instance& Layout::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.instances)
  return _internal_instances(index);
}
inline ::vlsir::raw::Instance* Layout::_internal_add_instances() {
  return instances_.Add();
}
inline ::vlsir::raw::Instance* Layout::add_instances() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Layout.instances)
  return _internal_add_instances();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >&
Layout::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Layout.instances)
  return instances_;
}

// repeated .vlsir.raw.TextElement annotations = 4;
inline int Layout::_internal_annotations_size() const {
  return annotations_.size();
}
inline int Layout::annotations_size() const {
  return _internal_annotations_size();
}
inline void Layout::clear_annotations() {
  annotations_.Clear();
}
inline ::vlsir::raw::TextElement* Layout::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.annotations)
  return annotations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >*
Layout::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Layout.annotations)
  return &annotations_;
}
inline const ::vlsir::raw::TextElement& Layout::_internal_annotations(int index) const {
  return annotations_.Get(index);
}
inline const ::vlsir::raw::TextElement& Layout::annotations(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.annotations)
  return _internal_annotations(index);
}
inline ::vlsir::raw::TextElement* Layout::_internal_add_annotations() {
  return annotations_.Add();
}
inline ::vlsir::raw::TextElement* Layout::add_annotations() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Layout.annotations)
  return _internal_add_annotations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >&
Layout::annotations() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Layout.annotations)
  return annotations_;
}

// -------------------------------------------------------------------

// Abstract

// string name = 1;
inline void Abstract::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Abstract::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.name)
  return _internal_name();
}
inline void Abstract::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Abstract.name)
}
inline std::string* Abstract::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.name)
  return _internal_mutable_name();
}
inline const std::string& Abstract::_internal_name() const {
  return name_.Get();
}
inline void Abstract::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Abstract::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Abstract.name)
}
inline void Abstract::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Abstract.name)
}
inline void Abstract::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Abstract.name)
}
inline std::string* Abstract::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Abstract::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Abstract.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Abstract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Abstract.name)
}
inline std::string* Abstract::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Abstract.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Abstract::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Abstract.name)
}

// .vlsir.raw.Polygon outline = 2;
inline bool Abstract::_internal_has_outline() const {
  return this != internal_default_instance() && outline_ != nullptr;
}
inline bool Abstract::has_outline() const {
  return _internal_has_outline();
}
inline void Abstract::clear_outline() {
  if (GetArena() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
}
inline const ::vlsir::raw::Polygon& Abstract::_internal_outline() const {
  const ::vlsir::raw::Polygon* p = outline_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Polygon*>(
      &::vlsir::raw::_Polygon_default_instance_);
}
inline const ::vlsir::raw::Polygon& Abstract::outline() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.outline)
  return _internal_outline();
}
inline void Abstract::unsafe_arena_set_allocated_outline(
    ::vlsir::raw::Polygon* outline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outline_);
  }
  outline_ = outline;
  if (outline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Abstract.outline)
}
inline ::vlsir::raw::Polygon* Abstract::release_outline() {
  auto temp = unsafe_arena_release_outline();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Polygon* Abstract::unsafe_arena_release_outline() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Abstract.outline)
  
  ::vlsir::raw::Polygon* temp = outline_;
  outline_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Polygon* Abstract::_internal_mutable_outline() {
  
  if (outline_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Polygon>(GetArena());
    outline_ = p;
  }
  return outline_;
}
inline ::vlsir::raw::Polygon* Abstract::mutable_outline() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.outline)
  return _internal_mutable_outline();
}
inline void Abstract::set_allocated_outline(::vlsir::raw::Polygon* outline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete outline_;
  }
  if (outline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(outline);
    if (message_arena != submessage_arena) {
      outline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outline, submessage_arena);
    }
    
  } else {
    
  }
  outline_ = outline;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Abstract.outline)
}

// repeated .vlsir.raw.AbstractPort ports = 4;
inline int Abstract::_internal_ports_size() const {
  return ports_.size();
}
inline int Abstract::ports_size() const {
  return _internal_ports_size();
}
inline void Abstract::clear_ports() {
  ports_.Clear();
}
inline ::vlsir::raw::AbstractPort* Abstract::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >*
Abstract::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Abstract.ports)
  return &ports_;
}
inline const ::vlsir::raw::AbstractPort& Abstract::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::vlsir::raw::AbstractPort& Abstract::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.ports)
  return _internal_ports(index);
}
inline ::vlsir::raw::AbstractPort* Abstract::_internal_add_ports() {
  return ports_.Add();
}
inline ::vlsir::raw::AbstractPort* Abstract::add_ports() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Abstract.ports)
  return _internal_add_ports();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >&
Abstract::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Abstract.ports)
  return ports_;
}

// repeated .vlsir.raw.LayerShapes blockages = 5;
inline int Abstract::_internal_blockages_size() const {
  return blockages_.size();
}
inline int Abstract::blockages_size() const {
  return _internal_blockages_size();
}
inline void Abstract::clear_blockages() {
  blockages_.Clear();
}
inline ::vlsir::raw::LayerShapes* Abstract::mutable_blockages(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.blockages)
  return blockages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
Abstract::mutable_blockages() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Abstract.blockages)
  return &blockages_;
}
inline const ::vlsir::raw::LayerShapes& Abstract::_internal_blockages(int index) const {
  return blockages_.Get(index);
}
inline const ::vlsir::raw::LayerShapes& Abstract::blockages(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.blockages)
  return _internal_blockages(index);
}
inline ::vlsir::raw::LayerShapes* Abstract::_internal_add_blockages() {
  return blockages_.Add();
}
inline ::vlsir::raw::LayerShapes* Abstract::add_blockages() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Abstract.blockages)
  return _internal_add_blockages();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
Abstract::blockages() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Abstract.blockages)
  return blockages_;
}

// -------------------------------------------------------------------

// AbstractPort

// string net = 1;
inline void AbstractPort::clear_net() {
  net_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AbstractPort::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.AbstractPort.net)
  return _internal_net();
}
inline void AbstractPort::set_net(const std::string& value) {
  _internal_set_net(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.AbstractPort.net)
}
inline std::string* AbstractPort::mutable_net() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.AbstractPort.net)
  return _internal_mutable_net();
}
inline const std::string& AbstractPort::_internal_net() const {
  return net_.Get();
}
inline void AbstractPort::_internal_set_net(const std::string& value) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AbstractPort::set_net(std::string&& value) {
  
  net_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.AbstractPort.net)
}
inline void AbstractPort::set_net(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.AbstractPort.net)
}
inline void AbstractPort::set_net(const char* value,
    size_t size) {
  
  net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.AbstractPort.net)
}
inline std::string* AbstractPort::_internal_mutable_net() {
  
  return net_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AbstractPort::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.AbstractPort.net)
  return net_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AbstractPort::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  net_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), net,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.AbstractPort.net)
}
inline std::string* AbstractPort::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.AbstractPort.net)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return net_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AbstractPort::unsafe_arena_set_allocated_net(
    std::string* net) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (net != nullptr) {
    
  } else {
    
  }
  net_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      net, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.AbstractPort.net)
}

// repeated .vlsir.raw.LayerShapes shapes = 2;
inline int AbstractPort::_internal_shapes_size() const {
  return shapes_.size();
}
inline int AbstractPort::shapes_size() const {
  return _internal_shapes_size();
}
inline void AbstractPort::clear_shapes() {
  shapes_.Clear();
}
inline ::vlsir::raw::LayerShapes* AbstractPort::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.AbstractPort.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
AbstractPort::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.AbstractPort.shapes)
  return &shapes_;
}
inline const ::vlsir::raw::LayerShapes& AbstractPort::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::vlsir::raw::LayerShapes& AbstractPort::shapes(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.AbstractPort.shapes)
  return _internal_shapes(index);
}
inline ::vlsir::raw::LayerShapes* AbstractPort::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::vlsir::raw::LayerShapes* AbstractPort::add_shapes() {
  // @@protoc_insertion_point(field_add:vlsir.raw.AbstractPort.shapes)
  return _internal_add_shapes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
AbstractPort::shapes() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.AbstractPort.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// Cell

// string name = 1;
inline void Cell::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Cell::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.name)
  return _internal_name();
}
inline void Cell::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Cell.name)
}
inline std::string* Cell::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.name)
  return _internal_mutable_name();
}
inline const std::string& Cell::_internal_name() const {
  return name_.Get();
}
inline void Cell::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Cell::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Cell.name)
}
inline void Cell::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Cell.name)
}
inline void Cell::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Cell.name)
}
inline std::string* Cell::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Cell::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cell::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.name)
}
inline std::string* Cell::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Cell.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Cell::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.name)
}

// .vlsir.circuit.Interface interface = 10;
inline bool Cell::_internal_has_interface() const {
  return this != internal_default_instance() && interface_ != nullptr;
}
inline bool Cell::has_interface() const {
  return _internal_has_interface();
}
inline const ::vlsir::circuit::Interface& Cell::_internal_interface() const {
  const ::vlsir::circuit::Interface* p = interface_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::circuit::Interface*>(
      &::vlsir::circuit::_Interface_default_instance_);
}
inline const ::vlsir::circuit::Interface& Cell::interface() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.interface)
  return _internal_interface();
}
inline void Cell::unsafe_arena_set_allocated_interface(
    ::vlsir::circuit::Interface* interface) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  interface_ = interface;
  if (interface) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.interface)
}
inline ::vlsir::circuit::Interface* Cell::release_interface() {
  auto temp = unsafe_arena_release_interface();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::circuit::Interface* Cell::unsafe_arena_release_interface() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.interface)
  
  ::vlsir::circuit::Interface* temp = interface_;
  interface_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Interface* Cell::_internal_mutable_interface() {
  
  if (interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Interface>(GetArena());
    interface_ = p;
  }
  return interface_;
}
inline ::vlsir::circuit::Interface* Cell::mutable_interface() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.interface)
  return _internal_mutable_interface();
}
inline void Cell::set_allocated_interface(::vlsir::circuit::Interface* interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  if (interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface)->GetArena();
    if (message_arena != submessage_arena) {
      interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.interface)
}

// .vlsir.circuit.Module module = 11;
inline bool Cell::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool Cell::has_module() const {
  return _internal_has_module();
}
inline const ::vlsir::circuit::Module& Cell::_internal_module() const {
  const ::vlsir::circuit::Module* p = module_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::circuit::Module*>(
      &::vlsir::circuit::_Module_default_instance_);
}
inline const ::vlsir::circuit::Module& Cell::module() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.module)
  return _internal_module();
}
inline void Cell::unsafe_arena_set_allocated_module(
    ::vlsir::circuit::Module* module) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.module)
}
inline ::vlsir::circuit::Module* Cell::release_module() {
  auto temp = unsafe_arena_release_module();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::circuit::Module* Cell::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.module)
  
  ::vlsir::circuit::Module* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Module* Cell::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Module>(GetArena());
    module_ = p;
  }
  return module_;
}
inline ::vlsir::circuit::Module* Cell::mutable_module() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.module)
  return _internal_mutable_module();
}
inline void Cell::set_allocated_module(::vlsir::circuit::Module* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module)->GetArena();
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.module)
}

// .vlsir.raw.Abstract abstract = 12;
inline bool Cell::_internal_has_abstract() const {
  return this != internal_default_instance() && abstract_ != nullptr;
}
inline bool Cell::has_abstract() const {
  return _internal_has_abstract();
}
inline void Cell::clear_abstract() {
  if (GetArena() == nullptr && abstract_ != nullptr) {
    delete abstract_;
  }
  abstract_ = nullptr;
}
inline const ::vlsir::raw::Abstract& Cell::_internal_abstract() const {
  const ::vlsir::raw::Abstract* p = abstract_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Abstract*>(
      &::vlsir::raw::_Abstract_default_instance_);
}
inline const ::vlsir::raw::Abstract& Cell::abstract() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.abstract)
  return _internal_abstract();
}
inline void Cell::unsafe_arena_set_allocated_abstract(
    ::vlsir::raw::Abstract* abstract) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abstract_);
  }
  abstract_ = abstract;
  if (abstract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.abstract)
}
inline ::vlsir::raw::Abstract* Cell::release_abstract() {
  auto temp = unsafe_arena_release_abstract();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Abstract* Cell::unsafe_arena_release_abstract() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.abstract)
  
  ::vlsir::raw::Abstract* temp = abstract_;
  abstract_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Abstract* Cell::_internal_mutable_abstract() {
  
  if (abstract_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Abstract>(GetArena());
    abstract_ = p;
  }
  return abstract_;
}
inline ::vlsir::raw::Abstract* Cell::mutable_abstract() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.abstract)
  return _internal_mutable_abstract();
}
inline void Cell::set_allocated_abstract(::vlsir::raw::Abstract* abstract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete abstract_;
  }
  if (abstract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(abstract);
    if (message_arena != submessage_arena) {
      abstract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abstract, submessage_arena);
    }
    
  } else {
    
  }
  abstract_ = abstract;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.abstract)
}

// .vlsir.raw.Layout layout = 13;
inline bool Cell::_internal_has_layout() const {
  return this != internal_default_instance() && layout_ != nullptr;
}
inline bool Cell::has_layout() const {
  return _internal_has_layout();
}
inline void Cell::clear_layout() {
  if (GetArena() == nullptr && layout_ != nullptr) {
    delete layout_;
  }
  layout_ = nullptr;
}
inline const ::vlsir::raw::Layout& Cell::_internal_layout() const {
  const ::vlsir::raw::Layout* p = layout_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::raw::Layout*>(
      &::vlsir::raw::_Layout_default_instance_);
}
inline const ::vlsir::raw::Layout& Cell::layout() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.layout)
  return _internal_layout();
}
inline void Cell::unsafe_arena_set_allocated_layout(
    ::vlsir::raw::Layout* layout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(layout_);
  }
  layout_ = layout;
  if (layout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.layout)
}
inline ::vlsir::raw::Layout* Cell::release_layout() {
  auto temp = unsafe_arena_release_layout();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::raw::Layout* Cell::unsafe_arena_release_layout() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.layout)
  
  ::vlsir::raw::Layout* temp = layout_;
  layout_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layout* Cell::_internal_mutable_layout() {
  
  if (layout_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layout>(GetArena());
    layout_ = p;
  }
  return layout_;
}
inline ::vlsir::raw::Layout* Cell::mutable_layout() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.layout)
  return _internal_mutable_layout();
}
inline void Cell::set_allocated_layout(::vlsir::raw::Layout* layout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete layout_;
  }
  if (layout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(layout);
    if (message_arena != submessage_arena) {
      layout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layout, submessage_arena);
    }
    
  } else {
    
  }
  layout_ = layout;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.layout)
}

// -------------------------------------------------------------------

// Library

// string domain = 1;
inline void Library::clear_domain() {
  domain_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Library::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.domain)
  return _internal_domain();
}
inline void Library::set_domain(const std::string& value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Library.domain)
}
inline std::string* Library::mutable_domain() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Library.domain)
  return _internal_mutable_domain();
}
inline const std::string& Library::_internal_domain() const {
  return domain_.Get();
}
inline void Library::_internal_set_domain(const std::string& value) {
  
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Library::set_domain(std::string&& value) {
  
  domain_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vlsir.raw.Library.domain)
}
inline void Library::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vlsir.raw.Library.domain)
}
inline void Library::set_domain(const char* value,
    size_t size) {
  
  domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vlsir.raw.Library.domain)
}
inline std::string* Library::_internal_mutable_domain() {
  
  return domain_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Library::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Library.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Library::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Library.domain)
}
inline std::string* Library::unsafe_arena_release_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vlsir.raw.Library.domain)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return domain_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Library::unsafe_arena_set_allocated_domain(
    std::string* domain) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      domain, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Library.domain)
}

// .vlsir.raw.Units units = 2;
inline void Library::clear_units() {
  units_ = 0;
}
inline ::vlsir::raw::Units Library::_internal_units() const {
  return static_cast< ::vlsir::raw::Units >(units_);
}
inline ::vlsir::raw::Units Library::units() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.units)
  return _internal_units();
}
inline void Library::_internal_set_units(::vlsir::raw::Units value) {
  
  units_ = value;
}
inline void Library::set_units(::vlsir::raw::Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Library.units)
}

// repeated .vlsir.raw.Cell cells = 10;
inline int Library::_internal_cells_size() const {
  return cells_.size();
}
inline int Library::cells_size() const {
  return _internal_cells_size();
}
inline void Library::clear_cells() {
  cells_.Clear();
}
inline ::vlsir::raw::Cell* Library::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Library.cells)
  return cells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >*
Library::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Library.cells)
  return &cells_;
}
inline const ::vlsir::raw::Cell& Library::_internal_cells(int index) const {
  return cells_.Get(index);
}
inline const ::vlsir::raw::Cell& Library::cells(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.cells)
  return _internal_cells(index);
}
inline ::vlsir::raw::Cell* Library::_internal_add_cells() {
  return cells_.Add();
}
inline ::vlsir::raw::Cell* Library::add_cells() {
  // @@protoc_insertion_point(field_add:vlsir.raw.Library.cells)
  return _internal_add_cells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >&
Library::cells() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Library.cells)
  return cells_;
}

// .vlsir.utils.AuthorMetadata author = 20;
inline bool Library::_internal_has_author() const {
  return this != internal_default_instance() && author_ != nullptr;
}
inline bool Library::has_author() const {
  return _internal_has_author();
}
inline const ::vlsir::utils::AuthorMetadata& Library::_internal_author() const {
  const ::vlsir::utils::AuthorMetadata* p = author_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vlsir::utils::AuthorMetadata*>(
      &::vlsir::utils::_AuthorMetadata_default_instance_);
}
inline const ::vlsir::utils::AuthorMetadata& Library::author() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.author)
  return _internal_author();
}
inline void Library::unsafe_arena_set_allocated_author(
    ::vlsir::utils::AuthorMetadata* author) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author_);
  }
  author_ = author;
  if (author) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Library.author)
}
inline ::vlsir::utils::AuthorMetadata* Library::release_author() {
  auto temp = unsafe_arena_release_author();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vlsir::utils::AuthorMetadata* Library::unsafe_arena_release_author() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Library.author)
  
  ::vlsir::utils::AuthorMetadata* temp = author_;
  author_ = nullptr;
  return temp;
}
inline ::vlsir::utils::AuthorMetadata* Library::_internal_mutable_author() {
  
  if (author_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::AuthorMetadata>(GetArena());
    author_ = p;
  }
  return author_;
}
inline ::vlsir::utils::AuthorMetadata* Library::mutable_author() {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Library.author)
  return _internal_mutable_author();
}
inline void Library::set_allocated_author(::vlsir::utils::AuthorMetadata* author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(author_);
  }
  if (author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author)->GetArena();
    if (message_arena != submessage_arena) {
      author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, author, submessage_arena);
    }
    
  } else {
    
  }
  author_ = author;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Library.author)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace raw
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::raw::Units> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::raw::Units>() {
  return ::vlsir::raw::Units_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_raw_2eproto
