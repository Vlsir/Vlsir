// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tetris.proto

#include "tetris.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_circuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Interface_circuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_circuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Module_circuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_raw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Layer_raw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_raw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point_raw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Abstract_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_AbstractPort_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AbstractPort_EdgePort_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AbstractPort_ZTopEdgePort_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AbstractPort_ZTopInner_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Assign_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Cell_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Instance_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LayerEnum_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Layout_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MetalLayer_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Outline_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Place_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PrimitiveLayer_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RelPlace_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrackCross_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TrackRef_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TrackSpec_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrackSpec_Repeat_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TrackSpec_TrackEntry_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ViaLayer_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_tetris_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Xy_tetris_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_utils_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AuthorMetadata_utils_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_utils_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Reference_utils_2eproto;
namespace vlsir {
namespace tetris {
class LibraryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Library> _instance;
} _Library_default_instance_;
class CellDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Cell> _instance;
} _Cell_default_instance_;
class LayoutDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Layout> _instance;
} _Layout_default_instance_;
class AssignDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Assign> _instance;
} _Assign_default_instance_;
class TrackCrossDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrackCross> _instance;
} _TrackCross_default_instance_;
class TrackRefDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrackRef> _instance;
} _TrackRef_default_instance_;
class OutlineDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Outline> _instance;
} _Outline_default_instance_;
class AbstractDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Abstract> _instance;
} _Abstract_default_instance_;
class AbstractPort_EdgePortDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AbstractPort_EdgePort> _instance;
} _AbstractPort_EdgePort_default_instance_;
class AbstractPort_ZTopEdgePortDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AbstractPort_ZTopEdgePort> _instance;
} _AbstractPort_ZTopEdgePort_default_instance_;
class AbstractPort_ZTopInnerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AbstractPort_ZTopInner> _instance;
} _AbstractPort_ZTopInner_default_instance_;
class AbstractPortDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AbstractPort> _instance;
  const ::vlsir::tetris::AbstractPort_EdgePort* edge_;
  const ::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge_;
  const ::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner_;
} _AbstractPort_default_instance_;
class InstanceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Instance> _instance;
} _Instance_default_instance_;
class PlaceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Place> _instance;
  const ::vlsir::raw::Point* abs_;
  const ::vlsir::tetris::RelPlace* rel_;
} _Place_default_instance_;
class RelPlaceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RelPlace> _instance;
} _RelPlace_default_instance_;
class StackDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Stack> _instance;
} _Stack_default_instance_;
class LayerEnumDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LayerEnum> _instance;
} _LayerEnum_default_instance_;
class MetalLayerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MetalLayer> _instance;
} _MetalLayer_default_instance_;
class ViaLayerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ViaLayer> _instance;
} _ViaLayer_default_instance_;
class PrimitiveLayerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PrimitiveLayer> _instance;
} _PrimitiveLayer_default_instance_;
class TrackSpec_TrackEntryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrackSpec_TrackEntry> _instance;
} _TrackSpec_TrackEntry_default_instance_;
class TrackSpec_RepeatDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrackSpec_Repeat> _instance;
} _TrackSpec_Repeat_default_instance_;
class TrackSpecDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrackSpec> _instance;
  const ::vlsir::tetris::TrackSpec_TrackEntry* entry_;
  const ::vlsir::tetris::TrackSpec_Repeat* repeat_;
} _TrackSpec_default_instance_;
class XyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Xy> _instance;
} _Xy_default_instance_;
}  // namespace tetris
}  // namespace vlsir
static void InitDefaultsscc_info_Abstract_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Abstract_default_instance_;
    new (ptr) ::vlsir::tetris::Abstract();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Abstract::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Abstract_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Abstract_tetris_2eproto}, {
      &scc_info_Outline_tetris_2eproto.base,
      &scc_info_AbstractPort_tetris_2eproto.base,}};

static void InitDefaultsscc_info_AbstractPort_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_AbstractPort_default_instance_;
    new (ptr) ::vlsir::tetris::AbstractPort();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::AbstractPort::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_AbstractPort_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_AbstractPort_tetris_2eproto}, {
      &scc_info_AbstractPort_EdgePort_tetris_2eproto.base,
      &scc_info_AbstractPort_ZTopEdgePort_tetris_2eproto.base,
      &scc_info_AbstractPort_ZTopInner_tetris_2eproto.base,}};

static void InitDefaultsscc_info_AbstractPort_EdgePort_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_AbstractPort_EdgePort_default_instance_;
    new (ptr) ::vlsir::tetris::AbstractPort_EdgePort();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::AbstractPort_EdgePort::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AbstractPort_EdgePort_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AbstractPort_EdgePort_tetris_2eproto}, {
      &scc_info_TrackRef_tetris_2eproto.base,}};

static void InitDefaultsscc_info_AbstractPort_ZTopEdgePort_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_AbstractPort_ZTopEdgePort_default_instance_;
    new (ptr) ::vlsir::tetris::AbstractPort_ZTopEdgePort();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::AbstractPort_ZTopEdgePort::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AbstractPort_ZTopEdgePort_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AbstractPort_ZTopEdgePort_tetris_2eproto}, {
      &scc_info_TrackRef_tetris_2eproto.base,}};

static void InitDefaultsscc_info_AbstractPort_ZTopInner_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_AbstractPort_ZTopInner_default_instance_;
    new (ptr) ::vlsir::tetris::AbstractPort_ZTopInner();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::AbstractPort_ZTopInner::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AbstractPort_ZTopInner_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AbstractPort_ZTopInner_tetris_2eproto}, {
      &scc_info_TrackCross_tetris_2eproto.base,}};

static void InitDefaultsscc_info_Assign_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Assign_default_instance_;
    new (ptr) ::vlsir::tetris::Assign();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Assign::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Assign_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Assign_tetris_2eproto}, {
      &scc_info_TrackCross_tetris_2eproto.base,}};

static void InitDefaultsscc_info_Cell_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Cell_default_instance_;
    new (ptr) ::vlsir::tetris::Cell();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Cell::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Cell_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Cell_tetris_2eproto}, {
      &scc_info_Interface_circuit_2eproto.base,
      &scc_info_Module_circuit_2eproto.base,
      &scc_info_Abstract_tetris_2eproto.base,
      &scc_info_Layout_tetris_2eproto.base,}};

static void InitDefaultsscc_info_Instance_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Instance_default_instance_;
    new (ptr) ::vlsir::tetris::Instance();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Instance::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Instance_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Instance_tetris_2eproto}, {
      &scc_info_Reference_utils_2eproto.base,
      &scc_info_Place_tetris_2eproto.base,}};

static void InitDefaultsscc_info_LayerEnum_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_LayerEnum_default_instance_;
    new (ptr) ::vlsir::tetris::LayerEnum();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::LayerEnum::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LayerEnum_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LayerEnum_tetris_2eproto}, {}};

static void InitDefaultsscc_info_Layout_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Layout_default_instance_;
    new (ptr) ::vlsir::tetris::Layout();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Layout::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Layout_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Layout_tetris_2eproto}, {
      &scc_info_Outline_tetris_2eproto.base,
      &scc_info_Instance_tetris_2eproto.base,
      &scc_info_Assign_tetris_2eproto.base,
      &scc_info_TrackCross_tetris_2eproto.base,}};

static void InitDefaultsscc_info_Library_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Library_default_instance_;
    new (ptr) ::vlsir::tetris::Library();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Library::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Library_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Library_tetris_2eproto}, {
      &scc_info_Cell_tetris_2eproto.base,
      &scc_info_AuthorMetadata_utils_2eproto.base,}};

static void InitDefaultsscc_info_MetalLayer_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_MetalLayer_default_instance_;
    new (ptr) ::vlsir::tetris::MetalLayer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::MetalLayer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MetalLayer_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_MetalLayer_tetris_2eproto}, {
      &scc_info_TrackSpec_tetris_2eproto.base,
      &scc_info_Layer_raw_2eproto.base,}};

static void InitDefaultsscc_info_Outline_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Outline_default_instance_;
    new (ptr) ::vlsir::tetris::Outline();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Outline::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Outline_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Outline_tetris_2eproto}, {}};

static void InitDefaultsscc_info_Place_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Place_default_instance_;
    new (ptr) ::vlsir::tetris::Place();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Place::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Place_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Place_tetris_2eproto}, {
      &scc_info_Point_raw_2eproto.base,
      &scc_info_RelPlace_tetris_2eproto.base,}};

static void InitDefaultsscc_info_PrimitiveLayer_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_PrimitiveLayer_default_instance_;
    new (ptr) ::vlsir::tetris::PrimitiveLayer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::PrimitiveLayer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PrimitiveLayer_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PrimitiveLayer_tetris_2eproto}, {
      &scc_info_Xy_tetris_2eproto.base,}};

static void InitDefaultsscc_info_RelPlace_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_RelPlace_default_instance_;
    new (ptr) ::vlsir::tetris::RelPlace();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::RelPlace::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RelPlace_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RelPlace_tetris_2eproto}, {}};

static void InitDefaultsscc_info_Stack_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Stack_default_instance_;
    new (ptr) ::vlsir::tetris::Stack();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Stack::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Stack_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Stack_tetris_2eproto}, {
      &scc_info_PrimitiveLayer_tetris_2eproto.base,
      &scc_info_MetalLayer_tetris_2eproto.base,
      &scc_info_ViaLayer_tetris_2eproto.base,
      &scc_info_Layer_raw_2eproto.base,}};

static void InitDefaultsscc_info_TrackCross_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_TrackCross_default_instance_;
    new (ptr) ::vlsir::tetris::TrackCross();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::TrackCross::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrackCross_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TrackCross_tetris_2eproto}, {
      &scc_info_TrackRef_tetris_2eproto.base,}};

static void InitDefaultsscc_info_TrackRef_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_TrackRef_default_instance_;
    new (ptr) ::vlsir::tetris::TrackRef();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::TrackRef::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TrackRef_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TrackRef_tetris_2eproto}, {}};

static void InitDefaultsscc_info_TrackSpec_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_TrackSpec_default_instance_;
    new (ptr) ::vlsir::tetris::TrackSpec();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::TrackSpec::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TrackSpec_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TrackSpec_tetris_2eproto}, {
      &scc_info_TrackSpec_TrackEntry_tetris_2eproto.base,
      &scc_info_TrackSpec_Repeat_tetris_2eproto.base,}};

static void InitDefaultsscc_info_TrackSpec_Repeat_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_TrackSpec_Repeat_default_instance_;
    new (ptr) ::vlsir::tetris::TrackSpec_Repeat();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::TrackSpec_Repeat::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrackSpec_Repeat_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TrackSpec_Repeat_tetris_2eproto}, {
      &scc_info_TrackSpec_TrackEntry_tetris_2eproto.base,}};

static void InitDefaultsscc_info_TrackSpec_TrackEntry_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_TrackSpec_TrackEntry_default_instance_;
    new (ptr) ::vlsir::tetris::TrackSpec_TrackEntry();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::TrackSpec_TrackEntry::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TrackSpec_TrackEntry_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TrackSpec_TrackEntry_tetris_2eproto}, {}};

static void InitDefaultsscc_info_ViaLayer_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_ViaLayer_default_instance_;
    new (ptr) ::vlsir::tetris::ViaLayer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::ViaLayer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ViaLayer_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_ViaLayer_tetris_2eproto}, {
      &scc_info_LayerEnum_tetris_2eproto.base,
      &scc_info_Xy_tetris_2eproto.base,
      &scc_info_Layer_raw_2eproto.base,}};

static void InitDefaultsscc_info_Xy_tetris_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vlsir::tetris::_Xy_default_instance_;
    new (ptr) ::vlsir::tetris::Xy();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vlsir::tetris::Xy::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Xy_tetris_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Xy_tetris_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_tetris_2eproto[24];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_tetris_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_tetris_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_tetris_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, domain_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, cells_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, author_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, interface_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, module_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, abstract_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, layout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, outline_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, instances_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, assignments_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, cuts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, net_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, cross_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, layer_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, track_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, x_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, y_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, metals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, outline_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, ports_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, side_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, side_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, into_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopInner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopInner, locs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, net_),
  offsetof(::vlsir::tetris::AbstractPortDefaultTypeInternal, edge_),
  offsetof(::vlsir::tetris::AbstractPortDefaultTypeInternal, ztop_edge_),
  offsetof(::vlsir::tetris::AbstractPortDefaultTypeInternal, ztop_inner_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, kind_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, cell_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, loc_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, reflect_horiz_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, reflect_vert_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::vlsir::tetris::PlaceDefaultTypeInternal, abs_),
  offsetof(::vlsir::tetris::PlaceDefaultTypeInternal, rel_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, place_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::RelPlace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, units_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, prim_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, metals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, vias_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, boundary_layer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, type_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, dir_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, cutsize_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, entries_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, offset_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, overlap_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, flip_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, prim_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, raw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, top_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, bot_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, size_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, raw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::PrimitiveLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::PrimitiveLayer, pitches_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, ttype_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, entries_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, nrep_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::vlsir::tetris::TrackSpecDefaultTypeInternal, entry_),
  offsetof(::vlsir::tetris::TrackSpecDefaultTypeInternal, repeat_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, spec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, x_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, y_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::vlsir::tetris::Library)},
  { 8, -1, sizeof(::vlsir::tetris::Cell)},
  { 18, -1, sizeof(::vlsir::tetris::Layout)},
  { 28, -1, sizeof(::vlsir::tetris::Assign)},
  { 35, -1, sizeof(::vlsir::tetris::TrackCross)},
  { 42, -1, sizeof(::vlsir::tetris::TrackRef)},
  { 49, -1, sizeof(::vlsir::tetris::Outline)},
  { 57, -1, sizeof(::vlsir::tetris::Abstract)},
  { 65, -1, sizeof(::vlsir::tetris::AbstractPort_EdgePort)},
  { 72, -1, sizeof(::vlsir::tetris::AbstractPort_ZTopEdgePort)},
  { 80, -1, sizeof(::vlsir::tetris::AbstractPort_ZTopInner)},
  { 86, -1, sizeof(::vlsir::tetris::AbstractPort)},
  { 96, -1, sizeof(::vlsir::tetris::Instance)},
  { 106, -1, sizeof(::vlsir::tetris::Place)},
  { 114, -1, sizeof(::vlsir::tetris::RelPlace)},
  { 119, -1, sizeof(::vlsir::tetris::Stack)},
  { 129, -1, sizeof(::vlsir::tetris::LayerEnum)},
  { 136, -1, sizeof(::vlsir::tetris::MetalLayer)},
  { 150, -1, sizeof(::vlsir::tetris::ViaLayer)},
  { 160, -1, sizeof(::vlsir::tetris::PrimitiveLayer)},
  { 166, -1, sizeof(::vlsir::tetris::TrackSpec_TrackEntry)},
  { 173, -1, sizeof(::vlsir::tetris::TrackSpec_Repeat)},
  { 180, -1, sizeof(::vlsir::tetris::TrackSpec)},
  { 188, -1, sizeof(::vlsir::tetris::Xy)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Library_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Cell_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Layout_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Assign_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackCross_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackRef_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Outline_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Abstract_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_EdgePort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_ZTopEdgePort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_ZTopInner_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_AbstractPort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Instance_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Place_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_RelPlace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Stack_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_LayerEnum_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_MetalLayer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_ViaLayer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_PrimitiveLayer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackSpec_TrackEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackSpec_Repeat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_TrackSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::vlsir::tetris::_Xy_default_instance_),
};

const char descriptor_table_protodef_tetris_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014tetris.proto\022\014vlsir.tetris\032\013utils.prot"
  "o\032\traw.proto\032\rcircuit.proto\"i\n\007Library\022\016"
  "\n\006domain\030\001 \001(\t\022!\n\005cells\030\n \003(\0132\022.vlsir.te"
  "tris.Cell\022+\n\006author\030\024 \001(\0132\033.vlsir.utils."
  "AuthorMetadata\"\270\001\n\004Cell\022\014\n\004name\030\001 \001(\t\022+\n"
  "\tinterface\030\n \001(\0132\030.vlsir.circuit.Interfa"
  "ce\022%\n\006module\030\013 \001(\0132\025.vlsir.circuit.Modul"
  "e\022(\n\010abstract\030\014 \001(\0132\026.vlsir.tetris.Abstr"
  "act\022$\n\006layout\030\r \001(\0132\024.vlsir.tetris.Layou"
  "t\"\274\001\n\006Layout\022\014\n\004name\030\001 \001(\t\022&\n\007outline\030\n "
  "\001(\0132\025.vlsir.tetris.Outline\022)\n\tinstances\030"
  "\024 \003(\0132\026.vlsir.tetris.Instance\022)\n\013assignm"
  "ents\030\025 \003(\0132\024.vlsir.tetris.Assign\022&\n\004cuts"
  "\030\026 \003(\0132\030.vlsir.tetris.TrackCross\";\n\006Assi"
  "gn\022\013\n\003net\030\001 \001(\t\022$\n\002at\030\002 \001(\0132\030.vlsir.tetr"
  "is.TrackCross\"Z\n\nTrackCross\022%\n\005track\030\001 \001"
  "(\0132\026.vlsir.tetris.TrackRef\022%\n\005cross\030\002 \001("
  "\0132\026.vlsir.tetris.TrackRef\"(\n\010TrackRef\022\r\n"
  "\005layer\030\001 \001(\003\022\r\n\005track\030\002 \001(\003\"/\n\007Outline\022\t"
  "\n\001x\030\001 \003(\003\022\t\n\001y\030\002 \003(\003\022\016\n\006metals\030\003 \001(\003\"k\n\010"
  "Abstract\022\014\n\004name\030\001 \001(\t\022&\n\007outline\030\n \001(\0132"
  "\025.vlsir.tetris.Outline\022)\n\005ports\030\024 \003(\0132\032."
  "vlsir.tetris.AbstractPort\"\227\004\n\014AbstractPo"
  "rt\022\013\n\003net\030\001 \001(\t\0223\n\004edge\030\n \001(\0132#.vlsir.te"
  "tris.AbstractPort.EdgePortH\000\022<\n\tztop_edg"
  "e\030\013 \001(\0132\'.vlsir.tetris.AbstractPort.ZTop"
  "EdgePortH\000\022:\n\nztop_inner\030\014 \001(\0132$.vlsir.t"
  "etris.AbstractPort.ZTopInnerH\000\032d\n\010EdgePo"
  "rt\022%\n\005track\030\001 \001(\0132\026.vlsir.tetris.TrackRe"
  "f\0221\n\004side\030\002 \001(\0162#.vlsir.tetris.AbstractP"
  "ort.PortSide\032v\n\014ZTopEdgePort\022\r\n\005track\030\001 "
  "\001(\003\0221\n\004side\030\002 \001(\0162#.vlsir.tetris.Abstrac"
  "tPort.PortSide\022$\n\004into\030\003 \001(\0132\026.vlsir.tet"
  "ris.TrackRef\0323\n\tZTopInner\022&\n\004locs\030\001 \003(\0132"
  "\030.vlsir.tetris.TrackCross\"0\n\010PortSide\022\022\n"
  "\016BOTTOM_OR_LEFT\020\000\022\020\n\014TOP_OR_RIGHT\020\001B\006\n\004k"
  "ind\"\215\001\n\010Instance\022\014\n\004name\030\001 \001(\t\022$\n\004cell\030\003"
  " \001(\0132\026.vlsir.utils.Reference\022 \n\003loc\030\004 \001("
  "\0132\023.vlsir.tetris.Place\022\025\n\rreflect_horiz\030"
  "\006 \001(\010\022\024\n\014reflect_vert\030\007 \001(\010\"X\n\005Place\022\037\n\003"
  "abs\030\001 \001(\0132\020.vlsir.raw.PointH\000\022%\n\003rel\030\002 \001"
  "(\0132\026.vlsir.tetris.RelPlaceH\000B\007\n\005place\"\n\n"
  "\010RelPlace\"\316\001\n\005Stack\022\037\n\005units\030\001 \001(\0162\020.vls"
  "ir.raw.Units\022*\n\004prim\030\002 \001(\0132\034.vlsir.tetri"
  "s.PrimitiveLayer\022(\n\006metals\030\003 \003(\0132\030.vlsir"
  ".tetris.MetalLayer\022$\n\004vias\030\004 \003(\0132\026.vlsir"
  ".tetris.ViaLayer\022(\n\016boundary_layer\030\013 \001(\013"
  "2\020.vlsir.raw.Layer\"{\n\tLayerEnum\022/\n\004type\030"
  "\001 \001(\0162!.vlsir.tetris.LayerEnum.LayerType"
  "\022\r\n\005index\030\002 \001(\003\".\n\tLayerType\022\r\n\tPRIMITIV"
  "E\020\000\022\t\n\005METAL\020\001\022\007\n\003VIA\020\002\"\321\002\n\nMetalLayer\022\014"
  "\n\004name\030\001 \001(\t\022)\n\003dir\030\002 \001(\0162\034.vlsir.tetris"
  ".MetalLayer.Dir\022\017\n\007cutsize\030\003 \001(\003\022(\n\007entr"
  "ies\030\004 \003(\0132\027.vlsir.tetris.TrackSpec\022\016\n\006of"
  "fset\030\005 \001(\003\022\017\n\007overlap\030\006 \001(\003\022\014\n\004flip\030\007 \001("
  "\010\0224\n\004prim\030\010 \001(\0162&.vlsir.tetris.MetalLaye"
  "r.PrimitiveMode\022\035\n\003raw\030\013 \001(\0132\020.vlsir.raw"
  ".Layer\"\032\n\003Dir\022\t\n\005HORIZ\020\000\022\010\n\004VERT\020\001\"/\n\rPr"
  "imitiveMode\022\010\n\004PRIM\020\000\022\t\n\005SPLIT\020\001\022\t\n\005STAC"
  "K\020\002\"\243\001\n\010ViaLayer\022\014\n\004name\030\001 \001(\t\022$\n\003top\030\002 "
  "\001(\0132\027.vlsir.tetris.LayerEnum\022$\n\003bot\030\003 \001("
  "\0132\027.vlsir.tetris.LayerEnum\022\036\n\004size\030\004 \001(\013"
  "2\020.vlsir.tetris.Xy\022\035\n\003raw\030\013 \001(\0132\020.vlsir."
  "raw.Layer\"3\n\016PrimitiveLayer\022!\n\007pitches\030\001"
  " \001(\0132\020.vlsir.tetris.Xy\"\316\002\n\tTrackSpec\0223\n\005"
  "entry\030\001 \001(\0132\".vlsir.tetris.TrackSpec.Tra"
  "ckEntryH\000\0220\n\006repeat\030\002 \001(\0132\036.vlsir.tetris"
  ".TrackSpec.RepeatH\000\032\204\001\n\nTrackEntry\022;\n\005tt"
  "ype\030\001 \001(\0162,.vlsir.tetris.TrackSpec.Track"
  "Entry.TrackType\022\r\n\005width\030\002 \001(\003\"*\n\tTrackT"
  "ype\022\007\n\003GAP\020\000\022\n\n\006SIGNAL\020\001\022\010\n\004RAIL\020\002\032K\n\006Re"
  "peat\0223\n\007entries\030\001 \003(\0132\".vlsir.tetris.Tra"
  "ckSpec.TrackEntry\022\014\n\004nrep\030\002 \001(\003B\006\n\004spec\""
  "\032\n\002Xy\022\t\n\001x\030\001 \001(\003\022\t\n\001y\030\002 \001(\003b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_tetris_2eproto_deps[3] = {
  &::descriptor_table_circuit_2eproto,
  &::descriptor_table_raw_2eproto,
  &::descriptor_table_utils_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_tetris_2eproto_sccs[24] = {
  &scc_info_Abstract_tetris_2eproto.base,
  &scc_info_AbstractPort_tetris_2eproto.base,
  &scc_info_AbstractPort_EdgePort_tetris_2eproto.base,
  &scc_info_AbstractPort_ZTopEdgePort_tetris_2eproto.base,
  &scc_info_AbstractPort_ZTopInner_tetris_2eproto.base,
  &scc_info_Assign_tetris_2eproto.base,
  &scc_info_Cell_tetris_2eproto.base,
  &scc_info_Instance_tetris_2eproto.base,
  &scc_info_LayerEnum_tetris_2eproto.base,
  &scc_info_Layout_tetris_2eproto.base,
  &scc_info_Library_tetris_2eproto.base,
  &scc_info_MetalLayer_tetris_2eproto.base,
  &scc_info_Outline_tetris_2eproto.base,
  &scc_info_Place_tetris_2eproto.base,
  &scc_info_PrimitiveLayer_tetris_2eproto.base,
  &scc_info_RelPlace_tetris_2eproto.base,
  &scc_info_Stack_tetris_2eproto.base,
  &scc_info_TrackCross_tetris_2eproto.base,
  &scc_info_TrackRef_tetris_2eproto.base,
  &scc_info_TrackSpec_tetris_2eproto.base,
  &scc_info_TrackSpec_Repeat_tetris_2eproto.base,
  &scc_info_TrackSpec_TrackEntry_tetris_2eproto.base,
  &scc_info_ViaLayer_tetris_2eproto.base,
  &scc_info_Xy_tetris_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_tetris_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tetris_2eproto = {
  false, false, descriptor_table_protodef_tetris_2eproto, "tetris.proto", 2955,
  &descriptor_table_tetris_2eproto_once, descriptor_table_tetris_2eproto_sccs, descriptor_table_tetris_2eproto_deps, 24, 3,
  schemas, file_default_instances, TableStruct_tetris_2eproto::offsets,
  file_level_metadata_tetris_2eproto, 24, file_level_enum_descriptors_tetris_2eproto, file_level_service_descriptors_tetris_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_tetris_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_tetris_2eproto)), true);
namespace vlsir {
namespace tetris {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbstractPort_PortSide_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tetris_2eproto);
  return file_level_enum_descriptors_tetris_2eproto[0];
}
bool AbstractPort_PortSide_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AbstractPort_PortSide AbstractPort::BOTTOM_OR_LEFT;
constexpr AbstractPort_PortSide AbstractPort::TOP_OR_RIGHT;
constexpr AbstractPort_PortSide AbstractPort::PortSide_MIN;
constexpr AbstractPort_PortSide AbstractPort::PortSide_MAX;
constexpr int AbstractPort::PortSide_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LayerEnum_LayerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tetris_2eproto);
  return file_level_enum_descriptors_tetris_2eproto[1];
}
bool LayerEnum_LayerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LayerEnum_LayerType LayerEnum::PRIMITIVE;
constexpr LayerEnum_LayerType LayerEnum::METAL;
constexpr LayerEnum_LayerType LayerEnum::VIA;
constexpr LayerEnum_LayerType LayerEnum::LayerType_MIN;
constexpr LayerEnum_LayerType LayerEnum::LayerType_MAX;
constexpr int LayerEnum::LayerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_Dir_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tetris_2eproto);
  return file_level_enum_descriptors_tetris_2eproto[2];
}
bool MetalLayer_Dir_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MetalLayer_Dir MetalLayer::HORIZ;
constexpr MetalLayer_Dir MetalLayer::VERT;
constexpr MetalLayer_Dir MetalLayer::Dir_MIN;
constexpr MetalLayer_Dir MetalLayer::Dir_MAX;
constexpr int MetalLayer::Dir_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_PrimitiveMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tetris_2eproto);
  return file_level_enum_descriptors_tetris_2eproto[3];
}
bool MetalLayer_PrimitiveMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MetalLayer_PrimitiveMode MetalLayer::PRIM;
constexpr MetalLayer_PrimitiveMode MetalLayer::SPLIT;
constexpr MetalLayer_PrimitiveMode MetalLayer::STACK;
constexpr MetalLayer_PrimitiveMode MetalLayer::PrimitiveMode_MIN;
constexpr MetalLayer_PrimitiveMode MetalLayer::PrimitiveMode_MAX;
constexpr int MetalLayer::PrimitiveMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSpec_TrackEntry_TrackType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tetris_2eproto);
  return file_level_enum_descriptors_tetris_2eproto[4];
}
bool TrackSpec_TrackEntry_TrackType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::GAP;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::SIGNAL;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::RAIL;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::TrackType_MIN;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::TrackType_MAX;
constexpr int TrackSpec_TrackEntry::TrackType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Library::InitAsDefaultInstance() {
  ::vlsir::tetris::_Library_default_instance_._instance.get_mutable()->author_ = const_cast< ::vlsir::utils::AuthorMetadata*>(
      ::vlsir::utils::AuthorMetadata::internal_default_instance());
}
class Library::_Internal {
 public:
  static const ::vlsir::utils::AuthorMetadata& author(const Library* msg);
};

const ::vlsir::utils::AuthorMetadata&
Library::_Internal::author(const Library* msg) {
  return *msg->author_;
}
void Library::clear_author() {
  if (GetArena() == nullptr && author_ != nullptr) {
    delete author_;
  }
  author_ = nullptr;
}
Library::Library(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  cells_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Library)
}
Library::Library(const Library& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      cells_(from.cells_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_domain().empty()) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_domain(),
      GetArena());
  }
  if (from._internal_has_author()) {
    author_ = new ::vlsir::utils::AuthorMetadata(*from.author_);
  } else {
    author_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Library)
}

void Library::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Library_tetris_2eproto.base);
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  author_ = nullptr;
}

Library::~Library() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Library)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Library::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete author_;
}

void Library::ArenaDtor(void* object) {
  Library* _this = reinterpret_cast< Library* >(object);
  (void)_this;
}
void Library::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Library::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Library& Library::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Library_tetris_2eproto.base);
  return *internal_default_instance();
}


void Library::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Library)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cells_.Clear();
  domain_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && author_ != nullptr) {
    delete author_;
  }
  author_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Library::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string domain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_domain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Library.domain"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Cell cells = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // .vlsir.utils.AuthorMetadata author = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_author(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Library::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Library)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string domain = 1;
  if (this->domain().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain().data(), static_cast<int>(this->_internal_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Library.domain");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_domain(), target);
  }

  // repeated .vlsir.tetris.Cell cells = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cells_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_cells(i), target, stream);
  }

  // .vlsir.utils.AuthorMetadata author = 20;
  if (this->has_author()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::author(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Library)
  return target;
}

size_t Library::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Library)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.Cell cells = 10;
  total_size += 1UL * this->_internal_cells_size();
  for (const auto& msg : this->cells_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string domain = 1;
  if (this->domain().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain());
  }

  // .vlsir.utils.AuthorMetadata author = 20;
  if (this->has_author()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *author_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Library::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Library)
  GOOGLE_DCHECK_NE(&from, this);
  const Library* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Library>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Library)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Library)
    MergeFrom(*source);
  }
}

void Library::MergeFrom(const Library& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Library)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cells_.MergeFrom(from.cells_);
  if (from.domain().size() > 0) {
    _internal_set_domain(from._internal_domain());
  }
  if (from.has_author()) {
    _internal_mutable_author()->::vlsir::utils::AuthorMetadata::MergeFrom(from._internal_author());
  }
}

void Library::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Library)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Library::CopyFrom(const Library& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Library)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Library::IsInitialized() const {
  return true;
}

void Library::InternalSwap(Library* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  cells_.InternalSwap(&other->cells_);
  domain_.Swap(&other->domain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(author_, other->author_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Library::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Cell::InitAsDefaultInstance() {
  ::vlsir::tetris::_Cell_default_instance_._instance.get_mutable()->interface_ = const_cast< ::vlsir::circuit::Interface*>(
      ::vlsir::circuit::Interface::internal_default_instance());
  ::vlsir::tetris::_Cell_default_instance_._instance.get_mutable()->module_ = const_cast< ::vlsir::circuit::Module*>(
      ::vlsir::circuit::Module::internal_default_instance());
  ::vlsir::tetris::_Cell_default_instance_._instance.get_mutable()->abstract_ = const_cast< ::vlsir::tetris::Abstract*>(
      ::vlsir::tetris::Abstract::internal_default_instance());
  ::vlsir::tetris::_Cell_default_instance_._instance.get_mutable()->layout_ = const_cast< ::vlsir::tetris::Layout*>(
      ::vlsir::tetris::Layout::internal_default_instance());
}
class Cell::_Internal {
 public:
  static const ::vlsir::circuit::Interface& interface(const Cell* msg);
  static const ::vlsir::circuit::Module& module(const Cell* msg);
  static const ::vlsir::tetris::Abstract& abstract(const Cell* msg);
  static const ::vlsir::tetris::Layout& layout(const Cell* msg);
};

const ::vlsir::circuit::Interface&
Cell::_Internal::interface(const Cell* msg) {
  return *msg->interface_;
}
const ::vlsir::circuit::Module&
Cell::_Internal::module(const Cell* msg) {
  return *msg->module_;
}
const ::vlsir::tetris::Abstract&
Cell::_Internal::abstract(const Cell* msg) {
  return *msg->abstract_;
}
const ::vlsir::tetris::Layout&
Cell::_Internal::layout(const Cell* msg) {
  return *msg->layout_;
}
void Cell::clear_interface() {
  if (GetArena() == nullptr && interface_ != nullptr) {
    delete interface_;
  }
  interface_ = nullptr;
}
void Cell::clear_module() {
  if (GetArena() == nullptr && module_ != nullptr) {
    delete module_;
  }
  module_ = nullptr;
}
Cell::Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Cell)
}
Cell::Cell(const Cell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_interface()) {
    interface_ = new ::vlsir::circuit::Interface(*from.interface_);
  } else {
    interface_ = nullptr;
  }
  if (from._internal_has_module()) {
    module_ = new ::vlsir::circuit::Module(*from.module_);
  } else {
    module_ = nullptr;
  }
  if (from._internal_has_abstract()) {
    abstract_ = new ::vlsir::tetris::Abstract(*from.abstract_);
  } else {
    abstract_ = nullptr;
  }
  if (from._internal_has_layout()) {
    layout_ = new ::vlsir::tetris::Layout(*from.layout_);
  } else {
    layout_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Cell)
}

void Cell::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Cell_tetris_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&interface_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&layout_) -
      reinterpret_cast<char*>(&interface_)) + sizeof(layout_));
}

Cell::~Cell() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Cell)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Cell::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete interface_;
  if (this != internal_default_instance()) delete module_;
  if (this != internal_default_instance()) delete abstract_;
  if (this != internal_default_instance()) delete layout_;
}

void Cell::ArenaDtor(void* object) {
  Cell* _this = reinterpret_cast< Cell* >(object);
  (void)_this;
}
void Cell::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Cell::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Cell& Cell::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Cell_tetris_2eproto.base);
  return *internal_default_instance();
}


void Cell::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Cell)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && interface_ != nullptr) {
    delete interface_;
  }
  interface_ = nullptr;
  if (GetArena() == nullptr && module_ != nullptr) {
    delete module_;
  }
  module_ = nullptr;
  if (GetArena() == nullptr && abstract_ != nullptr) {
    delete abstract_;
  }
  abstract_ = nullptr;
  if (GetArena() == nullptr && layout_ != nullptr) {
    delete layout_;
  }
  layout_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cell::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Cell.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.circuit.Interface interface = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_interface(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.circuit.Module module = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_module(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.Abstract abstract = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_abstract(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.Layout layout = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_layout(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Cell::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Cell)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Cell.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.circuit.Interface interface = 10;
  if (this->has_interface()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::interface(this), target, stream);
  }

  // .vlsir.circuit.Module module = 11;
  if (this->has_module()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::module(this), target, stream);
  }

  // .vlsir.tetris.Abstract abstract = 12;
  if (this->has_abstract()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::abstract(this), target, stream);
  }

  // .vlsir.tetris.Layout layout = 13;
  if (this->has_layout()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::layout(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Cell)
  return target;
}

size_t Cell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Cell)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.circuit.Interface interface = 10;
  if (this->has_interface()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *interface_);
  }

  // .vlsir.circuit.Module module = 11;
  if (this->has_module()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *module_);
  }

  // .vlsir.tetris.Abstract abstract = 12;
  if (this->has_abstract()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *abstract_);
  }

  // .vlsir.tetris.Layout layout = 13;
  if (this->has_layout()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *layout_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Cell::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Cell)
  GOOGLE_DCHECK_NE(&from, this);
  const Cell* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Cell>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Cell)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Cell)
    MergeFrom(*source);
  }
}

void Cell::MergeFrom(const Cell& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Cell)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_interface()) {
    _internal_mutable_interface()->::vlsir::circuit::Interface::MergeFrom(from._internal_interface());
  }
  if (from.has_module()) {
    _internal_mutable_module()->::vlsir::circuit::Module::MergeFrom(from._internal_module());
  }
  if (from.has_abstract()) {
    _internal_mutable_abstract()->::vlsir::tetris::Abstract::MergeFrom(from._internal_abstract());
  }
  if (from.has_layout()) {
    _internal_mutable_layout()->::vlsir::tetris::Layout::MergeFrom(from._internal_layout());
  }
}

void Cell::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Cell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cell::CopyFrom(const Cell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Cell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cell::IsInitialized() const {
  return true;
}

void Cell::InternalSwap(Cell* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cell, layout_)
      + sizeof(Cell::layout_)
      - PROTOBUF_FIELD_OFFSET(Cell, interface_)>(
          reinterpret_cast<char*>(&interface_),
          reinterpret_cast<char*>(&other->interface_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cell::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Layout::InitAsDefaultInstance() {
  ::vlsir::tetris::_Layout_default_instance_._instance.get_mutable()->outline_ = const_cast< ::vlsir::tetris::Outline*>(
      ::vlsir::tetris::Outline::internal_default_instance());
}
class Layout::_Internal {
 public:
  static const ::vlsir::tetris::Outline& outline(const Layout* msg);
};

const ::vlsir::tetris::Outline&
Layout::_Internal::outline(const Layout* msg) {
  return *msg->outline_;
}
Layout::Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  instances_(arena),
  assignments_(arena),
  cuts_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Layout)
}
Layout::Layout(const Layout& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      instances_(from.instances_),
      assignments_(from.assignments_),
      cuts_(from.cuts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_outline()) {
    outline_ = new ::vlsir::tetris::Outline(*from.outline_);
  } else {
    outline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Layout)
}

void Layout::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Layout_tetris_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outline_ = nullptr;
}

Layout::~Layout() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Layout)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Layout::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete outline_;
}

void Layout::ArenaDtor(void* object) {
  Layout* _this = reinterpret_cast< Layout* >(object);
  (void)_this;
}
void Layout::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Layout::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Layout& Layout::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Layout_tetris_2eproto.base);
  return *internal_default_instance();
}


void Layout::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Layout)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  instances_.Clear();
  assignments_.Clear();
  cuts_.Clear();
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Layout::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Layout.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.Outline outline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_outline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Instance instances = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_instances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Assign assignments = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_assignments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.TrackCross cuts = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cuts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Layout::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Layout)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Layout.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->has_outline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::outline(this), target, stream);
  }

  // repeated .vlsir.tetris.Instance instances = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_instances_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_instances(i), target, stream);
  }

  // repeated .vlsir.tetris.Assign assignments = 21;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_assignments_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, this->_internal_assignments(i), target, stream);
  }

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cuts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, this->_internal_cuts(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Layout)
  return target;
}

size_t Layout::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Layout)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.Instance instances = 20;
  total_size += 2UL * this->_internal_instances_size();
  for (const auto& msg : this->instances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.Assign assignments = 21;
  total_size += 2UL * this->_internal_assignments_size();
  for (const auto& msg : this->assignments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  total_size += 2UL * this->_internal_cuts_size();
  for (const auto& msg : this->cuts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->has_outline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Layout::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Layout)
  GOOGLE_DCHECK_NE(&from, this);
  const Layout* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Layout>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Layout)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Layout)
    MergeFrom(*source);
  }
}

void Layout::MergeFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Layout)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  instances_.MergeFrom(from.instances_);
  assignments_.MergeFrom(from.assignments_);
  cuts_.MergeFrom(from.cuts_);
  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_outline()) {
    _internal_mutable_outline()->::vlsir::tetris::Outline::MergeFrom(from._internal_outline());
  }
}

void Layout::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Layout)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Layout::CopyFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Layout)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layout::IsInitialized() const {
  return true;
}

void Layout::InternalSwap(Layout* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  instances_.InternalSwap(&other->instances_);
  assignments_.InternalSwap(&other->assignments_);
  cuts_.InternalSwap(&other->cuts_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(outline_, other->outline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Layout::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Assign::InitAsDefaultInstance() {
  ::vlsir::tetris::_Assign_default_instance_._instance.get_mutable()->at_ = const_cast< ::vlsir::tetris::TrackCross*>(
      ::vlsir::tetris::TrackCross::internal_default_instance());
}
class Assign::_Internal {
 public:
  static const ::vlsir::tetris::TrackCross& at(const Assign* msg);
};

const ::vlsir::tetris::TrackCross&
Assign::_Internal::at(const Assign* msg) {
  return *msg->at_;
}
Assign::Assign(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Assign)
}
Assign::Assign(const Assign& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_net().empty()) {
    net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_net(),
      GetArena());
  }
  if (from._internal_has_at()) {
    at_ = new ::vlsir::tetris::TrackCross(*from.at_);
  } else {
    at_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Assign)
}

void Assign::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Assign_tetris_2eproto.base);
  net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  at_ = nullptr;
}

Assign::~Assign() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Assign)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Assign::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  net_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete at_;
}

void Assign::ArenaDtor(void* object) {
  Assign* _this = reinterpret_cast< Assign* >(object);
  (void)_this;
}
void Assign::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Assign::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Assign& Assign::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Assign_tetris_2eproto.base);
  return *internal_default_instance();
}


void Assign::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Assign)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  net_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && at_ != nullptr) {
    delete at_;
  }
  at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Assign::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_net();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Assign.net"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackCross at = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_at(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Assign::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Assign)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string net = 1;
  if (this->net().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_net().data(), static_cast<int>(this->_internal_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Assign.net");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_net(), target);
  }

  // .vlsir.tetris.TrackCross at = 2;
  if (this->has_at()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::at(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Assign)
  return target;
}

size_t Assign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Assign)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string net = 1;
  if (this->net().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_net());
  }

  // .vlsir.tetris.TrackCross at = 2;
  if (this->has_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *at_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Assign::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Assign)
  GOOGLE_DCHECK_NE(&from, this);
  const Assign* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Assign>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Assign)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Assign)
    MergeFrom(*source);
  }
}

void Assign::MergeFrom(const Assign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Assign)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.net().size() > 0) {
    _internal_set_net(from._internal_net());
  }
  if (from.has_at()) {
    _internal_mutable_at()->::vlsir::tetris::TrackCross::MergeFrom(from._internal_at());
  }
}

void Assign::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Assign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Assign::CopyFrom(const Assign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Assign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Assign::IsInitialized() const {
  return true;
}

void Assign::InternalSwap(Assign* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  net_.Swap(&other->net_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(at_, other->at_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Assign::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrackCross::InitAsDefaultInstance() {
  ::vlsir::tetris::_TrackCross_default_instance_._instance.get_mutable()->track_ = const_cast< ::vlsir::tetris::TrackRef*>(
      ::vlsir::tetris::TrackRef::internal_default_instance());
  ::vlsir::tetris::_TrackCross_default_instance_._instance.get_mutable()->cross_ = const_cast< ::vlsir::tetris::TrackRef*>(
      ::vlsir::tetris::TrackRef::internal_default_instance());
}
class TrackCross::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& track(const TrackCross* msg);
  static const ::vlsir::tetris::TrackRef& cross(const TrackCross* msg);
};

const ::vlsir::tetris::TrackRef&
TrackCross::_Internal::track(const TrackCross* msg) {
  return *msg->track_;
}
const ::vlsir::tetris::TrackRef&
TrackCross::_Internal::cross(const TrackCross* msg) {
  return *msg->cross_;
}
TrackCross::TrackCross(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackCross)
}
TrackCross::TrackCross(const TrackCross& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_track()) {
    track_ = new ::vlsir::tetris::TrackRef(*from.track_);
  } else {
    track_ = nullptr;
  }
  if (from._internal_has_cross()) {
    cross_ = new ::vlsir::tetris::TrackRef(*from.cross_);
  } else {
    cross_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackCross)
}

void TrackCross::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrackCross_tetris_2eproto.base);
  ::memset(&track_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cross_) -
      reinterpret_cast<char*>(&track_)) + sizeof(cross_));
}

TrackCross::~TrackCross() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackCross)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrackCross::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete track_;
  if (this != internal_default_instance()) delete cross_;
}

void TrackCross::ArenaDtor(void* object) {
  TrackCross* _this = reinterpret_cast< TrackCross* >(object);
  (void)_this;
}
void TrackCross::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackCross::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrackCross& TrackCross::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrackCross_tetris_2eproto.base);
  return *internal_default_instance();
}


void TrackCross::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackCross)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && track_ != nullptr) {
    delete track_;
  }
  track_ = nullptr;
  if (GetArena() == nullptr && cross_ != nullptr) {
    delete cross_;
  }
  cross_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackCross::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackRef track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackRef cross = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cross(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrackCross::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackCross)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->has_track()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::track(this), target, stream);
  }

  // .vlsir.tetris.TrackRef cross = 2;
  if (this->has_cross()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::cross(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackCross)
  return target;
}

size_t TrackCross::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackCross)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *track_);
  }

  // .vlsir.tetris.TrackRef cross = 2;
  if (this->has_cross()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cross_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrackCross::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.TrackCross)
  GOOGLE_DCHECK_NE(&from, this);
  const TrackCross* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrackCross>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.TrackCross)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.TrackCross)
    MergeFrom(*source);
  }
}

void TrackCross::MergeFrom(const TrackCross& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackCross)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_track()) {
    _internal_mutable_track()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_track());
  }
  if (from.has_cross()) {
    _internal_mutable_cross()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_cross());
  }
}

void TrackCross::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.TrackCross)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackCross::CopyFrom(const TrackCross& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackCross)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackCross::IsInitialized() const {
  return true;
}

void TrackCross::InternalSwap(TrackCross* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackCross, cross_)
      + sizeof(TrackCross::cross_)
      - PROTOBUF_FIELD_OFFSET(TrackCross, track_)>(
          reinterpret_cast<char*>(&track_),
          reinterpret_cast<char*>(&other->track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackCross::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrackRef::InitAsDefaultInstance() {
}
class TrackRef::_Internal {
 public:
};

TrackRef::TrackRef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackRef)
}
TrackRef::TrackRef(const TrackRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&layer_, &from.layer_,
    static_cast<size_t>(reinterpret_cast<char*>(&track_) -
    reinterpret_cast<char*>(&layer_)) + sizeof(track_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackRef)
}

void TrackRef::SharedCtor() {
  ::memset(&layer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&track_) -
      reinterpret_cast<char*>(&layer_)) + sizeof(track_));
}

TrackRef::~TrackRef() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackRef)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrackRef::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TrackRef::ArenaDtor(void* object) {
  TrackRef* _this = reinterpret_cast< TrackRef* >(object);
  (void)_this;
}
void TrackRef::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackRef::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrackRef& TrackRef::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrackRef_tetris_2eproto.base);
  return *internal_default_instance();
}


void TrackRef::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackRef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&layer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&track_) -
      reinterpret_cast<char*>(&layer_)) + sizeof(track_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackRef::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int64 layer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          layer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 track = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrackRef::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackRef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 layer = 1;
  if (this->layer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_layer(), target);
  }

  // int64 track = 2;
  if (this->track() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_track(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackRef)
  return target;
}

size_t TrackRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackRef)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 layer = 1;
  if (this->layer() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_layer());
  }

  // int64 track = 2;
  if (this->track() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_track());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrackRef::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.TrackRef)
  GOOGLE_DCHECK_NE(&from, this);
  const TrackRef* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrackRef>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.TrackRef)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.TrackRef)
    MergeFrom(*source);
  }
}

void TrackRef::MergeFrom(const TrackRef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackRef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.layer() != 0) {
    _internal_set_layer(from._internal_layer());
  }
  if (from.track() != 0) {
    _internal_set_track(from._internal_track());
  }
}

void TrackRef::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.TrackRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackRef::CopyFrom(const TrackRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackRef::IsInitialized() const {
  return true;
}

void TrackRef::InternalSwap(TrackRef* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackRef, track_)
      + sizeof(TrackRef::track_)
      - PROTOBUF_FIELD_OFFSET(TrackRef, layer_)>(
          reinterpret_cast<char*>(&layer_),
          reinterpret_cast<char*>(&other->layer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackRef::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Outline::InitAsDefaultInstance() {
}
class Outline::_Internal {
 public:
};

Outline::Outline(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  x_(arena),
  y_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Outline)
}
Outline::Outline(const Outline& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      x_(from.x_),
      y_(from.y_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  metals_ = from.metals_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Outline)
}

void Outline::SharedCtor() {
  metals_ = PROTOBUF_LONGLONG(0);
}

Outline::~Outline() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Outline)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Outline::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Outline::ArenaDtor(void* object) {
  Outline* _this = reinterpret_cast< Outline* >(object);
  (void)_this;
}
void Outline::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Outline::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Outline& Outline::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Outline_tetris_2eproto.base);
  return *internal_default_instance();
}


void Outline::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Outline)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  x_.Clear();
  y_.Clear();
  metals_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Outline::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_x(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8) {
          _internal_add_x(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_y(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          _internal_add_y(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 metals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          metals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Outline::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Outline)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 x = 1;
  {
    int byte_size = _x_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_x(), byte_size, target);
    }
  }

  // repeated int64 y = 2;
  {
    int byte_size = _y_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_y(), byte_size, target);
    }
  }

  // int64 metals = 3;
  if (this->metals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_metals(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Outline)
  return target;
}

size_t Outline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Outline)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 x = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->x_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _x_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 y = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->y_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _y_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 metals = 3;
  if (this->metals() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_metals());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Outline::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Outline)
  GOOGLE_DCHECK_NE(&from, this);
  const Outline* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Outline>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Outline)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Outline)
    MergeFrom(*source);
  }
}

void Outline::MergeFrom(const Outline& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Outline)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  x_.MergeFrom(from.x_);
  y_.MergeFrom(from.y_);
  if (from.metals() != 0) {
    _internal_set_metals(from._internal_metals());
  }
}

void Outline::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Outline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Outline::CopyFrom(const Outline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Outline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Outline::IsInitialized() const {
  return true;
}

void Outline::InternalSwap(Outline* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  x_.InternalSwap(&other->x_);
  y_.InternalSwap(&other->y_);
  swap(metals_, other->metals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Outline::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Abstract::InitAsDefaultInstance() {
  ::vlsir::tetris::_Abstract_default_instance_._instance.get_mutable()->outline_ = const_cast< ::vlsir::tetris::Outline*>(
      ::vlsir::tetris::Outline::internal_default_instance());
}
class Abstract::_Internal {
 public:
  static const ::vlsir::tetris::Outline& outline(const Abstract* msg);
};

const ::vlsir::tetris::Outline&
Abstract::_Internal::outline(const Abstract* msg) {
  return *msg->outline_;
}
Abstract::Abstract(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  ports_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Abstract)
}
Abstract::Abstract(const Abstract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ports_(from.ports_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_outline()) {
    outline_ = new ::vlsir::tetris::Outline(*from.outline_);
  } else {
    outline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Abstract)
}

void Abstract::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Abstract_tetris_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outline_ = nullptr;
}

Abstract::~Abstract() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Abstract)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Abstract::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete outline_;
}

void Abstract::ArenaDtor(void* object) {
  Abstract* _this = reinterpret_cast< Abstract* >(object);
  (void)_this;
}
void Abstract::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Abstract::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Abstract& Abstract::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Abstract_tetris_2eproto.base);
  return *internal_default_instance();
}


void Abstract::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Abstract)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ports_.Clear();
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Abstract::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Abstract.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.Outline outline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_outline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.AbstractPort ports = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Abstract::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Abstract)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Abstract.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->has_outline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::outline(this), target, stream);
  }

  // repeated .vlsir.tetris.AbstractPort ports = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ports_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_ports(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Abstract)
  return target;
}

size_t Abstract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Abstract)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.AbstractPort ports = 20;
  total_size += 2UL * this->_internal_ports_size();
  for (const auto& msg : this->ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->has_outline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Abstract::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Abstract)
  GOOGLE_DCHECK_NE(&from, this);
  const Abstract* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Abstract>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Abstract)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Abstract)
    MergeFrom(*source);
  }
}

void Abstract::MergeFrom(const Abstract& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Abstract)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ports_.MergeFrom(from.ports_);
  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_outline()) {
    _internal_mutable_outline()->::vlsir::tetris::Outline::MergeFrom(from._internal_outline());
  }
}

void Abstract::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Abstract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Abstract::CopyFrom(const Abstract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Abstract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Abstract::IsInitialized() const {
  return true;
}

void Abstract::InternalSwap(Abstract* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ports_.InternalSwap(&other->ports_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(outline_, other->outline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Abstract::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AbstractPort_EdgePort::InitAsDefaultInstance() {
  ::vlsir::tetris::_AbstractPort_EdgePort_default_instance_._instance.get_mutable()->track_ = const_cast< ::vlsir::tetris::TrackRef*>(
      ::vlsir::tetris::TrackRef::internal_default_instance());
}
class AbstractPort_EdgePort::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& track(const AbstractPort_EdgePort* msg);
};

const ::vlsir::tetris::TrackRef&
AbstractPort_EdgePort::_Internal::track(const AbstractPort_EdgePort* msg) {
  return *msg->track_;
}
AbstractPort_EdgePort::AbstractPort_EdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.EdgePort)
}
AbstractPort_EdgePort::AbstractPort_EdgePort(const AbstractPort_EdgePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_track()) {
    track_ = new ::vlsir::tetris::TrackRef(*from.track_);
  } else {
    track_ = nullptr;
  }
  side_ = from.side_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.EdgePort)
}

void AbstractPort_EdgePort::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AbstractPort_EdgePort_tetris_2eproto.base);
  ::memset(&track_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&side_) -
      reinterpret_cast<char*>(&track_)) + sizeof(side_));
}

AbstractPort_EdgePort::~AbstractPort_EdgePort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.EdgePort)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AbstractPort_EdgePort::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete track_;
}

void AbstractPort_EdgePort::ArenaDtor(void* object) {
  AbstractPort_EdgePort* _this = reinterpret_cast< AbstractPort_EdgePort* >(object);
  (void)_this;
}
void AbstractPort_EdgePort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort_EdgePort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbstractPort_EdgePort& AbstractPort_EdgePort::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AbstractPort_EdgePort_tetris_2eproto.base);
  return *internal_default_instance();
}


void AbstractPort_EdgePort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.EdgePort)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && track_ != nullptr) {
    delete track_;
  }
  track_ = nullptr;
  side_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_EdgePort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackRef track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.PortSide side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::vlsir::tetris::AbstractPort_PortSide>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AbstractPort_EdgePort::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.EdgePort)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->has_track()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::track(this), target, stream);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.EdgePort)
  return target;
}

size_t AbstractPort_EdgePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.EdgePort)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *track_);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->side() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_side());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbstractPort_EdgePort::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.AbstractPort.EdgePort)
  GOOGLE_DCHECK_NE(&from, this);
  const AbstractPort_EdgePort* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AbstractPort_EdgePort>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.AbstractPort.EdgePort)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.AbstractPort.EdgePort)
    MergeFrom(*source);
  }
}

void AbstractPort_EdgePort::MergeFrom(const AbstractPort_EdgePort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.EdgePort)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_track()) {
    _internal_mutable_track()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_track());
  }
  if (from.side() != 0) {
    _internal_set_side(from._internal_side());
  }
}

void AbstractPort_EdgePort::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.AbstractPort.EdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbstractPort_EdgePort::CopyFrom(const AbstractPort_EdgePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.EdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_EdgePort::IsInitialized() const {
  return true;
}

void AbstractPort_EdgePort::InternalSwap(AbstractPort_EdgePort* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbstractPort_EdgePort, side_)
      + sizeof(AbstractPort_EdgePort::side_)
      - PROTOBUF_FIELD_OFFSET(AbstractPort_EdgePort, track_)>(
          reinterpret_cast<char*>(&track_),
          reinterpret_cast<char*>(&other->track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_EdgePort::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AbstractPort_ZTopEdgePort::InitAsDefaultInstance() {
  ::vlsir::tetris::_AbstractPort_ZTopEdgePort_default_instance_._instance.get_mutable()->into_ = const_cast< ::vlsir::tetris::TrackRef*>(
      ::vlsir::tetris::TrackRef::internal_default_instance());
}
class AbstractPort_ZTopEdgePort::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& into(const AbstractPort_ZTopEdgePort* msg);
};

const ::vlsir::tetris::TrackRef&
AbstractPort_ZTopEdgePort::_Internal::into(const AbstractPort_ZTopEdgePort* msg) {
  return *msg->into_;
}
AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
}
AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(const AbstractPort_ZTopEdgePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_into()) {
    into_ = new ::vlsir::tetris::TrackRef(*from.into_);
  } else {
    into_ = nullptr;
  }
  ::memcpy(&track_, &from.track_,
    static_cast<size_t>(reinterpret_cast<char*>(&side_) -
    reinterpret_cast<char*>(&track_)) + sizeof(side_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
}

void AbstractPort_ZTopEdgePort::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AbstractPort_ZTopEdgePort_tetris_2eproto.base);
  ::memset(&into_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&side_) -
      reinterpret_cast<char*>(&into_)) + sizeof(side_));
}

AbstractPort_ZTopEdgePort::~AbstractPort_ZTopEdgePort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AbstractPort_ZTopEdgePort::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete into_;
}

void AbstractPort_ZTopEdgePort::ArenaDtor(void* object) {
  AbstractPort_ZTopEdgePort* _this = reinterpret_cast< AbstractPort_ZTopEdgePort* >(object);
  (void)_this;
}
void AbstractPort_ZTopEdgePort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort_ZTopEdgePort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbstractPort_ZTopEdgePort& AbstractPort_ZTopEdgePort::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AbstractPort_ZTopEdgePort_tetris_2eproto.base);
  return *internal_default_instance();
}


void AbstractPort_ZTopEdgePort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && into_ != nullptr) {
    delete into_;
  }
  into_ = nullptr;
  ::memset(&track_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&side_) -
      reinterpret_cast<char*>(&track_)) + sizeof(side_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_ZTopEdgePort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int64 track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.PortSide side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::vlsir::tetris::AbstractPort_PortSide>(val));
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackRef into = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_into(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AbstractPort_ZTopEdgePort::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 track = 1;
  if (this->track() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_track(), target);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_side(), target);
  }

  // .vlsir.tetris.TrackRef into = 3;
  if (this->has_into()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::into(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.ZTopEdgePort)
  return target;
}

size_t AbstractPort_ZTopEdgePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef into = 3;
  if (this->has_into()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *into_);
  }

  // int64 track = 1;
  if (this->track() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_track());
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->side() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_side());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbstractPort_ZTopEdgePort::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  GOOGLE_DCHECK_NE(&from, this);
  const AbstractPort_ZTopEdgePort* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AbstractPort_ZTopEdgePort>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.AbstractPort.ZTopEdgePort)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.AbstractPort.ZTopEdgePort)
    MergeFrom(*source);
  }
}

void AbstractPort_ZTopEdgePort::MergeFrom(const AbstractPort_ZTopEdgePort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_into()) {
    _internal_mutable_into()->::vlsir::tetris::TrackRef::MergeFrom(from._internal_into());
  }
  if (from.track() != 0) {
    _internal_set_track(from._internal_track());
  }
  if (from.side() != 0) {
    _internal_set_side(from._internal_side());
  }
}

void AbstractPort_ZTopEdgePort::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbstractPort_ZTopEdgePort::CopyFrom(const AbstractPort_ZTopEdgePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_ZTopEdgePort::IsInitialized() const {
  return true;
}

void AbstractPort_ZTopEdgePort::InternalSwap(AbstractPort_ZTopEdgePort* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbstractPort_ZTopEdgePort, side_)
      + sizeof(AbstractPort_ZTopEdgePort::side_)
      - PROTOBUF_FIELD_OFFSET(AbstractPort_ZTopEdgePort, into_)>(
          reinterpret_cast<char*>(&into_),
          reinterpret_cast<char*>(&other->into_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_ZTopEdgePort::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AbstractPort_ZTopInner::InitAsDefaultInstance() {
}
class AbstractPort_ZTopInner::_Internal {
 public:
};

AbstractPort_ZTopInner::AbstractPort_ZTopInner(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  locs_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.ZTopInner)
}
AbstractPort_ZTopInner::AbstractPort_ZTopInner(const AbstractPort_ZTopInner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      locs_(from.locs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.ZTopInner)
}

void AbstractPort_ZTopInner::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AbstractPort_ZTopInner_tetris_2eproto.base);
}

AbstractPort_ZTopInner::~AbstractPort_ZTopInner() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.ZTopInner)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AbstractPort_ZTopInner::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AbstractPort_ZTopInner::ArenaDtor(void* object) {
  AbstractPort_ZTopInner* _this = reinterpret_cast< AbstractPort_ZTopInner* >(object);
  (void)_this;
}
void AbstractPort_ZTopInner::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort_ZTopInner::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbstractPort_ZTopInner& AbstractPort_ZTopInner::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AbstractPort_ZTopInner_tetris_2eproto.base);
  return *internal_default_instance();
}


void AbstractPort_ZTopInner::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.ZTopInner)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  locs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_ZTopInner::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .vlsir.tetris.TrackCross locs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AbstractPort_ZTopInner::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.ZTopInner)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackCross locs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_locs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_locs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.ZTopInner)
  return target;
}

size_t AbstractPort_ZTopInner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.ZTopInner)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackCross locs = 1;
  total_size += 1UL * this->_internal_locs_size();
  for (const auto& msg : this->locs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbstractPort_ZTopInner::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  GOOGLE_DCHECK_NE(&from, this);
  const AbstractPort_ZTopInner* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AbstractPort_ZTopInner>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.AbstractPort.ZTopInner)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.AbstractPort.ZTopInner)
    MergeFrom(*source);
  }
}

void AbstractPort_ZTopInner::MergeFrom(const AbstractPort_ZTopInner& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  locs_.MergeFrom(from.locs_);
}

void AbstractPort_ZTopInner::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbstractPort_ZTopInner::CopyFrom(const AbstractPort_ZTopInner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_ZTopInner::IsInitialized() const {
  return true;
}

void AbstractPort_ZTopInner::InternalSwap(AbstractPort_ZTopInner* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  locs_.InternalSwap(&other->locs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_ZTopInner::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AbstractPort::InitAsDefaultInstance() {
  ::vlsir::tetris::_AbstractPort_default_instance_.edge_ = const_cast< ::vlsir::tetris::AbstractPort_EdgePort*>(
      ::vlsir::tetris::AbstractPort_EdgePort::internal_default_instance());
  ::vlsir::tetris::_AbstractPort_default_instance_.ztop_edge_ = const_cast< ::vlsir::tetris::AbstractPort_ZTopEdgePort*>(
      ::vlsir::tetris::AbstractPort_ZTopEdgePort::internal_default_instance());
  ::vlsir::tetris::_AbstractPort_default_instance_.ztop_inner_ = const_cast< ::vlsir::tetris::AbstractPort_ZTopInner*>(
      ::vlsir::tetris::AbstractPort_ZTopInner::internal_default_instance());
}
class AbstractPort::_Internal {
 public:
  static const ::vlsir::tetris::AbstractPort_EdgePort& edge(const AbstractPort* msg);
  static const ::vlsir::tetris::AbstractPort_ZTopEdgePort& ztop_edge(const AbstractPort* msg);
  static const ::vlsir::tetris::AbstractPort_ZTopInner& ztop_inner(const AbstractPort* msg);
};

const ::vlsir::tetris::AbstractPort_EdgePort&
AbstractPort::_Internal::edge(const AbstractPort* msg) {
  return *msg->kind_.edge_;
}
const ::vlsir::tetris::AbstractPort_ZTopEdgePort&
AbstractPort::_Internal::ztop_edge(const AbstractPort* msg) {
  return *msg->kind_.ztop_edge_;
}
const ::vlsir::tetris::AbstractPort_ZTopInner&
AbstractPort::_Internal::ztop_inner(const AbstractPort* msg) {
  return *msg->kind_.ztop_inner_;
}
void AbstractPort::set_allocated_edge(::vlsir::tetris::AbstractPort_EdgePort* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_kind();
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    set_has_edge();
    kind_.edge_ = edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.edge)
}
void AbstractPort::set_allocated_ztop_edge(::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_kind();
  if (ztop_edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ztop_edge);
    if (message_arena != submessage_arena) {
      ztop_edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ztop_edge, submessage_arena);
    }
    set_has_ztop_edge();
    kind_.ztop_edge_ = ztop_edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ztop_edge)
}
void AbstractPort::set_allocated_ztop_inner(::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_kind();
  if (ztop_inner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ztop_inner);
    if (message_arena != submessage_arena) {
      ztop_inner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ztop_inner, submessage_arena);
    }
    set_has_ztop_inner();
    kind_.ztop_inner_ = ztop_inner;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ztop_inner)
}
AbstractPort::AbstractPort(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort)
}
AbstractPort::AbstractPort(const AbstractPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_net().empty()) {
    net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_net(),
      GetArena());
  }
  clear_has_kind();
  switch (from.kind_case()) {
    case kEdge: {
      _internal_mutable_edge()->::vlsir::tetris::AbstractPort_EdgePort::MergeFrom(from._internal_edge());
      break;
    }
    case kZtopEdge: {
      _internal_mutable_ztop_edge()->::vlsir::tetris::AbstractPort_ZTopEdgePort::MergeFrom(from._internal_ztop_edge());
      break;
    }
    case kZtopInner: {
      _internal_mutable_ztop_inner()->::vlsir::tetris::AbstractPort_ZTopInner::MergeFrom(from._internal_ztop_inner());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort)
}

void AbstractPort::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AbstractPort_tetris_2eproto.base);
  net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  clear_has_kind();
}

AbstractPort::~AbstractPort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AbstractPort::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  net_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_kind()) {
    clear_kind();
  }
}

void AbstractPort::ArenaDtor(void* object) {
  AbstractPort* _this = reinterpret_cast< AbstractPort* >(object);
  (void)_this;
}
void AbstractPort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AbstractPort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbstractPort& AbstractPort::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AbstractPort_tetris_2eproto.base);
  return *internal_default_instance();
}


void AbstractPort::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.AbstractPort)
  switch (kind_case()) {
    case kEdge: {
      if (GetArena() == nullptr) {
        delete kind_.edge_;
      }
      break;
    }
    case kZtopEdge: {
      if (GetArena() == nullptr) {
        delete kind_.ztop_edge_;
      }
      break;
    }
    case kZtopInner: {
      if (GetArena() == nullptr) {
        delete kind_.ztop_inner_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void AbstractPort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  net_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  clear_kind();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_net();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.AbstractPort.net"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ztop_edge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_ztop_inner(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AbstractPort::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string net = 1;
  if (this->net().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_net().data(), static_cast<int>(this->_internal_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.AbstractPort.net");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_net(), target);
  }

  // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
  if (_internal_has_edge()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::edge(this), target, stream);
  }

  // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
  if (_internal_has_ztop_edge()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::ztop_edge(this), target, stream);
  }

  // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
  if (_internal_has_ztop_inner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::ztop_inner(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort)
  return target;
}

size_t AbstractPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string net = 1;
  if (this->net().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_net());
  }

  switch (kind_case()) {
    // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
    case kEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.edge_);
      break;
    }
    // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
    case kZtopEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.ztop_edge_);
      break;
    }
    // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
    case kZtopInner: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.ztop_inner_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbstractPort::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.AbstractPort)
  GOOGLE_DCHECK_NE(&from, this);
  const AbstractPort* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AbstractPort>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.AbstractPort)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.AbstractPort)
    MergeFrom(*source);
  }
}

void AbstractPort::MergeFrom(const AbstractPort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.net().size() > 0) {
    _internal_set_net(from._internal_net());
  }
  switch (from.kind_case()) {
    case kEdge: {
      _internal_mutable_edge()->::vlsir::tetris::AbstractPort_EdgePort::MergeFrom(from._internal_edge());
      break;
    }
    case kZtopEdge: {
      _internal_mutable_ztop_edge()->::vlsir::tetris::AbstractPort_ZTopEdgePort::MergeFrom(from._internal_ztop_edge());
      break;
    }
    case kZtopInner: {
      _internal_mutable_ztop_inner()->::vlsir::tetris::AbstractPort_ZTopInner::MergeFrom(from._internal_ztop_inner());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
}

void AbstractPort::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.AbstractPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbstractPort::CopyFrom(const AbstractPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort::IsInitialized() const {
  return true;
}

void AbstractPort::InternalSwap(AbstractPort* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  net_.Swap(&other->net_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Instance::InitAsDefaultInstance() {
  ::vlsir::tetris::_Instance_default_instance_._instance.get_mutable()->cell_ = const_cast< ::vlsir::utils::Reference*>(
      ::vlsir::utils::Reference::internal_default_instance());
  ::vlsir::tetris::_Instance_default_instance_._instance.get_mutable()->loc_ = const_cast< ::vlsir::tetris::Place*>(
      ::vlsir::tetris::Place::internal_default_instance());
}
class Instance::_Internal {
 public:
  static const ::vlsir::utils::Reference& cell(const Instance* msg);
  static const ::vlsir::tetris::Place& loc(const Instance* msg);
};

const ::vlsir::utils::Reference&
Instance::_Internal::cell(const Instance* msg) {
  return *msg->cell_;
}
const ::vlsir::tetris::Place&
Instance::_Internal::loc(const Instance* msg) {
  return *msg->loc_;
}
void Instance::clear_cell() {
  if (GetArena() == nullptr && cell_ != nullptr) {
    delete cell_;
  }
  cell_ = nullptr;
}
Instance::Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Instance)
}
Instance::Instance(const Instance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_cell()) {
    cell_ = new ::vlsir::utils::Reference(*from.cell_);
  } else {
    cell_ = nullptr;
  }
  if (from._internal_has_loc()) {
    loc_ = new ::vlsir::tetris::Place(*from.loc_);
  } else {
    loc_ = nullptr;
  }
  ::memcpy(&reflect_horiz_, &from.reflect_horiz_,
    static_cast<size_t>(reinterpret_cast<char*>(&reflect_vert_) -
    reinterpret_cast<char*>(&reflect_horiz_)) + sizeof(reflect_vert_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Instance)
}

void Instance::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Instance_tetris_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&cell_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reflect_vert_) -
      reinterpret_cast<char*>(&cell_)) + sizeof(reflect_vert_));
}

Instance::~Instance() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Instance)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Instance::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete cell_;
  if (this != internal_default_instance()) delete loc_;
}

void Instance::ArenaDtor(void* object) {
  Instance* _this = reinterpret_cast< Instance* >(object);
  (void)_this;
}
void Instance::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Instance::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Instance& Instance::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Instance_tetris_2eproto.base);
  return *internal_default_instance();
}


void Instance::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Instance)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && cell_ != nullptr) {
    delete cell_;
  }
  cell_ = nullptr;
  if (GetArena() == nullptr && loc_ != nullptr) {
    delete loc_;
  }
  loc_ = nullptr;
  ::memset(&reflect_horiz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reflect_vert_) -
      reinterpret_cast<char*>(&reflect_horiz_)) + sizeof(reflect_vert_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Instance::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.Instance.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.utils.Reference cell = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.Place loc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_loc(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool reflect_horiz = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          reflect_horiz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool reflect_vert = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          reflect_vert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Instance::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Instance)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Instance.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.utils.Reference cell = 3;
  if (this->has_cell()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cell(this), target, stream);
  }

  // .vlsir.tetris.Place loc = 4;
  if (this->has_loc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::loc(this), target, stream);
  }

  // bool reflect_horiz = 6;
  if (this->reflect_horiz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_reflect_horiz(), target);
  }

  // bool reflect_vert = 7;
  if (this->reflect_vert() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_reflect_vert(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Instance)
  return target;
}

size_t Instance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Instance)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.utils.Reference cell = 3;
  if (this->has_cell()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cell_);
  }

  // .vlsir.tetris.Place loc = 4;
  if (this->has_loc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *loc_);
  }

  // bool reflect_horiz = 6;
  if (this->reflect_horiz() != 0) {
    total_size += 1 + 1;
  }

  // bool reflect_vert = 7;
  if (this->reflect_vert() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Instance::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Instance)
  GOOGLE_DCHECK_NE(&from, this);
  const Instance* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Instance>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Instance)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Instance)
    MergeFrom(*source);
  }
}

void Instance::MergeFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Instance)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_cell()) {
    _internal_mutable_cell()->::vlsir::utils::Reference::MergeFrom(from._internal_cell());
  }
  if (from.has_loc()) {
    _internal_mutable_loc()->::vlsir::tetris::Place::MergeFrom(from._internal_loc());
  }
  if (from.reflect_horiz() != 0) {
    _internal_set_reflect_horiz(from._internal_reflect_horiz());
  }
  if (from.reflect_vert() != 0) {
    _internal_set_reflect_vert(from._internal_reflect_vert());
  }
}

void Instance::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Instance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Instance::CopyFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Instance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instance::IsInitialized() const {
  return true;
}

void Instance::InternalSwap(Instance* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Instance, reflect_vert_)
      + sizeof(Instance::reflect_vert_)
      - PROTOBUF_FIELD_OFFSET(Instance, cell_)>(
          reinterpret_cast<char*>(&cell_),
          reinterpret_cast<char*>(&other->cell_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Instance::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Place::InitAsDefaultInstance() {
  ::vlsir::tetris::_Place_default_instance_.abs_ = const_cast< ::vlsir::raw::Point*>(
      ::vlsir::raw::Point::internal_default_instance());
  ::vlsir::tetris::_Place_default_instance_.rel_ = const_cast< ::vlsir::tetris::RelPlace*>(
      ::vlsir::tetris::RelPlace::internal_default_instance());
}
class Place::_Internal {
 public:
  static const ::vlsir::raw::Point& abs(const Place* msg);
  static const ::vlsir::tetris::RelPlace& rel(const Place* msg);
};

const ::vlsir::raw::Point&
Place::_Internal::abs(const Place* msg) {
  return *msg->place_.abs_;
}
const ::vlsir::tetris::RelPlace&
Place::_Internal::rel(const Place* msg) {
  return *msg->place_.rel_;
}
void Place::set_allocated_abs(::vlsir::raw::Point* abs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_place();
  if (abs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abs)->GetArena();
    if (message_arena != submessage_arena) {
      abs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abs, submessage_arena);
    }
    set_has_abs();
    place_.abs_ = abs;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Place.abs)
}
void Place::clear_abs() {
  if (_internal_has_abs()) {
    if (GetArena() == nullptr) {
      delete place_.abs_;
    }
    clear_has_place();
  }
}
void Place::set_allocated_rel(::vlsir::tetris::RelPlace* rel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_place();
  if (rel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rel);
    if (message_arena != submessage_arena) {
      rel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rel, submessage_arena);
    }
    set_has_rel();
    place_.rel_ = rel;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Place.rel)
}
Place::Place(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Place)
}
Place::Place(const Place& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_place();
  switch (from.place_case()) {
    case kAbs: {
      _internal_mutable_abs()->::vlsir::raw::Point::MergeFrom(from._internal_abs());
      break;
    }
    case kRel: {
      _internal_mutable_rel()->::vlsir::tetris::RelPlace::MergeFrom(from._internal_rel());
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Place)
}

void Place::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Place_tetris_2eproto.base);
  clear_has_place();
}

Place::~Place() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Place)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Place::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_place()) {
    clear_place();
  }
}

void Place::ArenaDtor(void* object) {
  Place* _this = reinterpret_cast< Place* >(object);
  (void)_this;
}
void Place::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Place::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Place& Place::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Place_tetris_2eproto.base);
  return *internal_default_instance();
}


void Place::clear_place() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.Place)
  switch (place_case()) {
    case kAbs: {
      if (GetArena() == nullptr) {
        delete place_.abs_;
      }
      break;
    }
    case kRel: {
      if (GetArena() == nullptr) {
        delete place_.rel_;
      }
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PLACE_NOT_SET;
}


void Place::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Place)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_place();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Place::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.raw.Point abs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_abs(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.RelPlace rel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rel(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Place::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Place)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.raw.Point abs = 1;
  if (_internal_has_abs()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::abs(this), target, stream);
  }

  // .vlsir.tetris.RelPlace rel = 2;
  if (_internal_has_rel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::rel(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Place)
  return target;
}

size_t Place::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Place)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (place_case()) {
    // .vlsir.raw.Point abs = 1;
    case kAbs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *place_.abs_);
      break;
    }
    // .vlsir.tetris.RelPlace rel = 2;
    case kRel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *place_.rel_);
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Place::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Place)
  GOOGLE_DCHECK_NE(&from, this);
  const Place* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Place>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Place)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Place)
    MergeFrom(*source);
  }
}

void Place::MergeFrom(const Place& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Place)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.place_case()) {
    case kAbs: {
      _internal_mutable_abs()->::vlsir::raw::Point::MergeFrom(from._internal_abs());
      break;
    }
    case kRel: {
      _internal_mutable_rel()->::vlsir::tetris::RelPlace::MergeFrom(from._internal_rel());
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
}

void Place::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Place)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Place::CopyFrom(const Place& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Place)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Place::IsInitialized() const {
  return true;
}

void Place::InternalSwap(Place* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(place_, other->place_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Place::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RelPlace::InitAsDefaultInstance() {
}
class RelPlace::_Internal {
 public:
};

RelPlace::RelPlace(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.RelPlace)
}
RelPlace::RelPlace(const RelPlace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.RelPlace)
}

void RelPlace::SharedCtor() {
}

RelPlace::~RelPlace() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.RelPlace)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RelPlace::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void RelPlace::ArenaDtor(void* object) {
  RelPlace* _this = reinterpret_cast< RelPlace* >(object);
  (void)_this;
}
void RelPlace::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RelPlace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RelPlace& RelPlace::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RelPlace_tetris_2eproto.base);
  return *internal_default_instance();
}


void RelPlace::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.RelPlace)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RelPlace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RelPlace::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.RelPlace)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.RelPlace)
  return target;
}

size_t RelPlace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.RelPlace)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RelPlace::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.RelPlace)
  GOOGLE_DCHECK_NE(&from, this);
  const RelPlace* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RelPlace>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.RelPlace)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.RelPlace)
    MergeFrom(*source);
  }
}

void RelPlace::MergeFrom(const RelPlace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.RelPlace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void RelPlace::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.RelPlace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RelPlace::CopyFrom(const RelPlace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.RelPlace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RelPlace::IsInitialized() const {
  return true;
}

void RelPlace::InternalSwap(RelPlace* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RelPlace::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Stack::InitAsDefaultInstance() {
  ::vlsir::tetris::_Stack_default_instance_._instance.get_mutable()->prim_ = const_cast< ::vlsir::tetris::PrimitiveLayer*>(
      ::vlsir::tetris::PrimitiveLayer::internal_default_instance());
  ::vlsir::tetris::_Stack_default_instance_._instance.get_mutable()->boundary_layer_ = const_cast< ::vlsir::raw::Layer*>(
      ::vlsir::raw::Layer::internal_default_instance());
}
class Stack::_Internal {
 public:
  static const ::vlsir::tetris::PrimitiveLayer& prim(const Stack* msg);
  static const ::vlsir::raw::Layer& boundary_layer(const Stack* msg);
};

const ::vlsir::tetris::PrimitiveLayer&
Stack::_Internal::prim(const Stack* msg) {
  return *msg->prim_;
}
const ::vlsir::raw::Layer&
Stack::_Internal::boundary_layer(const Stack* msg) {
  return *msg->boundary_layer_;
}
void Stack::clear_boundary_layer() {
  if (GetArena() == nullptr && boundary_layer_ != nullptr) {
    delete boundary_layer_;
  }
  boundary_layer_ = nullptr;
}
Stack::Stack(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  metals_(arena),
  vias_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Stack)
}
Stack::Stack(const Stack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      metals_(from.metals_),
      vias_(from.vias_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_prim()) {
    prim_ = new ::vlsir::tetris::PrimitiveLayer(*from.prim_);
  } else {
    prim_ = nullptr;
  }
  if (from._internal_has_boundary_layer()) {
    boundary_layer_ = new ::vlsir::raw::Layer(*from.boundary_layer_);
  } else {
    boundary_layer_ = nullptr;
  }
  units_ = from.units_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Stack)
}

void Stack::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Stack_tetris_2eproto.base);
  ::memset(&prim_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&units_) -
      reinterpret_cast<char*>(&prim_)) + sizeof(units_));
}

Stack::~Stack() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Stack)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Stack::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete prim_;
  if (this != internal_default_instance()) delete boundary_layer_;
}

void Stack::ArenaDtor(void* object) {
  Stack* _this = reinterpret_cast< Stack* >(object);
  (void)_this;
}
void Stack::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Stack::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Stack& Stack::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Stack_tetris_2eproto.base);
  return *internal_default_instance();
}


void Stack::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Stack)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metals_.Clear();
  vias_.Clear();
  if (GetArena() == nullptr && prim_ != nullptr) {
    delete prim_;
  }
  prim_ = nullptr;
  if (GetArena() == nullptr && boundary_layer_ != nullptr) {
    delete boundary_layer_;
  }
  boundary_layer_ = nullptr;
  units_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stack::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.raw.Units units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_units(static_cast<::vlsir::raw::Units>(val));
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.PrimitiveLayer prim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prim(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.MetalLayer metals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.ViaLayer vias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vias(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // .vlsir.raw.Layer boundary_layer = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundary_layer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Stack::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Stack)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.raw.Units units = 1;
  if (this->units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_units(), target);
  }

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  if (this->has_prim()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::prim(this), target, stream);
  }

  // repeated .vlsir.tetris.MetalLayer metals = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_metals_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_metals(i), target, stream);
  }

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_vias_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_vias(i), target, stream);
  }

  // .vlsir.raw.Layer boundary_layer = 11;
  if (this->has_boundary_layer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::boundary_layer(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Stack)
  return target;
}

size_t Stack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Stack)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.MetalLayer metals = 3;
  total_size += 1UL * this->_internal_metals_size();
  for (const auto& msg : this->metals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  total_size += 1UL * this->_internal_vias_size();
  for (const auto& msg : this->vias_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  if (this->has_prim()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *prim_);
  }

  // .vlsir.raw.Layer boundary_layer = 11;
  if (this->has_boundary_layer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *boundary_layer_);
  }

  // .vlsir.raw.Units units = 1;
  if (this->units() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_units());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Stack::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Stack)
  GOOGLE_DCHECK_NE(&from, this);
  const Stack* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Stack>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Stack)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Stack)
    MergeFrom(*source);
  }
}

void Stack::MergeFrom(const Stack& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Stack)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  metals_.MergeFrom(from.metals_);
  vias_.MergeFrom(from.vias_);
  if (from.has_prim()) {
    _internal_mutable_prim()->::vlsir::tetris::PrimitiveLayer::MergeFrom(from._internal_prim());
  }
  if (from.has_boundary_layer()) {
    _internal_mutable_boundary_layer()->::vlsir::raw::Layer::MergeFrom(from._internal_boundary_layer());
  }
  if (from.units() != 0) {
    _internal_set_units(from._internal_units());
  }
}

void Stack::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Stack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stack::CopyFrom(const Stack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Stack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stack::IsInitialized() const {
  return true;
}

void Stack::InternalSwap(Stack* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  metals_.InternalSwap(&other->metals_);
  vias_.InternalSwap(&other->vias_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stack, units_)
      + sizeof(Stack::units_)
      - PROTOBUF_FIELD_OFFSET(Stack, prim_)>(
          reinterpret_cast<char*>(&prim_),
          reinterpret_cast<char*>(&other->prim_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stack::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LayerEnum::InitAsDefaultInstance() {
}
class LayerEnum::_Internal {
 public:
};

LayerEnum::LayerEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.LayerEnum)
}
LayerEnum::LayerEnum(const LayerEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&index_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.LayerEnum)
}

void LayerEnum::SharedCtor() {
  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&index_)) + sizeof(type_));
}

LayerEnum::~LayerEnum() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.LayerEnum)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LayerEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LayerEnum::ArenaDtor(void* object) {
  LayerEnum* _this = reinterpret_cast< LayerEnum* >(object);
  (void)_this;
}
void LayerEnum::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LayerEnum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LayerEnum& LayerEnum::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LayerEnum_tetris_2eproto.base);
  return *internal_default_instance();
}


void LayerEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.LayerEnum)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&index_)) + sizeof(type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LayerEnum::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.tetris.LayerEnum.LayerType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::vlsir::tetris::LayerEnum_LayerType>(val));
        } else goto handle_unusual;
        continue;
      // int64 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LayerEnum::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.LayerEnum)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  if (this->type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // int64 index = 2;
  if (this->index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.LayerEnum)
  return target;
}

size_t LayerEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.LayerEnum)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 index = 2;
  if (this->index() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_index());
  }

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LayerEnum::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.LayerEnum)
  GOOGLE_DCHECK_NE(&from, this);
  const LayerEnum* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LayerEnum>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.LayerEnum)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.LayerEnum)
    MergeFrom(*source);
  }
}

void LayerEnum::MergeFrom(const LayerEnum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.LayerEnum)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.index() != 0) {
    _internal_set_index(from._internal_index());
  }
  if (from.type() != 0) {
    _internal_set_type(from._internal_type());
  }
}

void LayerEnum::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.LayerEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LayerEnum::CopyFrom(const LayerEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.LayerEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerEnum::IsInitialized() const {
  return true;
}

void LayerEnum::InternalSwap(LayerEnum* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LayerEnum, type_)
      + sizeof(LayerEnum::type_)
      - PROTOBUF_FIELD_OFFSET(LayerEnum, index_)>(
          reinterpret_cast<char*>(&index_),
          reinterpret_cast<char*>(&other->index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LayerEnum::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MetalLayer::InitAsDefaultInstance() {
  ::vlsir::tetris::_MetalLayer_default_instance_._instance.get_mutable()->raw_ = const_cast< ::vlsir::raw::Layer*>(
      ::vlsir::raw::Layer::internal_default_instance());
}
class MetalLayer::_Internal {
 public:
  static const ::vlsir::raw::Layer& raw(const MetalLayer* msg);
};

const ::vlsir::raw::Layer&
MetalLayer::_Internal::raw(const MetalLayer* msg) {
  return *msg->raw_;
}
void MetalLayer::clear_raw() {
  if (GetArena() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
}
MetalLayer::MetalLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  entries_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.MetalLayer)
}
MetalLayer::MetalLayer(const MetalLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_raw()) {
    raw_ = new ::vlsir::raw::Layer(*from.raw_);
  } else {
    raw_ = nullptr;
  }
  ::memcpy(&cutsize_, &from.cutsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&prim_) -
    reinterpret_cast<char*>(&cutsize_)) + sizeof(prim_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.MetalLayer)
}

void MetalLayer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MetalLayer_tetris_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&raw_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prim_) -
      reinterpret_cast<char*>(&raw_)) + sizeof(prim_));
}

MetalLayer::~MetalLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.MetalLayer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MetalLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete raw_;
}

void MetalLayer::ArenaDtor(void* object) {
  MetalLayer* _this = reinterpret_cast< MetalLayer* >(object);
  (void)_this;
}
void MetalLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MetalLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MetalLayer& MetalLayer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MetalLayer_tetris_2eproto.base);
  return *internal_default_instance();
}


void MetalLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.MetalLayer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
  ::memset(&cutsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prim_) -
      reinterpret_cast<char*>(&cutsize_)) + sizeof(prim_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MetalLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.MetalLayer.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.MetalLayer.Dir dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::vlsir::tetris::MetalLayer_Dir>(val));
        } else goto handle_unusual;
        continue;
      // int64 cutsize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          cutsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.TrackSpec entries = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // int64 offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 overlap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool flip = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          flip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_prim(static_cast<::vlsir::tetris::MetalLayer_PrimitiveMode>(val));
        } else goto handle_unusual;
        continue;
      // .vlsir.raw.Layer raw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MetalLayer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.MetalLayer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.MetalLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  if (this->dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_dir(), target);
  }

  // int64 cutsize = 3;
  if (this->cutsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_cutsize(), target);
  }

  // repeated .vlsir.tetris.TrackSpec entries = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_entries(i), target, stream);
  }

  // int64 offset = 5;
  if (this->offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_offset(), target);
  }

  // int64 overlap = 6;
  if (this->overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_overlap(), target);
  }

  // bool flip = 7;
  if (this->flip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_flip(), target);
  }

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  if (this->prim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_prim(), target);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->has_raw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::raw(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.MetalLayer)
  return target;
}

size_t MetalLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.MetalLayer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec entries = 4;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->has_raw()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *raw_);
  }

  // int64 cutsize = 3;
  if (this->cutsize() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_cutsize());
  }

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  if (this->dir() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dir());
  }

  // bool flip = 7;
  if (this->flip() != 0) {
    total_size += 1 + 1;
  }

  // int64 offset = 5;
  if (this->offset() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_offset());
  }

  // int64 overlap = 6;
  if (this->overlap() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_overlap());
  }

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  if (this->prim() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_prim());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MetalLayer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.MetalLayer)
  GOOGLE_DCHECK_NE(&from, this);
  const MetalLayer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MetalLayer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.MetalLayer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.MetalLayer)
    MergeFrom(*source);
  }
}

void MetalLayer::MergeFrom(const MetalLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.MetalLayer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_raw()) {
    _internal_mutable_raw()->::vlsir::raw::Layer::MergeFrom(from._internal_raw());
  }
  if (from.cutsize() != 0) {
    _internal_set_cutsize(from._internal_cutsize());
  }
  if (from.dir() != 0) {
    _internal_set_dir(from._internal_dir());
  }
  if (from.flip() != 0) {
    _internal_set_flip(from._internal_flip());
  }
  if (from.offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  if (from.overlap() != 0) {
    _internal_set_overlap(from._internal_overlap());
  }
  if (from.prim() != 0) {
    _internal_set_prim(from._internal_prim());
  }
}

void MetalLayer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.MetalLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MetalLayer::CopyFrom(const MetalLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.MetalLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetalLayer::IsInitialized() const {
  return true;
}

void MetalLayer::InternalSwap(MetalLayer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MetalLayer, prim_)
      + sizeof(MetalLayer::prim_)
      - PROTOBUF_FIELD_OFFSET(MetalLayer, raw_)>(
          reinterpret_cast<char*>(&raw_),
          reinterpret_cast<char*>(&other->raw_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MetalLayer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ViaLayer::InitAsDefaultInstance() {
  ::vlsir::tetris::_ViaLayer_default_instance_._instance.get_mutable()->top_ = const_cast< ::vlsir::tetris::LayerEnum*>(
      ::vlsir::tetris::LayerEnum::internal_default_instance());
  ::vlsir::tetris::_ViaLayer_default_instance_._instance.get_mutable()->bot_ = const_cast< ::vlsir::tetris::LayerEnum*>(
      ::vlsir::tetris::LayerEnum::internal_default_instance());
  ::vlsir::tetris::_ViaLayer_default_instance_._instance.get_mutable()->size_ = const_cast< ::vlsir::tetris::Xy*>(
      ::vlsir::tetris::Xy::internal_default_instance());
  ::vlsir::tetris::_ViaLayer_default_instance_._instance.get_mutable()->raw_ = const_cast< ::vlsir::raw::Layer*>(
      ::vlsir::raw::Layer::internal_default_instance());
}
class ViaLayer::_Internal {
 public:
  static const ::vlsir::tetris::LayerEnum& top(const ViaLayer* msg);
  static const ::vlsir::tetris::LayerEnum& bot(const ViaLayer* msg);
  static const ::vlsir::tetris::Xy& size(const ViaLayer* msg);
  static const ::vlsir::raw::Layer& raw(const ViaLayer* msg);
};

const ::vlsir::tetris::LayerEnum&
ViaLayer::_Internal::top(const ViaLayer* msg) {
  return *msg->top_;
}
const ::vlsir::tetris::LayerEnum&
ViaLayer::_Internal::bot(const ViaLayer* msg) {
  return *msg->bot_;
}
const ::vlsir::tetris::Xy&
ViaLayer::_Internal::size(const ViaLayer* msg) {
  return *msg->size_;
}
const ::vlsir::raw::Layer&
ViaLayer::_Internal::raw(const ViaLayer* msg) {
  return *msg->raw_;
}
void ViaLayer::clear_raw() {
  if (GetArena() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
}
ViaLayer::ViaLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.ViaLayer)
}
ViaLayer::ViaLayer(const ViaLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_top()) {
    top_ = new ::vlsir::tetris::LayerEnum(*from.top_);
  } else {
    top_ = nullptr;
  }
  if (from._internal_has_bot()) {
    bot_ = new ::vlsir::tetris::LayerEnum(*from.bot_);
  } else {
    bot_ = nullptr;
  }
  if (from._internal_has_size()) {
    size_ = new ::vlsir::tetris::Xy(*from.size_);
  } else {
    size_ = nullptr;
  }
  if (from._internal_has_raw()) {
    raw_ = new ::vlsir::raw::Layer(*from.raw_);
  } else {
    raw_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.ViaLayer)
}

void ViaLayer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ViaLayer_tetris_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&top_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&raw_) -
      reinterpret_cast<char*>(&top_)) + sizeof(raw_));
}

ViaLayer::~ViaLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.ViaLayer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ViaLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete top_;
  if (this != internal_default_instance()) delete bot_;
  if (this != internal_default_instance()) delete size_;
  if (this != internal_default_instance()) delete raw_;
}

void ViaLayer::ArenaDtor(void* object) {
  ViaLayer* _this = reinterpret_cast< ViaLayer* >(object);
  (void)_this;
}
void ViaLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ViaLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ViaLayer& ViaLayer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ViaLayer_tetris_2eproto.base);
  return *internal_default_instance();
}


void ViaLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.ViaLayer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && top_ != nullptr) {
    delete top_;
  }
  top_ = nullptr;
  if (GetArena() == nullptr && bot_ != nullptr) {
    delete bot_;
  }
  bot_ = nullptr;
  if (GetArena() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
  if (GetArena() == nullptr && raw_ != nullptr) {
    delete raw_;
  }
  raw_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ViaLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "vlsir.tetris.ViaLayer.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.LayerEnum top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_top(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.LayerEnum bot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bot(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.Xy size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.raw.Layer raw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ViaLayer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.ViaLayer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.ViaLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.LayerEnum top = 2;
  if (this->has_top()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::top(this), target, stream);
  }

  // .vlsir.tetris.LayerEnum bot = 3;
  if (this->has_bot()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::bot(this), target, stream);
  }

  // .vlsir.tetris.Xy size = 4;
  if (this->has_size()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::size(this), target, stream);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->has_raw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::raw(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.ViaLayer)
  return target;
}

size_t ViaLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.ViaLayer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.LayerEnum top = 2;
  if (this->has_top()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *top_);
  }

  // .vlsir.tetris.LayerEnum bot = 3;
  if (this->has_bot()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bot_);
  }

  // .vlsir.tetris.Xy size = 4;
  if (this->has_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *size_);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->has_raw()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *raw_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ViaLayer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.ViaLayer)
  GOOGLE_DCHECK_NE(&from, this);
  const ViaLayer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ViaLayer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.ViaLayer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.ViaLayer)
    MergeFrom(*source);
  }
}

void ViaLayer::MergeFrom(const ViaLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.ViaLayer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_top()) {
    _internal_mutable_top()->::vlsir::tetris::LayerEnum::MergeFrom(from._internal_top());
  }
  if (from.has_bot()) {
    _internal_mutable_bot()->::vlsir::tetris::LayerEnum::MergeFrom(from._internal_bot());
  }
  if (from.has_size()) {
    _internal_mutable_size()->::vlsir::tetris::Xy::MergeFrom(from._internal_size());
  }
  if (from.has_raw()) {
    _internal_mutable_raw()->::vlsir::raw::Layer::MergeFrom(from._internal_raw());
  }
}

void ViaLayer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.ViaLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ViaLayer::CopyFrom(const ViaLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.ViaLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViaLayer::IsInitialized() const {
  return true;
}

void ViaLayer::InternalSwap(ViaLayer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ViaLayer, raw_)
      + sizeof(ViaLayer::raw_)
      - PROTOBUF_FIELD_OFFSET(ViaLayer, top_)>(
          reinterpret_cast<char*>(&top_),
          reinterpret_cast<char*>(&other->top_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ViaLayer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PrimitiveLayer::InitAsDefaultInstance() {
  ::vlsir::tetris::_PrimitiveLayer_default_instance_._instance.get_mutable()->pitches_ = const_cast< ::vlsir::tetris::Xy*>(
      ::vlsir::tetris::Xy::internal_default_instance());
}
class PrimitiveLayer::_Internal {
 public:
  static const ::vlsir::tetris::Xy& pitches(const PrimitiveLayer* msg);
};

const ::vlsir::tetris::Xy&
PrimitiveLayer::_Internal::pitches(const PrimitiveLayer* msg) {
  return *msg->pitches_;
}
PrimitiveLayer::PrimitiveLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.PrimitiveLayer)
}
PrimitiveLayer::PrimitiveLayer(const PrimitiveLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pitches()) {
    pitches_ = new ::vlsir::tetris::Xy(*from.pitches_);
  } else {
    pitches_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.PrimitiveLayer)
}

void PrimitiveLayer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PrimitiveLayer_tetris_2eproto.base);
  pitches_ = nullptr;
}

PrimitiveLayer::~PrimitiveLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.PrimitiveLayer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PrimitiveLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pitches_;
}

void PrimitiveLayer::ArenaDtor(void* object) {
  PrimitiveLayer* _this = reinterpret_cast< PrimitiveLayer* >(object);
  (void)_this;
}
void PrimitiveLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrimitiveLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PrimitiveLayer& PrimitiveLayer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PrimitiveLayer_tetris_2eproto.base);
  return *internal_default_instance();
}


void PrimitiveLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.PrimitiveLayer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && pitches_ != nullptr) {
    delete pitches_;
  }
  pitches_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrimitiveLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.tetris.Xy pitches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pitches(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PrimitiveLayer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.PrimitiveLayer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.Xy pitches = 1;
  if (this->has_pitches()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pitches(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.PrimitiveLayer)
  return target;
}

size_t PrimitiveLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.PrimitiveLayer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.Xy pitches = 1;
  if (this->has_pitches()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pitches_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrimitiveLayer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.PrimitiveLayer)
  GOOGLE_DCHECK_NE(&from, this);
  const PrimitiveLayer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PrimitiveLayer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.PrimitiveLayer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.PrimitiveLayer)
    MergeFrom(*source);
  }
}

void PrimitiveLayer::MergeFrom(const PrimitiveLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.PrimitiveLayer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_pitches()) {
    _internal_mutable_pitches()->::vlsir::tetris::Xy::MergeFrom(from._internal_pitches());
  }
}

void PrimitiveLayer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.PrimitiveLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrimitiveLayer::CopyFrom(const PrimitiveLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.PrimitiveLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimitiveLayer::IsInitialized() const {
  return true;
}

void PrimitiveLayer::InternalSwap(PrimitiveLayer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(pitches_, other->pitches_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrimitiveLayer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrackSpec_TrackEntry::InitAsDefaultInstance() {
}
class TrackSpec_TrackEntry::_Internal {
 public:
};

TrackSpec_TrackEntry::TrackSpec_TrackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec.TrackEntry)
}
TrackSpec_TrackEntry::TrackSpec_TrackEntry(const TrackSpec_TrackEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&ttype_) -
    reinterpret_cast<char*>(&width_)) + sizeof(ttype_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec.TrackEntry)
}

void TrackSpec_TrackEntry::SharedCtor() {
  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ttype_) -
      reinterpret_cast<char*>(&width_)) + sizeof(ttype_));
}

TrackSpec_TrackEntry::~TrackSpec_TrackEntry() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec.TrackEntry)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrackSpec_TrackEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TrackSpec_TrackEntry::ArenaDtor(void* object) {
  TrackSpec_TrackEntry* _this = reinterpret_cast< TrackSpec_TrackEntry* >(object);
  (void)_this;
}
void TrackSpec_TrackEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackSpec_TrackEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrackSpec_TrackEntry& TrackSpec_TrackEntry::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrackSpec_TrackEntry_tetris_2eproto.base);
  return *internal_default_instance();
}


void TrackSpec_TrackEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec.TrackEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ttype_) -
      reinterpret_cast<char*>(&width_)) + sizeof(ttype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec_TrackEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ttype(static_cast<::vlsir::tetris::TrackSpec_TrackEntry_TrackType>(val));
        } else goto handle_unusual;
        continue;
      // int64 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrackSpec_TrackEntry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec.TrackEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  if (this->ttype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ttype(), target);
  }

  // int64 width = 2;
  if (this->width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec.TrackEntry)
  return target;
}

size_t TrackSpec_TrackEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec.TrackEntry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 width = 2;
  if (this->width() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_width());
  }

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  if (this->ttype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ttype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrackSpec_TrackEntry::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  GOOGLE_DCHECK_NE(&from, this);
  const TrackSpec_TrackEntry* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrackSpec_TrackEntry>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.TrackSpec.TrackEntry)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.TrackSpec.TrackEntry)
    MergeFrom(*source);
  }
}

void TrackSpec_TrackEntry::MergeFrom(const TrackSpec_TrackEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from.ttype() != 0) {
    _internal_set_ttype(from._internal_ttype());
  }
}

void TrackSpec_TrackEntry::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackSpec_TrackEntry::CopyFrom(const TrackSpec_TrackEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec_TrackEntry::IsInitialized() const {
  return true;
}

void TrackSpec_TrackEntry::InternalSwap(TrackSpec_TrackEntry* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackSpec_TrackEntry, ttype_)
      + sizeof(TrackSpec_TrackEntry::ttype_)
      - PROTOBUF_FIELD_OFFSET(TrackSpec_TrackEntry, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec_TrackEntry::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrackSpec_Repeat::InitAsDefaultInstance() {
}
class TrackSpec_Repeat::_Internal {
 public:
};

TrackSpec_Repeat::TrackSpec_Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  entries_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec.Repeat)
}
TrackSpec_Repeat::TrackSpec_Repeat(const TrackSpec_Repeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nrep_ = from.nrep_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec.Repeat)
}

void TrackSpec_Repeat::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrackSpec_Repeat_tetris_2eproto.base);
  nrep_ = PROTOBUF_LONGLONG(0);
}

TrackSpec_Repeat::~TrackSpec_Repeat() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec.Repeat)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrackSpec_Repeat::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TrackSpec_Repeat::ArenaDtor(void* object) {
  TrackSpec_Repeat* _this = reinterpret_cast< TrackSpec_Repeat* >(object);
  (void)_this;
}
void TrackSpec_Repeat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackSpec_Repeat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrackSpec_Repeat& TrackSpec_Repeat::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrackSpec_Repeat_tetris_2eproto.base);
  return *internal_default_instance();
}


void TrackSpec_Repeat::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec.Repeat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  nrep_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec_Repeat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // int64 nrep = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          nrep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrackSpec_Repeat::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec.Repeat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  // int64 nrep = 2;
  if (this->nrep() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_nrep(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec.Repeat)
  return target;
}

size_t TrackSpec_Repeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec.Repeat)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 nrep = 2;
  if (this->nrep() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_nrep());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrackSpec_Repeat::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.TrackSpec.Repeat)
  GOOGLE_DCHECK_NE(&from, this);
  const TrackSpec_Repeat* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrackSpec_Repeat>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.TrackSpec.Repeat)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.TrackSpec.Repeat)
    MergeFrom(*source);
  }
}

void TrackSpec_Repeat::MergeFrom(const TrackSpec_Repeat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec.Repeat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  if (from.nrep() != 0) {
    _internal_set_nrep(from._internal_nrep());
  }
}

void TrackSpec_Repeat::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.TrackSpec.Repeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackSpec_Repeat::CopyFrom(const TrackSpec_Repeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec.Repeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec_Repeat::IsInitialized() const {
  return true;
}

void TrackSpec_Repeat::InternalSwap(TrackSpec_Repeat* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
  swap(nrep_, other->nrep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec_Repeat::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrackSpec::InitAsDefaultInstance() {
  ::vlsir::tetris::_TrackSpec_default_instance_.entry_ = const_cast< ::vlsir::tetris::TrackSpec_TrackEntry*>(
      ::vlsir::tetris::TrackSpec_TrackEntry::internal_default_instance());
  ::vlsir::tetris::_TrackSpec_default_instance_.repeat_ = const_cast< ::vlsir::tetris::TrackSpec_Repeat*>(
      ::vlsir::tetris::TrackSpec_Repeat::internal_default_instance());
}
class TrackSpec::_Internal {
 public:
  static const ::vlsir::tetris::TrackSpec_TrackEntry& entry(const TrackSpec* msg);
  static const ::vlsir::tetris::TrackSpec_Repeat& repeat(const TrackSpec* msg);
};

const ::vlsir::tetris::TrackSpec_TrackEntry&
TrackSpec::_Internal::entry(const TrackSpec* msg) {
  return *msg->spec_.entry_;
}
const ::vlsir::tetris::TrackSpec_Repeat&
TrackSpec::_Internal::repeat(const TrackSpec* msg) {
  return *msg->spec_.repeat_;
}
void TrackSpec::set_allocated_entry(::vlsir::tetris::TrackSpec_TrackEntry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_spec();
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    set_has_entry();
    spec_.entry_ = entry;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackSpec.entry)
}
void TrackSpec::set_allocated_repeat(::vlsir::tetris::TrackSpec_Repeat* repeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_spec();
  if (repeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(repeat);
    if (message_arena != submessage_arena) {
      repeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeat, submessage_arena);
    }
    set_has_repeat();
    spec_.repeat_ = repeat;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackSpec.repeat)
}
TrackSpec::TrackSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec)
}
TrackSpec::TrackSpec(const TrackSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_spec();
  switch (from.spec_case()) {
    case kEntry: {
      _internal_mutable_entry()->::vlsir::tetris::TrackSpec_TrackEntry::MergeFrom(from._internal_entry());
      break;
    }
    case kRepeat: {
      _internal_mutable_repeat()->::vlsir::tetris::TrackSpec_Repeat::MergeFrom(from._internal_repeat());
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec)
}

void TrackSpec::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrackSpec_tetris_2eproto.base);
  clear_has_spec();
}

TrackSpec::~TrackSpec() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrackSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_spec()) {
    clear_spec();
  }
}

void TrackSpec::ArenaDtor(void* object) {
  TrackSpec* _this = reinterpret_cast< TrackSpec* >(object);
  (void)_this;
}
void TrackSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrackSpec& TrackSpec::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrackSpec_tetris_2eproto.base);
  return *internal_default_instance();
}


void TrackSpec::clear_spec() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.TrackSpec)
  switch (spec_case()) {
    case kEntry: {
      if (GetArena() == nullptr) {
        delete spec_.entry_;
      }
      break;
    }
    case kRepeat: {
      if (GetArena() == nullptr) {
        delete spec_.repeat_;
      }
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SPEC_NOT_SET;
}


void TrackSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_spec();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_entry(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrackSpec::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
  if (_internal_has_entry()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::entry(this), target, stream);
  }

  // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
  if (_internal_has_repeat()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::repeat(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec)
  return target;
}

size_t TrackSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (spec_case()) {
    // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
    case kEntry: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_.entry_);
      break;
    }
    // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
    case kRepeat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_.repeat_);
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrackSpec::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.TrackSpec)
  GOOGLE_DCHECK_NE(&from, this);
  const TrackSpec* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrackSpec>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.TrackSpec)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.TrackSpec)
    MergeFrom(*source);
  }
}

void TrackSpec::MergeFrom(const TrackSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.spec_case()) {
    case kEntry: {
      _internal_mutable_entry()->::vlsir::tetris::TrackSpec_TrackEntry::MergeFrom(from._internal_entry());
      break;
    }
    case kRepeat: {
      _internal_mutable_repeat()->::vlsir::tetris::TrackSpec_Repeat::MergeFrom(from._internal_repeat());
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
}

void TrackSpec::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.TrackSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackSpec::CopyFrom(const TrackSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec::IsInitialized() const {
  return true;
}

void TrackSpec::InternalSwap(TrackSpec* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(spec_, other->spec_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Xy::InitAsDefaultInstance() {
}
class Xy::_Internal {
 public:
};

Xy::Xy(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Xy)
}
Xy::Xy(const Xy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Xy)
}

void Xy::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Xy::~Xy() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Xy)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Xy::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Xy::ArenaDtor(void* object) {
  Xy* _this = reinterpret_cast< Xy* >(object);
  (void)_this;
}
void Xy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Xy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Xy& Xy::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Xy_tetris_2eproto.base);
  return *internal_default_instance();
}


void Xy::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Xy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Xy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Xy::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Xy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_x(), target);
  }

  // int64 y = 2;
  if (this->y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Xy)
  return target;
}

size_t Xy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Xy)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->x() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_x());
  }

  // int64 y = 2;
  if (this->y() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_y());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Xy::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vlsir.tetris.Xy)
  GOOGLE_DCHECK_NE(&from, this);
  const Xy* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Xy>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vlsir.tetris.Xy)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vlsir.tetris.Xy)
    MergeFrom(*source);
  }
}

void Xy::MergeFrom(const Xy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Xy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    _internal_set_x(from._internal_x());
  }
  if (from.y() != 0) {
    _internal_set_y(from._internal_y());
  }
}

void Xy::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vlsir.tetris.Xy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Xy::CopyFrom(const Xy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Xy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Xy::IsInitialized() const {
  return true;
}

void Xy::InternalSwap(Xy* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Xy, y_)
      + sizeof(Xy::y_)
      - PROTOBUF_FIELD_OFFSET(Xy, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Xy::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace tetris
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Library* Arena::CreateMaybeMessage< ::vlsir::tetris::Library >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Library >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Cell* Arena::CreateMaybeMessage< ::vlsir::tetris::Cell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Cell >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Layout* Arena::CreateMaybeMessage< ::vlsir::tetris::Layout >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Layout >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Assign* Arena::CreateMaybeMessage< ::vlsir::tetris::Assign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Assign >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackCross* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackCross >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackCross >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackRef* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackRef >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Outline* Arena::CreateMaybeMessage< ::vlsir::tetris::Outline >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Outline >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Abstract* Arena::CreateMaybeMessage< ::vlsir::tetris::Abstract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Abstract >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_EdgePort* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_EdgePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_EdgePort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_ZTopEdgePort* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_ZTopInner* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopInner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_ZTopInner >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort* Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Instance* Arena::CreateMaybeMessage< ::vlsir::tetris::Instance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Instance >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Place* Arena::CreateMaybeMessage< ::vlsir::tetris::Place >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Place >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::RelPlace* Arena::CreateMaybeMessage< ::vlsir::tetris::RelPlace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::RelPlace >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Stack* Arena::CreateMaybeMessage< ::vlsir::tetris::Stack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Stack >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::LayerEnum* Arena::CreateMaybeMessage< ::vlsir::tetris::LayerEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::LayerEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::MetalLayer* Arena::CreateMaybeMessage< ::vlsir::tetris::MetalLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::MetalLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::ViaLayer* Arena::CreateMaybeMessage< ::vlsir::tetris::ViaLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::ViaLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::PrimitiveLayer* Arena::CreateMaybeMessage< ::vlsir::tetris::PrimitiveLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::PrimitiveLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec_TrackEntry* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec_TrackEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec_TrackEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec_Repeat* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec_Repeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec_Repeat >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec* Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Xy* Arena::CreateMaybeMessage< ::vlsir::tetris::Xy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Xy >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
